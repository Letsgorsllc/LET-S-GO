Index: app/src/main/res/xml/backup_rules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/backup_rules.xml b/app/src/main/res/xml/backup_rules.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/xml/backup_rules.xml	
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample backup rules file; uncomment and customize as necessary.
+   See https://developer.android.com/guide/topics/data/autobackup
+   for details.
+   Note: This file is ignored for devices older that API 31
+   See https://developer.android.com/about/versions/12/backup-restore
+-->
+<full-backup-content>
+    <!--
+   <include domain="sharedpref" path="."/>
+   <exclude domain="sharedpref" path="device.xml"/>
+-->
+</full-backup-content>
\ No newline at end of file
Index: app/src/main/res/xml/data_extraction_rules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/xml/data_extraction_rules.xml b/app/src/main/res/xml/data_extraction_rules.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/xml/data_extraction_rules.xml	
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample data extraction rules file; uncomment and customize as necessary.
+   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
+   for details.
+-->
+<data-extraction-rules>
+    <cloud-backup>
+        <!-- TODO: Use <include> and <exclude> to control what is backed up.
+        <include .../>
+        <exclude .../>
+        -->
+    </cloud-backup>
+    <!--
+    <device-transfer>
+        <include .../>
+        <exclude .../>
+    </device-transfer>
+    -->
+</data-extraction-rules>
\ No newline at end of file
Index: app/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/colors.xml b/app/src/main/res/values/colors.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/values/colors.xml	
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="purple_200">#FFBB86FC</color>
+    <color name="purple_500">#FF6200EE</color>
+    <color name="purple_700">#FF3700B3</color>
+    <color name="teal_200">#FF03DAC5</color>
+    <color name="teal_700">#FF018786</color>
+    <color name="black">#FF000000</color>
+    <color name="white">#FFFFFFFF</color>
+</resources>
\ No newline at end of file
Index: app/src/main/res/values/themes.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/themes.xml b/app/src/main/res/values/themes.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/values/themes.xml	
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <style name="Theme.LETSGO" parent="android:Theme.Material.Light.NoActionBar" />
+</resources>
\ No newline at end of file
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/values/strings.xml	
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">LET\'S GO</string>
+</resources>
\ No newline at end of file
Index: app/src/main/res/drawable/ic_launcher_background.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_launcher_background.xml b/app/src/main/res/drawable/ic_launcher_background.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/drawable/ic_launcher_background.xml	
@@ -0,0 +1,170 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path
+        android:fillColor="#3DDC84"
+        android:pathData="M0,0h108v108h-108z" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M9,0L9,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,0L19,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,0L29,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,0L39,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,0L49,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,0L59,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,0L69,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,0L79,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M89,0L89,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M99,0L99,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,9L108,9"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,19L108,19"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,29L108,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,39L108,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,49L108,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,59L108,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,69L108,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,79L108,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,89L108,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,99L108,99"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,29L89,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,39L89,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,49L89,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,59L89,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,69L89,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,79L89,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,19L29,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,19L39,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,19L49,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,19L59,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,19L69,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,19L79,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+</vector>
Index: app/src/main/res/drawable/ic_launcher_foreground.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/ic_launcher_foreground.xml b/app/src/main/res/drawable/ic_launcher_foreground.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/drawable/ic_launcher_foreground.xml	
@@ -0,0 +1,30 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:aapt="http://schemas.android.com/aapt"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
+        <aapt:attr name="android:fillColor">
+            <gradient
+                android:endX="85.84757"
+                android:endY="92.4963"
+                android:startX="42.9492"
+                android:startY="49.59793"
+                android:type="linear">
+                <item
+                    android:color="#44000000"
+                    android:offset="0.0" />
+                <item
+                    android:color="#00000000"
+                    android:offset="1.0" />
+            </gradient>
+        </aapt:attr>
+    </path>
+    <path
+        android:fillColor="#FFFFFF"
+        android:fillType="nonZero"
+        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
+        android:strokeWidth="1"
+        android:strokeColor="#00000000" />
+</vector>
\ No newline at end of file
Index: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml b/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
Index: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml b/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
\ No newline at end of file
Index: app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Type.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Type.kt b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Type.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Type.kt	
@@ -0,0 +1,34 @@
+package com.letsgorsllc.letsgoride.ui.theme
+
+import androidx.compose.material3.Typography
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontFamily
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.unit.sp
+
+// Set of Material typography styles to start with
+val Typography = Typography(
+    bodyLarge = TextStyle(
+        fontFamily = FontFamily.Default,
+        fontWeight = FontWeight.Normal,
+        fontSize = 16.sp,
+        lineHeight = 24.sp,
+        letterSpacing = 0.5.sp
+    )
+    /* Other default text styles to override
+    titleLarge = TextStyle(
+        fontFamily = FontFamily.Default,
+        fontWeight = FontWeight.Normal,
+        fontSize = 22.sp,
+        lineHeight = 28.sp,
+        letterSpacing = 0.sp
+    ),
+    labelSmall = TextStyle(
+        fontFamily = FontFamily.Default,
+        fontWeight = FontWeight.Medium,
+        fontSize = 11.sp,
+        lineHeight = 16.sp,
+        letterSpacing = 0.5.sp
+    )
+    */
+)
\ No newline at end of file
Index: app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Color.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Color.kt b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Color.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Color.kt	
@@ -0,0 +1,11 @@
+package com.letsgorsllc.letsgoride.ui.theme
+
+import androidx.compose.ui.graphics.Color
+
+val Purple80 = Color(0xFFD0BCFF)
+val PurpleGrey80 = Color(0xFFCCC2DC)
+val Pink80 = Color(0xFFEFB8C8)
+
+val Purple40 = Color(0xFF6650a4)
+val PurpleGrey40 = Color(0xFF625b71)
+val Pink40 = Color(0xFF7D5260)
\ No newline at end of file
Index: app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Theme.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Theme.kt b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Theme.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/letsgorsllc/letsgoride/ui/theme/Theme.kt	
@@ -0,0 +1,58 @@
+package com.letsgorsllc.letsgoride.ui.theme
+
+import android.app.Activity
+import android.os.Build
+import androidx.compose.foundation.isSystemInDarkTheme
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.darkColorScheme
+import androidx.compose.material3.dynamicDarkColorScheme
+import androidx.compose.material3.dynamicLightColorScheme
+import androidx.compose.material3.lightColorScheme
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.platform.LocalContext
+
+private val DarkColorScheme = darkColorScheme(
+    primary = Purple80,
+    secondary = PurpleGrey80,
+    tertiary = Pink80
+)
+
+private val LightColorScheme = lightColorScheme(
+    primary = Purple40,
+    secondary = PurpleGrey40,
+    tertiary = Pink40
+
+    /* Other default colors to override
+    background = Color(0xFFFFFBFE),
+    surface = Color(0xFFFFFBFE),
+    onPrimary = Color.White,
+    onSecondary = Color.White,
+    onTertiary = Color.White,
+    onBackground = Color(0xFF1C1B1F),
+    onSurface = Color(0xFF1C1B1F),
+    */
+)
+
+@Composable
+fun LETSGOTheme(
+    darkTheme: Boolean = isSystemInDarkTheme(),
+    // Dynamic color is available on Android 12+
+    dynamicColor: Boolean = true,
+    content: @Composable () -> Unit
+) {
+    val colorScheme = when {
+        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
+            val context = LocalContext.current
+            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
+        }
+
+        darkTheme -> DarkColorScheme
+        else -> LightColorScheme
+    }
+
+    MaterialTheme(
+        colorScheme = colorScheme,
+        typography = Typography,
+        content = content
+    )
+}
\ No newline at end of file
Index: app/src/main/java/com/letsgorsllc/letsgoride/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/letsgorsllc/letsgoride/MainActivity.kt b/app/src/main/java/com/letsgorsllc/letsgoride/MainActivity.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/letsgorsllc/letsgoride/MainActivity.kt	
@@ -0,0 +1,47 @@
+package com.letsgorsllc.letsgoride
+
+import android.os.Bundle
+import androidx.activity.ComponentActivity
+import androidx.activity.compose.setContent
+import androidx.activity.enableEdgeToEdge
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.padding
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.tooling.preview.Preview
+import com.letsgorsllc.letsgoride.ui.theme.LETSGOTheme
+
+class MainActivity : ComponentActivity() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        enableEdgeToEdge()
+        setContent {
+            LETSGOTheme {
+                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
+                    Greeting(
+                        name = "Android",
+                        modifier = Modifier.padding(innerPadding)
+                    )
+                }
+            }
+        }
+    }
+}
+
+@Composable
+fun Greeting(name: String, modifier: Modifier = Modifier) {
+    Text(
+        text = "Hello $name!",
+        modifier = modifier
+    )
+}
+
+@Preview(showBackground = true)
+@Composable
+fun GreetingPreview() {
+    LETSGOTheme {
+        Greeting("Android")
+    }
+}
\ No newline at end of file
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/AndroidManifest.xml	
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools">
+
+    <application
+        android:allowBackup="true"
+        android:dataExtractionRules="@xml/data_extraction_rules"
+        android:fullBackupContent="@xml/backup_rules"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:roundIcon="@mipmap/ic_launcher_round"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.LETSGO"
+        tools:targetApi="31">
+        <activity
+            android:name=".MainActivity"
+            android:exported="true"
+            android:label="@string/app_name"
+            android:theme="@style/Theme.LETSGO">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
Index: app/src/test/java/com/letsgorsllc/letsgoride/ExampleUnitTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/test/java/com/letsgorsllc/letsgoride/ExampleUnitTest.kt b/app/src/test/java/com/letsgorsllc/letsgoride/ExampleUnitTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/test/java/com/letsgorsllc/letsgoride/ExampleUnitTest.kt	
@@ -0,0 +1,17 @@
+package com.letsgorsllc.letsgoride
+
+import org.junit.Test
+
+import org.junit.Assert.*
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * See [testing documentation](http://d.android.com/tools/testing).
+ */
+class ExampleUnitTest {
+    @Test
+    fun addition_isCorrect() {
+        assertEquals(4, 2 + 2)
+    }
+}
\ No newline at end of file
Index: app/src/androidTest/java/com/letsgorsllc/letsgoride/ExampleInstrumentedTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/androidTest/java/com/letsgorsllc/letsgoride/ExampleInstrumentedTest.kt b/app/src/androidTest/java/com/letsgorsllc/letsgoride/ExampleInstrumentedTest.kt
new file mode 100644
--- /dev/null	
+++ b/app/src/androidTest/java/com/letsgorsllc/letsgoride/ExampleInstrumentedTest.kt	
@@ -0,0 +1,24 @@
+package com.letsgorsllc.letsgoride
+
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+
+import org.junit.Test
+import org.junit.runner.RunWith
+
+import org.junit.Assert.*
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * See [testing documentation](http://d.android.com/tools/testing).
+ */
+@RunWith(AndroidJUnit4::class)
+class ExampleInstrumentedTest {
+    @Test
+    fun useAppContext() {
+        // Context of the app under test.
+        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
+        assertEquals("com.letsgorsllc.letsgoride", appContext.packageName)
+    }
+}
\ No newline at end of file
Index: app/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/.gitignore b/app/.gitignore
new file mode 100644
--- /dev/null	
+++ b/app/.gitignore	
@@ -0,0 +1,1 @@
+/build
\ No newline at end of file
Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
new file mode 100644
--- /dev/null	
+++ b/app/build.gradle.kts	
@@ -0,0 +1,59 @@
+plugins {
+    alias(libs.plugins.android.application)
+    alias(libs.plugins.kotlin.android)
+    alias(libs.plugins.kotlin.compose)
+}
+
+android {
+    namespace = "com.letsgorsllc.letsgoride"
+    compileSdk = 34
+
+    defaultConfig {
+        applicationId = "com.letsgorsllc.letsgoride"
+        minSdk = 24
+        targetSdk = 34
+        versionCode = 1
+        versionName = "1.0"
+
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            isMinifyEnabled = false
+            proguardFiles(
+                getDefaultProguardFile("proguard-android-optimize.txt"),
+                "proguard-rules.pro"
+            )
+        }
+    }
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_11
+        targetCompatibility = JavaVersion.VERSION_11
+    }
+    kotlinOptions {
+        jvmTarget = "11"
+    }
+    buildFeatures {
+        compose = true
+    }
+}
+
+dependencies {
+
+    implementation(libs.androidx.core.ktx)
+    implementation(libs.androidx.lifecycle.runtime.ktx)
+    implementation(libs.androidx.activity.compose)
+    implementation(platform(libs.androidx.compose.bom))
+    implementation(libs.androidx.ui)
+    implementation(libs.androidx.ui.graphics)
+    implementation(libs.androidx.ui.tooling.preview)
+    implementation(libs.androidx.material3)
+    testImplementation(libs.junit)
+    androidTestImplementation(libs.androidx.junit)
+    androidTestImplementation(libs.androidx.espresso.core)
+    androidTestImplementation(platform(libs.androidx.compose.bom))
+    androidTestImplementation(libs.androidx.ui.test.junit4)
+    debugImplementation(libs.androidx.ui.tooling)
+    debugImplementation(libs.androidx.ui.test.manifest)
+}
\ No newline at end of file
Index: app/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
new file mode 100644
--- /dev/null	
+++ b/app/proguard-rules.pro	
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
\ No newline at end of file
Index: log/development.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/log/development.log b/log/development.log
new file mode 100644
--- /dev/null	
+++ b/log/development.log	
@@ -0,0 +1,25 @@
+  [1m[35m (11.2ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (2.9ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (5.4ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (8.3ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" varchar NOT NULL PRIMARY KEY)[0m
+  [1m[35m (4.8ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" varchar NOT NULL PRIMARY KEY, "value" varchar, "created_at" datetime(6) NOT NULL, "updated_at" datetime(6) NOT NULL)[0m
+  [1m[36mActiveRecord::InternalMetadata Load (1.1ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = ? LIMIT ?[0m  [["key", "environment"], ["LIMIT", 1]]
+  [1m[36mTRANSACTION (0.1ms)[0m  [1m[36mbegin transaction[0m
+  [1m[36mActiveRecord::InternalMetadata Create (1.7ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES (?, ?, ?, ?)[0m  [["key", "environment"], ["value", "development"], ["created_at", "2024-10-27 09:56:32.217695"], ["updated_at", "2024-10-27 09:56:32.217695"]]
+  [1m[36mTRANSACTION (3.1ms)[0m  [1m[36mcommit transaction[0m
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
+  [1m[35m (5.5ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = ? LIMIT ?[0m  [["key", "environment"], ["LIMIT", 1]]
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
+  [1m[35m (3.8ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = ? LIMIT ?[0m  [["key", "environment"], ["LIMIT", 1]]
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.3ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
+  [1m[35m (2.9ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = ? LIMIT ?[0m  [["key", "environment"], ["LIMIT", 1]]
+  [1m[35m (0.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
+  [1m[35m (0.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Index: src/routes/example.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/routes/example.js b/src/routes/example.js
new file mode 100644
--- /dev/null	
+++ b/src/routes/example.js	
@@ -0,0 +1,11 @@
+ ```javascript
+ const express = require('express');
+ const router = express.Router();
+
+ // Example route
+ router.get('/example', (req, res) => {
+   res.send('Example route is working!');
+ });
+
+ module.exports = router;
+ ```
Index: src/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/index.js b/src/index.js
new file mode 100644
--- /dev/null	
+++ b/src/index.js	
@@ -0,0 +1,22 @@
+ ```javascript
+ const express = require('express');
+ const app = express();
+ const port = process.env.PORT || 3000;
+
+ // Middleware
+ app.use(express.json());
+
+ // Routes
+ const exampleRoutes = require('./routes/example');
+ app.use('/api', exampleRoutes);
+
+ // Error handling middleware
+ app.use((err, req, res, next) => {
+   console.error(err.stack);
+   res.status(500).send('Something broke!');
+ });
+
+ app.listen(port, () => {
+   console.log(`Server is running on port ${port}`);
+ });
+ ```
Index: src/middleware/logger.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/middleware/logger.js b/src/middleware/logger.js
new file mode 100644
--- /dev/null	
+++ b/src/middleware/logger.js	
@@ -0,0 +1,8 @@
+ ```javascript
+ const logger = (req, res, next) => {
+   console.log(`${req.method} ${req.url}`);
+   next();
+ };
+
+ module.exports = logger;
+ ```
Index: tmp/development_secret.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tmp/development_secret.txt b/tmp/development_secret.txt
new file mode 100644
--- /dev/null	
+++ b/tmp/development_secret.txt	
@@ -0,0 +1,1 @@
+6e2d8b35f086325cc1faa632c7dfae6fe4b0a05fc2bd609017a463cb2d513c17bb9f42958db2409cbe18d8c627c38220b9bf3dc1b26c370def14b790dea1d57b
\ No newline at end of file
Index: .idea/caches/deviceStreaming.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/caches/deviceStreaming.xml b/.idea/caches/deviceStreaming.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/caches/deviceStreaming.xml	
@@ -0,0 +1,330 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="DeviceStreaming">
+    <option name="deviceSelectionList">
+      <list>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="27" />
+          <option name="brand" value="DOCOMO" />
+          <option name="codename" value="F01L" />
+          <option name="id" value="F01L" />
+          <option name="manufacturer" value="FUJITSU" />
+          <option name="name" value="F-01L" />
+          <option name="screenDensity" value="360" />
+          <option name="screenX" value="720" />
+          <option name="screenY" value="1280" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="28" />
+          <option name="brand" value="DOCOMO" />
+          <option name="codename" value="SH-01L" />
+          <option name="id" value="SH-01L" />
+          <option name="manufacturer" value="SHARP" />
+          <option name="name" value="AQUOS sense2 SH-01L" />
+          <option name="screenDensity" value="480" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2160" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="Lenovo" />
+          <option name="codename" value="TB370FU" />
+          <option name="id" value="TB370FU" />
+          <option name="manufacturer" value="Lenovo" />
+          <option name="name" value="Tab P12" />
+          <option name="screenDensity" value="340" />
+          <option name="screenX" value="1840" />
+          <option name="screenY" value="2944" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="31" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="a51" />
+          <option name="id" value="a51" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy A51" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="akita" />
+          <option name="id" value="akita" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 8a" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="b0q" />
+          <option name="id" value="b0q" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy S22 Ultra" />
+          <option name="screenDensity" value="600" />
+          <option name="screenX" value="1440" />
+          <option name="screenY" value="3088" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="32" />
+          <option name="brand" value="google" />
+          <option name="codename" value="bluejay" />
+          <option name="id" value="bluejay" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 6a" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="caiman" />
+          <option name="id" value="caiman" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 9 Pro" />
+          <option name="screenDensity" value="360" />
+          <option name="screenX" value="960" />
+          <option name="screenY" value="2142" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="comet" />
+          <option name="id" value="comet" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 9 Pro Fold" />
+          <option name="screenDensity" value="390" />
+          <option name="screenX" value="2076" />
+          <option name="screenY" value="2152" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="29" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="crownqlteue" />
+          <option name="id" value="crownqlteue" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy Note9" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="2220" />
+          <option name="screenY" value="1080" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="dm3q" />
+          <option name="id" value="dm3q" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy S23 Ultra" />
+          <option name="screenDensity" value="600" />
+          <option name="screenX" value="1440" />
+          <option name="screenY" value="3088" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="e1q" />
+          <option name="id" value="e1q" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy S24" />
+          <option name="screenDensity" value="480" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2340" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="google" />
+          <option name="codename" value="felix" />
+          <option name="id" value="felix" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel Fold" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="2208" />
+          <option name="screenY" value="1840" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="felix" />
+          <option name="id" value="felix" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel Fold" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="2208" />
+          <option name="screenY" value="1840" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="google" />
+          <option name="codename" value="felix_camera" />
+          <option name="id" value="felix_camera" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel Fold (Camera-enabled)" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="2208" />
+          <option name="screenY" value="1840" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="gts8uwifi" />
+          <option name="id" value="gts8uwifi" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy Tab S8 Ultra" />
+          <option name="screenDensity" value="320" />
+          <option name="screenX" value="1848" />
+          <option name="screenY" value="2960" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="husky" />
+          <option name="id" value="husky" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 8 Pro" />
+          <option name="screenDensity" value="390" />
+          <option name="screenX" value="1008" />
+          <option name="screenY" value="2244" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="30" />
+          <option name="brand" value="motorola" />
+          <option name="codename" value="java" />
+          <option name="id" value="java" />
+          <option name="manufacturer" value="Motorola" />
+          <option name="name" value="G20" />
+          <option name="screenDensity" value="280" />
+          <option name="screenX" value="720" />
+          <option name="screenY" value="1600" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="komodo" />
+          <option name="id" value="komodo" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 9 Pro XL" />
+          <option name="screenDensity" value="360" />
+          <option name="screenX" value="1008" />
+          <option name="screenY" value="2244" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="google" />
+          <option name="codename" value="lynx" />
+          <option name="id" value="lynx" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 7a" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="31" />
+          <option name="brand" value="google" />
+          <option name="codename" value="oriole" />
+          <option name="id" value="oriole" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 6" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="google" />
+          <option name="codename" value="panther" />
+          <option name="id" value="panther" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 7" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="q5q" />
+          <option name="id" value="q5q" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="Galaxy Z Fold5" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1812" />
+          <option name="screenY" value="2176" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="samsung" />
+          <option name="codename" value="q6q" />
+          <option name="id" value="q6q" />
+          <option name="manufacturer" value="Samsung" />
+          <option name="name" value="SM-F956B" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1856" />
+          <option name="screenY" value="2160" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="30" />
+          <option name="brand" value="google" />
+          <option name="codename" value="r11" />
+          <option name="id" value="r11" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel Watch" />
+          <option name="screenDensity" value="320" />
+          <option name="screenX" value="384" />
+          <option name="screenY" value="384" />
+          <option name="type" value="WEAR_OS" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="30" />
+          <option name="brand" value="google" />
+          <option name="codename" value="redfin" />
+          <option name="id" value="redfin" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 5" />
+          <option name="screenDensity" value="440" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2340" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="shiba" />
+          <option name="id" value="shiba" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 8" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2400" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="33" />
+          <option name="brand" value="google" />
+          <option name="codename" value="tangorpro" />
+          <option name="id" value="tangorpro" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel Tablet" />
+          <option name="screenDensity" value="320" />
+          <option name="screenX" value="1600" />
+          <option name="screenY" value="2560" />
+        </PersistentDeviceSelectionData>
+        <PersistentDeviceSelectionData>
+          <option name="api" value="34" />
+          <option name="brand" value="google" />
+          <option name="codename" value="tokay" />
+          <option name="id" value="tokay" />
+          <option name="manufacturer" value="Google" />
+          <option name="name" value="Pixel 9" />
+          <option name="screenDensity" value="420" />
+          <option name="screenX" value="1080" />
+          <option name="screenY" value="2424" />
+        </PersistentDeviceSelectionData>
+      </list>
+    </option>
+    <option name="selectedCloudProject" value="device-streaming-a252aefe" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/vcs.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/misc.xml	
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="jbr-21" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="ProjectType">
+    <option name="id" value="Android" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/gradle.xml b/.idea/gradle.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/gradle.xml	
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GradleMigrationSettings" migrationVersion="1" />
+  <component name="GradleSettings">
+    <option name="linkedExternalProjectsSettings">
+      <GradleProjectSettings>
+        <option name="testRunner" value="CHOOSE_PER_TEST" />
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="gradleJvm" value="#GRADLE_LOCAL_JAVA_HOME" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+            <option value="$PROJECT_DIR$/app" />
+          </set>
+        </option>
+        <option name="resolveExternalAnnotations" value="false" />
+      </GradleProjectSettings>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/kotlinc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/kotlinc.xml b/.idea/kotlinc.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/kotlinc.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="KotlinJpsPluginSettings">
+    <option name="version" value="2.0.0" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/migrations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/migrations.xml b/.idea/migrations.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/migrations.xml	
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectMigrations">
+    <option name="MigrateToGradleLocalJavaHome">
+      <set>
+        <option value="$PROJECT_DIR$" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/runConfigurations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/runConfigurations.xml	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="com.intellij.execution.junit.AbstractAllInDirectoryConfigurationProducer" />
+        <option value="com.intellij.execution.junit.AllInPackageConfigurationProducer" />
+        <option value="com.intellij.execution.junit.PatternConfigurationProducer" />
+        <option value="com.intellij.execution.junit.TestInClassConfigurationProducer" />
+        <option value="com.intellij.execution.junit.UniqueIdConfigurationProducer" />
+        <option value="com.intellij.execution.junit.testDiscovery.JUnitTestDiscoveryConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinJUnitRunConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinPatternConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/deploymentTargetSelector.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/deploymentTargetSelector.xml b/.idea/deploymentTargetSelector.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/deploymentTargetSelector.xml	
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="deploymentTargetSelector">
+    <selectionStates>
+      <SelectionState runConfigName="app">
+        <option name="selectionMode" value="DROPDOWN" />
+        <DropdownSelection timestamp="2024-11-12T00:54:36.486277600Z">
+          <Target type="DEFAULT_BOOT">
+            <handle>
+              <DeviceId pluginId="LocalEmulator" identifier="path=C:\Users\Owner\.android\avd\Pixel_Fold_API_35.avd" />
+            </handle>
+          </Target>
+        </DropdownSelection>
+        <DialogSelection />
+      </SelectionState>
+    </selectionStates>
+  </component>
+</project>
\ No newline at end of file
Index: outes/.gitkeep
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/outes/.gitkeep b/outes/.gitkeep
new file mode 100644
--- /dev/null	
+++ b/outes/.gitkeep	
@@ -0,0 +1,1 @@
+
Index: utils/.gitkeep
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils/.gitkeep b/utils/.gitkeep
new file mode 100644
--- /dev/null	
+++ b/utils/.gitkeep	
@@ -0,0 +1,1 @@
+
Index: utils/exampleUtil.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils/exampleUtil.js b/utils/exampleUtil.js
new file mode 100644
--- /dev/null	
+++ b/utils/exampleUtil.js	
@@ -0,0 +1,4 @@
+// Example Utility
+exports.exampleUtilFunction = () => {
+    return 'Utility function result';
+};
Index: app.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.js b/app.js
new file mode 100644
--- /dev/null	
+++ b/app.js	
@@ -0,0 +1,1 @@
+// Main application logic
Index: assets/Letsgo_transparentbg.svg
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/assets/Letsgo_transparentbg.svg b/assets/Letsgo_transparentbg.svg
new file mode 100644
--- /dev/null	
+++ b/assets/Letsgo_transparentbg.svg	
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 418.04 447.43">
+  <defs>
+    <style>
+      .cls-1 {
+        fill: #fff;
+      }
+
+      .cls-2 {
+        fill: #d9e026;
+      }
+    </style>
+  </defs>
+  <path class="cls-1" d="m0,0h20.88v224.9H0V0Z"/>
+  <path class="cls-1" d="m175.35,171.06l17.6,9.25c-5.77,11.33-12.44,20.48-20,27.44-7.56,6.96-16.07,12.26-25.53,15.88-9.46,3.63-20.15,5.44-32.1,5.44-26.47,0-47.17-8.67-62.1-26.02-14.93-17.35-22.39-36.96-22.39-58.84,0-20.58,6.32-38.92,18.96-55.03,16.02-20.48,37.47-30.72,64.34-30.72s49.76,10.49,66.28,31.47c11.74,14.82,17.71,33.31,17.91,55.48H52.31c.4,18.85,6.42,34.3,18.07,46.35,11.65,12.05,26.03,18.08,43.15,18.08,8.26,0,16.3-1.43,24.11-4.31,7.81-2.87,14.46-6.69,19.93-11.44s11.4-12.43,17.77-23.03Zm0-43.7c-2.79-11.13-6.84-20.03-12.17-26.7-5.33-6.66-12.37-12.03-21.13-16.11-8.76-4.08-17.97-6.11-27.62-6.11-15.93,0-29.62,5.12-41.06,15.36-8.36,7.46-14.69,18.64-18.96,33.56h120.95Z"/>
+  <path class="cls-1" d="m240.77,62.64V2.39h-20.88v60.25h-28.49v18.04h28.49l-.11,142.85-.05-.11v32.34c-9.68-11.19-19.73-19.21-30.15-24.09-10.42-4.87-21.66-7.31-33.71-7.31-14.52,0-28.33,3.67-41.42,10.99-13.09,7.33-23.34,17.29-30.75,29.87-7.41,12.59-11.11,26.16-11.11,40.72s3.55,27.92,10.67,40.07c7.11,12.15,17.19,21.82,30.23,29,13.04,7.19,26.97,10.78,41.79,10.78,12.64,0,24.6-2.58,35.86-7.74,11.26-5.16,20.8-12.56,28.6-22.2v8.1c0,17.35-2.07,29.92-6.22,37.7-4.15,7.78-11.09,14.25-20.82,19.39-9.73,5.14-21.67,7.71-35.79,7.71s-26.33-2.51-36.02-7.52c-9.68-5.02-17.59-12.73-23.71-23.14h-22.5c5.82,12.38,12.19,21.78,19.1,28.22,6.91,6.43,15.86,11.56,26.87,15.38,11,3.82,23.41,5.73,37.23,5.73,18.85,0,34.98-3.91,48.41-11.72,13.42-7.81,22.85-18.95,28.27-33.42,3.95-10.22,5.92-26.37,5.92-48.46l.33-129.3h0V80.68s33.1,0,33.1,0v-18.04h-33.11Zm-38.55,287.29c-11.6,11.19-26.92,16.78-45.96,16.78s-34.2-5.64-46.04-16.92c-11.84-11.28-17.76-25.55-17.76-42.82,0-11.38,2.86-21.96,8.59-31.75,5.72-9.79,13.62-17.45,23.68-23,10.07-5.54,20.97-8.32,32.71-8.32s21.76,2.7,31.53,8.1c9.77,5.4,17.32,12.75,22.65,22.06,5.33,9.31,7.99,19.89,7.99,31.75,0,18.23-5.8,32.93-17.39,44.12Z"/>
+  <path class="cls-1" d="m303.14,81.88l-11.48-6.56c3.78-7.55,6.31-13.47,7.61-17.75,1.29-4.27,2.24-9.79,2.83-16.55h-13.12V0h26.99v25.65c0,12.83-.87,22.89-2.61,30.2-1.74,7.31-5.14,15.98-10.22,26.02Z"/>
+  <path class="cls-1" d="m403.92,80.39l-13.42,13.87c-11.17-10.84-22.08-16.26-32.75-16.26-6.78,0-12.59,2.24-17.42,6.71-4.83,4.47-7.25,9.69-7.25,15.66,0,5.27,1.99,10.29,5.98,15.06,3.98,4.87,12.36,10.59,25.11,17.15,15.54,8.05,26.1,15.81,31.68,23.27,5.48,7.56,8.22,16.06,8.22,25.5,0,13.33-4.68,24.61-14.04,33.85-9.36,9.25-21.06,13.87-35.1,13.87-9.36,0-18.3-2.04-26.81-6.11-8.51-4.08-15.56-9.69-21.13-16.85l13.12-14.91c10.66,12.03,21.97,18.05,33.93,18.05,8.37,0,15.49-2.68,21.38-8.05,5.88-5.37,8.82-11.68,8.82-18.94,0-5.97-1.94-11.28-5.83-15.96-3.89-4.57-12.66-10.34-26.3-17.3-14.65-7.55-24.61-15.01-29.89-22.37-5.28-7.36-7.92-15.76-7.92-25.21,0-12.33,4.21-22.57,12.62-30.72,8.42-8.15,19.05-12.23,31.89-12.23,14.94,0,29.98,7.31,45.11,21.92Z"/>
+  <g>
+    <path class="cls-1" d="m392.01,267.15c1.23-1.87,2.72-3.12,2.87-4.51.81-7.43.33-14.31-6.27-19.73-21.76-17.88-46.45-23.73-73.75-18.07-14.41,2.99-26.94,10.24-37.62,20.4-6.69,6.36-6.92,16.93-.55,21.24,14.41-18.97,32.77-30.12,57.47-29.98,24.55.14,43.11,10.92,57.84,30.66Z"/>
+    <g>
+      <path class="cls-2" d="m418.03,273.21c-.84,20.03-.13,40.33-6.99,59.57-2.64,7.4-6.07,14.03-10.28,19.95-8.74,12.35-20.82,21.57-35.9,28.02-10.71,4.58-21.8,6.67-33.11,6.64-16.51-.03-31.8-5.41-45.1-15.09-6.46-4.71-12.29-10-17.19-15.98-6.04-7.36-10.68-15.77-13.41-25.42-2.49-8.82-3.55-18.07-4.84-27.19-1.02-7.13-1.66-14.34-1.99-21.54-.31-6.62-.56-13.08,5.09-18.57,4.79-4.68,8.16-10.79,12.44-16.04,1.28-1.57,3.52-2.37,5.44-3.59-1.13,5.38-2.53,9.94-2.89,14.59-.2,2.53.88,5.51,2.25,7.75,2.99,4.84,8.43,4.29,11.19-.83.38-.71.51-1.73,1.09-2.13,1.56-1.06,3.23-2.23,5-2.53.53-.09,2.14,2.54,2.2,3.97.39,9.99-4.15,18.1-10.2,25.59-4,4.96-7.98,9.95-11.9,14.98-3.87,4.98-4.33,10.44-1.95,16.21,2.47,6.04,4.94,12.08,7.42,18.12,7.64,11.56,17.07,21.14,29.68,27.36,23.9,11.78,54.17,7.22,74.18-9.96,10.87-9.33,17.47-20.89,22.05-34.22,3.41-9.96-.39-17.15-6.53-24.17-7.2-8.22-14.57-16.38-16.72-27.64-.42-2.21-1-4.51-.76-6.68.15-1.34,1.71-3.58,2.62-3.58,1.75,0,4.42.89,5.06,2.2,1.72,3.55,3.1,7.64,7.84,6.35,4.45-1.2,6.8-4.95,6.27-9.8-.53-4.89-1.33-9.76-2.09-15.16,2.23,1.48,5.18,2.65,7,4.78,4.8,5.59,9.27,11.47,13.5,17.5,1.2,1.72,1.62,4.36,1.53,6.54Z"/>
+      <path class="cls-1" d="m400.76,355.73l-63.37,91.56-68-88,.07.03c4.9,5.98,10.73,11.27,17.19,15.98,13.3,9.68,28.59,15.06,45.1,15.09,11.31.03,22.4-2.06,33.11-6.64,15.08-6.45,27.16-15.67,35.9-28.02Z"/>
+      <path class="cls-1" d="m390.96,300.13c-1.41-1.78-4.17-3.06-6.49-3.44-6.27-1.03-12.65-1.34-18.96-2.15-7.19-.91-14.08-2.11-20.22-6.95-5.54-4.36-12.46-4.17-19.14-1.84-3.68,2.01-7.35,4.02-11.03,6.02l-1.98.92c-5.67.68-11.34,1.36-17.02,2.04-4.03.3-8.11.33-12.08,1-2.19.37-4.79,1.27-6.16,2.85-2.95,3.38-5.35,7.27-7.7,11.11-.78,1.28-.74,3.06-1.38,6.04,6.54-5.17,12.61-7.22,19.33-7.33,5.01.66,10.01,1.32,15.02,1.98,1.42.71,2.89,1.35,4.26,2.14,11.85,6.85,18.56,16.63,18.85,30.79.19,9.13-2.31,17.03-8.5,24.76,11,2.11,21.05,2.37,31.43-.18-12.5-18.74-9.63-35.07,1.29-48.08,5.3-6.31,12.53-10.11,20.56-11.04,9.31-1.07,18.55.16,26.87,6.21,1.07-7-3.65-10.73-6.94-14.88Zm-57.56,16.16c-6.08,0-11-4.92-11-11s4.92-11,11-11,11,4.92,11,11-4.92,11-11,11Z"/>
+    </g>
+  </g>
+</svg>
\ No newline at end of file
Index: config/master.key
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/master.key b/config/master.key
new file mode 100644
--- /dev/null	
+++ b/config/master.key	
@@ -0,0 +1,1 @@
+f6239702f85cc579a7e38254d6304cbd
\ No newline at end of file
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
--- /dev/null	
+++ b/gradle/wrapper/gradle-wrapper.properties	
@@ -0,0 +1,6 @@
+#Wed Nov 06 13:28:30 EST 2024
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
Index: gradle/libs.versions.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
new file mode 100644
--- /dev/null	
+++ b/gradle/libs.versions.toml	
@@ -0,0 +1,32 @@
+[versions]
+agp = "8.7.2"
+kotlin = "2.0.0"
+coreKtx = "1.10.1"
+junit = "4.13.2"
+junitVersion = "1.1.5"
+espressoCore = "3.6.1"
+lifecycleRuntimeKtx = "2.6.1"
+activityCompose = "1.8.0"
+composeBom = "2024.04.01"
+
+[libraries]
+androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
+junit = { group = "junit", name = "junit", version.ref = "junit" }
+androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
+androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
+androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
+androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
+androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
+androidx-ui = { group = "androidx.compose.ui", name = "ui" }
+androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
+androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
+androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
+androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
+androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
+androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
+
+[plugins]
+android-application = { id = "com.android.application", version.ref = "agp" }
+kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
+kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
+
Index: models/.gitkeep
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/models/.gitkeep b/models/.gitkeep
new file mode 100644
--- /dev/null	
+++ b/models/.gitkeep	
@@ -0,0 +1,1 @@
+
Index: models/exampleModel.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/models/exampleModel.js b/models/exampleModel.js
new file mode 100644
--- /dev/null	
+++ b/models/exampleModel.js	
@@ -0,0 +1,7 @@
+// Example Model
+const mongoose = require('mongoose');
+const exampleSchema = new mongoose.Schema({
+    name: String,
+    value: Number
+});
+module.exports = mongoose.model('Example', exampleSchema);
Index: routes/.gitkeep
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/routes/.gitkeep b/routes/.gitkeep
new file mode 100644
--- /dev/null	
+++ b/routes/.gitkeep	
@@ -0,0 +1,1 @@
+
Index: routes/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/routes/index.js b/routes/index.js
new file mode 100644
--- /dev/null	
+++ b/routes/index.js	
@@ -0,0 +1,8 @@
+const express = require('express');
+const router = express.Router();
+const exampleController = require('../controllers/exampleController');
+
+// Example route
+router.get('/example', exampleController.exampleFunction);
+
+module.exports = router;
Index: .gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibs.java b/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibs.java
new file mode 100644
--- /dev/null	
+++ b/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibs.java	
@@ -0,0 +1,495 @@
+package org.gradle.accessors.dm;
+
+import org.gradle.api.NonNullApi;
+import org.gradle.api.artifacts.MinimalExternalModuleDependency;
+import org.gradle.plugin.use.PluginDependency;
+import org.gradle.api.artifacts.ExternalModuleDependencyBundle;
+import org.gradle.api.artifacts.MutableVersionConstraint;
+import org.gradle.api.provider.Provider;
+import org.gradle.api.model.ObjectFactory;
+import org.gradle.api.provider.ProviderFactory;
+import org.gradle.api.internal.catalog.AbstractExternalDependencyFactory;
+import org.gradle.api.internal.catalog.DefaultVersionCatalog;
+import java.util.Map;
+import org.gradle.api.internal.attributes.ImmutableAttributesFactory;
+import org.gradle.api.internal.artifacts.dsl.CapabilityNotationParser;
+import javax.inject.Inject;
+
+/**
+ * A catalog of dependencies accessible via the {@code libs} extension.
+ */
+@NonNullApi
+public class LibrariesForLibs extends AbstractExternalDependencyFactory {
+
+    private final AbstractExternalDependencyFactory owner = this;
+    private final AndroidxLibraryAccessors laccForAndroidxLibraryAccessors = new AndroidxLibraryAccessors(owner);
+    private final VersionAccessors vaccForVersionAccessors = new VersionAccessors(providers, config);
+    private final BundleAccessors baccForBundleAccessors = new BundleAccessors(objects, providers, config, attributesFactory, capabilityNotationParser);
+    private final PluginAccessors paccForPluginAccessors = new PluginAccessors(providers, config);
+
+    @Inject
+    public LibrariesForLibs(DefaultVersionCatalog config, ProviderFactory providers, ObjectFactory objects, ImmutableAttributesFactory attributesFactory, CapabilityNotationParser capabilityNotationParser) {
+        super(config, providers, objects, attributesFactory, capabilityNotationParser);
+    }
+
+    /**
+     * Dependency provider for <b>junit</b> with <b>junit:junit</b> coordinates and
+     * with version reference <b>junit</b>
+     * <p>
+     * This dependency was declared in catalog libs.versions.toml
+     */
+    public Provider<MinimalExternalModuleDependency> getJunit() {
+        return create("junit");
+    }
+
+    /**
+     * Group of libraries at <b>androidx</b>
+     */
+    public AndroidxLibraryAccessors getAndroidx() {
+        return laccForAndroidxLibraryAccessors;
+    }
+
+    /**
+     * Group of versions at <b>versions</b>
+     */
+    public VersionAccessors getVersions() {
+        return vaccForVersionAccessors;
+    }
+
+    /**
+     * Group of bundles at <b>bundles</b>
+     */
+    public BundleAccessors getBundles() {
+        return baccForBundleAccessors;
+    }
+
+    /**
+     * Group of plugins at <b>plugins</b>
+     */
+    public PluginAccessors getPlugins() {
+        return paccForPluginAccessors;
+    }
+
+    public static class AndroidxLibraryAccessors extends SubDependencyFactory {
+        private final AndroidxActivityLibraryAccessors laccForAndroidxActivityLibraryAccessors = new AndroidxActivityLibraryAccessors(owner);
+        private final AndroidxComposeLibraryAccessors laccForAndroidxComposeLibraryAccessors = new AndroidxComposeLibraryAccessors(owner);
+        private final AndroidxCoreLibraryAccessors laccForAndroidxCoreLibraryAccessors = new AndroidxCoreLibraryAccessors(owner);
+        private final AndroidxEspressoLibraryAccessors laccForAndroidxEspressoLibraryAccessors = new AndroidxEspressoLibraryAccessors(owner);
+        private final AndroidxLifecycleLibraryAccessors laccForAndroidxLifecycleLibraryAccessors = new AndroidxLifecycleLibraryAccessors(owner);
+        private final AndroidxUiLibraryAccessors laccForAndroidxUiLibraryAccessors = new AndroidxUiLibraryAccessors(owner);
+
+        public AndroidxLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>junit</b> with <b>androidx.test.ext:junit</b> coordinates and
+         * with version reference <b>junitVersion</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getJunit() {
+            return create("androidx.junit");
+        }
+
+        /**
+         * Dependency provider for <b>material3</b> with <b>androidx.compose.material3:material3</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getMaterial3() {
+            return create("androidx.material3");
+        }
+
+        /**
+         * Group of libraries at <b>androidx.activity</b>
+         */
+        public AndroidxActivityLibraryAccessors getActivity() {
+            return laccForAndroidxActivityLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.compose</b>
+         */
+        public AndroidxComposeLibraryAccessors getCompose() {
+            return laccForAndroidxComposeLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.core</b>
+         */
+        public AndroidxCoreLibraryAccessors getCore() {
+            return laccForAndroidxCoreLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.espresso</b>
+         */
+        public AndroidxEspressoLibraryAccessors getEspresso() {
+            return laccForAndroidxEspressoLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.lifecycle</b>
+         */
+        public AndroidxLifecycleLibraryAccessors getLifecycle() {
+            return laccForAndroidxLifecycleLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui</b>
+         */
+        public AndroidxUiLibraryAccessors getUi() {
+            return laccForAndroidxUiLibraryAccessors;
+        }
+
+    }
+
+    public static class AndroidxActivityLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxActivityLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>compose</b> with <b>androidx.activity:activity-compose</b> coordinates and
+         * with version reference <b>activityCompose</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getCompose() {
+            return create("androidx.activity.compose");
+        }
+
+    }
+
+    public static class AndroidxComposeLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxComposeLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>bom</b> with <b>androidx.compose:compose-bom</b> coordinates and
+         * with version reference <b>composeBom</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getBom() {
+            return create("androidx.compose.bom");
+        }
+
+    }
+
+    public static class AndroidxCoreLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxCoreLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ktx</b> with <b>androidx.core:core-ktx</b> coordinates and
+         * with version reference <b>coreKtx</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getKtx() {
+            return create("androidx.core.ktx");
+        }
+
+    }
+
+    public static class AndroidxEspressoLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxEspressoLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>core</b> with <b>androidx.test.espresso:espresso-core</b> coordinates and
+         * with version reference <b>espressoCore</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getCore() {
+            return create("androidx.espresso.core");
+        }
+
+    }
+
+    public static class AndroidxLifecycleLibraryAccessors extends SubDependencyFactory {
+        private final AndroidxLifecycleRuntimeLibraryAccessors laccForAndroidxLifecycleRuntimeLibraryAccessors = new AndroidxLifecycleRuntimeLibraryAccessors(owner);
+
+        public AndroidxLifecycleLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Group of libraries at <b>androidx.lifecycle.runtime</b>
+         */
+        public AndroidxLifecycleRuntimeLibraryAccessors getRuntime() {
+            return laccForAndroidxLifecycleRuntimeLibraryAccessors;
+        }
+
+    }
+
+    public static class AndroidxLifecycleRuntimeLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxLifecycleRuntimeLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ktx</b> with <b>androidx.lifecycle:lifecycle-runtime-ktx</b> coordinates and
+         * with version reference <b>lifecycleRuntimeKtx</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getKtx() {
+            return create("androidx.lifecycle.runtime.ktx");
+        }
+
+    }
+
+    public static class AndroidxUiLibraryAccessors extends SubDependencyFactory implements DependencyNotationSupplier {
+        private final AndroidxUiTestLibraryAccessors laccForAndroidxUiTestLibraryAccessors = new AndroidxUiTestLibraryAccessors(owner);
+        private final AndroidxUiToolingLibraryAccessors laccForAndroidxUiToolingLibraryAccessors = new AndroidxUiToolingLibraryAccessors(owner);
+
+        public AndroidxUiLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ui</b> with <b>androidx.compose.ui:ui</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> asProvider() {
+            return create("androidx.ui");
+        }
+
+        /**
+         * Dependency provider for <b>graphics</b> with <b>androidx.compose.ui:ui-graphics</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getGraphics() {
+            return create("androidx.ui.graphics");
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui.test</b>
+         */
+        public AndroidxUiTestLibraryAccessors getTest() {
+            return laccForAndroidxUiTestLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui.tooling</b>
+         */
+        public AndroidxUiToolingLibraryAccessors getTooling() {
+            return laccForAndroidxUiToolingLibraryAccessors;
+        }
+
+    }
+
+    public static class AndroidxUiTestLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxUiTestLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>junit4</b> with <b>androidx.compose.ui:ui-test-junit4</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getJunit4() {
+            return create("androidx.ui.test.junit4");
+        }
+
+        /**
+         * Dependency provider for <b>manifest</b> with <b>androidx.compose.ui:ui-test-manifest</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getManifest() {
+            return create("androidx.ui.test.manifest");
+        }
+
+    }
+
+    public static class AndroidxUiToolingLibraryAccessors extends SubDependencyFactory implements DependencyNotationSupplier {
+
+        public AndroidxUiToolingLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>tooling</b> with <b>androidx.compose.ui:ui-tooling</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> asProvider() {
+            return create("androidx.ui.tooling");
+        }
+
+        /**
+         * Dependency provider for <b>preview</b> with <b>androidx.compose.ui:ui-tooling-preview</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         */
+        public Provider<MinimalExternalModuleDependency> getPreview() {
+            return create("androidx.ui.tooling.preview");
+        }
+
+    }
+
+    public static class VersionAccessors extends VersionFactory  {
+
+        public VersionAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Version alias <b>activityCompose</b> with value <b>1.8.0</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getActivityCompose() { return getVersion("activityCompose"); }
+
+        /**
+         * Version alias <b>agp</b> with value <b>8.7.2</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getAgp() { return getVersion("agp"); }
+
+        /**
+         * Version alias <b>composeBom</b> with value <b>2024.04.01</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getComposeBom() { return getVersion("composeBom"); }
+
+        /**
+         * Version alias <b>coreKtx</b> with value <b>1.10.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getCoreKtx() { return getVersion("coreKtx"); }
+
+        /**
+         * Version alias <b>espressoCore</b> with value <b>3.6.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getEspressoCore() { return getVersion("espressoCore"); }
+
+        /**
+         * Version alias <b>junit</b> with value <b>4.13.2</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getJunit() { return getVersion("junit"); }
+
+        /**
+         * Version alias <b>junitVersion</b> with value <b>1.1.5</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getJunitVersion() { return getVersion("junitVersion"); }
+
+        /**
+         * Version alias <b>kotlin</b> with value <b>2.0.0</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getKotlin() { return getVersion("kotlin"); }
+
+        /**
+         * Version alias <b>lifecycleRuntimeKtx</b> with value <b>2.6.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getLifecycleRuntimeKtx() { return getVersion("lifecycleRuntimeKtx"); }
+
+    }
+
+    public static class BundleAccessors extends BundleFactory {
+
+        public BundleAccessors(ObjectFactory objects, ProviderFactory providers, DefaultVersionCatalog config, ImmutableAttributesFactory attributesFactory, CapabilityNotationParser capabilityNotationParser) { super(objects, providers, config, attributesFactory, capabilityNotationParser); }
+
+    }
+
+    public static class PluginAccessors extends PluginFactory {
+        private final AndroidPluginAccessors paccForAndroidPluginAccessors = new AndroidPluginAccessors(providers, config);
+        private final KotlinPluginAccessors paccForKotlinPluginAccessors = new KotlinPluginAccessors(providers, config);
+
+        public PluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Group of plugins at <b>plugins.android</b>
+         */
+        public AndroidPluginAccessors getAndroid() {
+            return paccForAndroidPluginAccessors;
+        }
+
+        /**
+         * Group of plugins at <b>plugins.kotlin</b>
+         */
+        public KotlinPluginAccessors getKotlin() {
+            return paccForKotlinPluginAccessors;
+        }
+
+    }
+
+    public static class AndroidPluginAccessors extends PluginFactory {
+
+        public AndroidPluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Plugin provider for <b>android.application</b> with plugin id <b>com.android.application</b> and
+         * with version reference <b>agp</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getApplication() { return createPlugin("android.application"); }
+
+    }
+
+    public static class KotlinPluginAccessors extends PluginFactory {
+
+        public KotlinPluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Plugin provider for <b>kotlin.android</b> with plugin id <b>org.jetbrains.kotlin.android</b> and
+         * with version reference <b>kotlin</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getAndroid() { return createPlugin("kotlin.android"); }
+
+        /**
+         * Plugin provider for <b>kotlin.compose</b> with plugin id <b>org.jetbrains.kotlin.plugin.compose</b> and
+         * with version reference <b>kotlin</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getCompose() { return createPlugin("kotlin.compose"); }
+
+    }
+
+}
Index: .gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibsInPluginsBlock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibsInPluginsBlock.java b/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibsInPluginsBlock.java
new file mode 100644
--- /dev/null	
+++ b/.gradle/8.9/dependencies-accessors/653825400482ee63928b2750563e94a5ec2d47e4/sources/org/gradle/accessors/dm/LibrariesForLibsInPluginsBlock.java	
@@ -0,0 +1,639 @@
+package org.gradle.accessors.dm;
+
+import org.gradle.api.NonNullApi;
+import org.gradle.api.artifacts.MinimalExternalModuleDependency;
+import org.gradle.plugin.use.PluginDependency;
+import org.gradle.api.artifacts.ExternalModuleDependencyBundle;
+import org.gradle.api.artifacts.MutableVersionConstraint;
+import org.gradle.api.provider.Provider;
+import org.gradle.api.model.ObjectFactory;
+import org.gradle.api.provider.ProviderFactory;
+import org.gradle.api.internal.catalog.AbstractExternalDependencyFactory;
+import org.gradle.api.internal.catalog.DefaultVersionCatalog;
+import java.util.Map;
+import org.gradle.api.internal.attributes.ImmutableAttributesFactory;
+import org.gradle.api.internal.artifacts.dsl.CapabilityNotationParser;
+import javax.inject.Inject;
+
+/**
+ * A catalog of dependencies accessible via the {@code libs} extension.
+ */
+@NonNullApi
+public class LibrariesForLibsInPluginsBlock extends AbstractExternalDependencyFactory {
+
+    private final AbstractExternalDependencyFactory owner = this;
+    private final AndroidxLibraryAccessors laccForAndroidxLibraryAccessors = new AndroidxLibraryAccessors(owner);
+    private final VersionAccessors vaccForVersionAccessors = new VersionAccessors(providers, config);
+    private final BundleAccessors baccForBundleAccessors = new BundleAccessors(objects, providers, config, attributesFactory, capabilityNotationParser);
+    private final PluginAccessors paccForPluginAccessors = new PluginAccessors(providers, config);
+
+    @Inject
+    public LibrariesForLibsInPluginsBlock(DefaultVersionCatalog config, ProviderFactory providers, ObjectFactory objects, ImmutableAttributesFactory attributesFactory, CapabilityNotationParser capabilityNotationParser) {
+        super(config, providers, objects, attributesFactory, capabilityNotationParser);
+    }
+
+    /**
+     * Dependency provider for <b>junit</b> with <b>junit:junit</b> coordinates and
+     * with version reference <b>junit</b>
+     * <p>
+     * This dependency was declared in catalog libs.versions.toml
+     *
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public Provider<MinimalExternalModuleDependency> getJunit() {
+        org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+        return create("junit");
+    }
+
+    /**
+     * Group of libraries at <b>androidx</b>
+     *
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public AndroidxLibraryAccessors getAndroidx() {
+        org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+        return laccForAndroidxLibraryAccessors;
+    }
+
+    /**
+     * Group of versions at <b>versions</b>
+     */
+    public VersionAccessors getVersions() {
+        return vaccForVersionAccessors;
+    }
+
+    /**
+     * Group of bundles at <b>bundles</b>
+     *
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public BundleAccessors getBundles() {
+        org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+        return baccForBundleAccessors;
+    }
+
+    /**
+     * Group of plugins at <b>plugins</b>
+     */
+    public PluginAccessors getPlugins() {
+        return paccForPluginAccessors;
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxLibraryAccessors extends SubDependencyFactory {
+        private final AndroidxActivityLibraryAccessors laccForAndroidxActivityLibraryAccessors = new AndroidxActivityLibraryAccessors(owner);
+        private final AndroidxComposeLibraryAccessors laccForAndroidxComposeLibraryAccessors = new AndroidxComposeLibraryAccessors(owner);
+        private final AndroidxCoreLibraryAccessors laccForAndroidxCoreLibraryAccessors = new AndroidxCoreLibraryAccessors(owner);
+        private final AndroidxEspressoLibraryAccessors laccForAndroidxEspressoLibraryAccessors = new AndroidxEspressoLibraryAccessors(owner);
+        private final AndroidxLifecycleLibraryAccessors laccForAndroidxLifecycleLibraryAccessors = new AndroidxLifecycleLibraryAccessors(owner);
+        private final AndroidxUiLibraryAccessors laccForAndroidxUiLibraryAccessors = new AndroidxUiLibraryAccessors(owner);
+
+        public AndroidxLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>junit</b> with <b>androidx.test.ext:junit</b> coordinates and
+         * with version reference <b>junitVersion</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getJunit() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.junit");
+        }
+
+        /**
+         * Dependency provider for <b>material3</b> with <b>androidx.compose.material3:material3</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getMaterial3() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.material3");
+        }
+
+        /**
+         * Group of libraries at <b>androidx.activity</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxActivityLibraryAccessors getActivity() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxActivityLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.compose</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxComposeLibraryAccessors getCompose() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxComposeLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.core</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxCoreLibraryAccessors getCore() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxCoreLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.espresso</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxEspressoLibraryAccessors getEspresso() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxEspressoLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.lifecycle</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxLifecycleLibraryAccessors getLifecycle() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxLifecycleLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxUiLibraryAccessors getUi() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxUiLibraryAccessors;
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxActivityLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxActivityLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>compose</b> with <b>androidx.activity:activity-compose</b> coordinates and
+         * with version reference <b>activityCompose</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getCompose() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.activity.compose");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxComposeLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxComposeLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>bom</b> with <b>androidx.compose:compose-bom</b> coordinates and
+         * with version reference <b>composeBom</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getBom() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.compose.bom");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxCoreLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxCoreLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ktx</b> with <b>androidx.core:core-ktx</b> coordinates and
+         * with version reference <b>coreKtx</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getKtx() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.core.ktx");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxEspressoLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxEspressoLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>core</b> with <b>androidx.test.espresso:espresso-core</b> coordinates and
+         * with version reference <b>espressoCore</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getCore() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.espresso.core");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxLifecycleLibraryAccessors extends SubDependencyFactory {
+        private final AndroidxLifecycleRuntimeLibraryAccessors laccForAndroidxLifecycleRuntimeLibraryAccessors = new AndroidxLifecycleRuntimeLibraryAccessors(owner);
+
+        public AndroidxLifecycleLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Group of libraries at <b>androidx.lifecycle.runtime</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxLifecycleRuntimeLibraryAccessors getRuntime() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxLifecycleRuntimeLibraryAccessors;
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxLifecycleRuntimeLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxLifecycleRuntimeLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ktx</b> with <b>androidx.lifecycle:lifecycle-runtime-ktx</b> coordinates and
+         * with version reference <b>lifecycleRuntimeKtx</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getKtx() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.lifecycle.runtime.ktx");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxUiLibraryAccessors extends SubDependencyFactory implements DependencyNotationSupplier {
+        private final AndroidxUiTestLibraryAccessors laccForAndroidxUiTestLibraryAccessors = new AndroidxUiTestLibraryAccessors(owner);
+        private final AndroidxUiToolingLibraryAccessors laccForAndroidxUiToolingLibraryAccessors = new AndroidxUiToolingLibraryAccessors(owner);
+
+        public AndroidxUiLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>ui</b> with <b>androidx.compose.ui:ui</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> asProvider() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui");
+        }
+
+        /**
+         * Dependency provider for <b>graphics</b> with <b>androidx.compose.ui:ui-graphics</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getGraphics() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui.graphics");
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui.test</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxUiTestLibraryAccessors getTest() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxUiTestLibraryAccessors;
+        }
+
+        /**
+         * Group of libraries at <b>androidx.ui.tooling</b>
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public AndroidxUiToolingLibraryAccessors getTooling() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return laccForAndroidxUiToolingLibraryAccessors;
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxUiTestLibraryAccessors extends SubDependencyFactory {
+
+        public AndroidxUiTestLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>junit4</b> with <b>androidx.compose.ui:ui-test-junit4</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getJunit4() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui.test.junit4");
+        }
+
+        /**
+         * Dependency provider for <b>manifest</b> with <b>androidx.compose.ui:ui-test-manifest</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getManifest() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui.test.manifest");
+        }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class AndroidxUiToolingLibraryAccessors extends SubDependencyFactory implements DependencyNotationSupplier {
+
+        public AndroidxUiToolingLibraryAccessors(AbstractExternalDependencyFactory owner) { super(owner); }
+
+        /**
+         * Dependency provider for <b>tooling</b> with <b>androidx.compose.ui:ui-tooling</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> asProvider() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui.tooling");
+        }
+
+        /**
+         * Dependency provider for <b>preview</b> with <b>androidx.compose.ui:ui-tooling-preview</b> coordinates and
+         * with <b>no version specified</b>
+         * <p>
+         * This dependency was declared in catalog libs.versions.toml
+         *
+         * @deprecated Will be removed in Gradle 9.0.
+         */
+        @Deprecated
+        public Provider<MinimalExternalModuleDependency> getPreview() {
+            org.gradle.internal.deprecation.DeprecationLogger.deprecateBehaviour("Accessing libraries or bundles from version catalogs in the plugins block.").withAdvice("Only use versions or plugins from catalogs in the plugins block.").willBeRemovedInGradle9().withUpgradeGuideSection(8, "kotlin_dsl_deprecated_catalogs_plugins_block").nagUser();
+            return create("androidx.ui.tooling.preview");
+        }
+
+    }
+
+    public static class VersionAccessors extends VersionFactory  {
+
+        public VersionAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Version alias <b>activityCompose</b> with value <b>1.8.0</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getActivityCompose() { return getVersion("activityCompose"); }
+
+        /**
+         * Version alias <b>agp</b> with value <b>8.7.2</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getAgp() { return getVersion("agp"); }
+
+        /**
+         * Version alias <b>composeBom</b> with value <b>2024.04.01</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getComposeBom() { return getVersion("composeBom"); }
+
+        /**
+         * Version alias <b>coreKtx</b> with value <b>1.10.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getCoreKtx() { return getVersion("coreKtx"); }
+
+        /**
+         * Version alias <b>espressoCore</b> with value <b>3.6.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getEspressoCore() { return getVersion("espressoCore"); }
+
+        /**
+         * Version alias <b>junit</b> with value <b>4.13.2</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getJunit() { return getVersion("junit"); }
+
+        /**
+         * Version alias <b>junitVersion</b> with value <b>1.1.5</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getJunitVersion() { return getVersion("junitVersion"); }
+
+        /**
+         * Version alias <b>kotlin</b> with value <b>2.0.0</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getKotlin() { return getVersion("kotlin"); }
+
+        /**
+         * Version alias <b>lifecycleRuntimeKtx</b> with value <b>2.6.1</b>
+         * <p>
+         * If the version is a rich version and cannot be represented as a
+         * single version string, an empty string is returned.
+         * <p>
+         * This version was declared in catalog libs.versions.toml
+         */
+        public Provider<String> getLifecycleRuntimeKtx() { return getVersion("lifecycleRuntimeKtx"); }
+
+    }
+
+    /**
+     * @deprecated Will be removed in Gradle 9.0.
+     */
+    @Deprecated
+    public static class BundleAccessors extends BundleFactory {
+
+        public BundleAccessors(ObjectFactory objects, ProviderFactory providers, DefaultVersionCatalog config, ImmutableAttributesFactory attributesFactory, CapabilityNotationParser capabilityNotationParser) { super(objects, providers, config, attributesFactory, capabilityNotationParser); }
+
+    }
+
+    public static class PluginAccessors extends PluginFactory {
+        private final AndroidPluginAccessors paccForAndroidPluginAccessors = new AndroidPluginAccessors(providers, config);
+        private final KotlinPluginAccessors paccForKotlinPluginAccessors = new KotlinPluginAccessors(providers, config);
+
+        public PluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Group of plugins at <b>plugins.android</b>
+         */
+        public AndroidPluginAccessors getAndroid() {
+            return paccForAndroidPluginAccessors;
+        }
+
+        /**
+         * Group of plugins at <b>plugins.kotlin</b>
+         */
+        public KotlinPluginAccessors getKotlin() {
+            return paccForKotlinPluginAccessors;
+        }
+
+    }
+
+    public static class AndroidPluginAccessors extends PluginFactory {
+
+        public AndroidPluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Plugin provider for <b>android.application</b> with plugin id <b>com.android.application</b> and
+         * with version reference <b>agp</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getApplication() { return createPlugin("android.application"); }
+
+    }
+
+    public static class KotlinPluginAccessors extends PluginFactory {
+
+        public KotlinPluginAccessors(ProviderFactory providers, DefaultVersionCatalog config) { super(providers, config); }
+
+        /**
+         * Plugin provider for <b>kotlin.android</b> with plugin id <b>org.jetbrains.kotlin.android</b> and
+         * with version reference <b>kotlin</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getAndroid() { return createPlugin("kotlin.android"); }
+
+        /**
+         * Plugin provider for <b>kotlin.compose</b> with plugin id <b>org.jetbrains.kotlin.plugin.compose</b> and
+         * with version reference <b>kotlin</b>
+         * <p>
+         * This plugin was declared in catalog libs.versions.toml
+         */
+        public Provider<PluginDependency> getCompose() { return createPlugin("kotlin.compose"); }
+
+    }
+
+}
Index: Gemfile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Gemfile b/Gemfile
new file mode 100644
--- /dev/null	
+++ b/Gemfile	
@@ -0,0 +1,10 @@
+source 'https://rubygems.org'
+
+gem 'rails', '~> 6.1'
+# Add other gems your project needs
+gem 'mutex_m'
+gem 'fiddle'
+gem 'ostruct'
+gem 'logger'
+gem 'base64'
+gem 'bigdecimal'
Index: gradlew
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradlew b/gradlew
new file mode 100644
--- /dev/null	
+++ b/gradlew	
@@ -0,0 +1,185 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=`expr $i + 1`
+    done
+    case $i in
+        0) set -- ;;
+        1) set -- "$args0" ;;
+        2) set -- "$args0" "$args1" ;;
+        3) set -- "$args0" "$args1" "$args2" ;;
+        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=`save "$@"`
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+exec "$JAVACMD" "$@"
Index: index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/index.js b/index.js
new file mode 100644
--- /dev/null	
+++ b/index.js	
@@ -0,0 +1,1 @@
+Add example files for routes// Entry point for the application
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
new file mode 100644
--- /dev/null	
+++ b/README.md	
@@ -0,0 +1,12 @@
+Innovative Rideshare Solutions
+Let’s Go Rideshare LLC was founded by Don Badsha, who spent several years driving for Uber and Lyft. His experiences revealed major gaps in the rideshare industry, particularly in safety, ride consistency, and driver satisfaction. These challenges inspired him to create Let’s Go Rideshare, a platform designed to address these issues head-on while providing a better experience for both riders and drivers.
+
+One of the most significant innovations introduced by Let’s Go Rideshare is the dual-stage identity verification system. This feature enhances safety by requiring multiple layers of verification for both drivers and riders before each trip begins. This method ensures a higher level of trust and security compared to existing platforms. Additionally, Let’s Go Rideshare offers optional live trip recordings, providing riders and drivers with an extra layer of protection during each journey. These combined safety features set new standards in the rideshare industry, giving users peace of mind.
+
+To further improve the quality of the service, Let’s Go Rideshare focuses on maintaining consistent ride quality. The platform uses real-time trip monitoring and conducts thorough vehicle inspections to ensure all cars meet high standards of cleanliness, safety, and comfort. Let’s Go Rideshare also takes a unique approach to improving driver satisfaction by using a rewards system based on Net Promoter Scores (NPS). Drivers are incentivized to provide excellent service, and this performance-based system ensures that riders receive a better overall experience.
+
+One of the standout features of Let’s Go Rideshare is its transparent pricing model. Unlike other rideshare platforms that use surge pricing during peak hours or periods of high demand, Let’s Go Rideshare eliminates surge pricing altogether. Instead, it offers fixed pricing driven by real-time data analytics, ensuring that riders always know what to expect. This approach improves fairness and predictability for riders, creating a more customer-friendly environment and avoiding the frustration of fluctuating fares.
+
+Inclusivity is another critical aspect of Let’s Go Rides hare's business model. The platform is designed to cater to a wide range of passengers, including elderly individuals and those needing medical transport. Let’s Go Rideshare offers specialized services for these groups, ensuring that all passengers have access to safe, reliable, and comfortable transportation options. By focusing on inclusivity, Let’s Go Rideshare ensures that it serves the broader community, especially those who may not be adequately served by traditional rideshare platforms.
+
+In summary, Let’s Go Rideshare LLC offers a reimagined approach to ride sharing, solving key industry issues like safety, ride quality, and pricing fairness. The company uses innovative technology to improve the experience for both riders and drivers while maintaining a commitment to inclusivity and community-focused services. Through its advanced safety protocols, real-time monitoring, fixed pricing, and driver incentive programs, Let’s Go Rideshare sets itself apart as a leader in the rideshare industry, offering practical and meaningful solutions to real-world problems. 
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null	
+++ b/.gitignore	
@@ -0,0 +1,15 @@
+*.iml
+.gradle
+/local.properties
+/.idea/caches
+/.idea/libraries
+/.idea/modules.xml
+/.idea/workspace.xml
+/.idea/navEditor.xml
+/.idea/assetWizardSettings.xml
+.DS_Store
+/build
+/captures
+.externalNativeBuild
+.cxx
+local.properties
Index: controllers/.gitkeep
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/controllers/.gitkeep b/controllers/.gitkeep
new file mode 100644
--- /dev/null	
+++ b/controllers/.gitkeep	
@@ -0,0 +1,1 @@
+
Index: controllers/exampleController.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/controllers/exampleController.js b/controllers/exampleController.js
new file mode 100644
--- /dev/null	
+++ b/controllers/exampleController.js	
@@ -0,0 +1,4 @@
+// Example Controller
+exports.exampleFunction = (req, res) => {
+    res.send('Hello, world!');
+};
Index: gradlew.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
--- /dev/null	
+++ b/gradlew.bat	
@@ -0,0 +1,89 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
Index: trigger.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/trigger.txt b/trigger.txt
new file mode 100644
--- /dev/null	
+++ b/trigger.txt	
@@ -0,0 +1,1 @@
+"Triggering CI/CD pipeline" 
Index: libffi-3.4.6/m4/asmcfi.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/asmcfi.m4 b/libffi-3.4.6/m4/asmcfi.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/asmcfi.m4	
@@ -0,0 +1,13 @@
+AC_DEFUN([GCC_AS_CFI_PSEUDO_OP],
+[AC_CACHE_CHECK([assembler .cfi pseudo-op support],
+    gcc_cv_as_cfi_pseudo_op, [
+    gcc_cv_as_cfi_pseudo_op=unknown
+    AC_TRY_COMPILE([asm (".cfi_sections\n\t.cfi_startproc\n\t.cfi_endproc");],,
+		   [gcc_cv_as_cfi_pseudo_op=yes],
+		   [gcc_cv_as_cfi_pseudo_op=no])
+ ])
+ if test "x$gcc_cv_as_cfi_pseudo_op" = xyes; then
+    AC_DEFINE(HAVE_AS_CFI_PSEUDO_OP, 1,
+	      [Define if your assembler supports .cfi_* directives.])
+ fi
+])
Index: libffi-3.4.6/m4/ax_cc_maxopt.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_cc_maxopt.m4 b/libffi-3.4.6/m4/ax_cc_maxopt.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_cc_maxopt.m4	
@@ -0,0 +1,198 @@
+# ===========================================================================
+#       https://www.gnu.org/software/autoconf-archive/ax_cc_maxopt.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CC_MAXOPT
+#
+# DESCRIPTION
+#
+#   Try to turn on "good" C optimization flags for various compilers and
+#   architectures, for some definition of "good". (In our case, good for
+#   FFTW and hopefully for other scientific codes. Modify as needed.)
+#
+#   The user can override the flags by setting the CFLAGS environment
+#   variable. The user can also specify --enable-portable-binary in order to
+#   disable any optimization flags that might result in a binary that only
+#   runs on the host architecture.
+#
+#   Note also that the flags assume that ANSI C aliasing rules are followed
+#   by the code (e.g. for gcc's -fstrict-aliasing), and that floating-point
+#   computations can be re-ordered as needed.
+#
+#   Requires macros: AX_CHECK_COMPILE_FLAG, AX_COMPILER_VENDOR,
+#   AX_GCC_ARCHFLAG, AX_GCC_X86_CPUID.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2008 Matteo Frigo
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 22
+
+AC_DEFUN([AX_CC_MAXOPT],
+[
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AX_COMPILER_VENDOR])
+AC_REQUIRE([AC_CANONICAL_HOST])
+
+AC_ARG_ENABLE(portable-binary, [AS_HELP_STRING([--enable-portable-binary], [disable compiler optimizations that would produce unportable binaries])],
+	acx_maxopt_portable=$enableval, acx_maxopt_portable=no)
+
+# Try to determine "good" native compiler flags if none specified via CFLAGS
+if test "x$ac_test_CFLAGS" = "x"; then
+  case $ax_cv_c_compiler_vendor in
+    dec) CFLAGS="$CFLAGS -newc -w0 -O5 -ansi_alias -ansi_args -fp_reorder -tune host"
+	 if test "x$acx_maxopt_portable" = xno; then
+           CFLAGS="$CFLAGS -arch host"
+         fi;;
+
+    sun) CFLAGS="$CFLAGS -native -fast -xO5 -dalign"
+	 if test "x$acx_maxopt_portable" = xyes; then
+	   CFLAGS="$CFLAGS -xarch=generic"
+         fi;;
+
+    hp)  CFLAGS="$CFLAGS +Oall +Optrs_ansi +DSnative"
+	 if test "x$acx_maxopt_portable" = xyes; then
+	   CFLAGS="$CFLAGS +DAportable"
+	 fi;;
+
+    ibm) if test "x$acx_maxopt_portable" = xno; then
+           xlc_opt="-qarch=auto -qtune=auto"
+	 else
+           xlc_opt="-qtune=auto"
+	 fi
+         AX_CHECK_COMPILE_FLAG($xlc_opt,
+		CFLAGS="$CFLAGS -O3 -qansialias -w $xlc_opt",
+               [CFLAGS="$CFLAGS -O3 -qansialias -w"
+                echo "******************************************************"
+                echo "*  You seem to have the IBM  C compiler.  It is      *"
+                echo "*  recommended for best performance that you use:    *"
+                echo "*                                                    *"
+                echo "*    CFLAGS=-O3 -qarch=xxx -qtune=xxx -qansialias -w *"
+                echo "*                      ^^^        ^^^                *"
+                echo "*  where xxx is pwr2, pwr3, 604, or whatever kind of *"
+                echo "*  CPU you have.  (Set the CFLAGS environment var.   *"
+                echo "*  and re-run configure.)  For more info, man cc.    *"
+                echo "******************************************************"])
+         ;;
+
+    intel) CFLAGS="$CFLAGS -O3 -ansi_alias"
+	if test "x$acx_maxopt_portable" = xno; then
+	  icc_archflag=unknown
+	  icc_flags=""
+	  case $host_cpu in
+	    i686*|x86_64*)
+              # icc accepts gcc assembly syntax, so these should work:
+	      AX_GCC_X86_CPUID(0)
+              AX_GCC_X86_CPUID(1)
+	      case $ax_cv_gcc_x86_cpuid_0 in # see AX_GCC_ARCHFLAG
+                *:756e6547:6c65746e:49656e69) # Intel
+                  case $ax_cv_gcc_x86_cpuid_1 in
+		    *0?6[[78ab]]?:*:*:*|?6[[78ab]]?:*:*:*|6[[78ab]]?:*:*:*) icc_flags="-xK" ;;
+		    *0?6[[9d]]?:*:*:*|?6[[9d]]?:*:*:*|6[[9d]]?:*:*:*|*1?65?:*:*:*) icc_flags="-xSSE2 -xB -xK" ;;
+		    *0?6e?:*:*:*|?6e?:*:*:*|6e?:*:*:*) icc_flags="-xSSE3 -xP -xO -xB -xK" ;;
+		    *0?6f?:*:*:*|?6f?:*:*:*|6f?:*:*:*|*1?66?:*:*:*) icc_flags="-xSSSE3 -xT -xB -xK" ;;
+		    *1?6[[7d]]?:*:*:*) icc_flags="-xSSE4.1 -xS -xT -xB -xK" ;;
+		    *1?6[[aef]]?:*:*:*|*2?6[[5cef]]?:*:*:*) icc_flags="-xSSE4.2 -xS -xT -xB -xK" ;;
+		    *2?6[[ad]]?:*:*:*) icc_flags="-xAVX -SSE4.2 -xS -xT -xB -xK" ;;
+		    *3?6[[ae]]?:*:*:*) icc_flags="-xCORE-AVX-I -xAVX -SSE4.2 -xS -xT -xB -xK" ;;
+		    *3?6[[cf]]?:*:*:*|*4?6[[56]]?:*:*:*) icc_flags="-xCORE-AVX2 -xCORE-AVX-I -xAVX -SSE4.2 -xS -xT -xB -xK" ;;
+		    *000?f[[346]]?:*:*:*|?f[[346]]?:*:*:*|f[[346]]?:*:*:*) icc_flags="-xSSE3 -xP -xO -xN -xW -xK" ;;
+		    *00??f??:*:*:*|??f??:*:*:*|?f??:*:*:*|f??:*:*:*) icc_flags="-xSSE2 -xN -xW -xK" ;;
+                  esac ;;
+              esac ;;
+          esac
+          if test "x$icc_flags" != x; then
+            for flag in $icc_flags; do
+              AX_CHECK_COMPILE_FLAG($flag, [icc_archflag=$flag; break])
+            done
+          fi
+          AC_MSG_CHECKING([for icc architecture flag])
+	  AC_MSG_RESULT($icc_archflag)
+          if test "x$icc_archflag" != xunknown; then
+            CFLAGS="$CFLAGS $icc_archflag"
+          fi
+        fi
+	;;
+
+    nvhpc)
+     # default optimization flags for nvhpc
+     CFLAGS="$CFLAGS -O3"
+     ;;
+
+    gnu)
+     # default optimization flags for gcc on all systems
+     CFLAGS="$CFLAGS -O3 -fomit-frame-pointer"
+
+     # -malign-double for x86 systems
+     # LIBFFI_LOCAL: don't do this.
+     # The testsuite doesn't use these flags and we'll get test failures.
+     # AX_CHECK_COMPILE_FLAG(-malign-double, CFLAGS="$CFLAGS -malign-double")
+
+     #  -fstrict-aliasing for gcc-2.95+
+     AX_CHECK_COMPILE_FLAG(-fstrict-aliasing,
+	CFLAGS="$CFLAGS -fstrict-aliasing")
+
+     # note that we enable "unsafe" fp optimization with other compilers, too
+     AX_CHECK_COMPILE_FLAG(-ffast-math, CFLAGS="$CFLAGS -ffast-math")
+
+     AX_GCC_ARCHFLAG($acx_maxopt_portable)
+     ;;
+
+    microsoft)
+     # default optimization flags for MSVC opt builds
+     CFLAGS="$CFLAGS -O2"
+     ;;
+  esac
+
+  if test -z "$CFLAGS"; then
+	echo ""
+	echo "********************************************************"
+        echo "* WARNING: Don't know the best CFLAGS for this system  *"
+        echo "* Use ./configure CFLAGS=... to specify your own flags *"
+	echo "* (otherwise, a default of CFLAGS=-O3 will be used)    *"
+	echo "********************************************************"
+	echo ""
+        CFLAGS="$CFLAGS -O3"
+  fi
+
+  AX_CHECK_COMPILE_FLAG($CFLAGS, [], [
+	echo ""
+        echo "********************************************************"
+        echo "* WARNING: The guessed CFLAGS don't seem to work with  *"
+        echo "* your compiler.                                       *"
+        echo "* Use ./configure CFLAGS=... to specify your own flags *"
+        echo "********************************************************"
+        echo ""
+  ])
+
+fi
+])
Index: libffi-3.4.6/m4/ax_append_flag.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_append_flag.m4 b/libffi-3.4.6/m4/ax_append_flag.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_append_flag.m4	
@@ -0,0 +1,50 @@
+# ===========================================================================
+#      https://www.gnu.org/software/autoconf-archive/ax_append_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
+#   added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 8
+
+AC_DEFUN([AX_APPEND_FLAG],
+[dnl
+AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
+AS_VAR_SET_IF(FLAGS,[
+  AS_CASE([" AS_VAR_GET(FLAGS) "],
+    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
+    [
+     AS_VAR_APPEND(FLAGS,[" $1"])
+     AC_RUN_LOG([: FLAGS="$FLAGS"])
+    ])
+  ],
+  [
+  AS_VAR_SET(FLAGS,[$1])
+  AC_RUN_LOG([: FLAGS="$FLAGS"])
+  ])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
Index: libffi-3.4.6/m4/ax_gcc_archflag.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_gcc_archflag.m4 b/libffi-3.4.6/m4/ax_gcc_archflag.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_gcc_archflag.m4	
@@ -0,0 +1,267 @@
+# ===========================================================================
+#     https://www.gnu.org/software/autoconf-archive/ax_gcc_archflag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_ARCHFLAG([PORTABLE?], [ACTION-SUCCESS], [ACTION-FAILURE])
+#
+# DESCRIPTION
+#
+#   This macro tries to guess the "native" arch corresponding to the target
+#   architecture for use with gcc's -march=arch or -mtune=arch flags. If
+#   found, the cache variable $ax_cv_gcc_archflag is set to this flag and
+#   ACTION-SUCCESS is executed; otherwise $ax_cv_gcc_archflag is set to
+#   "unknown" and ACTION-FAILURE is executed. The default ACTION-SUCCESS is
+#   to add $ax_cv_gcc_archflag to the end of $CFLAGS.
+#
+#   PORTABLE? should be either [yes] (default) or [no]. In the former case,
+#   the flag is set to -mtune (or equivalent) so that the architecture is
+#   only used for tuning, but the instruction set used is still portable. In
+#   the latter case, the flag is set to -march (or equivalent) so that
+#   architecture-specific instructions are enabled.
+#
+#   The user can specify --with-gcc-arch=<arch> in order to override the
+#   macro's choice of architecture, or --without-gcc-arch to disable this.
+#
+#   When cross-compiling, or if $CC is not gcc, then ACTION-FAILURE is
+#   called unless the user specified --with-gcc-arch manually.
+#
+#   Requires macros: AX_CHECK_COMPILE_FLAG, AX_GCC_X86_CPUID
+#
+#   (The main emphasis here is on recent CPUs, on the principle that doing
+#   high-performance computing on old hardware is uncommon.)
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2008 Matteo Frigo
+#   Copyright (c) 2014 Tsukasa Oi
+#   Copyright (c) 2017-2018 Alexey Kopytov
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 22
+
+AC_DEFUN([AX_GCC_ARCHFLAG],
+[AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_CANONICAL_HOST])
+AC_REQUIRE([AC_PROG_SED])
+AC_REQUIRE([AX_COMPILER_VENDOR])
+
+AC_ARG_WITH(gcc-arch, [AS_HELP_STRING([--with-gcc-arch=<arch>], [use architecture <arch> for gcc -march/-mtune, instead of guessing])],
+	ax_gcc_arch=$withval, ax_gcc_arch=yes)
+
+AC_MSG_CHECKING([for gcc architecture flag])
+AC_MSG_RESULT([])
+AC_CACHE_VAL(ax_cv_gcc_archflag,
+[
+ax_cv_gcc_archflag="unknown"
+
+if test "$GCC" = yes; then
+
+if test "x$ax_gcc_arch" = xyes; then
+ax_gcc_arch=""
+if test "$cross_compiling" = no; then
+case $host_cpu in
+  i[[3456]]86*|x86_64*|amd64*) # use cpuid codes
+     AX_GCC_X86_CPUID(0)
+     AX_GCC_X86_CPUID(1)
+     case $ax_cv_gcc_x86_cpuid_0 in
+       *:756e6547:6c65746e:49656e69) # Intel
+          case $ax_cv_gcc_x86_cpuid_1 in
+	    *5[[4578]]?:*:*:*) ax_gcc_arch="pentium-mmx pentium" ;;
+	    *5[[123]]?:*:*:*) ax_gcc_arch=pentium ;;
+	    *0?61?:*:*:*|?61?:*:*:*|61?:*:*:*) ax_gcc_arch=pentiumpro ;;
+	    *0?6[[356]]?:*:*:*|?6[[356]]?:*:*:*|6[[356]]?:*:*:*) ax_gcc_arch="pentium2 pentiumpro" ;;
+	    *0?6[[78ab]]?:*:*:*|?6[[78ab]]?:*:*:*|6[[78ab]]?:*:*:*) ax_gcc_arch="pentium3 pentiumpro" ;;
+	    *0?6[[9d]]?:*:*:*|?6[[9d]]?:*:*:*|6[[9d]]?:*:*:*|*1?65?:*:*:*) ax_gcc_arch="pentium-m pentium3 pentiumpro" ;;
+	    *0?6e?:*:*:*|?6e?:*:*:*|6e?:*:*:*) ax_gcc_arch="yonah pentium-m pentium3 pentiumpro" ;;
+	    *0?6f?:*:*:*|?6f?:*:*:*|6f?:*:*:*|*1?66?:*:*:*) ax_gcc_arch="core2 pentium-m pentium3 pentiumpro" ;;
+	    *1?6[[7d]]?:*:*:*) ax_gcc_arch="penryn core2 pentium-m pentium3 pentiumpro" ;;
+	    *1?6[[aef]]?:*:*:*|*2?6e?:*:*:*) ax_gcc_arch="nehalem corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *2?6[[5cf]]?:*:*:*) ax_gcc_arch="westmere corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *2?6[[ad]]?:*:*:*) ax_gcc_arch="sandybridge corei7-avx corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *3?6[[ae]]?:*:*:*) ax_gcc_arch="ivybridge core-avx-i corei7-avx corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *3?6[[cf]]?:*:*:*|*4?6[[56]]?:*:*:*) ax_gcc_arch="haswell core-avx2 core-avx-i corei7-avx corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *3?6d?:*:*:*|*4?6[[7f]]?:*:*:*|*5?66?:*:*:*) ax_gcc_arch="broadwell core-avx2 core-avx-i corei7-avx corei7 core2 pentium-m pentium3 pentiumpro" ;;
+	    *1?6c?:*:*:*|*2?6[[67]]?:*:*:*|*3?6[[56]]?:*:*:*) ax_gcc_arch="bonnell atom core2 pentium-m pentium3 pentiumpro" ;;
+	    *3?67?:*:*:*|*[[45]]?6[[ad]]?:*:*:*) ax_gcc_arch="silvermont atom core2 pentium-m pentium3 pentiumpro" ;;
+	    *000?f[[012]]?:*:*:*|?f[[012]]?:*:*:*|f[[012]]?:*:*:*) ax_gcc_arch="pentium4 pentiumpro" ;;
+	    *000?f[[346]]?:*:*:*|?f[[346]]?:*:*:*|f[[346]]?:*:*:*) ax_gcc_arch="nocona prescott pentium4 pentiumpro" ;;
+	    # fallback
+	    *5??:*:*:*) ax_gcc_arch=pentium ;;
+	    *??6??:*:*:*) ax_gcc_arch="core2 pentiumpro" ;;
+	    *6??:*:*:*) ax_gcc_arch=pentiumpro ;;
+	    *00??f??:*:*:*|??f??:*:*:*|?f??:*:*:*|f??:*:*:*) ax_gcc_arch="pentium4 pentiumpro" ;;
+          esac ;;
+       *:68747541:444d4163:69746e65) # AMD
+          case $ax_cv_gcc_x86_cpuid_1 in
+	    *5[[67]]?:*:*:*) ax_gcc_arch=k6 ;;
+	    *5[[8]]?:*:*:*) ax_gcc_arch="k6-2 k6" ;;
+	    *5[[9d]]?:*:*:*) ax_gcc_arch="k6-3 k6" ;;
+	    *6[[12]]?:*:*:*) ax_gcc_arch="athlon k7" ;;
+	    *6[[34]]?:*:*:*) ax_gcc_arch="athlon-tbird k7" ;;
+	    *6[[678a]]?:*:*:*) ax_gcc_arch="athlon-xp athlon-4 athlon k7" ;;
+	    *000?f[[4578bcef]]?:*:*:*|?f[[4578bcef]]?:*:*:*|f[[4578bcef]]?:*:*:*|*001?f[[4578bcf]]?:*:*:*|1?f[[4578bcf]]?:*:*:*) ax_gcc_arch="athlon64 k8" ;;
+	    *002?f[[13457bcf]]?:*:*:*|2?f[[13457bcf]]?:*:*:*|*004?f[[138bcf]]?:*:*:*|4?f[[138bcf]]?:*:*:*|*005?f[[df]]?:*:*:*|5?f[[df]]?:*:*:*|*006?f[[8bcf]]?:*:*:*|6?f[[8bcf]]?:*:*:*|*007?f[[cf]]?:*:*:*|7?f[[cf]]?:*:*:*|*00c?f1?:*:*:*|c?f1?:*:*:*|*020?f3?:*:*:*|20?f3?:*:*:*) ax_gcc_arch="athlon64-sse3 k8-sse3 athlon64 k8" ;;
+	    *010?f[[245689a]]?:*:*:*|10?f[[245689a]]?:*:*:*|*030?f1?:*:*:*|30?f1?:*:*:*) ax_gcc_arch="barcelona amdfam10 k8" ;;
+	    *050?f[[12]]?:*:*:*|50?f[[12]]?:*:*:*) ax_gcc_arch="btver1 amdfam10 k8" ;;
+	    *060?f1?:*:*:*|60?f1?:*:*:*) ax_gcc_arch="bdver1 amdfam10 k8" ;;
+	    *060?f2?:*:*:*|60?f2?:*:*:*|*061?f[[03]]?:*:*:*|61?f[[03]]?:*:*:*) ax_gcc_arch="bdver2 bdver1 amdfam10 k8" ;;
+	    *063?f0?:*:*:*|63?f0?:*:*:*) ax_gcc_arch="bdver3 bdver2 bdver1 amdfam10 k8" ;;
+	    *07[[03]]?f0?:*:*:*|7[[03]]?f0?:*:*:*) ax_gcc_arch="btver2 btver1 amdfam10 k8" ;;
+	    # fallback
+	    *0[[13]]??f??:*:*:*|[[13]]??f??:*:*:*) ax_gcc_arch="barcelona amdfam10 k8" ;;
+	    *020?f??:*:*:*|20?f??:*:*:*) ax_gcc_arch="athlon64-sse3 k8-sse3 athlon64 k8" ;;
+	    *05??f??:*:*:*|5??f??:*:*:*) ax_gcc_arch="btver1 amdfam10 k8" ;;
+	    *060?f??:*:*:*|60?f??:*:*:*) ax_gcc_arch="bdver1 amdfam10 k8" ;;
+	    *061?f??:*:*:*|61?f??:*:*:*) ax_gcc_arch="bdver2 bdver1 amdfam10 k8" ;;
+	    *06??f??:*:*:*|6??f??:*:*:*) ax_gcc_arch="bdver3 bdver2 bdver1 amdfam10 k8" ;;
+	    *070?f??:*:*:*|70?f??:*:*:*) ax_gcc_arch="btver2 btver1 amdfam10 k8" ;;
+	    *???f??:*:*:*) ax_gcc_arch="amdfam10 k8" ;;
+          esac ;;
+	*:746e6543:736c7561:48727561) # IDT / VIA (Centaur)
+	   case $ax_cv_gcc_x86_cpuid_1 in
+	     *54?:*:*:*) ax_gcc_arch=winchip-c6 ;;
+	     *5[[89]]?:*:*:*) ax_gcc_arch=winchip2 ;;
+	     *66?:*:*:*) ax_gcc_arch=winchip2 ;;
+	     *6[[78]]?:*:*:*) ax_gcc_arch=c3 ;;
+	     *6[[9adf]]?:*:*:*) ax_gcc_arch="c3-2 c3" ;;
+	   esac ;;
+     esac
+     if test x"$ax_gcc_arch" = x; then # fallback
+	case $host_cpu in
+	  i586*) ax_gcc_arch=pentium ;;
+	  i686*) ax_gcc_arch=pentiumpro ;;
+        esac
+     fi
+     ;;
+
+  sparc*)
+     AC_PATH_PROG([PRTDIAG], [prtdiag], [prtdiag], [$PATH:/usr/platform/`uname -i`/sbin/:/usr/platform/`uname -m`/sbin/])
+     cputype=`(((grep cpu /proc/cpuinfo | cut -d: -f2) ; ($PRTDIAG -v |grep -i sparc) ; grep -i cpu /var/run/dmesg.boot ) | head -n 1) 2> /dev/null`
+     cputype=`echo "$cputype" | tr -d ' -' | $SED 's/SPARCIIi/SPARCII/' |tr $as_cr_LETTERS $as_cr_letters`
+     case $cputype in
+         *ultrasparciv*) ax_gcc_arch="ultrasparc4 ultrasparc3 ultrasparc v9" ;;
+         *ultrasparciii*) ax_gcc_arch="ultrasparc3 ultrasparc v9" ;;
+         *ultrasparc*) ax_gcc_arch="ultrasparc v9" ;;
+         *supersparc*|*tms390z5[[05]]*) ax_gcc_arch="supersparc v8" ;;
+         *hypersparc*|*rt62[[056]]*) ax_gcc_arch="hypersparc v8" ;;
+         *cypress*) ax_gcc_arch=cypress ;;
+     esac ;;
+
+  alphaev5) ax_gcc_arch=ev5 ;;
+  alphaev56) ax_gcc_arch=ev56 ;;
+  alphapca56) ax_gcc_arch="pca56 ev56" ;;
+  alphapca57) ax_gcc_arch="pca57 pca56 ev56" ;;
+  alphaev6) ax_gcc_arch=ev6 ;;
+  alphaev67) ax_gcc_arch=ev67 ;;
+  alphaev68) ax_gcc_arch="ev68 ev67" ;;
+  alphaev69) ax_gcc_arch="ev69 ev68 ev67" ;;
+  alphaev7) ax_gcc_arch="ev7 ev69 ev68 ev67" ;;
+  alphaev79) ax_gcc_arch="ev79 ev7 ev69 ev68 ev67" ;;
+
+  powerpc*)
+     cputype=`((grep cpu /proc/cpuinfo | head -n 1 | cut -d: -f2 | cut -d, -f1 | $SED 's/ //g') ; /usr/bin/machine ; /bin/machine; grep CPU /var/run/dmesg.boot | head -n 1 | cut -d" " -f2) 2> /dev/null`
+     cputype=`echo $cputype | $SED -e 's/ppc//g;s/ *//g'`
+     case $cputype in
+       *750*) ax_gcc_arch="750 G3" ;;
+       *740[[0-9]]*) ax_gcc_arch="$cputype 7400 G4" ;;
+       *74[[4-5]][[0-9]]*) ax_gcc_arch="$cputype 7450 G4" ;;
+       *74[[0-9]][[0-9]]*) ax_gcc_arch="$cputype G4" ;;
+       *970*) ax_gcc_arch="970 G5 power4";;
+       *POWER4*|*power4*|*gq*) ax_gcc_arch="power4 970";;
+       *POWER5*|*power5*|*gr*|*gs*) ax_gcc_arch="power5 power4 970";;
+       603ev|8240) ax_gcc_arch="$cputype 603e 603";;
+       *POWER7*) ax_gcc_arch="power7";;
+       *POWER8*) ax_gcc_arch="power8";;
+       *POWER9*) ax_gcc_arch="power9";;
+       *POWER10*) ax_gcc_arch="power10";;
+       *) ax_gcc_arch=$cputype ;;
+     esac
+     ax_gcc_arch="$ax_gcc_arch powerpc"
+     ;;
+  aarch64)
+     cpuimpl=`grep 'CPU implementer' /proc/cpuinfo 2> /dev/null | cut -d: -f2 | tr -d " " | head -n 1`
+     cpuarch=`grep 'CPU architecture' /proc/cpuinfo 2> /dev/null | cut -d: -f2 | tr -d " " | head -n 1`
+     cpuvar=`grep 'CPU variant' /proc/cpuinfo 2> /dev/null | cut -d: -f2 | tr -d " " | head -n 1`
+     case $cpuimpl in
+       0x42) case $cpuarch in
+               8) case $cpuvar in
+                    0x0) ax_gcc_arch="thunderx2t99 vulcan armv8.1-a armv8-a+lse armv8-a native" ;;
+                  esac
+                  ;;
+             esac
+             ;;
+       0x43) case $cpuarch in
+               8) case $cpuvar in
+                    0x0) ax_gcc_arch="thunderx armv8-a native" ;;
+                    0x1) ax_gcc_arch="thunderx+lse armv8.1-a armv8-a+lse armv8-a native" ;;
+                  esac
+                  ;;
+             esac
+             ;;
+      esac
+      ;;
+esac
+fi # not cross-compiling
+fi # guess arch
+
+if test "x$ax_gcc_arch" != x -a "x$ax_gcc_arch" != xno; then
+if test "x[]m4_default([$1],yes)" = xyes; then # if we require portable code
+  flag_prefixes="-mtune="
+  if test "x$ax_cv_[]_AC_LANG_ABBREV[]_compiler_vendor" = xclang; then flag_prefixes="-march="; fi
+  # -mcpu=$arch and m$arch generate nonportable code on every arch except
+  # x86.  And some other arches (e.g. Alpha) don't accept -mtune.  Grrr.
+  case $host_cpu in i*86|x86_64*|amd64*) flag_prefixes="$flag_prefixes -mcpu= -m";; esac
+else
+  flag_prefixes="-march= -mcpu= -m"
+fi
+for flag_prefix in $flag_prefixes; do
+  for arch in $ax_gcc_arch; do
+    flag="$flag_prefix$arch"
+    AX_CHECK_COMPILE_FLAG($flag, [if test "x$ax_cv_[]_AC_LANG_ABBREV[]_compiler_vendor" = xclang; then
+      if test "x[]m4_default([$1],yes)" = xyes; then
+	if test "x$flag" = "x-march=$arch"; then flag=-mtune=$arch; fi
+      fi
+    fi; ax_cv_gcc_archflag=$flag; break])
+  done
+  test "x$ax_cv_gcc_archflag" = xunknown || break
+done
+fi
+
+fi # $GCC=yes
+])
+AC_MSG_CHECKING([for gcc architecture flag])
+AC_MSG_RESULT($ax_cv_gcc_archflag)
+if test "x$ax_cv_gcc_archflag" = xunknown; then
+  m4_default([$3],:)
+else
+  m4_default([$2], [CFLAGS="$CFLAGS $ax_cv_gcc_archflag"])
+fi
+])
Index: libffi-3.4.6/m4/ax_prepend_flag.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_prepend_flag.m4 b/libffi-3.4.6/m4/ax_prepend_flag.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_prepend_flag.m4	
@@ -0,0 +1,51 @@
+# ===========================================================================
+#     https://www.gnu.org/software/autoconf-archive/ax_prepend_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PREPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is added to the front of the FLAGS-VARIABLE shell variable, with a
+#   space added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_APPEND_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#   Copyright (c) 2018 John Zaitseff <J.Zaitseff@zap.org.au>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AC_DEFUN([AX_PREPEND_FLAG],
+[dnl
+AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
+AS_VAR_SET_IF(FLAGS,[
+  AS_CASE([" AS_VAR_GET(FLAGS) "],
+    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
+    [
+     FLAGS="$1 $FLAGS"
+     AC_RUN_LOG([: FLAGS="$FLAGS"])
+    ])
+  ],
+  [
+  AS_VAR_SET(FLAGS,[$1])
+  AC_RUN_LOG([: FLAGS="$FLAGS"])
+  ])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_PREPEND_FLAG
Index: libffi-3.4.6/m4/ax_gcc_x86_cpuid.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_gcc_x86_cpuid.m4 b/libffi-3.4.6/m4/ax_gcc_x86_cpuid.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_gcc_x86_cpuid.m4	
@@ -0,0 +1,89 @@
+# ===========================================================================
+#     https://www.gnu.org/software/autoconf-archive/ax_gcc_x86_cpuid.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_X86_CPUID(OP)
+#   AX_GCC_X86_CPUID_COUNT(OP, COUNT)
+#
+# DESCRIPTION
+#
+#   On Pentium and later x86 processors, with gcc or a compiler that has a
+#   compatible syntax for inline assembly instructions, run a small program
+#   that executes the cpuid instruction with input OP. This can be used to
+#   detect the CPU type. AX_GCC_X86_CPUID_COUNT takes an additional COUNT
+#   parameter that gets passed into register ECX before calling cpuid.
+#
+#   On output, the values of the eax, ebx, ecx, and edx registers are stored
+#   as hexadecimal strings as "eax:ebx:ecx:edx" in the cache variable
+#   ax_cv_gcc_x86_cpuid_OP.
+#
+#   If the cpuid instruction fails (because you are running a
+#   cross-compiler, or because you are not using gcc, or because you are on
+#   a processor that doesn't have this instruction), ax_cv_gcc_x86_cpuid_OP
+#   is set to the string "unknown".
+#
+#   This macro mainly exists to be used in AX_GCC_ARCHFLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2008 Matteo Frigo
+#   Copyright (c) 2015 Michael Petch <mpetch@capp-sysware.com>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 10
+
+AC_DEFUN([AX_GCC_X86_CPUID],
+[AX_GCC_X86_CPUID_COUNT($1, 0)
+])
+
+AC_DEFUN([AX_GCC_X86_CPUID_COUNT],
+[AC_REQUIRE([AC_PROG_CC])
+AC_LANG_PUSH([C])
+AC_CACHE_CHECK(for x86 cpuid $1 output, ax_cv_gcc_x86_cpuid_$1,
+ [AC_RUN_IFELSE([AC_LANG_PROGRAM([#include <stdio.h>], [
+     int op = $1, level = $2, eax, ebx, ecx, edx;
+     FILE *f;
+      __asm__ __volatile__ ("xchg %%ebx, %1\n"
+        "cpuid\n"
+        "xchg %%ebx, %1\n"
+        : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
+        : "a" (op), "2" (level));
+
+     f = fopen("conftest_cpuid", "w"); if (!f) return 1;
+     fprintf(f, "%x:%x:%x:%x\n", eax, ebx, ecx, edx);
+     fclose(f);
+     return 0;
+])],
+     [ax_cv_gcc_x86_cpuid_$1=`cat conftest_cpuid`; rm -f conftest_cpuid],
+     [ax_cv_gcc_x86_cpuid_$1=unknown; rm -f conftest_cpuid],
+     [ax_cv_gcc_x86_cpuid_$1=unknown])])
+AC_LANG_POP([C])
+])
Index: libffi-3.4.6/m4/ax_configure_args.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_configure_args.m4 b/libffi-3.4.6/m4/ax_configure_args.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_configure_args.m4	
@@ -0,0 +1,49 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_configure_args.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CONFIGURE_ARGS
+#
+# DESCRIPTION
+#
+#   Helper macro for AX_ENABLE_BUILDDIR.
+#
+#   The traditional way of starting a subdir-configure is running the script
+#   with ${1+"$@"} but since autoconf 2.60 this is broken. Instead we have
+#   to rely on eval'ing $ac_configure_args however some old autoconf
+#   versions do not provide that. To ensure maximum portability of autoconf
+#   extension macros this helper can be AC_REQUIRE'd so that
+#   $ac_configure_args will always be present.
+#
+#   Sadly, the traditional "exec $SHELL" of the enable_builddir macros is
+#   spoiled now and must be replaced by "eval + exit $?".
+#
+#   Example:
+#
+#     AC_DEFUN([AX_ENABLE_SUBDIR],[dnl
+#       AC_REQUIRE([AX_CONFIGURE_ARGS])dnl
+#       eval $SHELL $ac_configure_args || exit $?
+#       ...])
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 14
+
+AC_DEFUN([AX_CONFIGURE_ARGS],[
+   # [$]@ is unusable in 2.60+ but earlier autoconf had no ac_configure_args
+   if test "${ac_configure_args+set}" != "set" ; then
+      ac_configure_args=
+      for ac_arg in ${1+"[$]@"}; do
+         ac_configure_args="$ac_configure_args '$ac_arg'"
+      done
+   fi
+])
Index: libffi-3.4.6/m4/ax_cflags_warn_all.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_cflags_warn_all.m4 b/libffi-3.4.6/m4/ax_cflags_warn_all.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_cflags_warn_all.m4	
@@ -0,0 +1,158 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_cflags_warn_all.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CFLAGS_WARN_ALL   [(shellvar[, default[, action-if-found[, action-if-not-found]]])]
+#   AX_CXXFLAGS_WARN_ALL [(shellvar[, default[, action-if-found[, action-if-not-found]]])]
+#   AX_FCFLAGS_WARN_ALL  [(shellvar[, default[, action-if-found[, action-if-not-found]]])]
+#
+# DESCRIPTION
+#
+#   Specify compiler options that enable most reasonable warnings.  For the
+#   GNU Compiler Collection (GCC), for example, it will be "-Wall".  The
+#   result is added to shellvar, one of CFLAGS, CXXFLAGS or FCFLAGS if the
+#   first parameter is not specified.
+#
+#   Each of these macros accepts the following optional arguments:
+#
+#     - $1 - shellvar
+#         shell variable to use (CFLAGS, CXXFLAGS or FCFLAGS if not
+#         specified, depending on macro)
+#
+#     - $2 - default
+#         value to use for flags if compiler vendor cannot be determined (by
+#         default, "")
+#
+#     - $3 - action-if-found
+#         action to take if the compiler vendor has been successfully
+#         determined (by default, add the appropriate compiler flags to
+#         shellvar)
+#
+#     - $4 - action-if-not-found
+#         action to take if the compiler vendor has not been determined or
+#         is unknown (by default, add the default flags, or "" if not
+#         specified, to shellvar)
+#
+#   These macros use AX_COMPILER_VENDOR to determine which flags should be
+#   returned for a given compiler.  Not all compilers currently have flags
+#   defined for them; patches are welcome.  If need be, compiler flags may
+#   be made language-dependent: use a construct like the following:
+#
+#     [vendor_name], [m4_if(_AC_LANG_PREFIX,[C],   VAR="--relevant-c-flags",dnl
+#                     m4_if(_AC_LANG_PREFIX,[CXX], VAR="--relevant-c++-flags",dnl
+#                     m4_if(_AC_LANG_PREFIX,[FC],  VAR="--relevant-fortran-flags",dnl
+#                     VAR="$2"; FOUND="no")))],
+#
+#   Note: These macros also depend on AX_PREPEND_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2010 Rhys Ulerich <rhys.ulerich@gmail.com>
+#   Copyright (c) 2018 John Zaitseff <J.Zaitseff@zap.org.au>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 25
+
+AC_DEFUN([AX_FLAGS_WARN_ALL], [
+    AX_REQUIRE_DEFINED([AX_PREPEND_FLAG])dnl
+    AC_REQUIRE([AX_COMPILER_VENDOR])dnl
+
+    AS_VAR_PUSHDEF([FLAGS], [m4_default($1,_AC_LANG_PREFIX[]FLAGS)])dnl
+    AS_VAR_PUSHDEF([VAR],   [ac_cv_[]_AC_LANG_ABBREV[]flags_warn_all])dnl
+    AS_VAR_PUSHDEF([FOUND], [ac_save_[]_AC_LANG_ABBREV[]flags_warn_all_found])dnl
+
+    AC_CACHE_CHECK([FLAGS for most reasonable warnings], VAR, [
+	VAR=""
+	FOUND="yes"
+	dnl  Cases are listed in the order found in ax_compiler_vendor.m4
+	AS_CASE("$ax_cv_[]_AC_LANG_ABBREV[]_compiler_vendor",
+	    [intel],		[VAR="-w2"],
+	    [ibm],		[VAR="-qsrcmsg -qinfo=all:noppt:noppc:noobs:nocnd"],
+	    [pathscale],	[],
+	    [clang],		[VAR="-Wall"],
+	    [cray],		[VAR="-h msglevel 2"],
+	    [fujitsu],		[],
+	    [sdcc],		[],
+	    [sx],		[VAR="-pvctl[,]fullmsg"],
+	    [portland],		[],
+	    [gnu],		[VAR="-Wall"],
+	    [sun],		[VAR="-v"],
+	    [hp],		[VAR="+w1"],
+	    [dec],		[VAR="-verbose -w0 -warnprotos"],
+	    [borland],		[],
+	    [comeau],		[],
+	    [kai],		[],
+	    [lcc],		[],
+	    [sgi],		[VAR="-fullwarn"],
+	    [microsoft],	[],
+	    [metrowerks],	[],
+	    [watcom],		[],
+	    [tcc],		[],
+	    [unknown],		[
+				    VAR="$2"
+				    FOUND="no"
+				],
+				[
+				    AC_MSG_WARN([Unknown compiler vendor returned by [AX_COMPILER_VENDOR]])
+				    VAR="$2"
+				    FOUND="no"
+				]
+	)
+
+	AS_IF([test "x$FOUND" = "xyes"], [dnl
+	    m4_default($3, [AS_IF([test "x$VAR" != "x"], [AX_PREPEND_FLAG([$VAR], [FLAGS])])])
+	], [dnl
+	    m4_default($4, [m4_ifval($2, [AX_PREPEND_FLAG([$VAR], [FLAGS])], [true])])
+	])dnl
+    ])dnl
+
+    AS_VAR_POPDEF([FOUND])dnl
+    AS_VAR_POPDEF([VAR])dnl
+    AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_FLAGS_WARN_ALL
+
+AC_DEFUN([AX_CFLAGS_WARN_ALL], [dnl
+    AC_LANG_PUSH([C])
+    AX_FLAGS_WARN_ALL([$1], [$2], [$3], [$4])
+    AC_LANG_POP([C])
+])dnl
+
+AC_DEFUN([AX_CXXFLAGS_WARN_ALL], [dnl
+    AC_LANG_PUSH([C++])
+    AX_FLAGS_WARN_ALL([$1], [$2], [$3], [$4])
+    AC_LANG_POP([C++])
+])dnl
+
+AC_DEFUN([AX_FCFLAGS_WARN_ALL], [dnl
+    AC_LANG_PUSH([Fortran])
+    AX_FLAGS_WARN_ALL([$1], [$2], [$3], [$4])
+    AC_LANG_POP([Fortran])
+])dnl
Index: libffi-3.4.6/m4/ax_compiler_vendor.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_compiler_vendor.m4 b/libffi-3.4.6/m4/ax_compiler_vendor.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_compiler_vendor.m4	
@@ -0,0 +1,119 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_compiler_vendor.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_COMPILER_VENDOR
+#
+# DESCRIPTION
+#
+#   Determine the vendor of the C, C++ or Fortran compiler.  The vendor is
+#   returned in the cache variable $ax_cv_c_compiler_vendor for C,
+#   $ax_cv_cxx_compiler_vendor for C++ or $ax_cv_fc_compiler_vendor for
+#   (modern) Fortran.  The value is one of "intel", "ibm", "pathscale",
+#   "clang" (LLVM), "cray", "fujitsu", "sdcc", "sx", "nvhpc" (NVIDIA HPC
+#   Compiler), "portland" (PGI), "gnu" (GCC), "sun" (Oracle Developer
+#   Studio), "hp", "dec", "borland", "comeau", "kai", "lcc", "sgi",
+#   "microsoft", "metrowerks", "watcom", "tcc" (Tiny CC) or "unknown" (if
+#   the compiler cannot be determined).
+#
+#   To check for a Fortran compiler, you must first call AC_FC_PP_SRCEXT
+#   with an appropriate preprocessor-enabled extension.  For example:
+#
+#     AC_LANG_PUSH([Fortran])
+#     AC_PROG_FC
+#     AC_FC_PP_SRCEXT([F])
+#     AX_COMPILER_VENDOR
+#     AC_LANG_POP([Fortran])
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2008 Matteo Frigo
+#   Copyright (c) 2018-19 John Zaitseff <J.Zaitseff@zap.org.au>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 32
+
+AC_DEFUN([AX_COMPILER_VENDOR], [dnl
+    AC_CACHE_CHECK([for _AC_LANG compiler vendor], ax_cv_[]_AC_LANG_ABBREV[]_compiler_vendor, [dnl
+	dnl  If you modify this list of vendors, please add similar support
+	dnl  to ax_compiler_version.m4 if at all possible.
+	dnl
+	dnl  Note: Do NOT check for GCC first since some other compilers
+	dnl  define __GNUC__ to remain compatible with it.  Compilers that
+	dnl  are very slow to start (such as Intel) are listed first.
+
+	vendors="
+		intel:		__ICC,__ECC,__INTEL_COMPILER
+		ibm:		__xlc__,__xlC__,__IBMC__,__IBMCPP__,__ibmxl__
+		pathscale:	__PATHCC__,__PATHSCALE__
+		clang:		__clang__
+		cray:		_CRAYC
+		fujitsu:	__FUJITSU
+		sdcc:		SDCC,__SDCC
+		sx:		_SX
+		nvhpc:		__NVCOMPILER
+		portland:	__PGI
+		gnu:		__GNUC__
+		sun:		__SUNPRO_C,__SUNPRO_CC,__SUNPRO_F90,__SUNPRO_F95
+		hp:		__HP_cc,__HP_aCC
+		dec:		__DECC,__DECCXX,__DECC_VER,__DECCXX_VER
+		borland:	__BORLANDC__,__CODEGEARC__,__TURBOC__
+		comeau:		__COMO__
+		kai:		__KCC
+		lcc:		__LCC__
+		sgi:		__sgi,sgi
+		microsoft:	_MSC_VER
+		metrowerks:	__MWERKS__
+		watcom:		__WATCOMC__
+		tcc:		__TINYC__
+		unknown:	UNKNOWN
+	"
+	for ventest in $vendors; do
+	    case $ventest in
+		*:)
+		    vendor=$ventest
+		    continue
+		    ;;
+		*)
+		    vencpp="defined("`echo $ventest | sed 's/,/) || defined(/g'`")"
+		    ;;
+	    esac
+
+	    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[
+#if !($vencpp)
+      thisisanerror;
+#endif
+	    ]])], [break])
+	done
+
+	ax_cv_[]_AC_LANG_ABBREV[]_compiler_vendor=`echo $vendor | cut -d: -f1`
+    ])
+])dnl
Index: libffi-3.4.6/m4/ax_enable_builddir.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_enable_builddir.m4 b/libffi-3.4.6/m4/ax_enable_builddir.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_enable_builddir.m4	
@@ -0,0 +1,302 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_enable_builddir.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_ENABLE_BUILDDIR [(dirstring-or-command [,Makefile.mk [,-all]])]
+#
+# DESCRIPTION
+#
+#   If the current configure was run within the srcdir then we move all
+#   configure-files into a subdir and let the configure steps continue
+#   there. We provide an option --disable-builddir to suppress the move into
+#   a separate builddir.
+#
+#   Defaults:
+#
+#     $1 = $host (overridden with $HOST)
+#     $2 = Makefile.mk
+#     $3 = -all
+#
+#   This macro must be called before AM_INIT_AUTOMAKE. It creates a default
+#   toplevel srcdir Makefile from the information found in the created
+#   toplevel builddir Makefile. It just copies the variables and
+#   rule-targets, each extended with a default rule-execution that recurses
+#   into the build directory of the current "HOST". You can override the
+#   auto-detection through `config.guess` and build-time of course, as in
+#
+#     make HOST=i386-mingw-cross
+#
+#   which can of course set at configure time as well using
+#
+#     configure --host=i386-mingw-cross
+#
+#   After the default has been created, additional rules can be appended
+#   that will not just recurse into the subdirectories and only ever exist
+#   in the srcdir toplevel makefile - these parts are read from the $2 =
+#   Makefile.mk file
+#
+#   The automatic rules are usually scanning the toplevel Makefile for lines
+#   like '#### $host |$builddir' to recognize the place where to recurse
+#   into. Usually, the last one is the only one used. However, almost all
+#   targets have an additional "*-all" rule which makes the script to
+#   recurse into _all_ variants of the current HOST (!!) setting. The "-all"
+#   suffix can be overridden for the macro as well.
+#
+#   a special rule is only given for things like "dist" that will copy the
+#   tarball from the builddir to the sourcedir (or $(PUB)) for reason of
+#   convenience.
+#
+# LICENSE
+#
+#   Copyright (c) 2009 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2009 Alan Jenkins <alan-jenkins@tuffmail.co.uk>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 30
+
+AC_DEFUN([AX_ENABLE_BUILDDIR],[
+AC_REQUIRE([AC_CANONICAL_HOST])[]dnl
+AC_REQUIRE([AC_CANONICAL_TARGET])[]dnl
+AC_REQUIRE([AX_CONFIGURE_ARGS])[]dnl
+AC_REQUIRE([AM_AUX_DIR_EXPAND])[]dnl
+AC_BEFORE([$0],[AM_INIT_AUTOMAKE])dnl
+AS_VAR_PUSHDEF([SUB],[ax_enable_builddir])dnl
+AS_VAR_PUSHDEF([AUX],[ax_enable_builddir_auxdir])dnl
+AS_VAR_PUSHDEF([SED],[ax_enable_builddir_sed])dnl
+SUB="."
+AC_ARG_ENABLE([builddir], AS_HELP_STRING(
+  [--disable-builddir],[disable automatic build in subdir of sources])
+  ,[SUB="$enableval"], [SUB="auto"])
+if test ".$ac_srcdir_defaulted" != ".no" ; then
+if test ".$srcdir" = ".." ; then
+  if test -f config.status ; then
+    AC_MSG_NOTICE(toplevel srcdir already configured... skipping subdir build)
+  else
+    test ".$SUB" = "."  && SUB="."
+    test ".$SUB" = ".no"  && SUB="."
+    test ".$TARGET" = "." && TARGET="$target"
+    test ".$SUB" = ".auto" && SUB="m4_ifval([$1], [$1],[$TARGET])"
+    if test ".$SUB" != ".." ; then    # we know where to go and
+      AS_MKDIR_P([$SUB])
+      echo __.$SUB.__ > $SUB/conftest.tmp
+      cd $SUB
+      if grep __.$SUB.__ conftest.tmp >/dev/null 2>/dev/null ; then
+        rm conftest.tmp
+        AC_MSG_RESULT([continue configure in default builddir "./$SUB"])
+      else
+        AC_MSG_ERROR([could not change to default builddir "./$SUB"])
+      fi
+      srcdir=`echo "$SUB" |
+              sed -e 's,^\./,,;s,[[^/]]$,&/,;s,[[^/]]*/,../,g;s,[[/]]$,,;'`
+      # going to restart from subdirectory location
+      test -f $srcdir/config.log   && mv $srcdir/config.log   .
+      test -f $srcdir/confdefs.h   && mv $srcdir/confdefs.h   .
+      test -f $srcdir/conftest.log && mv $srcdir/conftest.log .
+      test -f $srcdir/$cache_file  && mv $srcdir/$cache_file  .
+      AC_MSG_RESULT(....exec $SHELL $srcdir/[$]0 "--srcdir=$srcdir" "--enable-builddir=$SUB" ${1+"[$]@"})
+      case "[$]0" in # restart
+       [[\\/]]* | ?:[[\\/]]*) # Absolute name
+         eval $SHELL "'[$]0'" "'--srcdir=$srcdir'" "'--enable-builddir=$SUB'" $ac_configure_args ;;
+       *) eval $SHELL "'$srcdir/[$]0'" "'--srcdir=$srcdir'" "'--enable-builddir=$SUB'" $ac_configure_args ;;
+      esac ; exit $?
+    fi
+  fi
+fi fi
+test ".$SUB" = ".auto" && SUB="."
+dnl ac_path_prog uses "set dummy" to override $@ which would defeat the "exec"
+AC_PATH_PROG(SED,gsed sed, sed)
+AUX="$am_aux_dir"
+AS_VAR_POPDEF([SED])dnl
+AS_VAR_POPDEF([AUX])dnl
+AS_VAR_POPDEF([SUB])dnl
+AC_CONFIG_COMMANDS([buildir],[dnl .............. config.status ..............
+AS_VAR_PUSHDEF([SUB],[ax_enable_builddir])dnl
+AS_VAR_PUSHDEF([TOP],[top_srcdir])dnl
+AS_VAR_PUSHDEF([SRC],[ac_top_srcdir])dnl
+AS_VAR_PUSHDEF([AUX],[ax_enable_builddir_auxdir])dnl
+AS_VAR_PUSHDEF([SED],[ax_enable_builddir_sed])dnl
+pushdef([END],[Makefile.mk])dnl
+pushdef([_ALL],[ifelse([$3],,[-all],[$3])])dnl
+  SRC="$ax_enable_builddir_srcdir"
+  if test ".$SUB" = ".." ; then
+    if test -f "$TOP/Makefile" ; then
+      AC_MSG_NOTICE([skipping TOP/Makefile - left untouched])
+    else
+      AC_MSG_NOTICE([skipping TOP/Makefile - not created])
+    fi
+  else
+    if test -f "$SRC/Makefile" ; then
+      a=`grep "^VERSION " "$SRC/Makefile"` ; b=`grep "^VERSION " Makefile`
+      test "$a" != "$b" && rm "$SRC/Makefile"
+    fi
+    if test -f "$SRC/Makefile" ; then
+	echo "$SRC/Makefile : $SRC/Makefile.in" > $tmp/conftemp.mk
+	echo "	[]@ echo 'REMOVED,,,' >\$[]@" >> $tmp/conftemp.mk
+      eval "${MAKE-make} -f $tmp/conftemp.mk 2>/dev/null >/dev/null"
+      if grep '^REMOVED,,,' "$SRC/Makefile" >/dev/null
+      then rm $SRC/Makefile ; fi
+      cp $tmp/conftemp.mk $SRC/makefiles.mk~      ## DEBUGGING
+    fi
+    if test ! -f "$SRC/Makefile" ; then
+      AC_MSG_NOTICE([create TOP/Makefile guessed from local Makefile])
+      x='`' ; cat >$tmp/conftemp.sed <<_EOF
+/^\$/n
+x
+/^\$/bS
+x
+/\\\\\$/{H;d;}
+{H;s/.*//;x;}
+bM
+:S
+x
+/\\\\\$/{h;d;}
+{h;s/.*//;x;}
+:M
+s/\\(\\n\\)	/\\1 /g
+/^	/d
+/^[[	 ]]*[[\\#]]/d
+/^VPATH *=/d
+s/^srcdir *=.*/srcdir = ./
+s/^top_srcdir *=.*/top_srcdir = ./
+/[[:=]]/!d
+/^\\./d
+dnl Now handle rules (i.e. lines containing ":" but not " = ").
+/ = /b
+/ .= /b
+/:/!b
+s/:.*/:/
+s/ /  /g
+s/ \\([[a-z]][[a-z-]]*[[a-zA-Z0-9]]\\)\\([[ :]]\\)/ \\1 \\1[]_ALL\\2/g
+s/^\\([[a-z]][[a-z-]]*[[a-zA-Z0-9]]\\)\\([[ :]]\\)/\\1 \\1[]_ALL\\2/
+s/  / /g
+/^all all[]_ALL[[ :]]/i\\
+all-configured : all[]_ALL
+dnl dist-all exists... and would make for dist-all-all
+s/ [[a-zA-Z0-9-]]*[]_ALL [[a-zA-Z0-9-]]*[]_ALL[]_ALL//g
+/[]_ALL[]_ALL/d
+a\\
+	@ HOST="\$(HOST)\" \\\\\\
+	; test ".\$\$HOST" = "." && HOST=$x sh $AUX/config.guess $x \\\\\\
+	; BUILD=$x grep "^#### \$\$HOST " Makefile | sed -e 's/.*|//' $x \\\\\\
+	; use=$x basename "\$\@" _ALL $x; n=$x echo \$\$BUILD | wc -w $x \\\\\\
+	; echo "MAKE \$\$HOST : \$\$n * \$\@"; if test "\$\$n" -eq "0" ; then : \\\\\\
+	; BUILD=$x grep "^####.*|" Makefile |tail -1| sed -e 's/.*|//' $x ; fi \\\\\\
+	; test ".\$\$BUILD" = "." && BUILD="." \\\\\\
+	; test "\$\$use" = "\$\@" && BUILD=$x echo "\$\$BUILD" | tail -1 $x \\\\\\
+	; for i in \$\$BUILD ; do test ".\$\$i" = "." && continue \\\\\\
+	; (cd "\$\$i" && test ! -f configure && \$(MAKE) \$\$use) || exit; done
+dnl special rule add-on: "dist" copies the tarball to $(PUB). (source tree)
+/dist[]_ALL *:/a\\
+	@ HOST="\$(HOST)\" \\\\\\
+	; test ".\$\$HOST" = "." && HOST=$x sh $AUX/config.guess $x \\\\\\
+	; BUILD=$x grep "^#### \$\$HOST " Makefile | sed -e 's/.*|//' $x \\\\\\
+	; found=$x echo \$\$BUILD | wc -w $x \\\\\\
+	; echo "MAKE \$\$HOST : \$\$found \$(PACKAGE)-\$(VERSION).tar.*" \\\\\\
+	; if test "\$\$found" -eq "0" ; then : \\\\\\
+	; BUILD=$x grep "^#### .*|" Makefile |tail -1| sed -e 's/.*|//' $x \\\\\\
+	; fi ; for i in \$\$BUILD ; do test ".\$\$i" = "." && continue \\\\\\
+	; for f in \$\$i/\$(PACKAGE)-\$(VERSION).tar.* \\\\\\
+	; do test -f "\$\$f" && mv "\$\$f" \$(PUB). ; done ; break ; done
+dnl special rule add-on: "dist-foo" copies all the archives to $(PUB). (source tree)
+/dist-[[a-zA-Z0-9]]*[]_ALL *:/a\\
+	@ HOST="\$(HOST)\" \\\\\\
+	; test ".\$\$HOST" = "." && HOST=$x sh ./config.guess $x \\\\\\
+	; BUILD=$x grep "^#### \$\$HOST " Makefile | sed -e 's/.*|//' $x \\\\\\
+	; found=$x echo \$\$BUILD | wc -w $x \\\\\\
+	; echo "MAKE \$\$HOST : \$\$found \$(PACKAGE)-\$(VERSION).*" \\\\\\
+	; if test "\$\$found" -eq "0" ; then : \\\\\\
+	; BUILD=$x grep "^#### .*|" Makefile |tail -1| sed -e 's/.*|//' $x \\\\\\
+	; fi ; for i in \$\$BUILD ; do test ".\$\$i" = "." && continue \\\\\\
+	; for f in \$\$i/\$(PACKAGE)-\$(VERSION).* \\\\\\
+	; do test -f "\$\$f" && mv "\$\$f" \$(PUB). ; done ; break ; done
+dnl special rule add-on: "distclean" removes all local builddirs completely
+/distclean[]_ALL *:/a\\
+	@ HOST="\$(HOST)\" \\\\\\
+	; test ".\$\$HOST" = "." && HOST=$x sh $AUX/config.guess $x \\\\\\
+	; BUILD=$x grep "^#### .*|" Makefile | sed -e 's/.*|//' $x \\\\\\
+	; use=$x basename "\$\@" _ALL $x; n=$x echo \$\$BUILD | wc -w $x \\\\\\
+	; echo "MAKE \$\$HOST : \$\$n * \$\@ (all local builds)" \\\\\\
+	; test ".\$\$BUILD" = "." && BUILD="." \\\\\\
+	; for i in \$\$BUILD ; do test ".\$\$i" = "." && continue \\\\\\
+	; echo "# rm -r \$\$i"; done ; echo "# (sleep 3)" ; sleep 3 \\\\\\
+	; for i in \$\$BUILD ; do test ".\$\$i" = "." && continue \\\\\\
+	; echo "\$\$i" | grep "^/" > /dev/null && continue \\\\\\
+	; echo "\$\$i" | grep "^../" > /dev/null && continue \\\\\\
+	; echo "rm -r \$\$i"; (rm -r "\$\$i") ; done ; rm Makefile
+_EOF
+      cp "$tmp/conftemp.sed" "$SRC/makefile.sed~"            ## DEBUGGING
+      $SED -f $tmp/conftemp.sed Makefile >$SRC/Makefile
+      if test -f "$SRC/m4_ifval([$2],[$2],[END])" ; then
+        AC_MSG_NOTICE([extend TOP/Makefile with TOP/m4_ifval([$2],[$2],[END])])
+        cat $SRC/END >>$SRC/Makefile
+      fi ; xxxx="####"
+      echo "$xxxx CONFIGURATIONS FOR TOPLEVEL MAKEFILE: " >>$SRC/Makefile
+      # sanity check
+      if grep '^; echo "MAKE ' $SRC/Makefile >/dev/null ; then
+        AC_MSG_NOTICE([buggy sed found - it deletes tab in "a" text parts])
+        $SED -e '/^@ HOST=/s/^/	/' -e '/^; /s/^/	/' $SRC/Makefile \
+          >$SRC/Makefile~
+        (test -s $SRC/Makefile~ && mv $SRC/Makefile~ $SRC/Makefile) 2>/dev/null
+      fi
+    else
+      xxxx="\\#\\#\\#\\#"
+      # echo "/^$xxxx *$ax_enable_builddir_host /d" >$tmp/conftemp.sed
+      echo "s!^$xxxx [[^|]]* | *$SUB *\$!$xxxx ...... $SUB!" >$tmp/conftemp.sed
+      $SED -f "$tmp/conftemp.sed" "$SRC/Makefile" >$tmp/mkfile.tmp
+        cp "$tmp/conftemp.sed" "$SRC/makefiles.sed~"         ## DEBUGGING
+        cp "$tmp/mkfile.tmp"   "$SRC/makefiles.out~"         ## DEBUGGING
+      if cmp -s "$SRC/Makefile" "$tmp/mkfile.tmp" 2>/dev/null ; then
+        AC_MSG_NOTICE([keeping TOP/Makefile from earlier configure])
+        rm "$tmp/mkfile.tmp"
+      else
+        AC_MSG_NOTICE([reusing TOP/Makefile from earlier configure])
+        mv "$tmp/mkfile.tmp" "$SRC/Makefile"
+      fi
+    fi
+    AC_MSG_NOTICE([build in $SUB (HOST=$ax_enable_builddir_host)])
+    xxxx="####"
+    echo "$xxxx" "$ax_enable_builddir_host" "|$SUB" >>$SRC/Makefile
+  fi
+popdef([END])dnl
+AS_VAR_POPDEF([SED])dnl
+AS_VAR_POPDEF([AUX])dnl
+AS_VAR_POPDEF([SRC])dnl
+AS_VAR_POPDEF([TOP])dnl
+AS_VAR_POPDEF([SUB])dnl
+],[dnl
+ax_enable_builddir_srcdir="$srcdir"                    # $srcdir
+ax_enable_builddir_host="$HOST"                        # $HOST / $host
+ax_enable_builddir_version="$VERSION"                  # $VERSION
+ax_enable_builddir_package="$PACKAGE"                  # $PACKAGE
+ax_enable_builddir_auxdir="$ax_enable_builddir_auxdir" # $AUX
+ax_enable_builddir_sed="$ax_enable_builddir_sed"       # $SED
+ax_enable_builddir="$ax_enable_builddir"               # $SUB
+])dnl
+])
Index: libffi-3.4.6/m4/ax_require_defined.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_require_defined.m4 b/libffi-3.4.6/m4/ax_require_defined.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_require_defined.m4	
@@ -0,0 +1,37 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_require_defined.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_REQUIRE_DEFINED(MACRO)
+#
+# DESCRIPTION
+#
+#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
+#   been defined and thus are available for use.  This avoids random issues
+#   where a macro isn't expanded.  Instead the configure script emits a
+#   non-fatal:
+#
+#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
+#
+#   It's like AC_REQUIRE except it doesn't expand the required macro.
+#
+#   Here's an example:
+#
+#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
+  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
+])dnl AX_REQUIRE_DEFINED
Index: libffi-3.4.6/m4/ax_check_compile_flag.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/m4/ax_check_compile_flag.m4 b/libffi-3.4.6/m4/ax_check_compile_flag.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/m4/ax_check_compile_flag.m4	
@@ -0,0 +1,53 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the current language's compiler
+#   or gives an error.  (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_VAR_IF(CACHEVAR,yes,
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
Index: libffi-3.4.6/doc/stamp-vti
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/doc/stamp-vti b/libffi-3.4.6/doc/stamp-vti
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/doc/stamp-vti	
@@ -0,0 +1,4 @@
+@set UPDATED 15 February 2024
+@set UPDATED-MONTH February 2024
+@set EDITION 3.4.6
+@set VERSION 3.4.6
Index: libffi-3.4.6/doc/libffi.texi
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/doc/libffi.texi b/libffi-3.4.6/doc/libffi.texi
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/doc/libffi.texi	
@@ -0,0 +1,1046 @@
+\input texinfo   @c -*-texinfo-*-
+@c %**start of header
+@setfilename libffi.info
+@include version.texi
+@settitle libffi: the portable foreign function interface library
+@setchapternewpage off
+@c %**end of header
+
+@c Merge the standard indexes into a single one.
+@syncodeindex fn cp
+@syncodeindex vr cp
+@syncodeindex ky cp
+@syncodeindex pg cp
+@syncodeindex tp cp
+
+@copying
+
+This manual is for libffi, a portable foreign function interface
+library.
+
+Copyright @copyright{} 2008--2024 Anthony Green and Red Hat, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+@end copying
+
+@dircategory Development
+@direntry
+* libffi: (libffi).             Portable foreign function interface library.
+@end direntry
+
+@titlepage
+@title libffi: a foreign function interface library
+@subtitle For Version @value{VERSION} of libffi
+@author Anthony Green
+@page
+@vskip 0pt plus 1filll
+@insertcopying
+@end titlepage
+
+
+@ifnottex
+@node Top
+@top libffi
+
+@insertcopying
+
+@menu
+* Introduction::                What is libffi?
+* Using libffi::                How to use libffi.
+* Memory Usage::                Where memory for closures comes from.
+* Missing Features::            Things libffi can't do.
+* Index::                       Index.
+@end menu
+
+@end ifnottex
+
+
+@node Introduction
+@chapter What is libffi?
+
+Compilers for high level languages generate code that follow certain
+conventions.  These conventions are necessary, in part, for separate
+compilation to work.  One such convention is the @dfn{calling
+convention}.  The calling convention is a set of assumptions made by
+the compiler about where function arguments will be found on entry to
+a function.  A calling convention also specifies where the return
+value for a function is found.  The calling convention is also
+sometimes called the @dfn{ABI} or @dfn{Application Binary Interface}.
+@cindex calling convention
+@cindex ABI
+@cindex Application Binary Interface
+
+Some programs may not know at the time of compilation what arguments
+are to be passed to a function.  For instance, an interpreter may be
+told at run-time about the number and types of arguments used to call
+a given function.  @code{libffi} can be used in such programs to
+provide a bridge from the interpreter program to compiled code.
+
+The @code{libffi} library provides a portable, high level programming
+interface to various calling conventions.  This allows a programmer to
+call any function specified by a call interface description at run
+time.
+
+@acronym{FFI} stands for Foreign Function Interface.  A foreign
+function interface is the popular name for the interface that allows
+code written in one language to call code written in another language.
+The @code{libffi} library really only provides the lowest, machine
+dependent layer of a fully featured foreign function interface.  A
+layer must exist above @code{libffi} that handles type conversions for
+values passed between the two languages.
+@cindex FFI
+@cindex Foreign Function Interface
+
+
+@node Using libffi
+@chapter Using libffi
+
+@menu
+* The Basics::                  The basic libffi API.
+* Simple Example::              A simple example.
+* Types::                       libffi type descriptions.
+* Multiple ABIs::               Different passing styles on one platform.
+* The Closure API::             Writing a generic function.
+* Closure Example::             A closure example.
+* Thread Safety::               Thread safety.
+@end menu
+
+
+@node The Basics
+@section The Basics
+
+@code{libffi} assumes that you have a pointer to the function you wish
+to call and that you know the number and types of arguments to pass
+it, as well as the return type of the function.
+
+The first thing you must do is create an @code{ffi_cif} object that
+matches the signature of the function you wish to call.  This is a
+separate step because it is common to make multiple calls using a
+single @code{ffi_cif}.  The @dfn{cif} in @code{ffi_cif} stands for
+Call InterFace.  To prepare a call interface object, use the function
+@code{ffi_prep_cif}.
+@cindex cif
+
+@findex ffi_prep_cif
+@defun ffi_status ffi_prep_cif (ffi_cif *@var{cif}, ffi_abi @var{abi}, unsigned int @var{nargs}, ffi_type *@var{rtype}, ffi_type **@var{argtypes})
+This initializes @var{cif} according to the given parameters.
+
+@var{abi} is the ABI to use; normally @code{FFI_DEFAULT_ABI} is what
+you want.  @ref{Multiple ABIs} for more information.
+
+@var{nargs} is the number of arguments that this function accepts.
+
+@var{rtype} is a pointer to an @code{ffi_type} structure that
+describes the return type of the function.  @xref{Types}.
+
+@var{argtypes} is a vector of @code{ffi_type} pointers.
+@var{argtypes} must have @var{nargs} elements.  If @var{nargs} is 0,
+this argument is ignored.
+
+@code{ffi_prep_cif} returns a @code{libffi} status code, of type
+@code{ffi_status}.  This will be either @code{FFI_OK} if everything
+worked properly; @code{FFI_BAD_TYPEDEF} if one of the @code{ffi_type}
+objects is incorrect; or @code{FFI_BAD_ABI} if the @var{abi} parameter
+is invalid.
+@end defun
+
+If the function being called is variadic (varargs) then
+@code{ffi_prep_cif_var} must be used instead of @code{ffi_prep_cif}.
+
+@findex ffi_prep_cif_var
+@defun ffi_status ffi_prep_cif_var (ffi_cif *@var{cif}, ffi_abi @var{abi}, unsigned int @var{nfixedargs}, unsigned int @var{ntotalargs}, ffi_type *@var{rtype}, ffi_type **@var{argtypes})
+This initializes @var{cif} according to the given parameters for
+a call to a variadic function.  In general its operation is the
+same as for @code{ffi_prep_cif} except that:
+
+@var{nfixedargs} is the number of fixed arguments, prior to any
+variadic arguments.  It must be greater than zero.
+
+@var{ntotalargs} the total number of arguments, including variadic
+and fixed arguments.  @var{argtypes} must have this many elements.
+
+@code{ffi_prep_cif_var} will return @code{FFI_BAD_ARGTYPE} if any of
+the variable argument types are @code{ffi_type_float} (promote to
+@code{ffi_type_double} first), or any integer type small than an int
+(promote to an int-sized type first).
+
+Note that, different cif's must be prepped for calls to the same
+function when different numbers of arguments are passed.
+
+Also note that a call to @code{ffi_prep_cif_var} with
+@var{nfixedargs}=@var{nototalargs} is NOT equivalent to a call to
+@code{ffi_prep_cif}.
+
+@end defun
+
+Note that the resulting @code{ffi_cif} holds pointers to all the
+@code{ffi_type} objects that were used during initialization.  You
+must ensure that these type objects have a lifetime at least as long
+as that of the @code{ffi_cif}.
+
+To call a function using an initialized @code{ffi_cif}, use the
+@code{ffi_call} function:
+
+@findex ffi_call
+@defun void ffi_call (ffi_cif *@var{cif}, void *@var{fn}, void *@var{rvalue}, void **@var{avalues})
+This calls the function @var{fn} according to the description given in
+@var{cif}.  @var{cif} must have already been prepared using
+@code{ffi_prep_cif}.
+
+@var{rvalue} is a pointer to a chunk of memory that will hold the
+result of the function call.  This must be large enough to hold the
+result, no smaller than the system register size (generally 32 or 64
+bits), and must be suitably aligned; it is the caller's responsibility
+to ensure this.  If @var{cif} declares that the function returns
+@code{void} (using @code{ffi_type_void}), then @var{rvalue} is
+ignored.
+
+In most situations, @code{libffi} will handle promotion according to
+the ABI.  However, for historical reasons, there is a special case
+with return values that must be handled by your code.  In particular,
+for integral (not @code{struct}) types that are narrower than the
+system register size, the return value will be widened by
+@code{libffi}.  @code{libffi} provides a type, @code{ffi_arg}, that
+can be used as the return type.  For example, if the CIF was defined
+with a return type of @code{char}, @code{libffi} will try to store a
+full @code{ffi_arg} into the return value.
+
+@var{avalues} is a vector of @code{void *} pointers that point to the
+memory locations holding the argument values for a call.  If @var{cif}
+declares that the function has no arguments (i.e., @var{nargs} was 0),
+then @var{avalues} is ignored.
+
+Note that while the return value must be register-sized, arguments
+should exactly match their declared type.  For example, if an argument
+is a @code{short}, then the entry in @var{avalues} should point to an
+object declared as @code{short}; but if the return type is
+@code{short}, then @var{rvalue} should point to an object declared as
+a larger type -- usually @code{ffi_arg}.
+@end defun
+
+
+@node Simple Example
+@section Simple Example
+
+Here is a trivial example that calls @code{puts} a few times.
+
+@example
+#include <stdio.h>
+#include <ffi.h>
+
+int main()
+@{
+  ffi_cif cif;
+  ffi_type *args[1];
+  void *values[1];
+  char *s;
+  ffi_arg rc;
+
+  /* Initialize the argument info vectors */
+  args[0] = &ffi_type_pointer;
+  values[0] = &s;
+
+  /* Initialize the cif */
+  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		       &ffi_type_sint, args) == FFI_OK)
+    @{
+      s = "Hello World!";
+      ffi_call(&cif, puts, &rc, values);
+      /* rc now holds the result of the call to puts */
+
+      /* values holds a pointer to the function's arg, so to
+         call puts() again all we need to do is change the
+         value of s */
+      s = "This is cool!";
+      ffi_call(&cif, puts, &rc, values);
+    @}
+
+  return 0;
+@}
+@end example
+
+
+@node Types
+@section Types
+
+@menu
+* Primitive Types::             Built-in types.
+* Structures::                  Structure types.
+* Size and Alignment::          Size and alignment of types.
+* Arrays Unions Enums::         Arrays, unions, and enumerations.
+* Type Example::                Structure type example.
+* Complex::                     Complex types.
+* Complex Type Example::        Complex type example.
+@end menu
+
+@node Primitive Types
+@subsection Primitive Types
+
+@code{Libffi} provides a number of built-in type descriptors that can
+be used to describe argument and return types:
+
+@table @code
+@item ffi_type_void
+@tindex ffi_type_void
+The type @code{void}.  This cannot be used for argument types, only
+for return values.
+
+@item ffi_type_uint8
+@tindex ffi_type_uint8
+An unsigned, 8-bit integer type.
+
+@item ffi_type_sint8
+@tindex ffi_type_sint8
+A signed, 8-bit integer type.
+
+@item ffi_type_uint16
+@tindex ffi_type_uint16
+An unsigned, 16-bit integer type.
+
+@item ffi_type_sint16
+@tindex ffi_type_sint16
+A signed, 16-bit integer type.
+
+@item ffi_type_uint32
+@tindex ffi_type_uint32
+An unsigned, 32-bit integer type.
+
+@item ffi_type_sint32
+@tindex ffi_type_sint32
+A signed, 32-bit integer type.
+
+@item ffi_type_uint64
+@tindex ffi_type_uint64
+An unsigned, 64-bit integer type.
+
+@item ffi_type_sint64
+@tindex ffi_type_sint64
+A signed, 64-bit integer type.
+
+@item ffi_type_float
+@tindex ffi_type_float
+The C @code{float} type.
+
+@item ffi_type_double
+@tindex ffi_type_double
+The C @code{double} type.
+
+@item ffi_type_uchar
+@tindex ffi_type_uchar
+The C @code{unsigned char} type.
+
+@item ffi_type_schar
+@tindex ffi_type_schar
+The C @code{signed char} type.  (Note that there is not an exact
+equivalent to the C @code{char} type in @code{libffi}; ordinarily you
+should either use @code{ffi_type_schar} or @code{ffi_type_uchar}
+depending on whether @code{char} is signed.)
+
+@item ffi_type_ushort
+@tindex ffi_type_ushort
+The C @code{unsigned short} type.
+
+@item ffi_type_sshort
+@tindex ffi_type_sshort
+The C @code{short} type.
+
+@item ffi_type_uint
+@tindex ffi_type_uint
+The C @code{unsigned int} type.
+
+@item ffi_type_sint
+@tindex ffi_type_sint
+The C @code{int} type.
+
+@item ffi_type_ulong
+@tindex ffi_type_ulong
+The C @code{unsigned long} type.
+
+@item ffi_type_slong
+@tindex ffi_type_slong
+The C @code{long} type.
+
+@item ffi_type_longdouble
+@tindex ffi_type_longdouble
+On platforms that have a C @code{long double} type, this is defined.
+On other platforms, it is not.
+
+@item ffi_type_pointer
+@tindex ffi_type_pointer
+A generic @code{void *} pointer.  You should use this for all
+pointers, regardless of their real type.
+
+@item ffi_type_complex_float
+@tindex ffi_type_complex_float
+The C @code{_Complex float} type.
+
+@item ffi_type_complex_double
+@tindex ffi_type_complex_double
+The C @code{_Complex double} type.
+
+@item ffi_type_complex_longdouble
+@tindex ffi_type_complex_longdouble
+The C @code{_Complex long double} type.
+On platforms that have a C @code{long double} type, this is defined.
+On other platforms, it is not.
+@end table
+
+Each of these is of type @code{ffi_type}, so you must take the address
+when passing to @code{ffi_prep_cif}.
+
+
+@node Structures
+@subsection Structures
+
+@code{libffi} is perfectly happy passing structures back and forth.
+You must first describe the structure to @code{libffi} by creating a
+new @code{ffi_type} object for it.
+
+@tindex ffi_type
+@deftp {Data type} ffi_type
+The @code{ffi_type} has the following members:
+@table @code
+@item size_t size
+This is set by @code{libffi}; you should initialize it to zero.
+
+@item unsigned short alignment
+This is set by @code{libffi}; you should initialize it to zero.
+
+@item unsigned short type
+For a structure, this should be set to @code{FFI_TYPE_STRUCT}.
+
+@item ffi_type **elements
+This is a @samp{NULL}-terminated array of pointers to @code{ffi_type}
+objects.  There is one element per field of the struct.
+
+Note that @code{libffi} has no special support for bit-fields.  You
+must manage these manually.
+@end table
+@end deftp
+
+The @code{size} and @code{alignment} fields will be filled in by
+@code{ffi_prep_cif} or @code{ffi_prep_cif_var}, as needed.
+
+@node Size and Alignment
+@subsection Size and Alignment
+
+@code{libffi} will set the @code{size} and @code{alignment} fields of
+an @code{ffi_type} object for you.  It does so using its knowledge of
+the ABI.
+
+You might expect that you can simply read these fields for a type that
+has been laid out by @code{libffi}.  However, there are some caveats.
+
+@itemize @bullet
+@item
+The size or alignment of some of the built-in types may vary depending
+on the chosen ABI.
+
+@item
+The size and alignment of a new structure type will not be set by
+@code{libffi} until it has been passed to @code{ffi_prep_cif} or
+@code{ffi_get_struct_offsets}.
+
+@item
+A structure type cannot be shared across ABIs.  Instead each ABI needs
+its own copy of the structure type.
+@end itemize
+
+So, before examining these fields, it is safest to pass the
+@code{ffi_type} object to @code{ffi_prep_cif} or
+@code{ffi_get_struct_offsets} first.  This function will do all the
+needed setup.
+
+@example
+ffi_type *desired_type;
+ffi_abi desired_abi;
+@dots{}
+ffi_cif cif;
+if (ffi_prep_cif (&cif, desired_abi, 0, desired_type, NULL) == FFI_OK)
+  @{
+    size_t size = desired_type->size;
+    unsigned short alignment = desired_type->alignment;
+  @}
+@end example
+
+@code{libffi} also provides a way to get the offsets of the members of
+a structure.
+
+@findex ffi_get_struct_offsets
+@defun ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type, size_t *offsets)
+Compute the offset of each element of the given structure type.
+@var{abi} is the ABI to use; this is needed because in some cases the
+layout depends on the ABI.
+
+@var{offsets} is an out parameter.  The caller is responsible for
+providing enough space for all the results to be written -- one
+element per element type in @var{struct_type}.  If @var{offsets} is
+@code{NULL}, then the type will be laid out but not otherwise
+modified.  This can be useful for accessing the type's size or layout,
+as mentioned above.
+
+This function returns @code{FFI_OK} on success; @code{FFI_BAD_ABI} if
+@var{abi} is invalid; or @code{FFI_BAD_TYPEDEF} if @var{struct_type}
+is invalid in some way.  Note that only @code{FFI_STRUCT} types are
+valid here.
+@end defun
+
+@node Arrays Unions Enums
+@subsection Arrays, Unions, and Enumerations
+
+@subsubsection Arrays
+
+@code{libffi} does not have direct support for arrays or unions.
+However, they can be emulated using structures.
+
+To emulate an array, simply create an @code{ffi_type} using
+@code{FFI_TYPE_STRUCT} with as many members as there are elements in
+the array.
+
+@example
+ffi_type array_type;
+ffi_type **elements
+int i;
+
+elements = malloc ((n + 1) * sizeof (ffi_type *));
+for (i = 0; i < n; ++i)
+  elements[i] = array_element_type;
+elements[n] = NULL;
+
+array_type.size = array_type.alignment = 0;
+array_type.type = FFI_TYPE_STRUCT;
+array_type.elements = elements;
+@end example
+
+Note that arrays cannot be passed or returned by value in C --
+structure types created like this should only be used to refer to
+members of real @code{FFI_TYPE_STRUCT} objects.
+
+However, a phony array type like this will not cause any errors from
+@code{libffi} if you use it as an argument or return type.  This may
+be confusing.
+
+@subsubsection Unions
+
+A union can also be emulated using @code{FFI_TYPE_STRUCT}.  In this
+case, however, you must make sure that the size and alignment match
+the real requirements of the union.
+
+One simple way to do this is to ensue that each element type is laid
+out.  Then, give the new structure type a single element; the size of
+the largest element; and the largest alignment seen as well.
+
+This example uses the @code{ffi_prep_cif} trick to ensure that each
+element type is laid out.
+
+@example
+ffi_abi desired_abi;
+ffi_type union_type;
+ffi_type **union_elements;
+
+int i;
+ffi_type element_types[2];
+
+element_types[1] = NULL;
+
+union_type.size = union_type.alignment = 0;
+union_type.type = FFI_TYPE_STRUCT;
+union_type.elements = element_types;
+
+for (i = 0; union_elements[i]; ++i)
+  @{
+    ffi_cif cif;
+    if (ffi_prep_cif (&cif, desired_abi, 0, union_elements[i], NULL) == FFI_OK)
+      @{
+        if (union_elements[i]->size > union_type.size)
+          @{
+            union_type.size = union_elements[i];
+            size = union_elements[i]->size;
+          @}
+        if (union_elements[i]->alignment > union_type.alignment)
+          union_type.alignment = union_elements[i]->alignment;
+      @}
+  @}
+@end example
+
+@subsubsection Enumerations
+
+@code{libffi} does not have any special support for C @code{enum}s.
+Although any given @code{enum} is implemented using a specific
+underlying integral type, exactly which type will be used cannot be
+determined by @code{libffi} -- it may depend on the values in the
+enumeration or on compiler flags such as @option{-fshort-enums}.
+@xref{Structures unions enumerations and bit-fields implementation, , , gcc},
+for more information about how GCC handles enumerations.
+
+@node Type Example
+@subsection Type Example
+
+The following example initializes a @code{ffi_type} object
+representing the @code{tm} struct from Linux's @file{time.h}.
+
+Here is how the struct is defined:
+
+@example
+struct tm @{
+    int tm_sec;
+    int tm_min;
+    int tm_hour;
+    int tm_mday;
+    int tm_mon;
+    int tm_year;
+    int tm_wday;
+    int tm_yday;
+    int tm_isdst;
+    /* Those are for future use. */
+    long int __tm_gmtoff__;
+    __const char *__tm_zone__;
+@};
+@end example
+
+Here is the corresponding code to describe this struct to
+@code{libffi}:
+
+@example
+    @{
+      ffi_type tm_type;
+      ffi_type *tm_type_elements[12];
+      int i;
+
+      tm_type.size = tm_type.alignment = 0;
+      tm_type.type = FFI_TYPE_STRUCT;
+      tm_type.elements = &tm_type_elements;
+
+      for (i = 0; i < 9; i++)
+          tm_type_elements[i] = &ffi_type_sint;
+
+      tm_type_elements[9] = &ffi_type_slong;
+      tm_type_elements[10] = &ffi_type_pointer;
+      tm_type_elements[11] = NULL;
+
+      /* tm_type can now be used to represent tm argument types and
+	 return types for ffi_prep_cif() */
+    @}
+@end example
+
+@node Complex
+@subsection Complex Types
+
+@code{libffi} supports the complex types defined by the C99
+standard (@code{_Complex float}, @code{_Complex double} and
+@code{_Complex long double} with the built-in type descriptors
+@code{ffi_type_complex_float}, @code{ffi_type_complex_double} and
+@code{ffi_type_complex_longdouble}.
+
+Custom complex types like @code{_Complex int} can also be used.
+An @code{ffi_type} object has to be defined to describe the
+complex type to @code{libffi}.
+
+@tindex ffi_type
+@deftp {Data type} ffi_type
+@table @code
+@item size_t size
+This must be manually set to the size of the complex type.
+
+@item unsigned short alignment
+This must be manually set to the alignment of the complex type.
+
+@item unsigned short type
+For a complex type, this must be set to @code{FFI_TYPE_COMPLEX}.
+
+@item ffi_type **elements
+
+This is a @samp{NULL}-terminated array of pointers to
+@code{ffi_type} objects.  The first element is set to the
+@code{ffi_type} of the complex's base type.  The second element
+must be set to @code{NULL}.
+@end table
+@end deftp
+
+The section @ref{Complex Type Example} shows a way to determine
+the @code{size} and @code{alignment} members in a platform
+independent way.
+
+For platforms that have no complex support in @code{libffi} yet,
+the functions @code{ffi_prep_cif} and @code{ffi_prep_args} abort
+the program if they encounter a complex type.
+
+@node Complex Type Example
+@subsection Complex Type Example
+
+This example demonstrates how to use complex types:
+
+@example
+#include <stdio.h>
+#include <ffi.h>
+#include <complex.h>
+
+void complex_fn(_Complex float cf,
+                _Complex double cd,
+                _Complex long double cld)
+@{
+  printf("cf=%f+%fi\ncd=%f+%fi\ncld=%f+%fi\n",
+         (float)creal (cf), (float)cimag (cf),
+         (float)creal (cd), (float)cimag (cd),
+         (float)creal (cld), (float)cimag (cld));
+@}
+
+int main()
+@{
+  ffi_cif cif;
+  ffi_type *args[3];
+  void *values[3];
+  _Complex float cf;
+  _Complex double cd;
+  _Complex long double cld;
+
+  /* Initialize the argument info vectors */
+  args[0] = &ffi_type_complex_float;
+  args[1] = &ffi_type_complex_double;
+  args[2] = &ffi_type_complex_longdouble;
+  values[0] = &cf;
+  values[1] = &cd;
+  values[2] = &cld;
+
+  /* Initialize the cif */
+  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+                   &ffi_type_void, args) == FFI_OK)
+    @{
+      cf = 1.0 + 20.0 * I;
+      cd = 300.0 + 4000.0 * I;
+      cld = 50000.0 + 600000.0 * I;
+      /* Call the function */
+      ffi_call(&cif, (void (*)(void))complex_fn, 0, values);
+    @}
+
+  return 0;
+@}
+@end example
+
+This is an example for defining a custom complex type descriptor
+for compilers that support them:
+
+@example
+/*
+ * This macro can be used to define new complex type descriptors
+ * in a platform independent way.
+ *
+ * name: Name of the new descriptor is ffi_type_complex_<name>.
+ * type: The C base type of the complex type.
+ */
+#define FFI_COMPLEX_TYPEDEF(name, type, ffitype)             \
+  static ffi_type *ffi_elements_complex_##name [2] = @{      \
+    (ffi_type *)(&ffitype), NULL                             \
+  @};                                                        \
+  struct struct_align_complex_##name @{                      \
+    char c;                                                  \
+    _Complex type x;                                         \
+  @};                                                        \
+  ffi_type ffi_type_complex_##name = @{                      \
+    sizeof(_Complex type),                                   \
+    offsetof(struct struct_align_complex_##name, x),         \
+    FFI_TYPE_COMPLEX,                                        \
+    (ffi_type **)ffi_elements_complex_##name                 \
+  @}
+
+/* Define new complex type descriptors using the macro: */
+/* ffi_type_complex_sint */
+FFI_COMPLEX_TYPEDEF(sint, int, ffi_type_sint);
+/* ffi_type_complex_uchar */
+FFI_COMPLEX_TYPEDEF(uchar, unsigned char, ffi_type_uint8);
+@end example
+
+The new type descriptors can then be used like one of the built-in
+type descriptors in the previous example.
+
+@node Multiple ABIs
+@section Multiple ABIs
+
+A given platform may provide multiple different ABIs at once.  For
+instance, the x86 platform has both @samp{stdcall} and @samp{fastcall}
+functions.
+
+@code{libffi} provides some support for this.  However, this is
+necessarily platform-specific.
+
+@c FIXME: document the platforms
+
+@node The Closure API
+@section The Closure API
+
+@code{libffi} also provides a way to write a generic function -- a
+function that can accept and decode any combination of arguments.
+This can be useful when writing an interpreter, or to provide wrappers
+for arbitrary functions.
+
+This facility is called the @dfn{closure API}.  Closures are not
+supported on all platforms; you can check the @code{FFI_CLOSURES}
+define to determine whether they are supported on the current
+platform.
+@cindex closures
+@cindex closure API
+@findex FFI_CLOSURES
+
+Because closures work by assembling a tiny function at runtime, they
+require special allocation on platforms that have a non-executable
+heap.  Memory management for closures is handled by a pair of
+functions:
+
+@findex ffi_closure_alloc
+@defun void *ffi_closure_alloc (size_t @var{size}, void **@var{code})
+Allocate a chunk of memory holding @var{size} bytes.  This returns a
+pointer to the writable address, and sets *@var{code} to the
+corresponding executable address.
+
+@var{size} should be sufficient to hold a @code{ffi_closure} object.
+@end defun
+
+@findex ffi_closure_free
+@defun void ffi_closure_free (void *@var{writable})
+Free memory allocated using @code{ffi_closure_alloc}.  The argument is
+the writable address that was returned.
+@end defun
+
+Once you have allocated the memory for a closure, you must construct a
+@code{ffi_cif} describing the function call.  Finally you can prepare
+the closure function:
+
+@findex ffi_prep_closure_loc
+@defun ffi_status ffi_prep_closure_loc (ffi_closure *@var{closure}, ffi_cif *@var{cif}, void (*@var{fun}) (ffi_cif *@var{cif}, void *@var{ret}, void **@var{args}, void *@var{user_data}), void *@var{user_data}, void *@var{codeloc})
+Prepare a closure function.  The arguments to
+@code{ffi_prep_closure_loc} are:
+
+@table @var
+@item closure
+The address of a @code{ffi_closure} object; this is the writable
+address returned by @code{ffi_closure_alloc}.
+
+@item cif
+The @code{ffi_cif} describing the function parameters.  Note that this
+object, and the types to which it refers, must be kept alive until the
+closure itself is freed.
+
+@item user_data
+An arbitrary datum that is passed, uninterpreted, to your closure
+function.
+
+@item codeloc
+The executable address returned by @code{ffi_closure_alloc}.
+
+@item fun
+The function which will be called when the closure is invoked.  It is
+called with the arguments:
+
+@table @var
+@item cif
+The @code{ffi_cif} passed to @code{ffi_prep_closure_loc}.
+
+@item ret
+A pointer to the memory used for the function's return value.
+
+If the function is declared as returning @code{void}, then this value
+is garbage and should not be used.
+
+Otherwise, @var{fun} must fill the object to which this points,
+following the same special promotion behavior as @code{ffi_call}.
+That is, in most cases, @var{ret} points to an object of exactly the
+size of the type specified when @var{cif} was constructed.  However,
+integral types narrower than the system register size are widened.  In
+these cases your program may assume that @var{ret} points to an
+@code{ffi_arg} object.
+
+@item args
+A vector of pointers to memory holding the arguments to the function.
+
+@item user_data
+The same @var{user_data} that was passed to
+@code{ffi_prep_closure_loc}.
+@end table
+@end table
+
+@code{ffi_prep_closure_loc} will return @code{FFI_OK} if everything
+went ok, and one of the other @code{ffi_status} values on error.
+
+After calling @code{ffi_prep_closure_loc}, you can cast @var{codeloc}
+to the appropriate pointer-to-function type.
+@end defun
+
+You may see old code referring to @code{ffi_prep_closure}.  This
+function is deprecated, as it cannot handle the need for separate
+writable and executable addresses.
+
+@node Closure Example
+@section Closure Example
+
+A trivial example that creates a new @code{puts} by binding
+@code{fputs} with @code{stdout}.
+
+@example
+#include <stdio.h>
+#include <ffi.h>
+
+/* Acts like puts with the file given at time of enclosure. */
+void puts_binding(ffi_cif *cif, void *ret, void* args[],
+                  void *stream)
+@{
+  *(ffi_arg *)ret = fputs(*(char **)args[0], (FILE *)stream);
+@}
+
+typedef int (*puts_t)(char *);
+
+int main()
+@{
+  ffi_cif cif;
+  ffi_type *args[1];
+  ffi_closure *closure;
+
+  void *bound_puts;
+  int rc;
+
+  /* Allocate closure and bound_puts */
+  closure = ffi_closure_alloc(sizeof(ffi_closure), &bound_puts);
+
+  if (closure)
+    @{
+      /* Initialize the argument info vectors */
+      args[0] = &ffi_type_pointer;
+
+      /* Initialize the cif */
+      if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+                       &ffi_type_sint, args) == FFI_OK)
+        @{
+          /* Initialize the closure, setting stream to stdout */
+          if (ffi_prep_closure_loc(closure, &cif, puts_binding,
+                                   stdout, bound_puts) == FFI_OK)
+            @{
+              rc = ((puts_t)bound_puts)("Hello World!");
+              /* rc now holds the result of the call to fputs */
+            @}
+        @}
+    @}
+
+  /* Deallocate both closure, and bound_puts */
+  ffi_closure_free(closure);
+
+  return 0;
+@}
+
+@end example
+
+@node Thread Safety
+@section Thread Safety
+
+@code{libffi} is not completely thread-safe.  However, many parts are,
+and if you follow some simple rules, you can use it safely in a
+multi-threaded program.
+
+@itemize @bullet
+@item
+@code{ffi_prep_cif} may modify the @code{ffi_type} objects passed to
+it.  It is best to ensure that only a single thread prepares a given
+@code{ffi_cif} at a time.
+
+@item
+On some platforms, @code{ffi_prep_cif} may modify the size and
+alignment of some types, depending on the chosen ABI.  On these
+platforms, if you switch between ABIs, you must ensure that there is
+only one call to @code{ffi_prep_cif} at a time.
+
+Currently the only affected platform is PowerPC and the only affected
+type is @code{long double}.
+@end itemize
+
+@node Memory Usage
+@chapter Memory Usage
+
+Note that memory allocated by @code{ffi_closure_alloc} and freed by
+@code{ffi_closure_free} does not come from the same general pool of
+memory that @code{malloc} and @code{free} use.  To accomodate security
+settings, @code{libffi} may aquire memory, for example, by mapping
+temporary files into multiple places in the address space (once to
+write out the closure, a second to execute it).  The search follows
+this list, using the first that works:
+
+@itemize @bullet
+
+@item
+A anonymous mapping (i.e. not file-backed)
+
+@item
+@code{memfd_create()}, if the kernel supports it.
+
+@item
+A file created in the directory referenced by the environment variable
+@code{LIBFFI_TMPDIR}.
+
+@item
+Likewise for the environment variable @code{TMPDIR}.
+
+@item
+A file created in @code{/tmp}.
+
+@item
+A file created in @code{/var/tmp}.
+
+@item
+A file created in @code{/dev/shm}.
+
+@item
+A file created in the user's home directory (@code{$HOME}).
+
+@item
+A file created in any directory listed in @code{/etc/mtab}.
+
+@item
+A file created in any directory listed in @code{/proc/mounts}.
+
+@end itemize
+
+If security settings prohibit using any of these for closures,
+@code{ffi_closure_alloc} will fail.
+
+@node Missing Features
+@chapter Missing Features
+
+@code{libffi} is missing a few features.  We welcome patches to add
+support for these.
+
+@itemize @bullet
+@item
+Variadic closures.
+
+@item
+There is no support for bit fields in structures.
+
+@item
+The ``raw'' API is undocumented.
+@c anything else?
+
+@item
+The Go API is undocumented.
+@end itemize
+
+@node Index
+@unnumbered Index
+
+@printindex cp
+
+@bye
Index: libffi-3.4.6/doc/Makefile.am
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/doc/Makefile.am b/libffi-3.4.6/doc/Makefile.am
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/doc/Makefile.am	
@@ -0,0 +1,3 @@
+## Process this with automake to create Makefile.in
+
+info_TEXINFOS = libffi.texi
Index: libffi-3.4.6/doc/version.texi
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/doc/version.texi b/libffi-3.4.6/doc/version.texi
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/doc/version.texi	
@@ -0,0 +1,4 @@
+@set UPDATED 15 February 2024
+@set UPDATED-MONTH February 2024
+@set EDITION 3.4.6
+@set VERSION 3.4.6
Index: libffi-3.4.6/man/ffi.3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/man/ffi.3 b/libffi-3.4.6/man/ffi.3
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/man/ffi.3	
@@ -0,0 +1,41 @@
+.Dd February 15, 2008
+.Dt FFI 3
+.Sh NAME
+.Nm FFI
+.Nd Foreign Function Interface
+.Sh LIBRARY
+libffi, -lffi
+.Sh SYNOPSIS
+.In ffi.h
+.Ft ffi_status
+.Fo ffi_prep_cif
+.Fa "ffi_cif *cif"
+.Fa "ffi_abi abi"
+.Fa "unsigned int nargs"
+.Fa "ffi_type *rtype"
+.Fa "ffi_type **atypes"
+.Fc
+.Ft void
+.Fo ffi_prep_cif_var
+.Fa "ffi_cif *cif"
+.Fa "ffi_abi abi"
+.Fa "unsigned int nfixedargs"
+.Fa "unsigned int ntotalargs"
+.Fa "ffi_type *rtype"
+.Fa "ffi_type **atypes"
+.Fc
+.Ft void
+.Fo ffi_call
+.Fa "ffi_cif *cif"
+.Fa "void (*fn)(void)"
+.Fa "void *rvalue"
+.Fa "void **avalue"
+.Fc
+.Sh DESCRIPTION
+The foreign function interface provides a mechanism by which a function can
+generate a call to another function at runtime without requiring knowledge of
+the called function's interface at compile time.
+.Sh SEE ALSO
+.Xr ffi_prep_cif 3 ,
+.Xr ffi_prep_cif_var 3 ,
+.Xr ffi_call 3
Index: libffi-3.4.6/man/ffi_call.3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/man/ffi_call.3 b/libffi-3.4.6/man/ffi_call.3
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/man/ffi_call.3	
@@ -0,0 +1,103 @@
+.Dd February 15, 2008
+.Dt ffi_call 3
+.Sh NAME
+.Nm ffi_call
+.Nd Invoke a foreign function.
+.Sh SYNOPSIS
+.In ffi.h
+.Ft void
+.Fo ffi_call
+.Fa "ffi_cif *cif"
+.Fa "void (*fn)(void)"
+.Fa "void *rvalue"
+.Fa "void **avalue"
+.Fc
+.Sh DESCRIPTION
+The
+.Nm ffi_call
+function provides a simple mechanism for invoking a function without
+requiring knowledge of the function's interface at compile time.
+.Fa fn
+is called with the values retrieved from the pointers in the
+.Fa avalue
+array. The return value from
+.Fa fn
+is placed in storage pointed to by
+.Fa rvalue .
+.Fa cif
+contains information describing the data types, sizes and alignments of the
+arguments to and return value from
+.Fa fn ,
+and must be initialized with
+.Nm ffi_prep_cif
+before it is used with
+.Nm ffi_call .
+.Pp
+.Fa rvalue
+must point to storage that is sizeof(ffi_arg) or larger for non-floating point
+types. For smaller-sized return value types, the
+.Nm ffi_arg
+or
+.Nm ffi_sarg
+integral type must be used to hold
+the return value.
+.Sh EXAMPLES
+.Bd -literal
+#include <ffi.h>
+#include <stdio.h>
+
+unsigned char
+foo(unsigned int, float);
+
+int
+main(int argc, const char **argv)
+{
+    ffi_cif cif;
+    ffi_type *arg_types[2];
+    void *arg_values[2];
+    ffi_status status;
+
+    // Because the return value from foo() is smaller than sizeof(long), it
+    // must be passed as ffi_arg or ffi_sarg.
+    ffi_arg result;
+
+    // Specify the data type of each argument. Available types are defined
+    // in <ffi/ffi.h>.
+    arg_types[0] = &ffi_type_uint;
+    arg_types[1] = &ffi_type_float;
+
+    // Prepare the ffi_cif structure.
+    if ((status = ffi_prep_cif(&cif, FFI_DEFAULT_ABI,
+        2, &ffi_type_uint8, arg_types)) != FFI_OK)
+    {
+        // Handle the ffi_status error.
+    }
+
+    // Specify the values of each argument.
+    unsigned int arg1 = 42;
+    float arg2 = 5.1;
+
+    arg_values[0] = &arg1;
+    arg_values[1] = &arg2;
+
+    // Invoke the function.
+    ffi_call(&cif, FFI_FN(foo), &result, arg_values);
+
+    // The ffi_arg 'result' now contains the unsigned char returned from foo(),
+    // which can be accessed by a typecast.
+    printf("result is %hhu", (unsigned char)result);
+
+    return 0;
+}
+
+// The target function.
+unsigned char
+foo(unsigned int x, float y)
+{
+    unsigned char result = x - y;
+    return result;
+}
+.Ed
+.Sh SEE ALSO
+.Xr ffi 3 ,
+.Xr ffi_prep_cif 3
Index: libffi-3.4.6/man/Makefile.am
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/man/Makefile.am b/libffi-3.4.6/man/Makefile.am
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/man/Makefile.am	
@@ -0,0 +1,8 @@
+## Process this with automake to create Makefile.in
+
+AUTOMAKE_OPTIONS=foreign
+
+EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3
+
+man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3
+
Index: libffi-3.4.6/man/ffi_prep_cif.3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/man/ffi_prep_cif.3 b/libffi-3.4.6/man/ffi_prep_cif.3
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/man/ffi_prep_cif.3	
@@ -0,0 +1,68 @@
+.Dd February 15, 2008
+.Dt ffi_prep_cif 3
+.Sh NAME
+.Nm ffi_prep_cif
+.Nd Prepare a
+.Nm ffi_cif
+structure for use with
+.Nm ffi_call 
+.
+.Sh SYNOPSIS
+.In ffi.h
+.Ft ffi_status
+.Fo ffi_prep_cif
+.Fa "ffi_cif *cif"
+.Fa "ffi_abi abi"
+.Fa "unsigned int nargs"
+.Fa "ffi_type *rtype"
+.Fa "ffi_type **atypes"
+.Fc
+.Sh DESCRIPTION
+The
+.Nm ffi_prep_cif
+function prepares a
+.Nm ffi_cif
+structure for use with 
+.Nm ffi_call
+.
+.Fa abi
+specifies a set of calling conventions to use.
+.Fa atypes
+is an array of
+.Fa nargs
+pointers to
+.Nm ffi_type
+structs that describe the data type, size and alignment of each argument.
+.Fa rtype
+points to an
+.Nm ffi_type
+that describes the data type, size and alignment of the
+return value. Note that to call a variadic function
+.Nm ffi_prep_cif_var
+must be used instead.
+.Sh RETURN VALUES
+Upon successful completion,
+.Nm ffi_prep_cif
+returns
+.Nm FFI_OK .
+It will return
+.Nm FFI_BAD_TYPEDEF
+if
+.Fa cif
+is
+.Nm NULL
+or
+.Fa atypes
+or
+.Fa rtype
+is malformed. If
+.Fa abi
+does not refer to a valid ABI,
+.Nm FFI_BAD_ABI
+will be returned. Available ABIs are
+defined in
+.Nm <ffitarget.h> .
+.Sh SEE ALSO
+.Xr ffi 3 ,
+.Xr ffi_call 3 ,
+.Xr ffi_prep_cif_var 3
Index: libffi-3.4.6/man/ffi_prep_cif_var.3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/man/ffi_prep_cif_var.3 b/libffi-3.4.6/man/ffi_prep_cif_var.3
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/man/ffi_prep_cif_var.3	
@@ -0,0 +1,73 @@
+.Dd January 25, 2011
+.Dt ffi_prep_cif_var 3
+.Sh NAME
+.Nm ffi_prep_cif_var
+.Nd Prepare a
+.Nm ffi_cif
+structure for use with
+.Nm ffi_call
+for variadic functions.
+.Sh SYNOPSIS
+.In ffi.h
+.Ft ffi_status
+.Fo ffi_prep_cif_var
+.Fa "ffi_cif *cif"
+.Fa "ffi_abi abi"
+.Fa "unsigned int nfixedargs"
+.Fa "unsigned int ntotalargs"
+.Fa "ffi_type *rtype"
+.Fa "ffi_type **atypes"
+.Fc
+.Sh DESCRIPTION
+The
+.Nm ffi_prep_cif_var
+function prepares a
+.Nm ffi_cif
+structure for use with
+.Nm ffi_call
+for variadic functions.
+.Fa abi
+specifies a set of calling conventions to use.
+.Fa atypes
+is an array of
+.Fa ntotalargs
+pointers to
+.Nm ffi_type
+structs that describe the data type, size and alignment of each argument.
+.Fa rtype
+points to an
+.Nm ffi_type
+that describes the data type, size and alignment of the
+return value.
+.Fa nfixedargs
+must contain the number of fixed (non-variadic) arguments.
+Note that to call a non-variadic function
+.Nm ffi_prep_cif
+must be used.
+.Sh RETURN VALUES
+Upon successful completion,
+.Nm ffi_prep_cif_var
+returns
+.Nm FFI_OK .
+It will return
+.Nm FFI_BAD_TYPEDEF
+if
+.Fa cif
+is
+.Nm NULL
+or
+.Fa atypes
+or
+.Fa rtype
+is malformed. If
+.Fa abi
+does not refer to a valid ABI,
+.Nm FFI_BAD_ABI
+will be returned. Available ABIs are
+defined in
+.Nm <ffitarget.h>
+.
+.Sh SEE ALSO
+.Xr ffi 3 ,
+.Xr ffi_call 3 ,
+.Xr ffi_prep_cif 3
Index: libffi-3.4.6/src/pa/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/ffi.c b/libffi-3.4.6/src/pa/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/ffi.c	
@@ -0,0 +1,673 @@
+/* -----------------------------------------------------------------------
+   ffi.c - (c) 2011 Anthony Green
+           (c) 2008 Red Hat, Inc.
+	   (c) 2006 Free Software Foundation, Inc.
+           (c) 2003-2004 Randolph Chung <tausq@debian.org>
+           
+   HPPA Foreign Function Interface
+   HP-UX PA ABI support 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))
+
+#define MIN_STACK_SIZE  64
+#define FIRST_ARG_SLOT  9
+#define DEBUG_LEVEL   0
+
+#define fldw(addr, fpreg) \
+  __asm__ volatile ("fldw 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)
+#define fstw(fpreg, addr) \
+  __asm__ volatile ("fstw %%" #fpreg "L, 0(%0)" : : "r"(addr))
+#define fldd(addr, fpreg) \
+  __asm__ volatile ("fldd 0(%0), %%" #fpreg : : "r"(addr) : #fpreg)
+#define fstd(fpreg, addr) \
+  __asm__ volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))
+
+#define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)
+
+static inline int ffi_struct_type(ffi_type *t)
+{
+  size_t sz = t->size;
+
+  /* Small structure results are passed in registers,
+     larger ones are passed by pointer.  Note that small
+     structures differ from the corresponding integer
+     types in that they have different alignment requirements.  */
+
+  if (sz <= 8)
+    return -sz;
+  else
+    return FFI_TYPE_STRUCT; /* else, we pass it by pointer.  */
+}
+
+/* PA has a downward growing stack, which looks like this:
+
+   Offset
+	[ Variable args ]
+   SP = (4*(n+9))       arg word N
+   ...
+   SP-52                arg word 4
+	[ Fixed args ]
+   SP-48                arg word 3
+   SP-44                arg word 2
+   SP-40                arg word 1
+   SP-36                arg word 0
+	[ Frame marker ]
+   ...
+   SP-20                RP
+   SP-4                 previous SP
+
+   The first four argument words on the stack are reserved for use by
+   the callee.  Instead, the general and floating registers replace
+   the first four argument slots.  Non FP arguments are passed solely
+   in the general registers.  FP arguments are passed in both general
+   and floating registers when using libffi.
+
+   Non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23.
+   Non-FP 64-bit args are passed in register pairs, starting
+   on an odd numbered register (i.e. r25+r26 and r23+r24).
+   FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L.
+   FP 64-bit arguments are passed in fr5 and fr7.
+
+   The registers are allocated in the same manner as stack slots.
+   This allows the callee to save its arguments on the stack if
+   necessary:
+
+   arg word 3 -> gr23 or fr7L
+   arg word 2 -> gr24 or fr6L or fr7R
+   arg word 1 -> gr25 or fr5L
+   arg word 0 -> gr26 or fr4L or fr5R
+
+   Note that fr4R and fr6R are never used for arguments (i.e.,
+   doubles are not passed in fr4 or fr6).
+
+   The rest of the arguments are passed on the stack starting at SP-52,
+   but 64-bit arguments need to be aligned to an 8-byte boundary
+
+   This means we can have holes either in the register allocation,
+   or in the stack.  */
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments
+
+   The following code will put everything into the stack frame
+   (which was allocated by the asm routine), and on return
+   the asm routine will load the arguments that should be
+   passed by register into the appropriate registers
+
+   NOTE: We load floating point args in this function... that means we
+   assume gcc will not mess with fp regs in here.  */
+
+void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)
+{
+  register unsigned int i;
+  register ffi_type **p_arg;
+  register void **p_argv;
+  unsigned int slot = FIRST_ARG_SLOT;
+  char *dest_cpy;
+  size_t len;
+
+  debug(1, "%s: stack = %p, ecif = %p, bytes = %u\n", __FUNCTION__, stack,
+	ecif, bytes);
+
+  p_arg = ecif->cif->arg_types;
+  p_argv = ecif->avalue;
+
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	  *(SINT32 *)(stack - slot) = *(SINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  *(UINT32 *)(stack - slot) = *(UINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  *(SINT32 *)(stack - slot) = *(SINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  *(UINT32 *)(stack - slot) = *(UINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  debug(3, "Storing UINT32 %u in slot %u\n", *(UINT32 *)(*p_argv),
+		slot);
+	  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  /* Align slot for 64-bit type.  */
+	  slot += (slot & 1) ? 1 : 2;
+	  *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* First 4 args go in fr4L - fr7L.  */
+	  debug(3, "Storing UINT32(float) in slot %u\n", slot);
+	  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    /* First 4 args go in fr4L - fr7L.  */
+	    case 0: fldw(stack - slot, fr4); break;
+	    case 1: fldw(stack - slot, fr5); break;
+	    case 2: fldw(stack - slot, fr6); break;
+	    case 3: fldw(stack - slot, fr7); break;
+	    }
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  /* Align slot for 64-bit type.  */
+	  slot += (slot & 1) ? 1 : 2;
+	  debug(3, "Storing UINT64(double) at slot %u\n", slot);
+	  *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	      /* First 2 args go in fr5, fr7.  */
+	      case 1: fldd(stack - slot, fr5); break;
+	      case 3: fldd(stack - slot, fr7); break;
+	    }
+	  break;
+
+#ifdef PA_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  /* Long doubles are passed in the same manner as structures
+	     larger than 8 bytes.  */
+	  *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);
+	  break;
+#endif
+
+	case FFI_TYPE_STRUCT:
+
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+
+	  len = (*p_arg)->size;
+	  if (len <= 4)
+	    {
+	      dest_cpy = (char *)(stack - slot) + 4 - len;
+	      memcpy(dest_cpy, (char *)*p_argv, len);
+	    }
+	  else if (len <= 8)
+	    {
+	      slot += (slot & 1) ? 1 : 2;
+	      dest_cpy = (char *)(stack - slot) + 8 - len;
+	      memcpy(dest_cpy, (char *)*p_argv, len);
+	    }
+	  else
+	    *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      slot++;
+      p_arg++;
+      p_argv++;
+    }
+
+  /* Make sure we didn't mess up and scribble on the stack.  */
+  {
+    unsigned int n;
+
+    debug(5, "Stack setup:\n");
+    for (n = 0; n < (bytes + 3) / 4; n++)
+      {
+	if ((n%4) == 0) { debug(5, "\n%08x: ", (unsigned int)(stack - n)); }
+	debug(5, "%08x ", *(stack - n));
+      }
+    debug(5, "\n");
+  }
+
+  FFI_ASSERT(slot * 4 <= bytes);
+
+  return;
+}
+
+static void ffi_size_stack_pa32(ffi_cif *cif)
+{
+  ffi_type **ptr;
+  int i;
+  int z = 0; /* # stack slots */
+
+  for (ptr = cif->arg_types, i = 0; i < cif->nargs; ptr++, i++)
+    {
+      int type = (*ptr)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  z += 2 + (z & 1); /* must start on even regs, so we may waste one */
+	  break;
+
+#ifdef PA_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+#endif
+	case FFI_TYPE_STRUCT:
+	  z += 1; /* pass by ptr, callee will copy */
+	  break;
+
+	default: /* <= 32-bit values */
+	  z++;
+	}
+    }
+
+  /* We can fit up to 6 args in the default 64-byte stack frame,
+     if we need more, we need more stack.  */
+  if (z <= 6)
+    cif->bytes = MIN_STACK_SIZE; /* min stack size */
+  else
+    cif->bytes = 64 + ROUND_UP((z - 6) * sizeof(UINT32), MIN_STACK_SIZE);
+
+  debug(3, "Calculated stack size is %u bytes\n", cif->bytes);
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+#ifdef PA_HPUX
+    case FFI_TYPE_LONGDOUBLE:
+      /* Long doubles are treated like a structure.  */
+      cif->flags = FFI_TYPE_STRUCT;
+      break;
+#endif
+
+    case FFI_TYPE_STRUCT:
+      /* For the return type we have to check the size of the structures.
+	 If the size is smaller or equal 4 bytes, the result is given back
+	 in one register. If the size is smaller or equal 8 bytes than we
+	 return the result in two registers. But if the size is bigger than
+	 8 bytes, we work with pointers.  */
+      cif->flags = ffi_struct_type(cif->rtype);
+      break;
+
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      cif->flags = FFI_TYPE_UINT64;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  /* Lucky us, because of the unique PA ABI we get to do our
+     own stack sizing.  */
+  switch (cif->abi)
+    {
+    case FFI_PA32:
+      ffi_size_stack_pa32(cif);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  return FFI_OK;
+}
+
+extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),
+			  extended_cif *, unsigned, unsigned, unsigned *,
+			  void (*fn)(void));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+  size_t i, nargs = cif->nargs;
+  ffi_type **arg_types = cif->arg_types;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT && size > 8)
+	{
+	  char *argcopy = alloca (size);
+	  memcpy (argcopy, avalue[i], size);
+	  avalue[i] = argcopy;
+	}
+    }
+
+  /* If the return value is a struct and we don't have a return
+     value address then we need to make one.  */
+
+  if (rvalue == NULL
+#ifdef PA_HPUX
+      && (cif->rtype->type == FFI_TYPE_STRUCT
+	  || cif->rtype->type == FFI_TYPE_LONGDOUBLE))
+#else
+      && cif->rtype->type == FFI_TYPE_STRUCT)
+#endif
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+
+  switch (cif->abi)
+    {
+    case FFI_PA32:
+      debug(3, "Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
+      ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,
+		     cif->flags, ecif.rvalue, fn);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#if FFI_CLOSURES
+/* This is more-or-less an inverse of ffi_call -- we have arguments on
+   the stack, and we need to fill them into a cif structure and invoke
+   the user function. This really ought to be in asm to make sure
+   the compiler doesn't do things we don't expect.  */
+ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)
+{
+  ffi_cif *cif;
+  void **avalue;
+  void *rvalue;
+  /* Functions can return up to 64-bits in registers.  Return address
+     must be double word aligned.  */
+  union { double rd; UINT32 ret[2]; } u;
+  ffi_type **p_arg;
+  char *tmp;
+  int i, avn;
+  unsigned int slot = FIRST_ARG_SLOT;
+  register UINT32 r28 asm("r28");
+
+  cif = closure->cif;
+
+  /* If returning via structure, callee will write to our pointer.  */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    rvalue = (void *)r28;
+  else
+    rvalue = &u;
+
+  avalue = (void **)alloca(cif->nargs * FFI_SIZEOF_ARG);
+  avn = cif->nargs;
+  p_arg = cif->arg_types;
+
+  for (i = 0; i < avn; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_POINTER:
+	  avalue[i] = (char *)(stack - slot) + sizeof(UINT32) - (*p_arg)->size;
+	  break;
+
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  slot += (slot & 1) ? 1 : 2;
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+#ifdef PA_LINUX
+	  /* The closure call is indirect.  In Linux, floating point
+	     arguments in indirect calls with a prototype are passed
+	     in the floating point registers instead of the general
+	     registers.  So, we need to replace what was previously
+	     stored in the current slot with the value in the
+	     corresponding floating point register.  */
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 0: fstw(fr4, (void *)(stack - slot)); break;
+	    case 1: fstw(fr5, (void *)(stack - slot)); break;
+	    case 2: fstw(fr6, (void *)(stack - slot)); break;
+	    case 3: fstw(fr7, (void *)(stack - slot)); break;
+	    }
+#endif
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  slot += (slot & 1) ? 1 : 2;
+#ifdef PA_LINUX
+	  /* See previous comment for FFI_TYPE_FLOAT.  */
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 1: fstd(fr5, (void *)(stack - slot)); break;
+	    case 3: fstd(fr7, (void *)(stack - slot)); break;
+	    }
+#endif
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+#ifdef PA_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  /* Long doubles are treated like a big structure.  */
+	  avalue[i] = (void *) *(stack - slot);
+	  break;
+#endif
+
+	case FFI_TYPE_STRUCT:
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+	  if((*p_arg)->size <= 4)
+	    {
+	      avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -
+		(*p_arg)->size;
+	    }
+	  else if ((*p_arg)->size <= 8)
+	    {
+	      slot += (slot & 1) ? 1 : 2;
+	      avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -
+		(*p_arg)->size;
+	    }
+	  else
+	    avalue[i] = (void *) *(stack - slot);
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      slot++;
+      p_arg++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  debug(3, "after calling function, ret[0] = %08x, ret[1] = %08x\n", u.ret[0],
+	u.ret[1]);
+
+  /* Store the result using the lower 2 bytes of the flags.  */
+  switch (cif->flags)
+    {
+    case FFI_TYPE_UINT8:
+      *(stack - FIRST_ARG_SLOT) = (UINT8)u.ret[0];
+      break;
+    case FFI_TYPE_SINT8:
+      *(stack - FIRST_ARG_SLOT) = (SINT8)u.ret[0];
+      break;
+    case FFI_TYPE_UINT16:
+      *(stack - FIRST_ARG_SLOT) = (UINT16)u.ret[0];
+      break;
+    case FFI_TYPE_SINT16:
+      *(stack - FIRST_ARG_SLOT) = (SINT16)u.ret[0];
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+      *(stack - FIRST_ARG_SLOT) = u.ret[0];
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      *(stack - FIRST_ARG_SLOT) = u.ret[0];
+      *(stack - FIRST_ARG_SLOT - 1) = u.ret[1];
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      fldd(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_FLOAT:
+      fldw(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* Don't need a return value, done by caller.  */
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT1:
+    case FFI_TYPE_SMALL_STRUCT2:
+    case FFI_TYPE_SMALL_STRUCT3:
+    case FFI_TYPE_SMALL_STRUCT4:
+      tmp = (void*)(stack -  FIRST_ARG_SLOT);
+      tmp += 4 - cif->rtype->size;
+      memcpy((void*)tmp, &u, cif->rtype->size);
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT5:
+    case FFI_TYPE_SMALL_STRUCT6:
+    case FFI_TYPE_SMALL_STRUCT7:
+    case FFI_TYPE_SMALL_STRUCT8:
+      {
+	unsigned int ret2[2];
+	int off;
+
+	/* Right justify ret[0] and ret[1] */
+	switch (cif->flags)
+	  {
+	    case FFI_TYPE_SMALL_STRUCT5: off = 3; break;
+	    case FFI_TYPE_SMALL_STRUCT6: off = 2; break;
+	    case FFI_TYPE_SMALL_STRUCT7: off = 1; break;
+	    default: off = 0; break;
+	  }
+
+	memset (ret2, 0, sizeof (ret2));
+	memcpy ((char *)ret2 + off, &u, 8 - off);
+
+	*(stack - FIRST_ARG_SLOT) = ret2[0];
+	*(stack - FIRST_ARG_SLOT - 1) = ret2[1];
+      }
+      break;
+
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_VOID:
+      break;
+
+    default:
+      debug(0, "assert with cif->flags: %d\n",cif->flags);
+      FFI_ASSERT(0);
+      break;
+    }
+  return FFI_OK;
+}
+
+/* Fill in a closure to refer to the specified fun and user_data.
+   cif specifies the argument and result types for fun.
+   The cif must already be prep'ed.  */
+
+extern void ffi_closure_pa32(void);
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  /* The layout of a function descriptor.  A function pointer with the PLABEL
+     bit set points to a function descriptor.  */
+  struct pa32_fd
+  {
+    UINT32 code_pointer;
+    UINT32 gp;
+  };
+
+  struct ffi_pa32_trampoline_struct
+  {
+     UINT32 code_pointer;        /* Pointer to ffi_closure_unix.  */
+     UINT32 fake_gp;             /* Pointer to closure, installed as gp.  */
+     UINT32 real_gp;             /* Real gp value.  */
+  };
+
+  struct ffi_pa32_trampoline_struct *tramp;
+  struct pa32_fd *fd;
+
+  if (cif->abi != FFI_PA32)
+    return FFI_BAD_ABI;
+
+  /* Get function descriptor address for ffi_closure_pa32.  */
+  fd = (struct pa32_fd *)((UINT32)ffi_closure_pa32 & ~3);
+
+  /* Setup trampoline.  */
+  tramp = (struct ffi_pa32_trampoline_struct *)closure->tramp;
+  tramp->code_pointer = fd->code_pointer;
+  tramp->fake_gp = (UINT32)codeloc & ~3;
+  tramp->real_gp = fd->gp;
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+#endif
Index: libffi-3.4.6/src/pa/ffi64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/ffi64.c b/libffi-3.4.6/src/pa/ffi64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/ffi64.c	
@@ -0,0 +1,614 @@
+/* -----------------------------------------------------------------------
+   ffi64.c - (c) 2022 John David Anglin <dave.anglin@bell.net>
+           
+   HPPA Foreign Function Interface
+   PA 64-Bit ABI support 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))
+
+#define FIRST_ARG_SLOT  0
+#define DEBUG_LEVEL   0
+
+#define fldw(addr, fpreg) \
+  __asm__ volatile ("fldw 4(%0), %%" #fpreg "R" : : "r"(addr) : #fpreg)
+#define fstw(fpreg, addr) \
+  __asm__ volatile ("fstw %%" #fpreg "R, 4(%0)" : : "r"(addr))
+#define fldd(addr, fpreg) \
+  __asm__ volatile ("fldd 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)
+#define fstd(fpreg, addr) \
+  __asm__ volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))
+
+#define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)
+
+static inline int ffi_struct_type(ffi_type *t)
+{
+  int sz = t->size;
+
+  /* Small structure results are returned in registers 28 and 29,
+     larger ones are in a buffer allocated by the callee.  The
+     address of the buffer is passed in r28.  The buffer is supposed
+     to be aligned on a 16-byte boundary.   Register return values are
+     padded on the right.  The pad bits on the right are undefined.  */
+
+  if (sz <= 16)
+    return -sz;
+  else
+    return FFI_TYPE_STRUCT;
+}
+
+/* PA has a downward growing stack, which looks like this.  Stack
+   arguments are offset from the argument ponter (AP) in r29.
+
+   Offset
+	[ Fixed args ]
+   AP-64                arg word 0 (r26, fr4)
+   AP-56                arg word 1 (r25, fr5)
+   AP-48                arg word 2 (r24, fr6)
+   AP-40                arg word 3 (r23, fr7)
+   AP-32                arg word 4 (r22, fr8)
+   AP-24                arg word 5 (r21, fr9)
+   AP-16                arg word 6 (r20, fr10)
+   AP-8	                arg word 7 (r19, fr11)
+	[ Variable args; AP = SP-16 if there are no variable args ]
+   AP			stack arg 0
+   AP+8			stack arg 1
+   ...
+	[ Frame marker ]
+   SP-16                RP
+   SP-8                 previous SP
+
+   The first eight argument words on the stack are reserved for use by
+   the callee.  Instead, the general and floating registers replace
+   the first four argument slots.  Non FP arguments are passed solely
+   in the general registers.  Single and double FP arguments are passed
+   in both general and floating registers when using libffi.
+
+   The registers are allocated in the same manner as stack slots.
+   This allows the callee to save its arguments on the stack if
+   necessary:
+
+   arg word 0 -> gr26 or fr4L or fr4R
+   arg word 1 -> gr25 or fr5L or fr5R
+   arg word 2 -> gr24 or fr6L or fr6R
+   arg word 3 -> gr23 or fr7L or fr7R
+   ...
+
+   Single Single-precision floating-point parameters, when passed in
+   floating-point registers, are passed in the right halves of the
+   floating point registers; the left halves are unused.
+
+   Quad-precision floating-point parameters within the first 64 bytes of
+   the parameter list are always passed in general registers.
+
+   The rest of the arguments are passed on the stack starting at AP.
+
+   This means we can have holes either in the register allocation,
+   or in the stack.  */
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments
+
+   The following code will put everything into the stack frame
+   (which was allocated by the asm routine), and on return
+   the asm routine will load the arguments that should be
+   passed by register into the appropriate registers
+
+   NOTE: We load floating point args in this function... that means we
+   assume gcc will not mess with fp regs in here.  */
+
+void ffi_prep_args_pa64(UINT64 *stack, extended_cif *ecif, unsigned bytes)
+{
+  register unsigned int i;
+  register ffi_type **p_arg;
+  register void **p_argv;
+  unsigned int slot = FIRST_ARG_SLOT;
+  size_t len;
+
+  debug(1, "%s: stack = %p, ecif = %p, bytes = %u\n", __FUNCTION__, stack,
+	ecif, bytes);
+
+  p_arg = ecif->cif->arg_types;
+  p_argv = ecif->avalue;
+
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      int type = (*p_arg)->type;
+
+      len = (*p_arg)->size;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	  *(SINT64 *)(stack + slot) = *(SINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  *(UINT64 *)(stack + slot) = *(UINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  *(SINT64 *)(stack + slot) = *(SINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  *(UINT64 *)(stack + slot) = *(UINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_SINT32:
+	  *(SINT64 *)(stack + slot) = *(SINT32 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT32:
+	  *(UINT64 *)(stack + slot) = *(UINT32 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_POINTER:
+	  debug(3, "Storing UINT64 %lu in slot %u\n", *(UINT64 *)(*p_argv),
+		slot);
+	  *(UINT64 *)(stack + slot) = *(UINT64 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* First 8 args go in fr4L - fr11L.  */
+	  debug(3, "Storing UINT32(float) in slot %u\n", slot);
+	  *(UINT64 *)(stack + slot) = *(UINT32 *)(*p_argv);
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    /* First 4 args go in fr4L - fr7L.  */
+	    case 0: fldw(stack + slot, fr4); break;
+	    case 1: fldw(stack + slot, fr5); break;
+	    case 2: fldw(stack + slot, fr6); break;
+	    case 3: fldw(stack + slot, fr7); break;
+	    case 4: fldw(stack + slot, fr8); break;
+	    case 5: fldw(stack + slot, fr9); break;
+	    case 6: fldw(stack + slot, fr10); break;
+	    case 7: fldw(stack + slot, fr11); break;
+	    }
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  debug(3, "Storing UINT64(double) at slot %u\n", slot);
+	  *(UINT64 *)(stack + slot) = *(UINT64 *)(*p_argv);
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    /* First 8 args go in fr4 to fr11.  */
+	    case 0: fldd(stack + slot, fr4); break;
+	    case 1: fldd(stack + slot, fr5); break;
+	    case 2: fldd(stack + slot, fr6); break;
+	    case 3: fldd(stack + slot, fr7); break;
+	    case 4: fldd(stack + slot, fr8); break;
+	    case 5: fldd(stack + slot, fr9); break;
+	    case 6: fldd(stack + slot, fr10); break;
+	    case 7: fldd(stack + slot, fr11); break;
+	    }
+	  break;
+
+#ifdef PA64_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  /* Align slot to a 16-byte boundary.  */
+	  slot += (slot & 1);
+	  *(UINT64 *)(stack + slot) = *(UINT64 *)(*p_argv);
+	  *(UINT64 *)(stack + slot + 1) = *(UINT64 *)(*p_argv + 8);
+	  break;
+#endif
+
+	case FFI_TYPE_STRUCT:
+	  /* Structs larger than 8 bytes are aligned on a 16-byte boundary. */
+	  if (len > 8)
+	    slot += (slot & 1);
+	  memcpy((char *)(stack + slot), (char *)*p_argv, len);
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      slot += ROUND_UP (len, 8) >> 3;
+      p_arg++;
+      p_argv++;
+    }
+
+  FFI_ASSERT(slot * 8 <= bytes);
+
+  return;
+}
+
+static void ffi_size_stack_pa64(ffi_cif *cif)
+{
+  ffi_type **ptr;
+  int i;
+  int z = 0; /* # stack slots */
+
+  for (ptr = cif->arg_types, i = 0; i < cif->nargs; ptr++, i++)
+    {
+      int type = (*ptr)->type;
+      int size = (*ptr)->size;
+
+      switch (type)
+	{
+#ifdef PA64_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  z += 2 + (z & 1);
+	  break;
+#endif
+
+	case FFI_TYPE_STRUCT:
+	  if (size > 8)
+	    z += (z & 1);
+	  z += ROUND_UP (size, 8) >> 3;
+	  break;
+
+	default: /* 64-bit values */
+	  z++;
+	}
+    }
+
+  /* We need a minimum of 8 argument slots.  Stack must be 16-byte
+     aligned.  */
+  if (z <= 8)
+    z = 8;
+  else
+    z += (z & 1);
+
+  /* Add 16 bytes for frame marker.  */
+  cif->bytes = z * 8 + 64;
+  debug(3, "Calculated stack size is %u bytes\n", cif->bytes);
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Set the return type flag for jump table.  */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_COMPLEX:
+    case FFI_TYPE_STRUCT:
+      /* For the return type we have to check the size of the structures.
+	 If the size is smaller or equal 8 bytes, the result is given back
+	 in one register. If the size is smaller or equal 16 bytes than we
+	 return the result in two registers. If the size is bigger than
+	 16 bytes, the return is in a buffer allocated by the caller.  */
+      cif->flags = ffi_struct_type(cif->rtype);
+      break;
+
+    default:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+    }
+
+  /* Lucky us, because of the unique PA ABI we get to do our
+     own stack sizing.  */
+  switch (cif->abi)
+    {
+    case FFI_PA64:
+      ffi_size_stack_pa64(cif);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  return FFI_OK;
+}
+
+extern void ffi_call_pa64(void (*)(UINT64 *, extended_cif *, unsigned),
+			  extended_cif *, unsigned, unsigned, unsigned *,
+			  void (*fn)(void));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return
+     value address then we need to make one.  */
+
+  if (rvalue == NULL
+      && (cif->rtype->type == FFI_TYPE_STRUCT
+	  || cif->rtype->type == FFI_TYPE_COMPLEX)
+      && cif->rtype->size > 16)
+    ecif.rvalue = alloca(ROUND_UP (cif->rtype->size, 16));
+  else
+    ecif.rvalue = rvalue;
+
+
+  switch (cif->abi)
+    {
+    case FFI_PA64:
+      debug(3, "Calling ffi_call_pa64: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
+      ffi_call_pa64(ffi_prep_args_pa64, &ecif, cif->bytes,
+		     cif->flags, ecif.rvalue, fn);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#if FFI_CLOSURES
+/* This is more-or-less an inverse of ffi_call -- we have arguments on
+   the stack, and we need to fill them into a cif structure and invoke
+   the user function. This really ought to be in asm to make sure
+   the compiler doesn't do things we don't expect.  */
+ffi_status ffi_closure_inner_pa64(ffi_closure *closure, UINT64 *stack)
+{
+  ffi_cif *cif;
+  void **avalue;
+  void *rvalue;
+  /* Functions can return up to 128-bits in registers.  Return address
+     must be double word aligned.  */
+  union { long double rld; UINT64 ret[2]; } u;
+  ffi_type **p_arg;
+  char *tmp;
+  int i, avn;
+  unsigned int slot = FIRST_ARG_SLOT;
+  register UINT64 r28 asm("r28");
+
+  cif = closure->cif;
+
+  /* If returning via structure, callee will write to our pointer.  */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    rvalue = (void *)r28;
+  else
+    rvalue = &u;
+
+  avalue = (void **)alloca(cif->nargs * FFI_SIZEOF_ARG);
+  avn = cif->nargs;
+  p_arg = cif->arg_types;
+
+  for (i = 0; i < avn; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  avalue[i] = (void *)(stack + slot) + 7;
+	  break;
+
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  avalue[i] = (void *)(stack + slot) + 6;
+	  break;
+
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	  avalue[i] = (void *)(stack + slot) + 4;
+	  break;
+
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  avalue[i] = (void *)(stack + slot);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* The closure call is indirect.  In Linux, floating point
+	     arguments in indirect calls with a prototype are passed
+	     in the floating point registers instead of the general
+	     registers.  So, we need to replace what was previously
+	     stored in the current slot with the value in the
+	     corresponding floating point register.  */
+	  switch (slot + FIRST_ARG_SLOT)
+	    {
+	    case 0: fstw(fr4, (void *)(stack + slot)); break;
+	    case 1: fstw(fr5, (void *)(stack + slot)); break;
+	    case 2: fstw(fr6, (void *)(stack + slot)); break;
+	    case 3: fstw(fr7, (void *)(stack + slot)); break;
+	    case 4: fstw(fr8, (void *)(stack + slot)); break;
+	    case 5: fstw(fr9, (void *)(stack + slot)); break;
+	    case 6: fstw(fr10, (void *)(stack + slot)); break;
+	    case 7: fstw(fr11, (void *)(stack + slot)); break;
+	    }
+	  avalue[i] = (void *)(stack + slot) + 4;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  /* See previous comment for FFI_TYPE_FLOAT.  */
+	  switch (slot + FIRST_ARG_SLOT)
+	    {
+	    case 0: fstd(fr4, (void *)(stack + slot)); break;
+	    case 1: fstd(fr5, (void *)(stack + slot)); break;
+	    case 2: fstd(fr6, (void *)(stack + slot)); break;
+	    case 3: fstd(fr7, (void *)(stack + slot)); break;
+	    case 4: fstd(fr8, (void *)(stack + slot)); break;
+	    case 5: fstd(fr9, (void *)(stack + slot)); break;
+	    case 6: fstd(fr10, (void *)(stack + slot)); break;
+	    case 7: fstd(fr11, (void *)(stack + slot)); break;
+	    }
+	  avalue[i] = (void *)(stack + slot);
+	  break;
+
+#ifdef PA64_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  /* Long doubles are treated like a big structure.  */
+	  slot += (slot & 1);
+	  avalue[i] = (void *)(stack + slot);
+	  break;
+#endif
+
+	case FFI_TYPE_STRUCT:
+	  /* All structs are passed in registers.  Structs larger
+	     than 8 bytes are aligned on a 16-byte boundary.  */
+	  if((*p_arg)->size > 8)
+	    slot += (slot & 1);
+	  avalue[i] = (void *) (stack + slot);
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      slot += (ROUND_UP ((*p_arg)->size, 8) >> 3);
+      p_arg++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  debug(3, "after calling function, ret[0] = %16lx, ret[1] = %16lx\n", u.ret[0],
+	u.ret[1]);
+
+  /* Store the result using the lower 2 bytes of the flags.  */
+  switch (cif->flags)
+    {
+    case FFI_TYPE_UINT8:
+      *(stack + FIRST_ARG_SLOT) = (UINT8)u.ret[0];
+      break;
+    case FFI_TYPE_SINT8:
+      *(stack + FIRST_ARG_SLOT) = (SINT8)u.ret[0];
+      break;
+    case FFI_TYPE_UINT16:
+      *(stack + FIRST_ARG_SLOT) = (UINT16)u.ret[0];
+      break;
+    case FFI_TYPE_SINT16:
+      *(stack + FIRST_ARG_SLOT) = (SINT16)u.ret[0];
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      *(stack + FIRST_ARG_SLOT) = (SINT32)u.ret[0];
+      break;
+    case FFI_TYPE_UINT32:
+      *(stack - FIRST_ARG_SLOT) = (UINT32)u.ret[0];
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_POINTER:
+      *(stack - FIRST_ARG_SLOT) = u.ret[0];
+      break;
+
+    case FFI_TYPE_LONGDOUBLE:
+      *(stack + FIRST_ARG_SLOT) = u.ret[0];
+      *(stack + FIRST_ARG_SLOT + 1) = u.ret[1];
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      fldd(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_FLOAT:
+      /* Adjust for address adjustment in fldw macro.  */
+      fldw(rvalue - 4, fr4);
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* Don't need a return value, done by caller.  */
+      break;
+
+    case -1:
+    case -2:
+    case -3:
+    case -4:
+    case -5:
+    case -6:
+    case -7:
+    case -8:
+    case -9:
+    case -10:
+    case -11:
+    case -12:
+    case -13:
+    case -14:
+    case -15:
+    case -16:
+      tmp = (void*)(stack + FIRST_ARG_SLOT);
+      memcpy((void*)tmp, &u, cif->rtype->size);
+      break;
+
+    case FFI_TYPE_VOID:
+      break;
+
+    default:
+      debug(0, "assert with cif->flags: %d\n",cif->flags);
+      FFI_ASSERT(0);
+      break;
+    }
+  return FFI_OK;
+}
+
+/* Fill in a closure to refer to the specified fun and user_data.
+   cif specifies the argument and result types for fun.
+   The cif must already be prep'ed.  */
+
+extern void ffi_closure_pa64(void);
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  /* The layout of a function descriptor.  */
+  struct pa64_fd
+  {
+    UINT64 tmp1;
+    UINT64 tmp2;
+    UINT64 code_pointer;
+    UINT64 gp;
+  };
+
+  struct ffi_pa64_trampoline_struct
+  {
+    UINT64 real_gp;             /* Real gp value.  */
+    UINT64 tmp2;
+    UINT64 code_pointer;        /* Pointer to ffi_closure_unix.  */
+    UINT64 fake_gp;             /* Pointer to closure, installed as gp.  */
+  };
+
+  struct ffi_pa64_trampoline_struct *tramp;
+  struct pa64_fd *fd;
+
+  if (cif->abi != FFI_PA64)
+    return FFI_BAD_ABI;
+
+  /* Get function descriptor address for ffi_closure_pa64.  */
+  fd = (struct pa64_fd *)((UINT64)ffi_closure_pa64);
+
+  /* Setup trampoline.  */
+  tramp = (struct ffi_pa64_trampoline_struct *)closure->tramp;
+  tramp->code_pointer = fd->code_pointer;
+  tramp->fake_gp = (UINT64)codeloc;
+  tramp->real_gp = fd->gp;
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+#endif
Index: libffi-3.4.6/src/pa/linux.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/linux.S b/libffi-3.4.6/src/pa/linux.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/linux.S	
@@ -0,0 +1,427 @@
+/* -----------------------------------------------------------------------
+   linux.S - (c) 2003-2004 Randolph Chung <tausq@debian.org>
+	     (c) 2008 Red Hat, Inc.
+
+   HPPA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.text
+	.level 1.1
+	.align 4
+
+	/* void ffi_call_pa32(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)(void));
+	 */
+
+	.export ffi_call_pa32,code
+	.import ffi_prep_args_pa32,code
+
+	.type ffi_call_pa32, @function
+.LFB1:
+ffi_call_pa32:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.entry
+	stw %rp, -20(%sp)
+	copy %r3, %r1
+.LCFI11:
+
+	copy %sp, %r3
+.LCFI12:
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 64-bytes register save area               ] <- %r4
+
+	   [ Stack space for actual call, passed as    ] <- %arg0
+	   [     arg0 to ffi_prep_args_pa32           ]
+
+	   [ Stack for calling prep_args               ] <- %sp
+	 */
+
+	stwm %r1, 64(%sp)
+	stw %r4, 12(%r3)
+.LCFI13:
+	copy %sp, %r4
+
+	addl %arg2, %r4, %arg0      /* arg stack */
+	stw %arg3, -48(%r3)         /* save flags; we need it later */
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above
+	   %arg1(ecif) -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl ffi_prep_args_pa32,%r2
+	ldo 64(%arg0), %sp
+	ldo -64(%sp), %sp
+
+	/* now %sp should point where %arg0 was pointing.  */
+
+	/* Load the arguments that should be passed in registers
+	   The fp args were loaded by the prep_args function.  */
+	ldw -36(%sp), %arg0
+	ldw -40(%sp), %arg1
+	ldw -44(%sp), %arg2
+	ldw -48(%sp), %arg3
+
+	/* in case the function is going to return a structure
+	   we need to give it a place to put the result.  */
+	ldw -52(%r3), %ret0                     /* %ret0 <- rvalue */
+	ldw -56(%r3), %r22                      /* %r22 <- function to call */
+	bl $$dyncall, %r31                      /* Call the user function */
+	copy %r31, %rp
+
+	/* Prepare to store the result; we need to recover flags and rvalue.  */
+	ldw -48(%r3), %r21                      /* r21 <- flags */
+
+	/* Adjust flags range from [-8, 15] to  [0, 23].  */
+	addi 8, %r21, %r21
+
+	blr %r21, %r0
+	ldw -52(%r3), %r20                      /* r20 <- rvalue */
+
+	/* Giant jump table */
+	/* 8-byte small struct */
+	b,n	.Lsmst8
+	nop
+	/* 7-byte small struct */
+	b,n	.Lsmst7
+	nop
+	/* 6-byte small struct */
+	b,n	.Lsmst6
+	nop
+	/* 5-byte small struct */
+	b,n	.Lsmst5
+	nop
+	/* 4-byte small struct */
+	b,n	.Lsmst4
+	nop
+	/* 3-byte small struct */
+	b,n	.Lsmst3
+	nop
+	/* 2-byte small struct */
+	b,n	.Lsmst2
+	nop
+	/* 1-byte small struct */
+	b	.Ldone
+	stb	%ret0, 0(%r20)
+	/* void */
+	b,n	.Ldone
+	nop
+	/* int */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* float */
+	b	.Ldone
+	fstw	%fr4L,0(%r20)
+	/* double */
+	b	.Ldone
+	fstd	%fr4,0(%r20)
+	/* long double */
+	b	.Ldone
+	fstd	%fr4,0(%r20)
+	/* unsigned int8 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* sint8 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* unsigned int16 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* sint16 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* unsigned int32 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* sint32 */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* unsigned int64 */
+	b,n	.Luint64
+	nop
+	/* signed int64 */
+	b,n	.Lsint64
+	nop
+	/* large struct */
+	b,n	.Ldone
+	nop
+	/* pointer */
+	b	.Ldone
+	stw	%ret0, 0(%r20)
+	/* complex */
+	b,n	.Ldone
+	nop
+
+	/* Store the result according to the return type.  */
+
+.Luint64:
+.Lsint64:
+	stw	%ret0, 0(%r20)
+	b	.Ldone
+	stw	%ret1, 4(%r20)
+
+.Lsmst2:
+	/* 2-byte structs are returned in ret0 as ????xxyy.  */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret0, 0(%r20)
+
+.Lsmst3:
+	/* 3-byte structs are returned in ret0 as ??xxyyzz.  */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret0, 0(%r20)
+
+.Lsmst4:
+	/* 4-byte structs are returned in ret0 as wwxxyyzz.  */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret0, 0(%r20)
+
+.Lsmst5:
+	/* 5 byte values are returned right justified:
+	      ret0     ret1
+	   5: ??????aa bbccddee */
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret1, 0(%r20)
+
+.Lsmst6:
+	/* 6 byte values are returned right justified:
+	      ret0     ret1
+	   6: ????aabb ccddeeff */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret1, 0(%r20)
+
+.Lsmst7:
+	/* 7 byte values are returned right justified:
+	      ret0     ret1
+	   7: ??aabbcc ddeeffgg */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	.Ldone
+	stb	%ret1, 0(%r20)
+
+.Lsmst8:
+	/* 8 byte values are returned right justified:
+	      ret0     ret1
+	   8: aabbccdd eeffgghh */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stb	%ret1, 0(%r20)
+
+.Ldone:
+	/* all done, return */
+	copy %r4, %sp                           /* pop arg stack */
+	ldw 12(%r3), %r4
+	ldwm -64(%sp), %r3                      /* .. and pop stack */
+	ldw -20(%sp), %rp
+	bv %r0(%rp)
+	nop
+	.exit
+	.procend
+.LFE1:
+
+	/* void ffi_closure_pa32(void);
+	   Called with closure argument in %r19 */
+	.export ffi_closure_pa32,code
+	.import ffi_closure_inner_pa32,code
+
+	.type ffi_closure_pa32, @function
+.LFB2:
+ffi_closure_pa32:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
+	.entry
+
+	stw %rp, -20(%sp)
+.LCFI20:
+	copy %r3, %r1
+.LCFI21:
+	copy %sp, %r3
+.LCFI22:
+	stwm %r1, 64(%sp)
+
+	/* Put arguments onto the stack and call ffi_closure_inner.  */
+	stw %arg0, -36(%r3)
+	stw %arg1, -40(%r3)
+	stw %arg2, -44(%r3)
+	stw %arg3, -48(%r3)
+
+	/* Retrieve closure pointer and real gp.  */
+	copy    %r19, %arg0
+	ldw     8(%r19), %r19
+	bl ffi_closure_inner_pa32, %r2
+	copy %r3, %arg1
+
+	ldwm -64(%sp), %r3
+	ldw -20(%sp), %rp
+	ldw -36(%sp), %ret0
+	bv %r0(%r2)
+	ldw -40(%sp), %ret1
+
+	.exit
+	.procend
+.LFE2:
+
+	.section        ".eh_frame",EH_FRAME_FLAGS,@progbits
+.Lframe1:
+	.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry
+.LSCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x1     ;# CIE Version
+#ifdef __PIC__
+	.ascii  "zR\0"  ;# CIE Augmentation: 'z' - data, 'R' - DW_EH_PE_... data
+#else
+	.ascii "\0"     ;# CIE Augmentation
+#endif
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 4      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+#ifdef __PIC__
+	.uleb128 0x1    ;# Augmentation size
+	.byte	0x1b    ;# FDE Encoding (DW_EH_PE_pcrel|DW_EH_PE_sdata4)
+#endif
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 4
+.LECIE1:
+.LSFDE1:
+	.word   .LEFDE1-.LASFDE1        ;# FDE Length
+.LASFDE1:
+	.word   .LASFDE1-.Lframe1       ;# FDE CIE offset
+#ifdef __PIC__
+	.word	.LFB1-. ;# FDE initial location
+#else
+	.word	.LFB1   ;# FDE initial location
+#endif
+	.word   .LFE1-.LFB1     ;# FDE address range
+#ifdef __PIC__
+	.uleb128 0x0	;# Augmentation size: no data
+#endif
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI11-.LFB1
+	.byte	0x83	;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI12-.LCFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI13-.LCFI12
+	.byte	0x84	;# DW_CFA_offset, column 0x4
+	.uleb128 0x3
+
+	.align 4
+.LEFDE1:
+
+.LSFDE2:
+	.word   .LEFDE2-.LASFDE2        ;# FDE Length
+.LASFDE2:
+	.word   .LASFDE2-.Lframe1       ;# FDE CIE offset
+#ifdef __PIC__
+	.word   .LFB2-. ;# FDE initial location
+#else
+	.word   .LFB2   ;# FDE initial location
+#endif
+	.word   .LFE2-.LFB2     ;# FDE address range
+#ifdef __PIC__
+	.uleb128 0x0	;# Augmentation size: no data
+#endif
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI21-.LFB2
+	.byte   0x83    ;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI22-.LCFI21
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.align 4
+.LEFDE2:
Index: libffi-3.4.6/src/pa/hpux32.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/hpux32.S b/libffi-3.4.6/src/pa/hpux32.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/hpux32.S	
@@ -0,0 +1,417 @@
+/* -----------------------------------------------------------------------
+   hpux32.S - Copyright (c) 2006 Free Software Foundation, Inc.
+	                (c) 2008 Red Hat, Inc.
+   based on src/pa/linux.S
+
+   HP-UX PA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.LEVEL 1.1
+	.SPACE	$PRIVATE$
+	.IMPORT	$global$,DATA
+	.IMPORT	$$dyncall,MILLICODE
+	.SUBSPA	$DATA$
+	.align	4
+
+	/* void ffi_call_pa32(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)(void));
+	 */
+
+	.export	ffi_call_pa32,ENTRY,PRIV_LEV=3
+	.import	ffi_prep_args_pa32,CODE
+
+	.SPACE	$TEXT$
+	.SUBSPA $CODE$
+	.align	4
+
+L$FB1
+ffi_call_pa32
+	.proc
+	.callinfo	FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.entry
+	stw	%rp, -20(%sp)
+	copy	%r3, %r1
+L$CFI11
+	copy	%sp, %r3
+L$CFI12
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 64-bytes register save area               ] <- %r4
+
+	   [ Stack space for actual call, passed as    ] <- %arg0
+	   [     arg0 to ffi_prep_args_pa32           ]
+
+	   [ Stack for calling prep_args               ] <- %sp
+	 */
+
+	stwm	%r1, 64(%sp)
+	stw	%r4, 12(%r3)
+L$CFI13
+	copy	%sp, %r4
+
+	addl	%arg2, %r4, %arg0	; arg stack
+	stw	%arg3, -48(%r3)		; save flags we need it later
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above
+	   %arg1(ecif)  -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl	ffi_prep_args_pa32,%r2
+	ldo	64(%arg0), %sp
+	ldo	-64(%sp), %sp
+
+	/* now %sp should point where %arg0 was pointing.  */
+
+	/* Load the arguments that should be passed in registers
+	   The fp args are loaded by the prep_args function.  */
+	ldw	-36(%sp), %arg0
+	ldw	-40(%sp), %arg1
+	ldw	-44(%sp), %arg2
+	ldw	-48(%sp), %arg3
+
+	/* in case the function is going to return a structure
+	   we need to give it a place to put the result.  */
+	ldw	-52(%r3), %ret0		; %ret0 <- rvalue
+	ldw	-56(%r3), %r22		; %r22 <- function to call
+	bl	$$dyncall, %r31		; Call the user function
+	copy	%r31, %rp
+
+	/* Prepare to store the result; we need to recover flags and rvalue.  */
+	ldw	-48(%r3), %r21		; r21 <- flags
+
+	/* Adjust flags range from [-8, 15] to  [0, 23].  */
+	addi	8, %r21, %r21
+
+	blr	%r21, %r0
+	ldw	-52(%r3), %r20		; r20 <- rvalue
+
+	/* Giant jump table */
+	/* 8-byte small struct */
+	b,n	L$smst8
+	nop
+	/* 7-byte small struct */
+	b,n	L$smst7
+	nop
+	/* 6-byte small struct */
+	b,n	L$smst6
+	nop
+	/* 5-byte small struct */
+	b,n	L$smst5
+	nop
+	/* 4-byte small struct */
+	b,n	L$smst4
+	nop
+	/* 3-byte small struct */
+	b,n	L$smst3
+	nop
+	/* 2-byte small struct */
+	b,n	L$smst2
+	nop
+	/* 1-byte small struct */
+	b	L$done
+	stb	%ret0, 0(%r20)
+	/* void */
+	b,n	L$done
+	nop
+	/* int */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* float */
+	b	L$done
+	fstw	%fr4L,0(%r20)
+	/* double */
+	b	L$done
+	fstd	%fr4,0(%r20)
+	/* long double */
+	b,n	L$done
+	nop
+	/* unsigned int8 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* signed int8 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* unsigned int16 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* signed int16 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* unsigned int32 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* signed int32 */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* unsigned int64 */
+	b,n	L$uint64
+	nop
+	/* signed int64 */
+	b,n	L$sint64
+	nop
+	/* large struct */
+	b,n	L$done
+	nop
+	/* pointer */
+	b	L$done
+	stw	%ret0, 0(%r20)
+	/* complex */
+	b,n	L$done
+	nop
+
+	/* Store the result according to the return type.  The most
+	   likely types should come first.  */
+
+L$uint64
+L$sint64
+	stw	%ret0, 0(%r20)
+	b	L$done
+	stw	%ret1, 4(%r20)
+
+L$smst2
+	/* 2-byte structs are returned in ret0 as ????xxyy.  */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$smst3
+	/* 3-byte structs are returned in ret0 as ??xxyyzz.  */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$smst4
+	/* 4-byte structs are returned in ret0 as wwxxyyzz.  */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$smst5
+	/* 5 byte values are returned right justified:
+	      ret0     ret1
+	   5: ??????aa bbccddee */
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$smst6
+	/* 6 byte values are returned right justified:
+	      ret0     ret1
+	   6: ????aabb ccddeeff */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$smst7
+	/* 7 byte values are returned right justified:
+	      ret0     ret1
+	   7: ??aabbcc ddeeffgg */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$smst8
+	/* 8 byte values are returned right justified:
+	      ret0     ret1
+	   8: aabbccdd eeffgghh */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stb	%ret1, 0(%r20)
+
+L$done
+	/* all done, return */
+	copy	%r4, %sp	; pop arg stack
+	ldw	12(%r3), %r4
+	ldwm	-64(%sp), %r3	; .. and pop stack
+	ldw	-20(%sp), %rp
+	bv	%r0(%rp)
+	nop
+	.exit
+	.procend
+L$FE1
+
+	/* void ffi_closure_pa32(void);
+	   Called with closure argument in %r19 */
+
+	.SPACE $TEXT$
+	.SUBSPA $CODE$
+	.export ffi_closure_pa32,ENTRY,PRIV_LEV=3,RTNVAL=GR
+	.import ffi_closure_inner_pa32,CODE
+	.align 4
+L$FB2
+ffi_closure_pa32
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
+	.entry
+
+	stw	%rp, -20(%sp)
+	copy	%r3, %r1
+L$CFI21
+	copy	%sp, %r3
+L$CFI22
+	stwm	%r1, 64(%sp)
+
+	/* Put arguments onto the stack and call ffi_closure_inner.  */
+	stw	%arg0, -36(%r3)
+	stw	%arg1, -40(%r3)
+	stw	%arg2, -44(%r3)
+	stw	%arg3, -48(%r3)
+
+	/* Retrieve closure pointer and real gp.  */
+	copy	%r19, %arg0
+	ldw	8(%r19), %r19
+	bl	ffi_closure_inner_pa32, %r2
+	copy    %r3, %arg1
+	ldwm	-64(%sp), %r3
+	ldw	-20(%sp), %rp
+	ldw	-36(%sp), %ret0
+	bv	%r0(%rp)
+	ldw	-40(%sp), %ret1
+	.exit
+	.procend
+L$FE2:
+
+	.SPACE $PRIVATE$
+	.SUBSPA $DATA$
+
+	.align 4
+	.EXPORT _GLOBAL__F_ffi_call_pa32,DATA
+_GLOBAL__F_ffi_call_pa32
+L$frame1:
+	.word   L$ECIE1-L$SCIE1 ;# Length of Common Information Entry
+L$SCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x1     ;# CIE Version
+	.ascii "\0"     ;# CIE Augmentation
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 4      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 4
+L$ECIE1:
+L$SFDE1:
+	.word   L$EFDE1-L$ASFDE1        ;# FDE Length
+L$ASFDE1:
+	.word   L$ASFDE1-L$frame1       ;# FDE CIE offset
+	.word   L$FB1   ;# FDE initial location
+	.word   L$FE1-L$FB1     ;# FDE address range
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI11-L$FB1
+	.byte	0x83	;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI12-L$CFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI13-L$CFI12
+	.byte	0x84	;# DW_CFA_offset, column 0x4
+	.uleb128 0x3
+
+	.align 4
+L$EFDE1:
+
+L$SFDE2:
+	.word   L$EFDE2-L$ASFDE2        ;# FDE Length
+L$ASFDE2:
+	.word   L$ASFDE2-L$frame1       ;# FDE CIE offset
+	.word   L$FB2   ;# FDE initial location
+	.word   L$FE2-L$FB2     ;# FDE address range
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI21-L$FB2
+	.byte   0x83    ;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI22-L$CFI21
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.align 4
+L$EFDE2:
Index: libffi-3.4.6/src/pa/hpux64.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/hpux64.S b/libffi-3.4.6/src/pa/hpux64.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/hpux64.S	
@@ -0,0 +1,681 @@
+/* -----------------------------------------------------------------------
+   hpux64.S - (c) 2005-2022 John David Anglin <dave.anglin@bell.net>
+
+   HPUX PA 64-Bit Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.LEVEL 2.0w
+	.text
+	.align	4
+
+	/* void ffi_call_pa64(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)());
+	 */
+
+	.export	ffi_call_pa64,code
+	.import	ffi_prep_args_pa64,code
+
+	.align	4
+
+L$FB1
+ffi_call_pa64
+	.proc
+	.callinfo	FRAME=48,CALLS,SAVE_RP,ENTRY_GR=4
+	.entry
+	std	%rp, -16(%sp)
+	copy	%r3, %r1
+L$CFI11
+	copy	%sp, %r3
+L$CFI12
+	std,ma	%r1, 48(%sp)
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 48-byte register save area                ]
+
+	   [ Stack space for call arguments            ] <- %r4
+
+	   [ 16-byte rame marker                       ]
+
+	   [ 128-byte stack for calling prep_args      ] <- %sp
+	 */
+
+	std	%r4, 8(%r3)		; save r4
+L$CFI13
+	std	%r23, 16(%r3)		; save flags we need it later
+	std	%r22, 24(%r3)		; save rvalue
+	std	%r21, 32(%r3)		; save fn pointer
+
+	copy	%sp, %r4
+	copy	%r4, %r26		; argument stack pointer
+	addl	%r24, %sp, %sp		; allocate argument space
+
+	ldo	112(%sp), %r29		; arg pointer for prep args
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above to point to call arguments
+	   %arg1(ecif) -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl	ffi_prep_args_pa64,%r2
+	ldo	128(%sp), %sp
+	ldo	-128(%sp), %sp
+
+	/* Load the arguments that should be passed in registers
+	   The fp args were loaded by the prep_args function.  */
+	ldd	0(%r4), %r26
+	ldd	8(%r4), %r25
+	ldd	16(%r4), %r24
+	ldd	24(%r4), %r23
+	ldd     32(%r4), %r22
+	ldd     40(%r4), %r21
+	ldd     48(%r4), %r20
+	ldd     56(%r4), %r19
+
+	ldd	24(%r3), %ret0		; %ret0 <- rvalue
+
+	ldd	32(%r3), %r1		; %r1 <- function pointer
+	ldd	16(%r1), %rp		; fn address
+	ldd	24(%r1), %dp		; New gp
+	bve,l	(%rp), %r2		; Call the user function
+	ldo	64(%r4), %r29		; Argument pointer
+
+	/* Prepare to store the result; recover flags and rvalue.  */
+	ldd	16(%r3), %r21		; r21 <- flags
+	extrd,s	%r21, 63, 32, %r21	; sign extend flags for blr
+
+	/* Adjust flags range from [-16, 15] to  [0, 31].  */
+	addi	16, %r21, %r21
+
+	blr	%r21, %r0
+	ldd	24(%r3), %r20		; r20 <- rvalue
+
+	/* Giant jump table */
+	/* 16-byte small struct */
+	b,n	L$smst16
+	nop
+	/* 15-byte small struct */
+	b,n	L$smst15
+	nop
+	/* 14-byte small struct */
+	b,n	L$smst14
+	nop
+	/* 13-byte small struct */
+	b,n	L$smst13
+	nop
+	/* 12-byte small struct */
+	b,n	L$smst12
+	nop
+	/* 11-byte small struct */
+	b,n	L$smst11
+	nop
+	/* 10-byte small struct */
+	b,n	L$smst10
+	nop
+	/* 9-byte small struct */
+	b,n	L$smst9
+	nop
+	/* 8-byte small struct */
+	b,n	L$smst8
+	nop
+	/* 7-byte small struct */
+	b,n	L$smst7
+	nop
+	/* 6-byte small struct */
+	b,n	L$smst6
+	nop
+	/* 5-byte small struct */
+	b,n	L$smst5
+	nop
+	/* 4-byte small struct */
+	b,n	L$smst4
+	nop
+	/* 3-byte small struct */
+	b,n	L$smst3
+	nop
+	/* 2-byte small struct */
+	b,n	L$smst2
+	nop
+	/* 1-byte small struct */
+	b,n	L$smst1
+	nop
+	/* void */
+	b,n	L$done
+	nop
+	/* int */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* float */
+	b	L$done
+	fstw	%fr4R, 0(%r20)
+	/* double */
+	b	L$done
+	fstd	%fr4, 0(%r20)
+	/* long double */
+	b,n	L$longdouble
+	nop
+	/* unsigned int8 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* signed int8 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* unsigned int16 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* signed int16 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* unsigned int32 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* signed int32 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* unsigned int64 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* signed int64 */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* large struct */
+	b,n	L$done
+	nop
+	/* pointer */
+	b	L$done
+	std	%ret0, 0(%r20)
+	/* complex */
+	b,n	L$done
+	nop
+
+L$longdouble
+	std	%ret0, 0(%r20)
+	b	L$done
+	std	%ret1, 8(%r20)
+
+	/* We need to copy byte-by-byte the exact number bytes
+	   in the struct to avoid clobbering other data.  */
+L$smst1
+	extrd,u	%ret0, 7, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst2
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst3
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst4
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst5
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst6
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst7
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst8
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$smst9
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst10
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst11
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst12
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 31, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst13
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 39, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst14
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 47, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst15
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 55, 8, %r22
+	b	L$done
+	stb	%r22, 0(%r20)
+
+L$smst16
+	extrd,u	%ret0, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret0, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb,ma	%ret0, 1(%r20)
+	extrd,u	%ret1, 7, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 15, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 23, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 31, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 39, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 47, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	extrd,u	%ret1, 55, 8, %r22
+	stb,ma	%r22, 1(%r20)
+	stb	%ret1, 0(%r20)
+
+L$done
+	/* all done, restore registers and return */
+	copy	%r4, %sp
+	ldd	8(%r3), %r4
+	ldd	-16(%r3), %rp
+	bve	(%rp)
+	ldd,mb	-48(%sp), %r3
+	.exit
+	.procend
+L$FE1
+	.size	ffi_call_pa64, .-ffi_call_pa64
+
+	/* void ffi_closure_pa64(void);
+	   Called with closure argument in %r21 */
+
+	.export ffi_closure_pa64,code
+	.import ffi_closure_inner_pa64,code
+	.align 4
+L$FB2
+ffi_closure_pa64
+	.proc
+	.callinfo FRAME=128,CALLS,SAVE_RP,ENTRY_GR=3
+	.entry
+
+	std	%rp, -16(%sp)
+	copy	%r3, %r1
+L$CFI21
+	copy	%sp, %r3
+L$CFI22
+	std,ma	%r1, 128(%sp)
+L$CFI23
+
+	/* Put arguments onto the stack and call ffi_closure_inner.  */
+	std	%r26, -64(%r29)
+	std	%r25, -56(%r29)
+	std	%r24, -48(%r29)
+	std	%r23, -40(%r29)
+	std	%r22, -32(%r29)
+	std	%r21, -24(%r29)
+	std	%r20, -16(%r29)
+	std	%r19, -8(%r29)
+
+	/* Load and save start of argument stack.  */
+	ldo	-64(%r29), %r25
+	std	%r25, 8(%r3)
+
+	/* Setup arg pointer.  */
+	ldo	-16(%sp), %ret1
+
+	/* Retrieve closure pointer and real gp.  */
+	copy	%dp, %r26
+	bl	ffi_closure_inner_pa64, %r2
+	ldd	0(%dp), %dp
+
+	/* Retrieve start of argument stack.  */
+	ldd	8(%r3), %r1
+
+	/* Restore r3 and op stack.  */
+	ldd,mb	-128(%sp), %r3
+
+	/* Load return address.  */
+	ldd	-16(%sp), %rp
+
+	/* Load return values from first and second stack slots.  */
+	ldd	0(%r1), %ret0
+	bve	(%rp)
+	ldd	8(%r1), %ret1
+
+	.exit
+	.procend
+	.end
+L$FE2:
+	.size	ffi_closure_pa64, .-ffi_closure_pa64
+
+	.section	.eh_frame,"aw",@progbits
+L$frame1:
+	.word   L$ECIE1-L$SCIE1 ;# Length of Common Information Entry
+L$SCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x3     ;# CIE Version
+	.stringz ""     ;# CIE Augmentation
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 8      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 8
+L$ECIE1:
+L$SFDE1:
+	.word   L$EFDE1-L$ASFDE1        ;# FDE Length
+L$ASFDE1:
+	.word   L$ASFDE1-L$frame1       ;# FDE CIE offset
+	.dword  L$FB1	;# FDE initial location
+	.dword  L$FE1-L$FB1	;# FDE address range
+
+	.byte   0x4	;# DW_CFA_advance_loc4
+	.word   L$CFI11-L$FB1
+	.byte	0x9	;# DW_CFA_register: r3 in r1
+	.uleb128 0x3
+	.uleb128 0x1
+	.byte   0x11    ;# DW_CFA_offset_extended_sf: r2 at cfa-16
+	.uleb128 0x2
+	.sleb128 -2
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI12-L$CFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register: r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI13-L$CFI12
+	.byte	0x83	;# DW_CFA_offset: r3 at cfa+0
+	.uleb128 0
+	.byte	0x84	;# DW_CFA_offset: r4 at cfa+8
+	.uleb128 1
+
+	.align 8
+L$EFDE1:
+
+L$SFDE2:
+	.word   L$EFDE2-L$ASFDE2        ;# FDE Length
+L$ASFDE2:
+	.word   L$ASFDE2-L$frame1       ;# FDE CIE offset
+	.dword   L$FB2	;# FDE initial location
+	.dword   L$FE2-L$FB2     ;# FDE address range
+	.byte   0x4	;# DW_CFA_advance_loc4
+	.word   L$CFI21-L$FB2
+	.byte   0x9	;# DW_CFA_register: r3 in r1
+	.uleb128 0x3
+	.uleb128 0x1
+	.byte   0x11    ;# DW_CFA_offset_extended_sf: r2 at cfa-16
+	.uleb128 0x2
+	.sleb128 -2
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI22-L$CFI21
+	.byte   0xd     ;# DW_CFA_def_cfa_register: r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI23-L$CFI22
+	.byte	0x83	;# DW_CFA_offset: r3 at cfa+0
+	.uleb128 0
+
+	.align 8
+L$EFDE2:
Index: libffi-3.4.6/src/pa/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/pa/ffitarget.h b/libffi-3.4.6/src/pa/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/pa/ffitarget.h	
@@ -0,0 +1,94 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for hppa.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+
+#ifdef PA_LINUX
+  FFI_PA32,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_PA32
+#endif
+
+#ifdef PA_HPUX
+  FFI_PA32,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_PA32
+#endif
+
+#ifdef PA64_HPUX
+  FFI_PA64,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_PA64
+#endif
+} ffi_abi;
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+#if defined(PA64_HPUX)
+#define FFI_TRAMPOLINE_SIZE 32
+#else
+#define FFI_TRAMPOLINE_SIZE 12
+#endif
+
+#define FFI_TYPE_SMALL_STRUCT1 -1
+#define FFI_TYPE_SMALL_STRUCT2 -2
+#define FFI_TYPE_SMALL_STRUCT3 -3
+#define FFI_TYPE_SMALL_STRUCT4 -4
+#define FFI_TYPE_SMALL_STRUCT5 -5
+#define FFI_TYPE_SMALL_STRUCT6 -6
+#define FFI_TYPE_SMALL_STRUCT7 -7
+#define FFI_TYPE_SMALL_STRUCT8 -8
+
+/* linux.S and hpux32.S expect FFI_TYPE_COMPLEX is the last generic type.  */
+#define FFI_PA_TYPE_LAST FFI_TYPE_COMPLEX
+
+/* If new generic types are added, the jump tables in linux.S and hpux32.S
+   likely need updating.  */
+#if FFI_TYPE_LAST != FFI_PA_TYPE_LAST
+# error "You likely have broken jump tables"
+#endif
+
+#endif
Index: libffi-3.4.6/src/sh/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh/ffi.c b/libffi-3.4.6/src/sh/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh/ffi.c	
@@ -0,0 +1,717 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2002-2008, 2012 Kaz Kojima
+           Copyright (c) 2008 Red Hat, Inc.
+   
+   SuperH Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+#define NGREGARG 4
+#if defined(__SH4__)
+#define NFREGARG 8
+#endif
+
+#if defined(__HITACHI__)
+#define STRUCT_VALUE_ADDRESS_WITH_ARG 1
+#else
+#define STRUCT_VALUE_ADDRESS_WITH_ARG 0
+#endif
+
+/* If the structure has essentially an unique element, return its type.  */
+static int
+simple_type (ffi_type *arg)
+{
+  if (arg->type != FFI_TYPE_STRUCT)
+    return arg->type;
+  else if (arg->elements[1])
+    return FFI_TYPE_STRUCT;
+
+  return simple_type (arg->elements[0]);
+}
+
+static int
+return_type (ffi_type *arg)
+{
+  unsigned short type;
+
+  if (arg->type != FFI_TYPE_STRUCT)
+    return arg->type;
+
+  type = simple_type (arg->elements[0]);
+  if (! arg->elements[1])
+    {
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	  return FFI_TYPE_INT;
+
+	default:
+	  return type;
+	}
+    }
+
+  /* gcc uses r0/r1 pair for some kind of structures.  */
+  if (arg->size <= 2 * sizeof (int))
+    {
+      int i = 0;
+      ffi_type *e;
+
+      while ((e = arg->elements[i++]))
+	{
+	  type = simple_type (e);
+	  switch (type)
+	    {
+	    case FFI_TYPE_SINT32:
+	    case FFI_TYPE_UINT32:
+	    case FFI_TYPE_INT:
+	    case FFI_TYPE_FLOAT:
+	      return FFI_TYPE_UINT64;
+
+	    default:
+	      break;
+	    }
+	}
+    }
+
+  return FFI_TYPE_STRUCT;
+}
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  register unsigned int i;
+  register int tmp;
+  register unsigned int avn;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+  int greg, ireg;
+#if defined(__SH4__)
+  int freg = 0;
+#endif
+
+  tmp = 0;
+  argp = stack;
+
+  if (return_type (ecif->cif->rtype) == FFI_TYPE_STRUCT)
+    {
+      *(void **) argp = ecif->rvalue;
+      argp += 4;
+      ireg = STRUCT_VALUE_ADDRESS_WITH_ARG ? 1 : 0;
+    }
+  else
+    ireg = 0;
+
+  /* Set arguments for registers.  */
+  greg = ireg;
+  avn = ecif->cif->nargs;
+  p_argv = ecif->avalue;
+
+  for (i = 0, p_arg = ecif->cif->arg_types; i < avn; i++, p_arg++, p_argv++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      if (z < sizeof(int))
+	{
+	  if (greg++ >= NGREGARG)
+	    continue;
+
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_STRUCT:
+	      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	  argp += z;
+	}
+      else if (z == sizeof(int))
+	{
+#if defined(__SH4__)
+	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	    {
+	      if (freg++ >= NFREGARG)
+		continue;
+	    }
+	  else
+#endif
+	    {
+	      if (greg++ >= NGREGARG)
+		continue;
+	    }
+	  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	  argp += z;
+	}
+#if defined(__SH4__)
+      else if ((*p_arg)->type == FFI_TYPE_DOUBLE)
+	{
+	  if (freg + 1 >= NFREGARG)
+	    continue;
+	  freg = (freg + 1) & ~1;
+	  freg += 2;
+	  memcpy (argp, *p_argv, z);
+	  argp += z;
+	}
+#endif
+      else
+	{
+	  int n = (z + sizeof (int) - 1) / sizeof (int);
+#if defined(__SH4__)
+	  if (greg + n - 1 >= NGREGARG)
+	    continue;
+#else
+	  if (greg >= NGREGARG)
+	    continue;
+#endif
+	  greg += n;
+	  memcpy (argp, *p_argv, z);
+	  argp += n * sizeof (int);
+	}
+    }
+
+  /* Set arguments on stack.  */
+  greg = ireg;
+#if defined(__SH4__)
+  freg = 0;
+#endif
+  p_argv = ecif->avalue;
+
+  for (i = 0, p_arg = ecif->cif->arg_types; i < avn; i++, p_arg++, p_argv++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      if (z < sizeof(int))
+	{
+	  if (greg++ < NGREGARG)
+	    continue;
+
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+	      break;
+  
+	    case FFI_TYPE_STRUCT:
+	      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	  argp += z;
+	}
+      else if (z == sizeof(int))
+	{
+#if defined(__SH4__)
+	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	    {
+	      if (freg++ < NFREGARG)
+		continue;
+	    }
+	  else
+#endif
+	    {
+	      if (greg++ < NGREGARG)
+		continue;
+	    }
+	  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	  argp += z;
+	}
+#if defined(__SH4__)
+      else if ((*p_arg)->type == FFI_TYPE_DOUBLE)
+	{
+	  if (freg + 1 < NFREGARG)
+	    {
+	      freg = (freg + 1) & ~1;
+	      freg += 2;
+	      continue;
+	    }
+	  memcpy (argp, *p_argv, z);
+	  argp += z;
+	}
+#endif
+      else
+	{
+	  int n = (z + sizeof (int) - 1) / sizeof (int);
+	  if (greg + n - 1 < NGREGARG)
+	    {
+	      greg += n;
+	      continue;
+	    }
+#if (! defined(__SH4__))
+	  else if (greg < NGREGARG)
+	    {
+	      greg = NGREGARG;
+	      continue;
+	    }
+#endif
+	  memcpy (argp, *p_argv, z);
+	  argp += n * sizeof (int);
+	}
+    }
+
+  return;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  int i, j;
+  int size, type;
+  int n, m;
+  int greg;
+#if defined(__SH4__)
+  int freg = 0;
+#endif
+
+  cif->flags = 0;
+
+  greg = ((return_type (cif->rtype) == FFI_TYPE_STRUCT) &&
+	  STRUCT_VALUE_ADDRESS_WITH_ARG) ? 1 : 0;
+
+#if defined(__SH4__)
+  for (i = j = 0; i < cif->nargs && j < 12; i++)
+    {
+      type = (cif->arg_types)[i]->type;
+      switch (type)
+	{
+	case FFI_TYPE_FLOAT:
+	  if (freg >= NFREGARG)
+	    continue;
+	  freg++;
+	  cif->flags += ((cif->arg_types)[i]->type) << (2 * j);
+	  j++;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if ((freg + 1) >= NFREGARG)
+	    continue;
+	  freg = (freg + 1) & ~1;
+	  freg += 2;
+	  cif->flags += ((cif->arg_types)[i]->type) << (2 * j);
+	  j++;
+	  break;
+	      
+	default:
+	  size = (cif->arg_types)[i]->size;
+	  n = (size + sizeof (int) - 1) / sizeof (int);
+	  if (greg + n - 1 >= NGREGARG)
+		continue;
+	  greg += n;
+	  for (m = 0; m < n; m++)
+	    cif->flags += FFI_TYPE_INT << (2 * j++);
+	  break;
+	}
+    }
+#else
+  for (i = j = 0; i < cif->nargs && j < 4; i++)
+    {
+      size = (cif->arg_types)[i]->size;
+      n = (size + sizeof (int) - 1) / sizeof (int);
+      if (greg >= NGREGARG)
+	continue;
+      else if (greg + n - 1 >= NGREGARG)
+	n = NGREGARG - greg;
+      greg += n;
+      for (m = 0; m < n; m++)
+        cif->flags += FFI_TYPE_INT << (2 * j++);
+    }
+#endif
+
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_STRUCT:
+      cif->flags += (unsigned) (return_type (cif->rtype)) << 24;
+      break;
+
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags += (unsigned) cif->rtype->type << 24;
+      break;
+
+    default:
+      cif->flags += FFI_TYPE_INT << 24;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)(void));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+  UINT64 trvalue;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)
+    ecif.rvalue = &trvalue;
+  else if ((rvalue == NULL) && 
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi) 
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+		    fn);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  if (rvalue
+      && cif->rtype->type == FFI_TYPE_STRUCT
+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)
+    memcpy (rvalue, &trvalue, cif->rtype->size);
+}
+
+extern void ffi_closure_SYSV (void);
+#if defined(__SH4__)
+extern void __ic_invalidate (void *line);
+#endif
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp;
+  unsigned int insn;
+
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  tramp = (unsigned int *) &closure->tramp[0];
+  /* Set T bit if the function returns a struct pointed with R2.  */
+  insn = (return_type (cif->rtype) == FFI_TYPE_STRUCT
+	  ? 0x0018 /* sett */
+	  : 0x0008 /* clrt */);
+
+#ifdef __LITTLE_ENDIAN__
+  tramp[0] = 0xd301d102;
+  tramp[1] = 0x0000412b | (insn << 16);
+#else
+  tramp[0] = 0xd102d301;
+  tramp[1] = 0x412b0000 | insn;
+#endif
+  *(void **) &tramp[2] = (void *)codeloc;          /* ctx */
+  *(void **) &tramp[3] = (void *)ffi_closure_SYSV; /* funaddr */
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+#if defined(__SH4__)
+  /* Flush the icache.  */
+  __ic_invalidate(codeloc);
+#endif
+
+  return FFI_OK;
+}
+
+/* Basically the trampoline invokes ffi_closure_SYSV, and on 
+ * entry, r3 holds the address of the closure.
+ * After storing the registers that could possibly contain
+ * parameters to be passed into the stack frame and setting
+ * up space for a return value, ffi_closure_SYSV invokes the 
+ * following helper function to do most of the work.
+ */
+
+#ifdef __LITTLE_ENDIAN__
+#define OFS_INT8	0
+#define OFS_INT16	0
+#else
+#define OFS_INT8	3
+#define OFS_INT16	2
+#endif
+
+int
+ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue, 
+			 unsigned long *pgr, unsigned long *pfr, 
+			 unsigned long *pst)
+{
+  void **avalue;
+  ffi_type **p_arg;
+  int i, avn;
+  int ireg, greg = 0;
+#if defined(__SH4__)
+  int freg = 0;
+#endif
+  ffi_cif *cif; 
+
+  cif = closure->cif;
+  avalue = alloca(cif->nargs * sizeof(void *));
+
+  /* Copy the caller's structure return value address so that the closure
+     returns the data directly to the caller.  */
+  if (cif->rtype->type == FFI_TYPE_STRUCT && STRUCT_VALUE_ADDRESS_WITH_ARG)
+    {
+      rvalue = (void *) *pgr++;
+      ireg = 1;
+    }
+  else
+    ireg = 0;
+
+  cif = closure->cif;
+  greg = ireg;
+  avn = cif->nargs;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      if (z < sizeof(int))
+	{
+	  if (greg++ >= NGREGARG)
+	    continue;
+
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	    case FFI_TYPE_UINT8:
+	      avalue[i] = (((char *)pgr) + OFS_INT8);
+	      break;
+  
+	    case FFI_TYPE_SINT16:
+	    case FFI_TYPE_UINT16:
+	      avalue[i] = (((char *)pgr) + OFS_INT16);
+	      break;
+  
+	    case FFI_TYPE_STRUCT:
+	      avalue[i] = pgr;
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	  pgr++;
+	}
+      else if (z == sizeof(int))
+	{
+#if defined(__SH4__)
+	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	    {
+	      if (freg++ >= NFREGARG)
+		continue;
+	      avalue[i] = pfr;
+	      pfr++;
+	    }
+	  else
+#endif
+	    {
+	      if (greg++ >= NGREGARG)
+		continue;
+	      avalue[i] = pgr;
+	      pgr++;
+	    }
+	}
+#if defined(__SH4__)
+      else if ((*p_arg)->type == FFI_TYPE_DOUBLE)
+	{
+	  if (freg + 1 >= NFREGARG)
+	    continue;
+	  if (freg & 1)
+	    pfr++;
+	  freg = (freg + 1) & ~1;
+	  freg += 2;
+	  avalue[i] = pfr;
+	  pfr += 2;
+	}
+#endif
+      else
+	{
+	  int n = (z + sizeof (int) - 1) / sizeof (int);
+#if defined(__SH4__)
+	  if (greg + n - 1 >= NGREGARG)
+	    continue;
+#else
+	  if (greg >= NGREGARG)
+	    continue;
+#endif
+	  greg += n;
+	  avalue[i] = pgr;
+	  pgr += n;
+	}
+    }
+
+  greg = ireg;
+#if defined(__SH4__)
+  freg = 0;
+#endif
+
+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      if (z < sizeof(int))
+	{
+	  if (greg++ < NGREGARG)
+	    continue;
+
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	    case FFI_TYPE_UINT8:
+	      avalue[i] = (((char *)pst) + OFS_INT8);
+	      break;
+  
+	    case FFI_TYPE_SINT16:
+	    case FFI_TYPE_UINT16:
+	      avalue[i] = (((char *)pst) + OFS_INT16);
+	      break;
+  
+	    case FFI_TYPE_STRUCT:
+	      avalue[i] = pst;
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	  pst++;
+	}
+      else if (z == sizeof(int))
+	{
+#if defined(__SH4__)
+	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	    {
+	      if (freg++ < NFREGARG)
+		continue;
+	    }
+	  else
+#endif
+	    {
+	      if (greg++ < NGREGARG)
+		continue;
+	    }
+	  avalue[i] = pst;
+	  pst++;
+	}
+#if defined(__SH4__)
+      else if ((*p_arg)->type == FFI_TYPE_DOUBLE)
+	{
+	  if (freg + 1 < NFREGARG)
+	    {
+	      freg = (freg + 1) & ~1;
+	      freg += 2;
+	      continue;
+	    }
+	  avalue[i] = pst;
+	  pst += 2;
+	}
+#endif
+      else
+	{
+	  int n = (z + sizeof (int) - 1) / sizeof (int);
+	  if (greg + n - 1 < NGREGARG)
+	    {
+	      greg += n;
+	      continue;
+	    }
+#if (! defined(__SH4__))
+	  else if (greg < NGREGARG)
+	    {
+	      greg += n;
+	      pst += greg - NGREGARG;
+	      continue;
+	    }
+#endif
+	  avalue[i] = pst;
+	  pst += n;
+	}
+    }
+
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  /* Tell ffi_closure_SYSV how to perform return type promotions.  */
+  return return_type (cif->rtype);
+}
Index: libffi-3.4.6/src/sh/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh/sysv.S b/libffi-3.4.6/src/sh/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh/sysv.S	
@@ -0,0 +1,850 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2002, 2003, 2004, 2006, 2008 Kaz Kojima
+   
+   SuperH Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+/* XXX these lose for some platforms, I'm sure. */
+#define CNAME(x) x
+#define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):
+#endif
+
+#if defined(__HITACHI__)
+#define STRUCT_VALUE_ADDRESS_WITH_ARG 1
+#else
+#define STRUCT_VALUE_ADDRESS_WITH_ARG 0
+#endif
+
+.text
+
+	# r4:	ffi_prep_args
+	# r5:	&ecif
+	# r6:	bytes
+	# r7:	flags
+	# sp+0: rvalue
+	# sp+4: fn
+
+	# This assumes we are using gas.
+ENTRY(ffi_call_SYSV)
+	# Save registers
+.LFB1:
+	mov.l	r8,@-r15
+.LCFI0:
+	mov.l	r9,@-r15
+.LCFI1:
+	mov.l	r10,@-r15
+.LCFI2:
+	mov.l	r12,@-r15
+.LCFI3:
+	mov.l	r14,@-r15
+.LCFI4:
+	sts.l	pr,@-r15
+.LCFI5:
+	mov	r15,r14
+.LCFI6:
+#if defined(__SH4__)
+	mov	r6,r8
+	mov	r7,r9
+
+	sub	r6,r15
+	add	#-16,r15
+	mov	#~7,r0
+	and	r0,r15
+
+	mov	r4,r0
+	jsr	@r0
+	 mov	r15,r4
+
+	mov	r9,r1
+	shlr8	r9
+	shlr8	r9
+	shlr8	r9
+
+	mov	#FFI_TYPE_STRUCT,r2
+	cmp/eq	r2,r9
+	bf	1f
+#if STRUCT_VALUE_ADDRESS_WITH_ARG
+ 	mov.l	@r15+,r4
+	bra	2f
+	 mov	#5,r2
+#else
+ 	mov.l	@r15+,r10
+#endif
+1:
+	mov	#4,r2
+2:
+	mov	#4,r3
+
+L_pass:
+	cmp/pl	r8
+	bf	L_call_it
+
+	mov	r1,r0
+	and	#3,r0
+
+L_pass_d:
+	cmp/eq	#FFI_TYPE_DOUBLE,r0
+	bf	L_pass_f
+
+	mov	r3,r0
+	and	#1,r0
+	tst	r0,r0
+	bt	1f
+	add	#1,r3
+1:
+	mov	#12,r0
+	cmp/hs	r0,r3
+	bt/s	3f
+	 shlr2	r1
+	bsr	L_pop_d
+	 nop
+3:
+	add	#2,r3
+	bra	L_pass
+	 add	#-8,r8
+
+L_pop_d:
+	mov	r3,r0
+	add	r0,r0
+	add	r3,r0
+	add	#-12,r0
+	braf	r0
+	 nop
+#ifdef __LITTLE_ENDIAN__
+	fmov.s	@r15+,fr5
+	rts
+	 fmov.s	@r15+,fr4
+	fmov.s	@r15+,fr7
+	rts
+	 fmov.s	@r15+,fr6
+	fmov.s	@r15+,fr9
+	rts
+	 fmov.s	@r15+,fr8
+	fmov.s	@r15+,fr11
+	rts
+	 fmov.s	@r15+,fr10
+#else
+	fmov.s	@r15+,fr4
+	rts
+	 fmov.s	@r15+,fr5
+	fmov.s	@r15+,fr6
+	rts
+	 fmov.s	@r15+,fr7
+	fmov.s	@r15+,fr8
+	rts
+	 fmov.s	@r15+,fr9
+	fmov.s	@r15+,fr10
+	rts
+	 fmov.s	@r15+,fr11
+#endif
+
+L_pass_f:
+	cmp/eq	#FFI_TYPE_FLOAT,r0
+	bf	L_pass_i
+
+	mov	#12,r0
+	cmp/hs	r0,r3
+	bt/s	2f
+	 shlr2	r1
+	bsr	L_pop_f
+	 nop
+2:
+	add	#1,r3
+	bra	L_pass
+	 add	#-4,r8
+
+L_pop_f:
+	mov	r3,r0
+	shll2	r0
+	add	#-16,r0
+	braf	r0
+	 nop
+#ifdef __LITTLE_ENDIAN__
+	rts
+	 fmov.s	@r15+,fr5
+	rts
+	 fmov.s	@r15+,fr4
+	rts
+	 fmov.s	@r15+,fr7
+	rts
+	 fmov.s	@r15+,fr6
+	rts
+	 fmov.s	@r15+,fr9
+	rts
+	 fmov.s	@r15+,fr8
+	rts
+	 fmov.s	@r15+,fr11
+	rts
+	 fmov.s	@r15+,fr10
+#else
+	rts
+	 fmov.s	@r15+,fr4
+	rts
+	 fmov.s	@r15+,fr5
+	rts
+	 fmov.s	@r15+,fr6
+	rts
+	 fmov.s	@r15+,fr7
+	rts
+	 fmov.s	@r15+,fr8
+	rts
+	 fmov.s	@r15+,fr9
+	rts
+	 fmov.s	@r15+,fr10
+	rts
+	 fmov.s	@r15+,fr11
+#endif
+
+L_pass_i:
+	cmp/eq	#FFI_TYPE_INT,r0
+	bf	L_call_it
+
+	mov	#8,r0
+	cmp/hs	r0,r2
+	bt/s	2f
+	 shlr2	r1
+	bsr	L_pop_i
+	 nop
+2:
+	add	#1,r2
+	bra	L_pass
+	 add	#-4,r8
+
+L_pop_i:
+	mov	r2,r0
+	shll2	r0
+	add	#-16,r0
+	braf	r0
+	 nop
+	rts
+	 mov.l	@r15+,r4
+	rts
+	 mov.l	@r15+,r5
+	rts
+	 mov.l	@r15+,r6
+	rts
+	 mov.l	@r15+,r7
+
+L_call_it:
+	# call function
+#if (! STRUCT_VALUE_ADDRESS_WITH_ARG)
+	mov	r10, r2
+#endif
+	mov.l  @(28,r14),r1
+	jsr    @r1
+	 nop
+
+L_ret_d:
+	mov	#FFI_TYPE_DOUBLE,r2
+	cmp/eq	r2,r9
+	bf	L_ret_ll
+
+	mov.l	@(24,r14),r1
+#ifdef __LITTLE_ENDIAN__
+	fmov.s	fr1,@r1
+	add	#4,r1
+	bra	L_epilogue
+	 fmov.s	fr0,@r1
+#else
+	fmov.s	fr0,@r1
+	add	#4,r1
+	bra	L_epilogue
+	 fmov.s	fr1,@r1
+#endif
+
+L_ret_ll:
+	mov	#FFI_TYPE_SINT64,r2
+	cmp/eq	r2,r9
+	bt/s	1f
+	 mov	#FFI_TYPE_UINT64,r2
+	cmp/eq	r2,r9
+	bf	L_ret_f
+
+1:
+	mov.l	@(24,r14),r2
+	mov.l	r0,@r2
+	bra	L_epilogue
+	 mov.l	r1,@(4,r2)
+
+L_ret_f:
+	mov	#FFI_TYPE_FLOAT,r2
+	cmp/eq	r2,r9
+	bf	L_ret_i
+
+	mov.l	@(24,r14),r1
+	bra	L_epilogue
+	 fmov.s	fr0,@r1
+
+L_ret_i:
+	mov	#FFI_TYPE_INT,r2
+	cmp/eq	r2,r9
+	bf	L_epilogue
+
+	mov.l	@(24,r14),r1
+	bra	L_epilogue
+	 mov.l	r0,@r1
+
+L_epilogue:
+	# Remove the space we pushed for the args
+	mov   r14,r15
+
+	lds.l  @r15+,pr
+	mov.l  @r15+,r14
+	mov.l  @r15+,r12
+	mov.l  @r15+,r10
+	mov.l  @r15+,r9
+	rts
+	 mov.l  @r15+,r8
+#else
+	mov	r6,r8
+	mov	r7,r9
+
+	sub	r6,r15
+	add	#-16,r15
+	mov	#~7,r0
+	and	r0,r15
+
+	mov	r4,r0
+	jsr	@r0
+	 mov	r15,r4
+
+	mov	r9,r3
+	shlr8	r9
+	shlr8	r9
+	shlr8	r9
+
+	mov	#FFI_TYPE_STRUCT,r2
+	cmp/eq	r2,r9
+	bf	1f
+#if STRUCT_VALUE_ADDRESS_WITH_ARG
+	mov.l	@r15+,r4
+	bra	2f
+	 mov	#5,r2
+#else
+	mov.l	@r15+,r10
+#endif
+1:
+	mov	#4,r2
+2:
+
+L_pass:
+	cmp/pl	r8
+	bf	L_call_it
+
+	mov	r3,r0
+	and	#3,r0
+
+L_pass_d:
+	cmp/eq	#FFI_TYPE_DOUBLE,r0
+	bf	L_pass_i
+
+	mov	r15,r0
+	and	#7,r0
+	tst	r0,r0
+	bt	1f
+	add	#4,r15
+1:
+	mov	#8,r0
+	cmp/hs	r0,r2
+	bt/s	2f
+	 shlr2	r3
+	bsr	L_pop_d
+	 nop
+2:
+	add	#2,r2
+	bra	L_pass
+	 add	#-8,r8
+
+L_pop_d:
+	mov	r2,r0
+	add	r0,r0
+	add	r2,r0
+	add	#-12,r0
+	add	r0,r0
+	braf	r0
+	 nop
+	mov.l	@r15+,r4
+	rts
+	 mov.l	@r15+,r5
+	mov.l	@r15+,r5
+	rts
+	 mov.l	@r15+,r6
+	mov.l	@r15+,r6
+	rts
+	 mov.l	@r15+,r7
+	rts
+	 mov.l	@r15+,r7
+
+L_pass_i:
+	cmp/eq	#FFI_TYPE_INT,r0
+	bf	L_call_it
+
+	mov	#8,r0
+	cmp/hs	r0,r2
+	bt/s	2f
+	 shlr2	r3
+	bsr	L_pop_i
+	 nop
+2:
+	add	#1,r2
+	bra	L_pass
+	 add	#-4,r8
+
+L_pop_i:
+	mov	r2,r0
+	shll2	r0
+	add	#-16,r0
+	braf	r0
+	 nop
+	rts
+	 mov.l	@r15+,r4
+	rts
+	 mov.l	@r15+,r5
+	rts
+	 mov.l	@r15+,r6
+	rts
+	 mov.l	@r15+,r7
+
+L_call_it:
+	# call function
+#if (! STRUCT_VALUE_ADDRESS_WITH_ARG)
+	mov	r10, r2
+#endif
+	mov.l  @(28,r14),r1
+	jsr    @r1
+	 nop
+
+L_ret_d:
+	mov	#FFI_TYPE_DOUBLE,r2
+	cmp/eq	r2,r9
+	bf	L_ret_ll
+
+	mov.l	@(24,r14),r2
+	mov.l	r0,@r2
+	bra	L_epilogue
+	 mov.l	r1,@(4,r2)
+
+L_ret_ll:
+	mov	#FFI_TYPE_SINT64,r2
+	cmp/eq	r2,r9
+	bt/s	1f
+	 mov	#FFI_TYPE_UINT64,r2
+	cmp/eq	r2,r9
+	bf	L_ret_i
+
+1:
+	mov.l	@(24,r14),r2
+	mov.l	r0,@r2
+	bra	L_epilogue
+	 mov.l	r1,@(4,r2)
+
+L_ret_i:
+	mov	#FFI_TYPE_FLOAT,r2
+	cmp/eq	r2,r9
+	bt	1f
+	mov	#FFI_TYPE_INT,r2
+	cmp/eq	r2,r9
+	bf	L_epilogue
+1:
+	mov.l	@(24,r14),r1
+	bra	L_epilogue
+	 mov.l	r0,@r1
+
+L_epilogue:
+	# Remove the space we pushed for the args
+	mov   r14,r15
+
+	lds.l  @r15+,pr
+	mov.l  @r15+,r14
+	mov.l  @r15+,r12
+	mov.l  @r15+,r10
+	mov.l  @r15+,r9
+	rts
+	 mov.l  @r15+,r8
+#endif
+.LFE1:
+.ffi_call_SYSV_end:
+        .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
+
+.globl	ffi_closure_helper_SYSV
+
+ENTRY(ffi_closure_SYSV)
+.LFB2:
+	mov.l	r7,@-r15
+.LCFI7:
+	mov.l	r6,@-r15
+.LCFI8:
+	mov.l	r5,@-r15
+.LCFI9:
+	mov.l	r4,@-r15
+.LCFIA:
+	mov.l	r14,@-r15
+.LCFIB:
+	sts.l	pr,@-r15
+
+	/* Stack layout:	
+	   xx bytes (on stack parameters)
+	   16 bytes (register parameters)
+	    4 bytes (saved frame pointer)
+	    4 bytes (saved return address)
+	   32 bytes (floating register parameters, SH-4 only)
+	    8 bytes (result)
+	    4 bytes (pad)
+	    4 bytes (5th arg)
+	   <- new stack pointer
+	*/
+.LCFIC:
+#if defined(__SH4__)
+	add	#-48,r15
+#else
+	add	#-16,r15
+#endif
+.LCFID:
+	mov	r15,r14
+.LCFIE:
+
+#if defined(__SH4__)
+	mov	r14,r1
+	add	#48,r1
+#ifdef __LITTLE_ENDIAN__
+	fmov.s	fr10,@-r1
+	fmov.s	fr11,@-r1
+	fmov.s	fr8,@-r1
+	fmov.s	fr9,@-r1
+	fmov.s	fr6,@-r1
+	fmov.s	fr7,@-r1
+	fmov.s	fr4,@-r1
+	fmov.s	fr5,@-r1
+#else
+	fmov.s	fr11,@-r1
+	fmov.s	fr10,@-r1
+	fmov.s	fr9,@-r1
+	fmov.s	fr8,@-r1
+	fmov.s	fr7,@-r1
+	fmov.s	fr6,@-r1
+	fmov.s	fr5,@-r1
+	fmov.s	fr4,@-r1
+#endif
+	mov	r1,r7
+	mov	r14,r6
+	add	#56,r6
+#else
+	mov	r14,r6
+	add	#24,r6
+#endif
+
+	bt/s	10f
+	 mov	r2, r5
+	mov	r14,r1
+	add	#8,r1
+	mov	r1,r5
+10:
+
+	mov	r14,r1
+#if defined(__SH4__)
+	add	#72,r1
+#else
+	add	#40,r1
+#endif
+	mov.l	r1,@r14
+
+#ifdef PIC
+	mov.l	L_got,r1
+	mova	L_got,r0
+	add	r0,r1
+	mov.l	L_helper,r0
+	add	r1,r0
+#else
+	mov.l	L_helper,r0
+#endif
+	jsr	@r0
+	 mov	r3,r4
+
+	shll	r0
+	mov	r0,r1
+	mova	L_table,r0
+	add	r1,r0
+	mov.w	@r0,r0
+	mov	r14,r2
+	braf	r0
+	 add	#8,r2
+0:
+	.align 2
+#ifdef PIC
+L_got:
+	.long	_GLOBAL_OFFSET_TABLE_
+L_helper:
+	.long	ffi_closure_helper_SYSV@GOTOFF
+#else
+L_helper:
+	.long	ffi_closure_helper_SYSV
+#endif
+L_table:
+	.short L_case_v - 0b	/* FFI_TYPE_VOID */
+	.short L_case_i - 0b	/* FFI_TYPE_INT */
+#if defined(__SH4__)
+	.short L_case_f - 0b	/* FFI_TYPE_FLOAT */
+	.short L_case_d - 0b	/* FFI_TYPE_DOUBLE */
+	.short L_case_d - 0b	/* FFI_TYPE_LONGDOUBLE */
+#else
+	.short L_case_i - 0b	/* FFI_TYPE_FLOAT */
+	.short L_case_ll - 0b	/* FFI_TYPE_DOUBLE */
+	.short L_case_ll - 0b	/* FFI_TYPE_LONGDOUBLE */
+#endif
+	.short L_case_uq - 0b	/* FFI_TYPE_UINT8 */
+	.short L_case_q - 0b	/* FFI_TYPE_SINT8 */
+	.short L_case_uh - 0b	/* FFI_TYPE_UINT16 */
+	.short L_case_h - 0b	/* FFI_TYPE_SINT16 */
+	.short L_case_i - 0b	/* FFI_TYPE_UINT32 */
+	.short L_case_i - 0b	/* FFI_TYPE_SINT32 */
+	.short L_case_ll - 0b	/* FFI_TYPE_UINT64 */
+	.short L_case_ll - 0b	/* FFI_TYPE_SINT64 */
+	.short L_case_v - 0b	/* FFI_TYPE_STRUCT */
+	.short L_case_i - 0b	/* FFI_TYPE_POINTER */
+
+#if defined(__SH4__)
+L_case_d:
+#ifdef __LITTLE_ENDIAN__
+	fmov.s	@r2+,fr1
+	bra	L_case_v
+	 fmov.s	@r2,fr0
+#else
+	fmov.s	@r2+,fr0
+	bra	L_case_v
+	 fmov.s	@r2,fr1
+#endif
+
+L_case_f:
+	bra	L_case_v
+	 fmov.s	@r2,fr0
+#endif
+	
+L_case_ll:
+	mov.l	@r2+,r0
+	bra	L_case_v
+	 mov.l	@r2,r1
+	
+L_case_i:
+	bra	L_case_v
+	 mov.l	@r2,r0
+	
+L_case_q:
+#ifdef __LITTLE_ENDIAN__
+#else
+	add	#3,r2
+#endif
+	bra	L_case_v
+	 mov.b	@r2,r0
+
+L_case_uq:
+#ifdef __LITTLE_ENDIAN__
+#else
+	add	#3,r2
+#endif
+	mov.b	@r2,r0
+	bra	L_case_v
+	 extu.b r0,r0
+
+L_case_h:
+#ifdef __LITTLE_ENDIAN__
+#else
+	add	#2,r2
+#endif
+	bra	L_case_v
+	 mov.w	@r2,r0
+
+L_case_uh:
+#ifdef __LITTLE_ENDIAN__
+#else
+	add	#2,r2
+#endif
+	mov.w	@r2,r0
+	extu.w	r0,r0
+	/* fall through */
+
+L_case_v:
+#if defined(__SH4__)
+	add	#48,r15
+#else
+	add	#16,r15
+#endif
+	lds.l	@r15+,pr
+	mov.l	@r15+,r14
+	rts
+	 add	#16,r15
+.LFE2:
+.ffi_closure_SYSV_end:
+        .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+
+	.section	".eh_frame","aw",@progbits
+__FRAME_BEGIN__:
+	.4byte	.LECIE1-.LSCIE1	/* Length of Common Information Entry */
+.LSCIE1:
+	.4byte	0x0	/* CIE Identifier Tag */
+	.byte	0x1	/* CIE Version */
+#ifdef PIC
+	.ascii "zR\0"	/* CIE Augmentation */
+#else
+	.byte	0x0	/* CIE Augmentation */
+#endif
+	.byte	0x1	/* uleb128 0x1; CIE Code Alignment Factor */
+	.byte	0x7c	/* sleb128 -4; CIE Data Alignment Factor */
+	.byte	0x11	/* CIE RA Column */
+#ifdef PIC
+	.uleb128 0x1	/* Augmentation size */
+	.byte	0x10	/* FDE Encoding (pcrel) */
+#endif
+	.byte	0xc	/* DW_CFA_def_cfa */
+	.byte	0xf	/* uleb128 0xf */
+	.byte	0x0	/* uleb128 0x0 */
+	.align	2
+.LECIE1:
+.LSFDE1:
+	.4byte	.LEFDE1-.LASFDE1	/* FDE Length */
+.LASFDE1:
+	.4byte	.LASFDE1-__FRAME_BEGIN__	/* FDE CIE offset */
+#ifdef PIC
+	.4byte	.LFB1-.	/* FDE initial location */
+#else
+	.4byte	.LFB1	/* FDE initial location */
+#endif
+	.4byte	.LFE1-.LFB1	 /* FDE address range */
+#ifdef PIC
+	.uleb128 0x0	/* Augmentation size */
+#endif
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI0-.LFB1
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x4	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI1-.LCFI0
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x8	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI2-.LCFI1
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0xc	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI3-.LCFI2
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x10	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI4-.LCFI3
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x14	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI5-.LCFI4
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x18	/* uleb128 0x4 */
+	.byte	0x91	/* DW_CFA_offset, column 0x11 */
+	.byte	0x6	/* uleb128 0x6 */
+	.byte	0x8e	/* DW_CFA_offset, column 0xe */
+	.byte	0x5	/* uleb128 0x5 */
+	.byte	0x8c	/* DW_CFA_offset, column 0xc */
+	.byte	0x4	/* uleb128 0x4 */
+	.byte	0x8a	/* DW_CFA_offset, column 0xa */
+	.byte	0x3	/* uleb128 0x3 */
+	.byte	0x89	/* DW_CFA_offset, column 0x9 */
+	.byte	0x2	/* uleb128 0x2 */
+	.byte	0x88	/* DW_CFA_offset, column 0x8 */
+	.byte	0x1	/* uleb128 0x1 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI6-.LCFI5
+	.byte	0xd	/* DW_CFA_def_cfa_register */
+	.byte	0xe	/* uleb128 0xe */
+	.align	2
+.LEFDE1:
+
+.LSFDE3:
+	.4byte	.LEFDE3-.LASFDE3	/* FDE Length */
+.LASFDE3:
+	.4byte	.LASFDE3-__FRAME_BEGIN__	/* FDE CIE offset */
+#ifdef PIC
+	.4byte	.LFB2-.	/* FDE initial location */
+#else
+	.4byte	.LFB2	/* FDE initial location */
+#endif
+	.4byte	.LFE2-.LFB2	 /* FDE address range */
+#ifdef PIC
+	.uleb128 0x0	/* Augmentation size */
+#endif
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI7-.LFB2
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x4	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI8-.LCFI7
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x8	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFI9-.LCFI8
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0xc	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFIA-.LCFI9
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x10	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFIB-.LCFIA
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x14	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFIC-.LCFIB
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.byte	0x18	/* uleb128 0x4 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFID-.LCFIC
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+#if defined(__SH4__)
+	.byte	24+48	/* uleb128 24+48 */
+#else
+	.byte	24+16	/* uleb128 24+16 */
+#endif
+	.byte	0x91	/* DW_CFA_offset, column 0x11 */
+	.byte	0x6	/* uleb128 0x6 */
+	.byte	0x8e	/* DW_CFA_offset, column 0xe */
+	.byte	0x5	/* uleb128 0x5 */
+	.byte	0x84	/* DW_CFA_offset, column 0x4 */
+	.byte	0x4	/* uleb128 0x4 */
+	.byte	0x85	/* DW_CFA_offset, column 0x5 */
+	.byte	0x3	/* uleb128 0x3 */
+	.byte	0x86	/* DW_CFA_offset, column 0x6 */
+	.byte	0x2	/* uleb128 0x2 */
+	.byte	0x87	/* DW_CFA_offset, column 0x7 */
+	.byte	0x1	/* uleb128 0x1 */
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	.LCFIE-.LCFID
+	.byte	0xd	/* DW_CFA_def_cfa_register */
+	.byte	0xe	/* uleb128 0xe */
+	.align	2
+.LEFDE3:
Index: libffi-3.4.6/src/sh/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh/ffitarget.h b/libffi-3.4.6/src/sh/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh/ffitarget.h	
@@ -0,0 +1,54 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012 Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for SuperH.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 16
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
Index: libffi-3.4.6/src/arc/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arc/ffi.c b/libffi-3.4.6/src/arc/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arc/ffi.c	
@@ -0,0 +1,443 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2013  Synopsys, Inc. (www.synopsys.com)
+   
+   ARC Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <sys/cachectl.h>
+
+#define NARGREG 8
+#define STKALIGN 4
+#define MAXCOPYARG (2 * sizeof(double))
+
+typedef struct call_context
+{
+  size_t r[8];
+  /* used by the assembly code to in-place construct its own stack frame */
+  char frame[16];
+} call_context;
+
+typedef struct call_builder
+{
+  call_context *aregs;
+  int used_integer;
+  //int used_float;
+  size_t *used_stack;
+  void *struct_stack;
+} call_builder;
+
+/* integer (not pointer) less than ABI XLEN */
+/* FFI_TYPE_INT does not appear to be used */
+#if defined(__ARC64_ARCH64__)
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT64)
+#else
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT32)
+#endif
+
+/* for little endian ARC, the code is in fact stored as mixed endian for
+   performance reasons */
+#if __BIG_ENDIAN__
+#define CODE_ENDIAN(x) (x)
+#else
+#define CODE_ENDIAN(x) ( (((uint32_t) (x)) << 16) | (((uint32_t) (x)) >> 16))
+#endif
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif * cif)
+{
+  /* Set the return type flag.  */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_DOUBLE:
+      cif->flags = FFI_TYPE_DOUBLE;
+      break;
+
+    case FFI_TYPE_FLOAT:
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+/* allocates a single register, float register, or XLEN-sized stack slot to a datum */
+static void marshal_atom(call_builder *cb, int type, void *data) {
+  size_t value = 0;
+  switch (type) {
+    case FFI_TYPE_UINT8: value = *(uint8_t *)data; break;
+    case FFI_TYPE_SINT8: value = *(int8_t *)data; break;
+    case FFI_TYPE_UINT16: value = *(uint16_t *)data; break;
+    case FFI_TYPE_SINT16: value = *(int16_t *)data; break;
+    /* 32-bit quantities are always sign-extended in the ABI */
+    case FFI_TYPE_UINT32: value = *(int32_t *)data; break;
+    case FFI_TYPE_SINT32: value = *(int32_t *)data; break;
+#if defined(__ARC64_ARCH64__)
+    case FFI_TYPE_UINT64: value = *(uint64_t *)data; break;
+    case FFI_TYPE_SINT64: value = *(int64_t *)data; break;
+#endif
+    case FFI_TYPE_POINTER: value = *(size_t *)data; break;
+    default: FFI_ASSERT(0); break;
+  }
+
+  if (cb->used_integer == NARGREG) {
+    *cb->used_stack++ = value;
+  } else {
+    cb->aregs->r[cb->used_integer++] = value;
+  }
+}
+
+/* adds an argument to a call, or a not by reference return value */
+static void marshal(call_builder *cb, ffi_type *type, int var, void *data) {
+  size_t realign[2];
+
+#if (defined(__ARC64_ARCH64__) || defined(__ARC64_ARCH32__))
+  if (type->size > 2 * __SIZEOF_POINTER__) {
+    if (var) {
+      marshal_atom(cb, FFI_TYPE_POINTER, &data);
+    } else {
+      /* copy to stack and pass by reference */
+      data = memcpy (cb->struct_stack, data, type->size);
+      cb->struct_stack = (size_t *) FFI_ALIGN ((char *) cb->struct_stack + type->size, __SIZEOF_POINTER__);
+      marshal_atom(cb, FFI_TYPE_POINTER, &data);
+    }
+  }
+#else
+  if (type->type == FFI_TYPE_STRUCT) {
+    if (var) {
+      if (type->size > 0)
+        marshal_atom(cb, FFI_TYPE_POINTER, data);
+    } else {
+      int i;
+      
+      for (i = 0; i < type->size; i += sizeof(size_t)) {
+        marshal_atom(cb, FFI_TYPE_POINTER, data);
+        data += sizeof(size_t);
+      }
+    }
+  }
+#endif
+  else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+    marshal_atom(cb, type->type, data);
+  } else {
+      memcpy(realign, data, type->size);
+      if (type->size > 0)
+        marshal_atom(cb, FFI_TYPE_POINTER, realign);
+      if (type->size > __SIZEOF_POINTER__)
+        marshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+  }
+}
+
+static void unmarshal_atom(call_builder *cb, int type, void *data) {
+  size_t value;
+
+  if (cb->used_integer == NARGREG) {
+    value = *cb->used_stack++;
+  } else {
+    value = cb->aregs->r[cb->used_integer++];
+  }
+
+  switch (type) {
+    case FFI_TYPE_UINT8: *(uint8_t *)data = value; break;
+    case FFI_TYPE_SINT8: *(uint8_t *)data = value; break;
+    case FFI_TYPE_UINT16: *(uint16_t *)data = value; break;
+    case FFI_TYPE_SINT16: *(uint16_t *)data = value; break;
+    case FFI_TYPE_UINT32: *(uint32_t *)data = value; break;
+    case FFI_TYPE_SINT32: *(uint32_t *)data = value; break;
+#if defined(__ARC64_ARCH64__)
+    case FFI_TYPE_UINT64: *(uint64_t *)data = value; break;
+    case FFI_TYPE_SINT64: *(uint64_t *)data = value; break;
+#endif
+    case FFI_TYPE_POINTER: *(size_t *)data = value; break;
+    default: FFI_ASSERT(0); break;
+  }
+}
+
+/* for arguments passed by reference returns the pointer, otherwise the arg is copied (up to MAXCOPYARG bytes) */
+static void *unmarshal(call_builder *cb, ffi_type *type, int var, void *data) {
+  size_t realign[2];
+  void *pointer;
+
+#if defined(__ARC64_ARCH64__)
+  if (type->size > 2 * __SIZEOF_POINTER__) {
+        /* pass by reference */
+        unmarshal_atom(cb, FFI_TYPE_POINTER, (char*)&pointer);
+        return pointer;
+    }
+#elif defined(__ARC64_ARCH32__)
+  if (type->type == FFI_TYPE_STRUCT) {
+    if (type->size > 2 * __SIZEOF_POINTER__) {
+      unmarshal_atom(cb, FFI_TYPE_POINTER, &realign[0]);
+      memcpy(data, (const void*)realign[0], type->size);
+      return data;
+    } else {
+      int i;
+      void *pdata = data;
+
+      for (i = 0; i < type->size; i += sizeof(size_t)) {
+        unmarshal_atom(cb, FFI_TYPE_POINTER, pdata);
+        pdata += sizeof(size_t);
+      }
+      return data;
+    }
+  }
+#else
+  if (type->type == FFI_TYPE_STRUCT) {
+
+      if (var) {
+        int i;
+        void *pdata = data;
+
+        for (i = 0; i < type->size; i += sizeof(size_t)) {
+          unmarshal_atom(cb, FFI_TYPE_POINTER, pdata);
+          pdata += sizeof(size_t);
+        }
+        return data;
+      } else {
+        if (type->size > 0)
+          unmarshal_atom(cb, FFI_TYPE_POINTER, &realign[0]);
+        memcpy(data, (const void*)realign[0], type->size);
+        return data;
+      }
+  }
+#endif
+  else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+    unmarshal_atom(cb, type->type, data);
+    return data;
+  } else {
+      if (type->size > 0)
+        unmarshal_atom(cb, FFI_TYPE_POINTER, realign);
+      if (type->size > __SIZEOF_POINTER__)
+        unmarshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+      memcpy(data, realign, type->size);
+      return data;
+  }
+}
+
+static int passed_by_ref(ffi_type *type, int var) {
+  if (type->type == FFI_TYPE_STRUCT)
+	  return 1;
+  
+  return type->size > 2 * __SIZEOF_POINTER__;
+}
+
+/* Low level routine for calling functions */
+extern void ffi_call_asm (void *stack, struct call_context *regs,
+			  void (*fn) (void), void *closure) FFI_HIDDEN;
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	      void *closure)
+{
+  int return_by_ref = passed_by_ref(cif->rtype, 0);
+
+  /* Allocate space for stack arg parameters.  */
+  size_t arg_bytes = FFI_ALIGN(2 * sizeof(size_t) * cif->nargs, STKALIGN);
+  /* Allocate space for copies of big structures.  */
+  size_t struct_bytes = FFI_ALIGN(cif->bytes, STKALIGN);
+  // size_t rval_bytes = 0;
+  // if (rvalue == NULL && cif->rtype->size > 2*__SIZEOF_POINTER__)
+  //   rval_bytes = FFI_ALIGN(cif->rtype->size, STKALIGN);
+  size_t alloc_size = arg_bytes + /*rval_bytes +*/ struct_bytes + sizeof(call_context);
+  size_t alloc_base = (size_t)alloca(alloc_size);
+
+  // if (rval_bytes)
+  //   rvalue = (void*)(alloc_base + arg_bytes);
+
+  call_builder cb;
+  cb.used_integer = 0;
+  cb.aregs = (call_context*)(alloc_base + arg_bytes /*+ rval_bytes*/ + struct_bytes);
+  cb.used_stack = (void*)alloc_base;
+  cb.struct_stack = (void *)(alloc_base + arg_bytes /*+ rval_bytes*/);
+
+  // if (cif->rtype->type == FFI_TYPE_STRUCT)
+  //   marshal(&cb, &ffi_type_pointer, 0, &rvalue);
+
+  if (return_by_ref)
+	  marshal(&cb, &ffi_type_pointer, 0, &rvalue);
+
+  int i;
+  for (i = 0; i < cif->nargs; i++)
+    marshal(&cb, cif->arg_types[i], 0, avalue[i]);
+
+  ffi_call_asm ((void *) alloc_base, cb.aregs, fn, closure);
+
+  cb.used_integer = 0;
+  if (!return_by_ref && rvalue)
+    {
+	    if (IS_INT(cif->rtype->type)
+	        && cif->rtype->size < sizeof (ffi_arg))
+	    {
+        /* Integer types smaller than ffi_arg need to be extended.  */
+	    switch (cif->rtype->type) {
+	      case FFI_TYPE_SINT8:
+	      case FFI_TYPE_SINT16:
+	      case FFI_TYPE_SINT32:
+		      unmarshal_atom (&cb, (sizeof (ffi_arg) > 4
+                          ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32),
+				                  rvalue);
+		      break;
+	      case FFI_TYPE_UINT8:
+	      case FFI_TYPE_UINT16:
+	      case FFI_TYPE_UINT32:
+		      unmarshal_atom (&cb, (sizeof (ffi_arg) > 4
+				                  ? FFI_TYPE_UINT64 : FFI_TYPE_UINT32),
+				                  rvalue);
+		      break;
+	      }
+	    }
+	    else
+	      unmarshal(&cb, cif->rtype, 0, rvalue);
+    }
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+extern void ffi_closure_asm(void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure * closure, ffi_cif * cif,
+		      void (*fun) (ffi_cif *, void *, void **, void *),
+		      void *user_data, void *codeloc)
+{
+  uint32_t *tramp = (uint32_t *) & (closure->tramp[0]);
+  size_t address_ffi_closure = (size_t) ffi_closure_asm;
+
+  switch (cif->abi)
+    {
+#if defined(__ARC64_ARCH64__)
+    case FFI_ARC64:
+      FFI_ASSERT (tramp == codeloc);
+      tramp[0] = CODE_ENDIAN (0x580a1fc0);	/* movl r8, pcl  */
+      tramp[1] = CODE_ENDIAN (0x5c0b1f80);	/* movhl r12, limm */
+      tramp[2] = CODE_ENDIAN ((uint32_t)(address_ffi_closure >> 32));
+      tramp[3] = CODE_ENDIAN (0x5c051f8c);	/* orl r12, r12, limm */
+      tramp[4] = CODE_ENDIAN ((uint32_t)(address_ffi_closure & 0xffffffff));
+      tramp[5] = CODE_ENDIAN (0x20200300);	/* j [r12] */
+      break;
+#else
+    case FFI_ARCOMPACT:
+      FFI_ASSERT (tramp == codeloc);
+      tramp[0] = CODE_ENDIAN (0x200a1fc0);	/* mov r8, pcl  */
+      tramp[1] = CODE_ENDIAN (0x20200f80);	/* j [long imm] */
+      tramp[2] = CODE_ENDIAN (ffi_closure_asm);
+      break;
+#endif
+
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+  cacheflush (codeloc, FFI_TRAMPOLINE_SIZE, BCACHE);
+
+  return FFI_OK;
+}
+
+extern void ffi_go_closure_asm (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+  if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (void *) ffi_go_closure_asm;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+/* Called by the assembly code with aregs pointing to saved argument registers
+   and stack pointing to the stacked arguments.  Return values passed in
+   registers will be reloaded from aregs. */
+void FFI_HIDDEN
+ffi_closure_inner (ffi_cif *cif,
+		   void (*fun) (ffi_cif *, void *, void **, void *),
+		   void *user_data,
+		   size_t *stack, call_context *aregs)
+{
+    void **avalue = alloca(cif->nargs * sizeof(void*));
+    /* storage for arguments which will be copied by unmarshal().  We could
+       theoretically avoid the copies in many cases and use at most 128 bytes
+       of memory, but allocating disjoint storage for each argument is
+       simpler. */
+    char *astorage = alloca(cif->bytes);
+    char *ptr = astorage;
+    void *rvalue;
+    call_builder cb;
+    int i;
+
+    cb.aregs = aregs;
+    cb.used_integer = 0;
+    cb.used_stack = stack;
+    
+    /* handle hidden argument */
+    if (cif->flags == FFI_TYPE_STRUCT)
+      unmarshal(&cb, &ffi_type_pointer, 0, &rvalue);
+    else
+      rvalue = alloca(cif->rtype->size);
+
+    for (i = 0; i < cif->nargs; i++) {
+      avalue[i] = unmarshal(&cb, cif->arg_types[i], 1, ptr);
+      ptr += cif->arg_types[i]->size;
+    }
+
+    fun (cif, rvalue, avalue, user_data);
+
+    if (cif->rtype->type != FFI_TYPE_VOID) {
+        cb.used_integer = 0;
+        marshal(&cb, cif->rtype, 1, rvalue);
+    }
+}
Index: libffi-3.4.6/src/arc/arcompact.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arc/arcompact.S b/libffi-3.4.6/src/arc/arcompact.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arc/arcompact.S	
@@ -0,0 +1,210 @@
+/* -----------------------------------------------------------------------
+   arcompact.S - Copyright (c) 2013 Synposys, Inc. (www.synopsys.com)
+   
+   ARCompact Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+#define CNAME(x) x
+#define ENTRY(x) .globl CNAME(x)` .type CNAME(x),%function` CNAME(x):
+#endif
+
+#if __SIZEOF_POINTER__ == 8
+#define PTRS 8
+#define FLTS 8
+#define LARG ldl
+#define SARG stl
+#define ADDPTR addl
+#define MOVPTR movl_s
+#else
+#define PTRS 4
+#define FLTS 4
+#define LARG ld
+#define SARG st
+#define ADDPTR add
+#define MOVPTR mov_s
+#endif
+
+#define FRAME_LEN (8 * PTRS + 16)
+
+.text
+
+ENTRY(ffi_call_asm)
+        .cfi_startproc
+
+        /* Save registers.  */
+        .cfi_def_cfa r1, FRAME_LEN
+        SARG    fp, [r1, FRAME_LEN - 2*PTRS]
+        .cfi_offset fp, -2*PTRS
+        SARG    blink, [r1, FRAME_LEN - 1*PTRS]
+        .cfi_offset blink, -1*PTRS
+        ADDPTR  fp, r1, FRAME_LEN
+        MOVPTR  sp, r0
+        .cfi_def_cfa fp, 0
+
+        /* Load arguments.  */
+        MOVPTR  r11, r2      /* fn */
+        MOVPTR  r12, r3      /* closure */
+
+        /* Save arguments.  */
+        LARG    r0, [fp, -FRAME_LEN+0*PTRS]
+        LARG    r1, [fp, -FRAME_LEN+1*PTRS]
+        LARG    r2, [fp, -FRAME_LEN+2*PTRS]
+        LARG    r3, [fp, -FRAME_LEN+3*PTRS]
+        LARG    r4, [fp, -FRAME_LEN+4*PTRS]
+        LARG    r5, [fp, -FRAME_LEN+5*PTRS]
+        LARG    r6, [fp, -FRAME_LEN+6*PTRS]
+        LARG    r7, [fp, -FRAME_LEN+7*PTRS]
+
+        /* Call the function.  */
+        jl         [r11] 
+
+        /* Save return value (r0/r1)  */
+        SARG    r0, [fp, -FRAME_LEN+0*PTRS]
+        SARG    r1, [fp, -FRAME_LEN+1*PTRS]
+
+        /* Restore and return.  */
+        add     sp, fp, -FRAME_LEN
+        .cfi_def_cfa sp, FRAME_LEN
+        LARG    blink, [fp, -1*PTRS]
+        .cfi_restore blink
+        LARG    fp, [fp, -2*PTRS]
+        .cfi_restore fp
+        j_s     [blink]
+        .cfi_endproc
+        .size   ffi_call_asm, .-ffi_call_asm
+
+/*
+  ffi_closure_asm. Expects address of the passed-in ffi_closure in r8.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+ENTRY(ffi_closure_asm)
+        .cfi_startproc
+
+        ADDPTR  sp, sp, -FRAME_LEN
+        .cfi_def_cfa_offset FRAME_LEN
+
+        /* Make a frame.  */
+        SARG    fp, [sp, FRAME_LEN-2*PTRS]
+        .cfi_offset fp, -2*PTRS
+        SARG    blink, [sp, FRAME_LEN-1*PTRS]
+        .cfi_offset blink, -1*PTRS
+        ADDPTR  fp, sp, FRAME_LEN
+
+        /* Save arguments.  */
+        SARG    r0, [sp, 0*PTRS]
+        SARG    r1, [sp, 1*PTRS]
+        SARG    r2, [sp, 2*PTRS]
+        SARG    r3, [sp, 3*PTRS]
+        SARG    r4, [sp, 4*PTRS]
+        SARG    r5, [sp, 5*PTRS]
+        SARG    r6, [sp, 6*PTRS]
+        SARG    r7, [sp, 7*PTRS]
+
+        /* Enter C.  */
+        LARG    r0, [r8, FFI_TRAMPOLINE_SIZE+0*PTRS]
+        LARG    r1, [r8, FFI_TRAMPOLINE_SIZE+1*PTRS]
+        LARG    r2, [r8, FFI_TRAMPOLINE_SIZE+2*PTRS]
+        ADDPTR  r3, sp, FRAME_LEN
+        MOVPTR  r4, sp
+
+        /* Call the C code.  */
+        bl      ffi_closure_inner
+        
+        /* Return values.  */
+        LARG    r0, [sp, 0*PTRS]
+        LARG    r1, [sp, 1*PTRS]
+
+        /* Restore and return.  */
+        LARG    blink, [sp, FRAME_LEN-1*PTRS]
+        .cfi_restore blink
+        LARG    fp, [sp, FRAME_LEN-2*PTRS]
+        .cfi_restore fp
+        ADDPTR  sp, sp, FRAME_LEN
+        .cfi_def_cfa_offset 0
+        j_s     [blink]
+        .cfi_endproc
+        .size ffi_closure_asm, .-ffi_closure_asm
+
+/*
+  ffi_go_closure_asm.  Expects address of the passed-in ffi_go_closure in r12.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+ENTRY(ffi_go_closure_asm)
+        .cfi_startproc
+
+        ADDPTR  sp, sp, -FRAME_LEN
+        .cfi_def_cfa_offset FRAME_LEN
+
+        /* make a frame */
+        SARG    fp, [sp, FRAME_LEN-2*PTRS]
+        .cfi_offset fp, -2*PTRS
+        SARG    blink, [sp, FRAME_LEN-1*PTRS]
+        .cfi_offset blink, -1*PTRS
+        ADDPTR  fp, sp, FRAME_LEN
+
+        /* save arguments */
+        SARG    r0, [sp, 0*PTRS]
+        SARG    r1, [sp, 1*PTRS]
+        SARG    r2, [sp, 2*PTRS]
+        SARG    r3, [sp, 3*PTRS]
+        SARG    r4, [sp, 4*PTRS]
+        SARG    r5, [sp, 5*PTRS]
+        SARG    r6, [sp, 6*PTRS]
+        SARG    r7, [sp, 7*PTRS]
+
+        /* enter C */
+        LARG    r0, [r12, 1*PTRS]
+        LARG    r1, [r12, 2*PTRS]
+        MOVPTR  r2, r12
+        ADDPTR  r3, sp, FRAME_LEN
+        MOVPTR  r4, sp
+
+        bl      ffi_closure_inner
+
+        /* Return values. */
+        LARG    r0, [sp, 0*PTRS]
+        LARG    r1, [sp, 1*PTRS]
+
+
+        LARG    blink, [sp, FRAME_LEN-1*PTRS]
+        .cfi_restore blink
+        LARG    fp, [sp, FRAME_LEN-2*PTRS]
+        .cfi_restore fp
+        ADDPTR  sp, sp, FRAME_LEN
+        .cfi_def_cfa_offset 0
+        j_s     [blink]
+        .cfi_endproc
+        .size ffi_go_closure_asm, .-ffi_go_closure_asm
Index: libffi-3.4.6/src/arc/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arc/ffitarget.h b/libffi-3.4.6/src/arc/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arc/ffitarget.h	
@@ -0,0 +1,67 @@
+/* -----------------------------------------------------------------------
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 2013  Synopsys, Inc. (www.synopsys.com)
+   Target configuration macros for ARC.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+typedef enum ffi_abi
+{
+  FFI_FIRST_ABI = 0,
+#if __SIZEOF_POINTER__ == 8
+  FFI_ARC64,
+#else
+  FFI_ARCOMPACT,
+#endif
+  FFI_LAST_ABI,
+#if __SIZEOF_POINTER__ == 8
+  FFI_DEFAULT_ABI = FFI_ARC64
+#else
+  FFI_DEFAULT_ABI = FFI_ARCOMPACT
+#endif
+} ffi_abi;
+#endif
+
+#define FFI_CLOSURES 		1
+#define FFI_GO_CLOSURES 1
+#if __SIZEOF_POINTER__ == 8
+#define FFI_TRAMPOLINE_SIZE	24
+#else
+#define FFI_TRAMPOLINE_SIZE	12
+#endif
+
+#define FFI_NATIVE_RAW_API 	0
+
+#endif
Index: libffi-3.4.6/src/arm/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arm/ffi.c b/libffi-3.4.6/src/arm/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arm/ffi.c	
@@ -0,0 +1,921 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2011 Timothy Wall
+           Copyright (c) 2011 Plausible Labs Cooperative, Inc.
+           Copyright (c) 2011 Anthony Green
+	   Copyright (c) 2011 Free Software Foundation
+           Copyright (c) 1998, 2008, 2011  Red Hat, Inc.
+
+   ARM Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#if defined(__arm__) || defined(_M_ARM)
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <tramp.h>
+#include "internal.h"
+
+#if defined(_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#include <mach/machine/vm_param.h>
+#endif
+
+#else
+#ifndef _WIN32
+extern unsigned int ffi_arm_trampoline[2] FFI_HIDDEN;
+#else
+// Declare this as an array of char, instead of array of int,
+// otherwise Clang optimizes out the "& 0xFFFFFFFE" for clearing
+// the thumb bit.
+extern unsigned char ffi_arm_trampoline[12] FFI_HIDDEN;
+#endif
+#endif
+
+#if defined(__FreeBSD__) && defined(__arm__)
+#include <sys/types.h>
+#include <machine/sysarch.h>
+#endif
+
+#if defined(__QNX__)
+#include <sys/mman.h>
+#endif
+
+/* Forward declares. */
+static int vfp_type_p (const ffi_type *);
+static void layout_vfp_args (ffi_cif *);
+
+static void *
+ffi_align (ffi_type *ty, void *p)
+{
+  /* Align if necessary */
+  size_t alignment;
+#ifdef _WIN32_WCE
+  alignment = 4;
+#else
+  alignment = ty->alignment;
+  if (alignment < 4)
+    alignment = 4;
+#endif
+  return (void *) FFI_ALIGN (p, alignment);
+}
+
+static size_t
+ffi_put_arg (ffi_type *ty, void *src, void *dst)
+{
+  size_t z = ty->size;
+
+  switch (ty->type)
+    {
+    case FFI_TYPE_SINT8:
+      *(UINT32 *)dst = *(SINT8 *)src;
+      break;
+    case FFI_TYPE_UINT8:
+      *(UINT32 *)dst = *(UINT8 *)src;
+      break;
+    case FFI_TYPE_SINT16:
+      *(UINT32 *)dst = *(SINT16 *)src;
+      break;
+    case FFI_TYPE_UINT16:
+      *(UINT32 *)dst = *(UINT16 *)src;
+      break;
+
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+#ifndef _WIN32
+    case FFI_TYPE_FLOAT:
+#endif
+      *(UINT32 *)dst = *(UINT32 *)src;
+      break;
+
+#ifdef _WIN32
+    // casting a float* to a UINT32* doesn't work on Windows
+    case FFI_TYPE_FLOAT:
+        *(uintptr_t *)dst = 0;
+        *(float *)dst = *(float *)src;
+        break;
+#endif
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_DOUBLE:
+      *(UINT64 *)dst = *(UINT64 *)src;
+      break;
+
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_COMPLEX:
+      memcpy (dst, src, z);
+      break;
+
+    default:
+      abort();
+    }
+
+  return FFI_ALIGN (z, 4);
+}
+
+/* ffi_prep_args is called once stack space has been allocated
+   for the function's arguments.
+
+   The vfp_space parameter is the load area for VFP regs, the return
+   value is cif->vfp_used (word bitset of VFP regs used for passing
+   arguments). These are only used for the VFP hard-float ABI.
+*/
+static void
+ffi_prep_args_SYSV (ffi_cif *cif, int flags, void *rvalue,
+		    void **avalue, char *argp)
+{
+  ffi_type **arg_types = cif->arg_types;
+  int i, n;
+
+  if (flags == ARM_TYPE_STRUCT)
+    {
+      *(void **) argp = rvalue;
+      argp += 4;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      argp = ffi_align (ty, argp);
+      argp += ffi_put_arg (ty, avalue[i], argp);
+    }
+}
+
+static void
+ffi_prep_args_VFP (ffi_cif *cif, int flags, void *rvalue,
+                   void **avalue, char *stack, char *vfp_space)
+{
+  ffi_type **arg_types = cif->arg_types;
+  int i, n, vi = 0;
+  char *argp, *regp, *eo_regp;
+  char stack_used = 0;
+  char done_with_regs = 0;
+
+  /* The first 4 words on the stack are used for values
+     passed in core registers.  */
+  regp = stack;
+  eo_regp = argp = regp + 16;
+
+  /* If the function returns an FFI_TYPE_STRUCT in memory,
+     that address is passed in r0 to the function.  */
+  if (flags == ARM_TYPE_STRUCT)
+    {
+      *(void **) regp = rvalue;
+      regp += 4;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      void *a = avalue[i];
+      int is_vfp_type = vfp_type_p (ty);
+
+      /* Allocated in VFP registers. */
+      if (vi < cif->vfp_nargs && is_vfp_type)
+	{
+	  char *vfp_slot = vfp_space + cif->vfp_args[vi++] * 4;
+	  ffi_put_arg (ty, a, vfp_slot);
+	  continue;
+	}
+      /* Try allocating in core registers. */
+      else if (!done_with_regs && !is_vfp_type)
+	{
+	  char *tregp = ffi_align (ty, regp);
+	  size_t size = ty->size;
+	  size = (size < 4) ? 4 : size;	// pad
+	  /* Check if there is space left in the aligned register
+	     area to place the argument.  */
+	  if (tregp + size <= eo_regp)
+	    {
+	      regp = tregp + ffi_put_arg (ty, a, tregp);
+	      done_with_regs = (regp == argp);
+	      // ensure we did not write into the stack area
+	      FFI_ASSERT (regp <= argp);
+	      continue;
+	    }
+	  /* In case there are no arguments in the stack area yet,
+	     the argument is passed in the remaining core registers
+	     and on the stack.  */
+	  else if (!stack_used)
+	    {
+	      stack_used = 1;
+	      done_with_regs = 1;
+	      argp = tregp + ffi_put_arg (ty, a, tregp);
+	      FFI_ASSERT (eo_regp < argp);
+	      continue;
+	    }
+	}
+      /* Base case, arguments are passed on the stack */
+      stack_used = 1;
+      argp = ffi_align (ty, argp);
+      argp += ffi_put_arg (ty, a, argp);
+    }
+}
+
+/* Perform machine dependent cif processing */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  int flags = 0, cabi = cif->abi;
+  size_t bytes = cif->bytes;
+
+  /* Map out the register placements of VFP register args.  The VFP
+     hard-float calling conventions are slightly more sophisticated
+     than the base calling conventions, so we do it here instead of
+     in ffi_prep_args(). */
+  if (cabi == FFI_VFP)
+    layout_vfp_args (cif);
+
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      flags = ARM_TYPE_VOID;
+      break;
+
+    case FFI_TYPE_INT:
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_POINTER:
+      flags = ARM_TYPE_INT;
+      break;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      flags = ARM_TYPE_INT64;
+      break;
+
+    case FFI_TYPE_FLOAT:
+      flags = (cabi == FFI_VFP ? ARM_TYPE_VFP_S : ARM_TYPE_INT);
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = (cabi == FFI_VFP ? ARM_TYPE_VFP_D : ARM_TYPE_INT64);
+      break;
+
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_COMPLEX:
+      if (cabi == FFI_VFP)
+	{
+	  int h = vfp_type_p (cif->rtype);
+
+	  flags = ARM_TYPE_VFP_N;
+	  if (h == 0x100 + FFI_TYPE_FLOAT)
+	    flags = ARM_TYPE_VFP_S;
+	  if (h == 0x100 + FFI_TYPE_DOUBLE)
+	    flags = ARM_TYPE_VFP_D;
+	  if (h != 0)
+	      break;
+	}
+
+      /* A Composite Type not larger than 4 bytes is returned in r0.
+	 A Composite Type larger than 4 bytes, or whose size cannot
+	 be determined statically ... is stored in memory at an
+	 address passed [in r0].  */
+      if (cif->rtype->size <= 4)
+	flags = ARM_TYPE_INT;
+      else
+	{
+	  flags = ARM_TYPE_STRUCT;
+	  bytes += 4;
+	}
+      break;
+
+    default:
+      abort();
+    }
+
+  /* Round the stack up to a multiple of 8 bytes.  This isn't needed
+     everywhere, but it is on some platforms, and it doesn't harm anything
+     when it isn't needed.  */
+  bytes = FFI_ALIGN (bytes, 8);
+
+  /* Minimum stack space is the 4 register arguments that we pop.  */
+  if (bytes < 4*4)
+    bytes = 4*4;
+
+  cif->bytes = bytes;
+  cif->flags = flags;
+
+  return FFI_OK;
+}
+
+/* Perform machine dependent cif processing for variadic calls */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var (ffi_cif * cif,
+			  unsigned int nfixedargs, unsigned int ntotalargs)
+{
+  /* VFP variadic calls actually use the SYSV ABI */
+  if (cif->abi == FFI_VFP)
+    cif->abi = FFI_SYSV;
+
+  return ffi_prep_cif_machdep (cif);
+}
+
+/* Prototypes for assembly functions, in sysv.S.  */
+
+struct call_frame
+{
+  void *fp;
+  void *lr;
+  void *rvalue;
+  int flags;
+  void *closure;
+};
+
+extern void ffi_call_SYSV (void *stack, struct call_frame *,
+			   void (*fn) (void)) FFI_HIDDEN;
+extern void ffi_call_VFP (void *vfp_space, struct call_frame *,
+			   void (*fn) (void), unsigned vfp_used) FFI_HIDDEN;
+
+static void
+ffi_call_int (ffi_cif * cif, void (*fn) (void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  int flags = cif->flags;
+  ffi_type *rtype = cif->rtype;
+  size_t bytes, rsize, vfp_size;
+  char *stack, *vfp_space, *new_rvalue;
+  struct call_frame *frame;
+
+  rsize = 0;
+  if (rvalue == NULL)
+    {
+      /* If the return value is a struct and we don't have a return
+	 value address then we need to make one.  Otherwise the return
+	 value is in registers and we can ignore them.  */
+      if (flags == ARM_TYPE_STRUCT)
+	rsize = rtype->size;
+      else
+	flags = ARM_TYPE_VOID;
+    }
+  else if (flags == ARM_TYPE_VFP_N)
+    {
+      /* Largest case is double x 4. */
+      rsize = 32;
+    }
+  else if (flags == ARM_TYPE_INT && rtype->type == FFI_TYPE_STRUCT)
+    rsize = 4;
+
+  /* Largest case.  */
+  vfp_size = (cif->abi == FFI_VFP && cif->vfp_used ? 8*8: 0);
+
+  bytes = cif->bytes;
+  stack = alloca (vfp_size + bytes + sizeof(struct call_frame) + rsize);
+
+  vfp_space = NULL;
+  if (vfp_size)
+    {
+      vfp_space = stack;
+      stack += vfp_size;
+    }
+
+  frame = (struct call_frame *)(stack + bytes);
+
+  new_rvalue = rvalue;
+  if (rsize)
+    new_rvalue = (void *)(frame + 1);
+
+  frame->rvalue = new_rvalue;
+  frame->flags = flags;
+  frame->closure = closure;
+
+  if (vfp_space)
+    {
+      ffi_prep_args_VFP (cif, flags, new_rvalue, avalue, stack, vfp_space);
+      ffi_call_VFP (vfp_space, frame, fn, cif->vfp_used);
+    }
+  else
+    {
+      ffi_prep_args_SYSV (cif, flags, new_rvalue, avalue, stack);
+      ffi_call_SYSV (stack, frame, fn);
+    }
+
+  if (rvalue && rvalue != new_rvalue)
+    memcpy (rvalue, new_rvalue, rtype->size);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+#ifdef FFI_GO_CLOSURES
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+#endif
+
+static void *
+ffi_prep_incoming_args_SYSV (ffi_cif *cif, void *rvalue,
+			     char *argp, void **avalue)
+{
+  ffi_type **arg_types = cif->arg_types;
+  int i, n;
+
+  if (cif->flags == ARM_TYPE_STRUCT)
+    {
+      rvalue = *(void **) argp;
+      argp += 4;
+    }
+  else
+    {
+      if (cif->rtype->size && cif->rtype->size < 4)
+        *(uint32_t *) rvalue = 0;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      size_t z = ty->size;
+
+      argp = ffi_align (ty, argp);
+      avalue[i] = (void *) argp;
+      argp += z;
+    }
+
+  return rvalue;
+}
+
+static void *
+ffi_prep_incoming_args_VFP (ffi_cif *cif, void *rvalue, char *stack,
+			    char *vfp_space, void **avalue)
+{
+  ffi_type **arg_types = cif->arg_types;
+  int i, n, vi = 0;
+  char *argp, *regp, *eo_regp;
+  char done_with_regs = 0;
+  char stack_used = 0;
+
+  regp = stack;
+  eo_regp = argp = regp + 16;
+
+  if (cif->flags == ARM_TYPE_STRUCT)
+    {
+      rvalue = *(void **) regp;
+      regp += 4;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      int is_vfp_type = vfp_type_p (ty);
+      size_t z = ty->size;
+
+      if (vi < cif->vfp_nargs && is_vfp_type)
+	{
+	  avalue[i] = vfp_space + cif->vfp_args[vi++] * 4;
+	  continue;
+	}
+      else if (!done_with_regs && !is_vfp_type)
+	{
+	  char *tregp = ffi_align (ty, regp);
+
+	  z = (z < 4) ? 4 : z;	// pad
+
+	  /* If the arguments either fits into the registers or uses registers
+	     and stack, while we haven't read other things from the stack */
+	  if (tregp + z <= eo_regp || !stack_used)
+	    {
+	      /* Because we're little endian, this is what it turns into.  */
+	      avalue[i] = (void *) tregp;
+	      regp = tregp + z;
+
+	      /* If we read past the last core register, make sure we
+		 have not read from the stack before and continue
+		 reading after regp.  */
+	      if (regp > eo_regp)
+		{
+		  FFI_ASSERT (!stack_used);
+		  argp = regp;
+		}
+	      if (regp >= eo_regp)
+		{
+		  done_with_regs = 1;
+		  stack_used = 1;
+		}
+	      continue;
+	    }
+	}
+
+      stack_used = 1;
+      argp = ffi_align (ty, argp);
+      avalue[i] = (void *) argp;
+      argp += z;
+    }
+
+  return rvalue;
+}
+
+#if FFI_CLOSURES
+
+struct closure_frame
+{
+  char vfp_space[8*8] __attribute__((aligned(8)));
+  char result[8*4];
+  char argp[];
+};
+
+int FFI_HIDDEN
+ffi_closure_inner_SYSV (ffi_cif *cif,
+		        void (*fun) (ffi_cif *, void *, void **, void *),
+		        void *user_data,
+		        struct closure_frame *frame)
+{
+  void **avalue = (void **) alloca (cif->nargs * sizeof (void *));
+  void *rvalue = ffi_prep_incoming_args_SYSV (cif, frame->result,
+					      frame->argp, avalue);
+  fun (cif, rvalue, avalue, user_data);
+  return cif->flags;
+}
+
+int FFI_HIDDEN
+ffi_closure_inner_VFP (ffi_cif *cif,
+		       void (*fun) (ffi_cif *, void *, void **, void *),
+		       void *user_data,
+		       struct closure_frame *frame)
+{
+  void **avalue = (void **) alloca (cif->nargs * sizeof (void *));
+  void *rvalue = ffi_prep_incoming_args_VFP (cif, frame->result, frame->argp,
+					     frame->vfp_space, avalue);
+  fun (cif, rvalue, avalue, user_data);
+  return cif->flags;
+}
+
+void ffi_closure_SYSV (void) FFI_HIDDEN;
+void ffi_closure_VFP (void) FFI_HIDDEN;
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void ffi_closure_SYSV_alt (void) FFI_HIDDEN;
+void ffi_closure_VFP_alt (void) FFI_HIDDEN;
+#endif
+
+#ifdef FFI_GO_CLOSURES
+void ffi_go_closure_SYSV (void) FFI_HIDDEN;
+void ffi_go_closure_VFP (void) FFI_HIDDEN;
+#endif
+
+/* the cif must already be prep'ed */
+
+#if defined(__FreeBSD__) && defined(__arm__)
+#define __clear_cache(start, end) do { \
+		struct arm_sync_icache_args ua; 		\
+								\
+		ua.addr = (uintptr_t)(start);			\
+		ua.len = (char *)(end) - (char *)start;		\
+		sysarch(ARM_SYNC_ICACHE, &ua);			\
+	} while (0);
+#endif
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure * closure,
+		      ffi_cif * cif,
+		      void (*fun) (ffi_cif *, void *, void **, void *),
+		      void *user_data, void *codeloc)
+{
+  void (*closure_func) (void) = ffi_closure_SYSV;
+
+  if (cif->abi == FFI_VFP)
+    {
+      /* We only need take the vfp path if there are vfp arguments.  */
+      if (cif->vfp_used)
+	closure_func = ffi_closure_VFP;
+    }
+  else if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);
+  config[0] = closure;
+  config[1] = closure_func;
+#else
+
+# if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      /* Initialize the static trampoline's parameters. */
+      if (closure_func == ffi_closure_SYSV)
+        closure_func = ffi_closure_SYSV_alt;
+      else
+        closure_func = ffi_closure_VFP_alt;
+      ffi_tramp_set_parms (closure->ftramp, closure_func, closure);
+      goto out;
+    }
+# endif
+
+  /* Initialize the dynamic trampoline. */
+# ifndef _WIN32
+  memcpy(closure->tramp, ffi_arm_trampoline, 8);
+# else
+  // cast away function type so MSVC doesn't set the lower bit of the function pointer
+  memcpy(closure->tramp, (void*)((uintptr_t)ffi_arm_trampoline & 0xFFFFFFFE), FFI_TRAMPOLINE_CLOSURE_OFFSET);
+# endif
+
+# if defined(__QNX__)
+  msync (closure->tramp, 8, MS_INVALIDATE_ICACHE);	/* clear data map */
+  msync (codeloc, 8, MS_INVALIDATE_ICACHE);		/* clear insn map */
+# elif defined(_WIN32)
+  FlushInstructionCache(GetCurrentProcess(), closure->tramp, FFI_TRAMPOLINE_SIZE);
+# else
+  __clear_cache(closure->tramp, closure->tramp + 8);	/* clear data map */
+  __clear_cache(codeloc, codeloc + 8);			/* clear insn map */
+# endif
+# ifdef _WIN32
+  *(void(**)(void))(closure->tramp + FFI_TRAMPOLINE_CLOSURE_FUNCTION) = closure_func;
+# else
+  *(void (**)(void))(closure->tramp + 8) = closure_func;
+# endif
+# if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+# endif
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+#ifdef FFI_GO_CLOSURES
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+  void (*closure_func) (void) = ffi_go_closure_SYSV;
+
+  if (cif->abi == FFI_VFP)
+    {
+      /* We only need take the vfp path if there are vfp arguments.  */
+      if (cif->vfp_used)
+	closure_func = ffi_go_closure_VFP;
+    }
+  else if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  closure->tramp = closure_func;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+#endif
+
+#endif /* FFI_CLOSURES */
+
+/* Below are routines for VFP hard-float support. */
+
+/* A subroutine of vfp_type_p.  Given a structure type, return the type code
+   of the first non-structure element.  Recurse for structure elements.
+   Return -1 if the structure is in fact empty, i.e. no nested elements.  */
+
+static int
+is_hfa0 (const ffi_type *ty)
+{
+  ffi_type **elements = ty->elements;
+  int i, ret = -1;
+
+  if (elements != NULL)
+    for (i = 0; elements[i]; ++i)
+      {
+        ret = elements[i]->type;
+        if (ret == FFI_TYPE_STRUCT || ret == FFI_TYPE_COMPLEX)
+          {
+            ret = is_hfa0 (elements[i]);
+            if (ret < 0)
+              continue;
+          }
+        break;
+      }
+
+  return ret;
+}
+
+/* A subroutine of vfp_type_p.  Given a structure type, return true if all
+   of the non-structure elements are the same as CANDIDATE.  */
+
+static int
+is_hfa1 (const ffi_type *ty, int candidate)
+{
+  ffi_type **elements = ty->elements;
+  int i;
+
+  if (elements != NULL)
+    for (i = 0; elements[i]; ++i)
+      {
+        int t = elements[i]->type;
+        if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)
+          {
+            if (!is_hfa1 (elements[i], candidate))
+              return 0;
+          }
+        else if (t != candidate)
+          return 0;
+      }
+
+  return 1;
+}
+
+/* Determine if TY is an homogenous floating point aggregate (HFA).
+   That is, a structure consisting of 1 to 4 members of all the same type,
+   where that type is a floating point scalar.
+
+   Returns non-zero iff TY is an HFA.  The result is an encoded value where
+   bits 0-7 contain the type code, and bits 8-10 contain the element count.  */
+
+static int
+vfp_type_p (const ffi_type *ty)
+{
+  ffi_type **elements;
+  int candidate, i;
+  size_t size, ele_count;
+
+  /* Quickest tests first.  */
+  candidate = ty->type;
+  switch (ty->type)
+    {
+    default:
+      return 0;
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      ele_count = 1;
+      goto done;
+    case FFI_TYPE_COMPLEX:
+      candidate = ty->elements[0]->type;
+      if (candidate != FFI_TYPE_FLOAT && candidate != FFI_TYPE_DOUBLE)
+	return 0;
+      ele_count = 2;
+      goto done;
+    case FFI_TYPE_STRUCT:
+      break;
+    }
+
+  /* No HFA types are smaller than 4 bytes, or larger than 32 bytes.  */
+  size = ty->size;
+  if (size < 4 || size > 32)
+    return 0;
+
+  /* Find the type of the first non-structure member.  */
+  elements = ty->elements;
+  candidate = elements[0]->type;
+  if (candidate == FFI_TYPE_STRUCT || candidate == FFI_TYPE_COMPLEX)
+    {
+      for (i = 0; ; ++i)
+        {
+          candidate = is_hfa0 (elements[i]);
+          if (candidate >= 0)
+            break;
+        }
+    }
+
+  /* If the first member is not a floating point type, it's not an HFA.
+     Also quickly re-check the size of the structure.  */
+  switch (candidate)
+    {
+    case FFI_TYPE_FLOAT:
+      ele_count = size / sizeof(float);
+      if (size != ele_count * sizeof(float))
+        return 0;
+      break;
+    case FFI_TYPE_DOUBLE:
+      ele_count = size / sizeof(double);
+      if (size != ele_count * sizeof(double))
+        return 0;
+      break;
+    default:
+      return 0;
+    }
+  if (ele_count > 4)
+    return 0;
+
+  /* Finally, make sure that all scalar elements are the same type.  */
+  for (i = 0; elements[i]; ++i)
+    {
+      int t = elements[i]->type;
+      if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)
+        {
+          if (!is_hfa1 (elements[i], candidate))
+            return 0;
+        }
+      else if (t != candidate)
+        return 0;
+    }
+
+  /* All tests succeeded.  Encode the result.  */
+ done:
+  return (ele_count << 8) | candidate;
+}
+
+static int
+place_vfp_arg (ffi_cif *cif, int h)
+{
+  unsigned short reg = cif->vfp_reg_free;
+  int align = 1, nregs = h >> 8;
+
+  if ((h & 0xff) == FFI_TYPE_DOUBLE)
+    align = 2, nregs *= 2;
+
+  /* Align register number. */
+  if ((reg & 1) && align == 2)
+    reg++;
+
+  while (reg + nregs <= 16)
+    {
+      int s, new_used = 0;
+      for (s = reg; s < reg + nregs; s++)
+	{
+	  new_used |= (1 << s);
+	  if (cif->vfp_used & (1 << s))
+	    {
+	      reg += align;
+	      goto next_reg;
+	    }
+	}
+      /* Found regs to allocate. */
+      cif->vfp_used |= new_used;
+      cif->vfp_args[cif->vfp_nargs++] = (signed char)reg;
+
+      /* Update vfp_reg_free. */
+      if (cif->vfp_used & (1 << cif->vfp_reg_free))
+	{
+	  reg += nregs;
+	  while (cif->vfp_used & (1 << reg))
+	    reg += 1;
+	  cif->vfp_reg_free = reg;
+	}
+      return 0;
+    next_reg:;
+    }
+  // done, mark all regs as used
+  cif->vfp_reg_free = 16;
+  cif->vfp_used = 0xFFFF;
+  return 1;
+}
+
+static void
+layout_vfp_args (ffi_cif * cif)
+{
+  unsigned int i;
+  /* Init VFP fields */
+  cif->vfp_used = 0;
+  cif->vfp_nargs = 0;
+  cif->vfp_reg_free = 0;
+  memset (cif->vfp_args, -1, 16);	/* Init to -1. */
+
+  for (i = 0; i < cif->nargs; i++)
+    {
+      int h = vfp_type_p (cif->arg_types[i]);
+      if (h && place_vfp_arg (cif, h) == 1)
+	break;
+    }
+}
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void *
+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)
+{
+  extern void *trampoline_code_table;
+
+  *tramp_size = ARM_TRAMP_SIZE;
+  *map_size = ARM_TRAMP_MAP_SIZE;
+  return &trampoline_code_table;
+}
+#endif
+
+#endif /* __arm__ or _M_ARM */
Index: libffi-3.4.6/src/arm/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arm/sysv.S b/libffi-3.4.6/src/arm/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arm/sysv.S	
@@ -0,0 +1,456 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 1998, 2008, 2011 Red Hat, Inc.
+	    Copyright (c) 2011 Plausible Labs Cooperative, Inc.
+
+   ARM Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifdef __arm__
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+
+/* GCC 4.8 provides __ARM_ARCH; construct it otherwise.  */
+#ifndef __ARM_ARCH
+# if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
+     || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+     || defined(__ARM_ARCH_7EM__)
+#  define __ARM_ARCH 7
+# elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
+        || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
+        || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) \
+	|| defined(__ARM_ARCH_6M__)
+#  define __ARM_ARCH 6
+# elif defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \
+	|| defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \
+	|| defined(__ARM_ARCH_5TEJ__)
+#  define __ARM_ARCH 5
+# else
+#  define __ARM_ARCH 4
+# endif
+#endif
+
+/* Conditionally compile unwinder directives.  */
+#ifdef __ARM_EABI__
+# define UNWIND(...)	__VA_ARGS__
+#else
+# define UNWIND(...)
+#endif
+
+#if defined(HAVE_AS_CFI_PSEUDO_OP) && defined(__ARM_EABI__)
+	.cfi_sections	.debug_frame
+#endif
+
+#define CONCAT(a, b)	CONCAT2(a, b)
+#define CONCAT2(a, b)	a ## b
+
+#ifdef __USER_LABEL_PREFIX__
+# define CNAME(X)	CONCAT (__USER_LABEL_PREFIX__, X)
+#else
+# define CNAME(X)	X
+#endif
+#ifdef __ELF__
+# define SIZE(X)	.size CNAME(X), . - CNAME(X)
+# define TYPE(X, Y)	.type CNAME(X), Y
+#else
+# define SIZE(X)
+# define TYPE(X, Y)
+#endif
+
+#define ARM_FUNC_START_LOCAL(name)	\
+	.align	3;			\
+	TYPE(CNAME(name), %function);	\
+	CNAME(name):
+
+#define ARM_FUNC_START(name)		\
+	.globl CNAME(name);		\
+	FFI_HIDDEN(CNAME(name));	\
+	ARM_FUNC_START_LOCAL(name)
+
+#define ARM_FUNC_END(name) \
+	SIZE(name)
+
+	.text
+	.syntax unified
+#if defined(_WIN32)
+	/* Windows on ARM is thumb-only */
+	.thumb
+#else
+	/* Keep the assembly in ARM mode in other cases, for simplicity
+	 * (to avoid interworking issues). */
+#undef __thumb__
+	.arm
+#endif
+
+/* Aid in defining a jump table with 8 bytes between entries.  */
+#ifdef __thumb__
+/* In thumb mode, instructions can be shorter than expected in arm mode, so
+ * we need to align the start of each case. */
+# define E(index) .align 3
+#elif defined(__clang__)
+/* ??? The clang assembler doesn't handle .if with symbolic expressions.  */
+# define E(index)
+#else
+# define E(index)				\
+	.if . - 0b - 8*index;			\
+	.error "type table out of sync";	\
+	.endif
+#endif
+
+
+#ifndef __clang__
+	/* We require interworking on LDM, which implies ARMv5T,
+	   which implies the existance of BLX.  */
+ 	.arch	armv5t
+#endif
+
+	/* Note that we use STC and LDC to encode VFP instructions,
+	   so that we do not need ".fpu vfp", nor get that added to
+	   the object file attributes.  These will not be executed
+	   unless the FFI_VFP abi is used.  */
+
+	@ r0:   stack
+	@ r1:   frame
+	@ r2:   fn
+	@ r3:	vfp_used
+
+ARM_FUNC_START(ffi_call_VFP)
+	UNWIND(.fnstart)
+	cfi_startproc
+
+	cmp	r3, #3			@ load only d0 if possible
+	ite	le
+	ldcle	p11, cr0, [r0]		@ vldrle d0, [r0]
+	ldcgt	p11, cr0, [r0], {16}	@ vldmgt r0, {d0-d7}
+	add	r0, r0, #64		@ discard the vfp register args
+	/* FALLTHRU */
+ARM_FUNC_END(ffi_call_VFP)
+
+ARM_FUNC_START(ffi_call_SYSV)
+	stm	r1, {fp, lr}
+	mov	fp, r1
+
+	@ This is a bit of a lie wrt the origin of the unwind info, but
+	@ now we've got the usual frame pointer and two saved registers.
+	UNWIND(.save {fp,lr})
+	UNWIND(.setfp fp, sp)
+	cfi_def_cfa(fp, 8)
+	cfi_rel_offset(fp, 0)
+	cfi_rel_offset(lr, 4)
+
+	mov	sp, r0		@ install the stack pointer
+	mov	lr, r2		@ move the fn pointer out of the way
+	ldr	ip, [fp, #16]	@ install the static chain
+	ldmia	sp!, {r0-r3}	@ move first 4 parameters in registers.
+	blx	lr		@ call fn
+
+	@ Load r2 with the pointer to storage for the return value
+	@ Load r3 with the return type code
+	ldr	r2, [fp, #8]
+	ldr	r3, [fp, #12]
+
+	@ Deallocate the stack with the arguments.
+	mov	sp, fp
+	cfi_def_cfa_register(sp)
+
+	@ Store values stored in registers.
+#ifndef __thumb__
+	.align	3
+	add	pc, pc, r3, lsl #3
+	nop
+#else
+	adr	ip, 0f
+	add	ip, ip, r3, lsl #3
+	mov	pc, ip
+	.align	3
+#endif
+0:
+E(ARM_TYPE_VFP_S)
+	stc	p10, cr0, [r2]		@ vstr s0, [r2]
+	pop	{fp,pc}
+E(ARM_TYPE_VFP_D)
+	stc	p11, cr0, [r2]		@ vstr d0, [r2]
+	pop	{fp,pc}
+E(ARM_TYPE_VFP_N)
+	stc	p11, cr0, [r2], {8}	@ vstm r2, {d0-d3}
+	pop	{fp,pc}
+E(ARM_TYPE_INT64)
+	str	r1, [r2, #4]
+	nop
+E(ARM_TYPE_INT)
+	str	r0, [r2]
+	pop	{fp,pc}
+E(ARM_TYPE_VOID)
+	pop	{fp,pc}
+	nop
+E(ARM_TYPE_STRUCT)
+	pop	{fp,pc}
+
+	cfi_endproc
+	UNWIND(.fnend)
+ARM_FUNC_END(ffi_call_SYSV)
+
+#if FFI_CLOSURES
+
+/*
+	int ffi_closure_inner_* (cif, fun, user_data, frame)
+*/
+
+ARM_FUNC_START(ffi_go_closure_SYSV)
+	cfi_startproc
+	stmdb	sp!, {r0-r3}			@ save argument regs
+	cfi_adjust_cfa_offset(16)
+	ldr	r0, [ip, #4]			@ load cif
+	ldr	r1, [ip, #8]			@ load fun
+	mov	r2, ip				@ load user_data
+	b	0f
+	cfi_endproc
+ARM_FUNC_END(ffi_go_closure_SYSV)
+
+ARM_FUNC_START(ffi_closure_SYSV)
+	UNWIND(.fnstart)
+	cfi_startproc
+#ifdef _WIN32
+	ldmfd	sp!, {r0, ip}			@ restore fp (r0 is used for stack alignment)
+#endif
+	stmdb	sp!, {r0-r3}			@ save argument regs
+	cfi_adjust_cfa_offset(16)
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+	ldr ip, [ip]				@ ip points to the config page, dereference to get the ffi_closure*
+#endif
+	ldr	r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]	@ load cif
+	ldr	r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  @ load fun
+	ldr	r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  @ load user_data
+0:
+	add	ip, sp, #16			@ compute entry sp
+	sub	sp, sp, #64+32			@ allocate frame
+	cfi_adjust_cfa_offset(64+32)
+	stmdb	sp!, {ip,lr}
+
+	/* Remember that EABI unwind info only applies at call sites.
+	   We need do nothing except note the save of the stack pointer
+	   and the link registers.  */
+	UNWIND(.save {sp,lr})
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(lr, 4)
+
+	add	r3, sp, #8			@ load frame
+	bl	CNAME(ffi_closure_inner_SYSV)
+
+	@ Load values returned in registers.
+	add	r2, sp, #8+64			@ load result
+	adr	r3, CNAME(ffi_closure_ret)
+#ifndef __thumb__
+	add	pc, r3, r0, lsl #3
+#else
+	add	r3, r3, r0, lsl #3
+	mov	pc, r3
+#endif
+	cfi_endproc
+	UNWIND(.fnend)
+ARM_FUNC_END(ffi_closure_SYSV)
+
+ARM_FUNC_START(ffi_go_closure_VFP)
+	cfi_startproc
+	stmdb	sp!, {r0-r3}			@ save argument regs
+	cfi_adjust_cfa_offset(16)
+	ldr	r0, [ip, #4]			@ load cif
+	ldr	r1, [ip, #8]			@ load fun
+	mov	r2, ip				@ load user_data
+	b	0f
+	cfi_endproc
+ARM_FUNC_END(ffi_go_closure_VFP)
+
+ARM_FUNC_START(ffi_closure_VFP)
+	UNWIND(.fnstart)
+	cfi_startproc
+#ifdef _WIN32
+	ldmfd	sp!, {r0, ip}			@ restore fp (r0 is used for stack alignment)
+#endif
+	stmdb	sp!, {r0-r3}			@ save argument regs
+	cfi_adjust_cfa_offset(16)
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+	ldr ip, [ip]				@ ip points to the config page, dereference to get the ffi_closure*
+#endif
+	ldr	r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]	@ load cif
+	ldr	r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  @ load fun
+	ldr	r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  @ load user_data
+0:
+	add	ip, sp, #16
+	sub	sp, sp, #64+32			@ allocate frame
+	cfi_adjust_cfa_offset(64+32)
+	stc	p11, cr0, [sp], {16}		@ vstm sp, {d0-d7}
+	stmdb	sp!, {ip,lr}
+
+	/* See above.  */
+	UNWIND(.save {sp,lr})
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(lr, 4)
+
+	add	r3, sp, #8			@ load frame
+	bl	CNAME(ffi_closure_inner_VFP)
+
+	@ Load values returned in registers.
+	add	r2, sp, #8+64			@ load result
+	adr	r3, CNAME(ffi_closure_ret)
+#ifndef __thumb__
+	add	pc, r3, r0, lsl #3
+#else
+	add	r3, r3, r0, lsl #3
+	mov	pc, r3
+#endif
+	cfi_endproc
+	UNWIND(.fnend)
+ARM_FUNC_END(ffi_closure_VFP)
+
+/* Load values returned in registers for both closure entry points.
+   Note that we use LDM with SP in the register set.  This is deprecated
+   by ARM, but not yet unpredictable.  */
+
+ARM_FUNC_START_LOCAL(ffi_closure_ret)
+	cfi_startproc
+	cfi_rel_offset(sp, 0)
+	cfi_rel_offset(lr, 4)
+0:
+E(ARM_TYPE_VFP_S)
+	ldc	p10, cr0, [r2]			@ vldr s0, [r2]
+	b	call_epilogue
+E(ARM_TYPE_VFP_D)
+	ldc	p11, cr0, [r2]			@ vldr d0, [r2]
+	b	call_epilogue
+E(ARM_TYPE_VFP_N)
+	ldc	p11, cr0, [r2], {8}		@ vldm r2, {d0-d3}
+	b	call_epilogue
+E(ARM_TYPE_INT64)
+	ldr	r1, [r2, #4]
+	nop
+E(ARM_TYPE_INT)
+	ldr	r0, [r2]
+	b	call_epilogue
+E(ARM_TYPE_VOID)
+	b	call_epilogue
+	nop
+E(ARM_TYPE_STRUCT)
+	b	call_epilogue
+call_epilogue:
+#ifndef __thumb__
+	ldm	sp, {sp,pc}
+#else
+	ldm	sp, {ip,lr}
+	mov	sp, ip
+	bx	lr
+#endif
+	cfi_endproc
+ARM_FUNC_END(ffi_closure_ret)
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+ARM_FUNC_START(ffi_closure_SYSV_alt)
+	/* See the comments above trampoline_code_table. */
+	ldr	ip, [sp, #4]			/* Load closure in ip */
+	add	sp, sp, 8			/* Restore the stack */
+	b	CNAME(ffi_closure_SYSV)
+ARM_FUNC_END(ffi_closure_SYSV_alt)
+
+ARM_FUNC_START(ffi_closure_VFP_alt)
+	/* See the comments above trampoline_code_table. */
+	ldr	ip, [sp, #4]			/* Load closure in ip */
+	add	sp, sp, 8			/* Restore the stack */
+	b	CNAME(ffi_closure_VFP)
+ARM_FUNC_END(ffi_closure_VFP_alt)
+
+/*
+ * Below is the definition of the trampoline code table. Each element in
+ * the code table is a trampoline.
+ */
+/*
+ * The trampoline uses register ip (r12). It saves the original value of ip
+ * on the stack.
+ *
+ * The trampoline has two parameters - target code to jump to and data for
+ * the target code. The trampoline extracts the parameters from its parameter
+ * block (see tramp_table_map()). The trampoline saves the data address on
+ * the stack. Finally, it jumps to the target code.
+ *
+ * The target code can choose to:
+ *
+ * - restore the value of ip
+ * - load the data address in a register
+ * - restore the stack pointer to what it was when the trampoline was invoked.
+ */
+	.align	ARM_TRAMP_MAP_SHIFT
+ARM_FUNC_START(trampoline_code_table)
+	.rept	ARM_TRAMP_MAP_SIZE / ARM_TRAMP_SIZE
+	sub	sp, sp, #8		/* Make space on the stack */
+	str	ip, [sp]		/* Save ip on stack */
+	ldr	ip, [pc, #4080]		/* Copy data into ip */
+	str	ip, [sp, #4]		/* Save data on stack */
+	ldr	pc, [pc, #4076]		/* Copy code into PC */
+	.endr
+ARM_FUNC_END(trampoline_code_table)
+	.align	ARM_TRAMP_MAP_SHIFT
+#endif /* FFI_EXEC_STATIC_TRAMP */
+
+#endif /* FFI_CLOSURES */
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#include <mach/machine/vm_param.h>
+
+.align	PAGE_MAX_SHIFT
+ARM_FUNC_START(ffi_closure_trampoline_table_page)
+.rept	PAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE
+	adr ip, #-PAGE_MAX_SIZE   @ the config page is PAGE_MAX_SIZE behind the trampoline page
+	sub ip, #8				  @ account for pc bias
+	ldr	pc, [ip, #4]		  @ jump to ffi_closure_SYSV or ffi_closure_VFP
+.endr
+ARM_FUNC_END(ffi_closure_trampoline_table_page)
+#endif
+
+#elif defined(_WIN32)
+
+ARM_FUNC_START(ffi_arm_trampoline)
+0:	adr	ip, 0b
+	stmdb	sp!, {r0, ip}
+	ldr	pc, 1f
+1:	.long	0
+ARM_FUNC_END(ffi_arm_trampoline)
+
+#else
+
+ARM_FUNC_START(ffi_arm_trampoline)
+0:	adr	ip, 0b
+	ldr	pc, 1f
+1:	.long	0
+ARM_FUNC_END(ffi_arm_trampoline)
+
+#endif /* FFI_EXEC_TRAMPOLINE_TABLE */
+#endif /* __arm__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",%progbits
+#endif
Index: libffi-3.4.6/src/arm/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arm/internal.h b/libffi-3.4.6/src/arm/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arm/internal.h	
@@ -0,0 +1,17 @@
+#define ARM_TYPE_VFP_S	0
+#define ARM_TYPE_VFP_D	1
+#define ARM_TYPE_VFP_N	2
+#define ARM_TYPE_INT64	3
+#define ARM_TYPE_INT	4
+#define ARM_TYPE_VOID	5
+#define ARM_TYPE_STRUCT	6
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+/*
+ * For the trampoline table mapping, a mapping size of 4K (base page size)
+ * is chosen.
+ */
+#define ARM_TRAMP_MAP_SHIFT	12
+#define ARM_TRAMP_MAP_SIZE	(1 << ARM_TRAMP_MAP_SHIFT)
+#define ARM_TRAMP_SIZE		20
+#endif
Index: libffi-3.4.6/src/arm/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arm/ffitarget.h b/libffi-3.4.6/src/arm/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arm/ffitarget.h	
@@ -0,0 +1,89 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 2010  CodeSourcery
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+
+   Target configuration macros for ARM.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_VFP,
+  FFI_LAST_ABI,
+#if defined(__ARM_PCS_VFP) || defined(_WIN32)
+  FFI_DEFAULT_ABI = FFI_VFP,
+#else
+  FFI_DEFAULT_ABI = FFI_SYSV,
+#endif
+} ffi_abi;
+#endif
+
+#define FFI_EXTRA_CIF_FIELDS			\
+  int vfp_used;					\
+  unsigned short vfp_reg_free, vfp_nargs;	\
+  signed char vfp_args[16]			\
+
+#define FFI_TARGET_SPECIFIC_VARIADIC
+#ifndef _WIN32
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#if defined (FFI_EXEC_TRAMPOLINE_TABLE) && FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#define FFI_TRAMPOLINE_SIZE 12
+#define FFI_TRAMPOLINE_CLOSURE_OFFSET 8
+#else
+#error "No trampoline table implementation"
+#endif
+
+#else
+#ifdef _WIN32
+#define FFI_TRAMPOLINE_SIZE 16
+#define FFI_TRAMPOLINE_CLOSURE_FUNCTION 12
+#else
+#define FFI_TRAMPOLINE_SIZE 12
+#endif
+#define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE
+#endif
+
+#endif
Index: libffi-3.4.6/src/arm/sysv_msvc_arm32.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/arm/sysv_msvc_arm32.S b/libffi-3.4.6/src/arm/sysv_msvc_arm32.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/arm/sysv_msvc_arm32.S	
@@ -0,0 +1,311 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 1998, 2008, 2011 Red Hat, Inc.
+        Copyright (c) 2011 Plausible Labs Cooperative, Inc.
+        Copyright (c) 2019 Microsoft Corporation.
+
+   ARM Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+#include "ksarm.h"
+
+
+        ; 8 byte aligned AREA to support 8 byte aligned jump tables
+        MACRO
+        NESTED_ENTRY_FFI $FuncName, $AreaName, $ExceptHandler
+
+        ; compute the function's labels
+        __DeriveFunctionLabels $FuncName
+
+        ; determine the area we will put the function into
+__FuncArea   SETS    "|.text|"
+        IF "$AreaName" != ""
+__FuncArea   SETS    "$AreaName"
+        ENDIF
+
+        ; set up the exception handler itself
+__FuncExceptionHandler SETS ""
+        IF "$ExceptHandler" != ""
+__FuncExceptionHandler SETS    "|$ExceptHandler|"
+        ENDIF
+
+        ; switch to the specified area, jump tables require 8 byte alignment
+        AREA    $__FuncArea,CODE,CODEALIGN,ALIGN=3,READONLY
+
+        ; export the function name
+        __ExportProc $FuncName
+
+        ; flush any pending literal pool stuff
+        ROUT
+
+        ; reset the state of the unwind code tracking
+        __ResetUnwindState
+
+        MEND
+
+;        MACRO
+;        TABLE_ENTRY $Type, $Table
+;$Type_$Table
+;        MEND
+
+#define E(index,table) return_##index##_##table
+
+    ; r0:   stack
+    ; r1:   frame
+    ; r2:   fn
+    ; r3:   vfp_used
+
+    ; fake entry point exists only to generate exists only to 
+    ; generate .pdata for exception unwinding
+    NESTED_ENTRY_FFI ffi_call_VFP_fake
+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind
+
+    ALTERNATE_ENTRY ffi_call_VFP
+    cmp    r3, #3                   ; load only d0 if possible
+    vldrle d0, [r0]
+    vldmgt r0, {d0-d7}
+    add    r0, r0, #64              ; discard the vfp register args
+    b ffi_call_SYSV
+    NESTED_END ffi_call_VFP_fake
+
+    ; fake entry point exists only to generate exists only to 
+    ; generate .pdata for exception unwinding
+    NESTED_ENTRY_FFI ffi_call_SYSV_fake
+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind
+
+    ALTERNATE_ENTRY ffi_call_SYSV
+    stm    r1, {fp, lr}
+    mov    fp, r1
+
+    mov    sp, r0                   ; install the stack pointer
+    mov    lr, r2                   ; move the fn pointer out of the way
+    ldr    ip, [fp, #16]            ; install the static chain
+    ldmia  sp!, {r0-r3}             ; move first 4 parameters in registers.
+    blx    lr                       ; call fn
+
+    ; Load r2 with the pointer to storage for the return value
+    ; Load r3 with the return type code
+    ldr    r2, [fp, #8]
+    ldr    r3, [fp, #12]
+
+    ; Deallocate the stack with the arguments.
+    mov    sp, fp
+
+    ; Store values stored in registers.
+    ALIGN 8
+    lsl     r3, #3
+    add     r3, r3, pc
+    add     r3, #8
+    mov     pc, r3
+
+
+E(ARM_TYPE_VFP_S, ffi_call)
+    ALIGN 8
+    vstr s0, [r2]
+    pop    {fp,pc}
+E(ARM_TYPE_VFP_D, ffi_call)
+    ALIGN 8
+    vstr d0, [r2]
+    pop    {fp,pc}
+E(ARM_TYPE_VFP_N, ffi_call)
+    ALIGN 8
+    vstm r2, {d0-d3}
+    pop    {fp,pc}
+E(ARM_TYPE_INT64, ffi_call)
+    ALIGN 8
+    str    r1, [r2, #4]
+    nop
+E(ARM_TYPE_INT, ffi_call)
+    ALIGN 8
+    str    r0, [r2]
+    pop    {fp,pc}
+E(ARM_TYPE_VOID, ffi_call)
+    ALIGN 8
+    pop    {fp,pc}
+    nop
+E(ARM_TYPE_STRUCT, ffi_call)
+    ALIGN 8
+    cmp r3, #ARM_TYPE_STRUCT
+    pop    {fp,pc}
+    NESTED_END ffi_call_SYSV_fake
+
+    IMPORT |ffi_closure_inner_SYSV|
+    /*
+    int ffi_closure_inner_SYSV
+    (
+        cif,        ; r0
+        fun,        ; r1
+        user_data,  ; r2
+        frame       ; r3
+    )
+    */
+
+    NESTED_ENTRY_FFI ffi_go_closure_SYSV
+    stmdb   sp!, {r0-r3}            ; save argument regs
+    ldr     r0, [ip, #4]            ; load cif
+    ldr     r1, [ip, #8]            ; load fun
+    mov     r2, ip                  ; load user_data
+    b       ffi_go_closure_SYSV_0
+    NESTED_END ffi_go_closure_SYSV
+
+    ; r3:    ffi_closure
+
+    ; fake entry point exists only to generate exists only to 
+    ; generate .pdata for exception unwinding
+    NESTED_ENTRY_FFI ffi_closure_SYSV_fake  
+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind
+    ALTERNATE_ENTRY ffi_closure_SYSV
+    ldmfd   sp!, {ip,r0}            ; restore fp (r0 is used for stack alignment)
+    stmdb   sp!, {r0-r3}            ; save argument regs
+
+    ldr     r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]    ; ffi_closure->cif
+    ldr     r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  ; ffi_closure->fun
+    ldr     r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  ; ffi_closure->user_data
+
+    ALTERNATE_ENTRY ffi_go_closure_SYSV_0
+    add     ip, sp, #16             ; compute entry sp
+
+    sub     sp, sp, #64+32          ; allocate frame parameter (sizeof(vfp_space) = 64, sizeof(result) = 32)
+    mov     r3, sp                  ; set frame parameter
+    stmdb   sp!, {ip,lr}
+
+    bl      ffi_closure_inner_SYSV  ; call the Python closure
+
+                                    ; Load values returned in registers.
+    add     r2, sp, #64+8           ; address of closure_frame->result
+    bl      ffi_closure_ret         ; move result to correct register or memory for type
+
+    ldmfd   sp!, {ip,lr}
+    mov     sp, ip                  ; restore stack pointer
+    mov     pc, lr
+    NESTED_END ffi_closure_SYSV_fake
+
+    IMPORT |ffi_closure_inner_VFP|
+    /*
+    int ffi_closure_inner_VFP
+    (
+        cif,        ; r0
+        fun,        ; r1
+        user_data,  ; r2
+        frame       ; r3
+    )
+    */
+
+    NESTED_ENTRY_FFI ffi_go_closure_VFP
+    stmdb   sp!, {r0-r3}			; save argument regs
+    ldr	r0, [ip, #4]			; load cif
+    ldr	r1, [ip, #8]			; load fun
+    mov	r2, ip				; load user_data
+    b	ffi_go_closure_VFP_0
+    NESTED_END ffi_go_closure_VFP
+
+    ; fake entry point exists only to generate exists only to 
+    ; generate .pdata for exception unwinding
+    ; r3:    closure
+    NESTED_ENTRY_FFI ffi_closure_VFP_fake
+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind
+
+    ALTERNATE_ENTRY ffi_closure_VFP
+    ldmfd   sp!, {ip,r0}            ; restore fp (r0 is used for stack alignment)
+    stmdb   sp!, {r0-r3}            ; save argument regs
+
+    ldr     r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]    ; load cif
+    ldr     r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  ; load fun
+    ldr     r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  ; load user_data
+
+    ALTERNATE_ENTRY ffi_go_closure_VFP_0
+    add     ip, sp, #16             ; compute entry sp
+    sub     sp, sp, #32             ; save space for closure_frame->result
+    vstmdb  sp!, {d0-d7}            ; push closure_frame->vfp_space
+
+    mov     r3, sp                  ; save closure_frame
+    stmdb   sp!, {ip,lr}
+
+    bl      ffi_closure_inner_VFP
+
+    ; Load values returned in registers.
+    add     r2, sp, #64+8           ; load result
+    bl      ffi_closure_ret
+    ldmfd   sp!, {ip,lr}
+    mov     sp, ip                  ; restore stack pointer
+    mov     pc, lr
+    NESTED_END ffi_closure_VFP_fake
+
+/* Load values returned in registers for both closure entry points.
+   Note that we use LDM with SP in the register set.  This is deprecated
+   by ARM, but not yet unpredictable.  */
+
+    NESTED_ENTRY_FFI ffi_closure_ret
+    stmdb sp!, {fp,lr}
+
+    ALIGN 8
+    lsl     r0, #3
+    add     r0, r0, pc
+    add     r0, #8
+    mov     pc, r0
+
+E(ARM_TYPE_VFP_S, ffi_closure)
+    ALIGN 8
+    vldr s0, [r2]
+    b call_epilogue
+E(ARM_TYPE_VFP_D, ffi_closure)
+    ALIGN 8
+    vldr d0, [r2]
+    b call_epilogue
+E(ARM_TYPE_VFP_N, ffi_closure)
+    ALIGN 8
+    vldm r2, {d0-d3}
+    b call_epilogue
+E(ARM_TYPE_INT64, ffi_closure)
+    ALIGN 8
+    ldr    r1, [r2, #4]
+    nop
+E(ARM_TYPE_INT, ffi_closure)
+    ALIGN 8
+    ldr    r0, [r2]
+    b call_epilogue
+E(ARM_TYPE_VOID, ffi_closure)
+    ALIGN 8
+    b call_epilogue
+    nop
+E(ARM_TYPE_STRUCT, ffi_closure)
+    ALIGN 8
+    b call_epilogue
+call_epilogue
+    ldmfd sp!, {fp,pc}
+    NESTED_END ffi_closure_ret
+
+    AREA |.trampoline|, DATA, THUMB, READONLY
+    EXPORT |ffi_arm_trampoline|
+|ffi_arm_trampoline| DATA
+thisproc    adr    ip, thisproc
+            stmdb  sp!, {ip, r0}
+            ldr    pc, [pc, #0]
+            DCD    0
+            ;ENDP
+
+    END
\ No newline at end of file
Index: libffi-3.4.6/src/frv/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/frv/ffi.c b/libffi-3.4.6/src/frv/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/frv/ffi.c	
@@ -0,0 +1,292 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (C) 2004  Anthony Green
+   Copyright (C) 2007  Free Software Foundation, Inc.
+	   Copyright (C) 2008  Red Hat, Inc.
+   
+   FR-V Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void *ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  register unsigned int i;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+  register int count = 0;
+
+  p_argv = ecif->avalue;
+  argp = stack;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       (i != 0);
+       i--, p_arg++)
+    {
+      size_t z;
+      
+      z = (*p_arg)->size;
+
+      if ((*p_arg)->type == FFI_TYPE_STRUCT)
+	{
+	  z = sizeof(void*);
+	  *(void **) argp = *p_argv;
+	} 
+      /*      if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	{
+	  if (count > 24)
+	    {
+	      // This is going on the stack.  Turn it into a double.  
+	      *(double *) argp = (double) *(float*)(* p_argv);
+	      z = sizeof(double);
+	    }
+	  else
+	    *(void **) argp = *(void **)(* p_argv);
+	}  */
+      else if (z < sizeof(int))
+	{
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+	      break;
+	      
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+	      break;
+	      
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+	      break;
+		  
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+	      break;
+		  
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	}
+      else if (z == sizeof(int))
+	{
+	  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	}
+      else
+	{
+	  memcpy(argp, *p_argv, z);
+	}
+      p_argv++;
+      argp += z;
+      count += z;
+    }
+
+  return (stack + ((count > 24) ? 24 : FFI_ALIGN_DOWN(count, 8)));
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    cif->flags = -1;
+  else
+    cif->flags = cif->rtype->size;
+
+  cif->bytes = FFI_ALIGN (cif->bytes, 8);
+
+  return FFI_OK;
+}
+
+extern void ffi_call_EABI(void *(*)(char *, extended_cif *), 
+			  extended_cif *, 
+			  unsigned, unsigned, 
+			  unsigned *, 
+			  void (*fn)(void));
+
+void ffi_call(ffi_cif *cif, 
+	      void (*fn)(void), 
+	      void *rvalue, 
+	      void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if ((rvalue == NULL) && 
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+    
+  
+  switch (cif->abi) 
+    {
+    case FFI_EABI:
+      ffi_call_EABI(ffi_prep_args, &ecif, cif->bytes, 
+		    cif->flags, ecif.rvalue, fn);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,
+		       unsigned arg4, unsigned arg5, unsigned arg6)
+{
+  /* This function is called by a trampoline.  The trampoline stows a
+     pointer to the ffi_closure object in gr7.  We must save this
+     pointer in a place that will persist while we do our work.  */
+  register ffi_closure *creg __asm__ ("gr7");
+  ffi_closure *closure = creg;
+
+  /* Arguments that don't fit in registers are found on the stack
+     at a fixed offset above the current frame pointer.  */
+  register char *frame_pointer __asm__ ("fp");
+  char *stack_args = frame_pointer + 16;
+
+  /* Lay the register arguments down in a continuous chunk of memory.  */
+  unsigned register_args[6] =
+    { arg1, arg2, arg3, arg4, arg5, arg6 };
+
+  ffi_cif *cif = closure->cif;
+  ffi_type **arg_types = cif->arg_types;
+  void **avalue = alloca (cif->nargs * sizeof(void *));
+  char *ptr = (char *) register_args;
+  int i;
+
+  /* Find the address of each argument.  */
+  for (i = 0; i < cif->nargs; i++)
+    {
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  avalue[i] = ptr + 3;
+	  break;
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  avalue[i] = ptr + 2;
+	  break;
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_FLOAT:
+	  avalue[i] = ptr;
+	  break;
+	case FFI_TYPE_STRUCT:
+	  avalue[i] = *(void**)ptr;
+	  break;
+	default:
+	  /* This is an 8-byte value.  */
+	  avalue[i] = ptr;
+	  ptr += 4;
+	  break;
+	}
+      ptr += 4;
+
+      /* If we've handled more arguments than fit in registers,
+	 start looking at the those passed on the stack.  */
+      if (ptr == ((char *)register_args + (6*4)))
+	ptr = stack_args;
+    }
+
+  /* Invoke the closure.  */
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+      /* The caller allocates space for the return structure, and
+       passes a pointer to this space in gr3.  Use this value directly
+       as the return value.  */
+      register void *return_struct_ptr __asm__("gr3");
+      (closure->fun) (cif, return_struct_ptr, avalue, closure->user_data);
+    }
+  else
+    {
+      /* Allocate space for the return value and call the function.  */
+      long long rvalue;
+      (closure->fun) (cif, &rvalue, avalue, closure->user_data);
+
+      /* Functions return 4-byte or smaller results in gr8.  8-byte
+	 values also use gr9.  We fill the both, even for small return
+	 values, just to avoid a branch.  */ 
+      asm ("ldi  @(%0, #0), gr8" : : "r" (&rvalue));
+      asm ("ldi  @(%0, #0), gr9" : : "r" (&((int *) &rvalue)[1]));
+    }
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+  unsigned long fn = (long) ffi_closure_eabi;
+  unsigned long cls = (long) codeloc;
+#ifdef __FRV_FDPIC__
+  register void *got __asm__("gr15");
+#endif
+  int i;
+
+  fn = (unsigned long) ffi_closure_eabi;
+
+#ifdef __FRV_FDPIC__
+  tramp[0] = &((unsigned int *)codeloc)[2];
+  tramp[1] = got;
+  tramp[2] = 0x8cfc0000 + (fn  & 0xffff); /* setlos lo(fn), gr6    */
+  tramp[3] = 0x8efc0000 + (cls & 0xffff); /* setlos lo(cls), gr7   */
+  tramp[4] = 0x8cf80000 + (fn  >> 16);	  /* sethi hi(fn), gr6     */
+  tramp[5] = 0x8ef80000 + (cls >> 16);    /* sethi hi(cls), gr7    */
+  tramp[6] = 0x9cc86000;                  /* ldi @(gr6, #0), gr14  */
+  tramp[7] = 0x8030e000;                  /* jmpl @(gr14, gr0)     */
+#else
+  tramp[0] = 0x8cfc0000 + (fn  & 0xffff); /* setlos lo(fn), gr6    */
+  tramp[1] = 0x8efc0000 + (cls & 0xffff); /* setlos lo(cls), gr7   */
+  tramp[2] = 0x8cf80000 + (fn  >> 16);	  /* sethi hi(fn), gr6     */
+  tramp[3] = 0x8ef80000 + (cls >> 16);    /* sethi hi(cls), gr7    */
+  tramp[4] = 0x80300006;                  /* jmpl @(gr0, gr6)      */
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  /* Cache flushing.  */
+  for (i = 0; i < FFI_TRAMPOLINE_SIZE; i++)
+    __asm__ volatile ("dcf @(%0,%1)\n\tici @(%2,%1)" :: "r" (tramp), "r" (i),
+		      "r" (codeloc));
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/frv/eabi.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/frv/eabi.S b/libffi-3.4.6/src/frv/eabi.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/frv/eabi.S	
@@ -0,0 +1,128 @@
+/* -----------------------------------------------------------------------
+   eabi.S - Copyright (c) 2004  Anthony Green
+   
+   FR-V Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.globl ffi_prep_args_EABI
+
+	.text
+	.p2align 4
+	.globl ffi_call_EABI
+	.type ffi_call_EABI, @function
+
+	# gr8 :   ffi_prep_args
+	# gr9 :   &ecif
+	# gr10:   cif->bytes
+	# gr11:   fig->flags
+	# gr12:   ecif.rvalue
+	# gr13:   fn
+	
+ffi_call_EABI:	
+	addi	sp, #-80, sp
+	sti	fp, @(sp, #24)
+	addi	sp, #24, fp
+	movsg	lr, gr5
+
+	/* Make room for the new arguments.  */
+	/* subi	sp, fp, gr10 */
+	
+	/* Store return address and incoming args on stack.  */
+	sti	gr5, @(fp, #8)
+	sti	gr8, @(fp, #-4)
+	sti	gr9, @(fp, #-8)
+	sti	gr10, @(fp, #-12)
+	sti	gr11, @(fp, #-16)
+	sti	gr12, @(fp, #-20)
+	sti	gr13, @(fp, #-24)
+
+	sub     sp, gr10, sp
+	
+	/* Call ffi_prep_args.  */
+	ldi	@(fp, #-4), gr4
+	addi	sp, #0, gr8
+	ldi	@(fp, #-8), gr9
+#ifdef __FRV_FDPIC__
+	ldd	@(gr4, gr0), gr14
+	calll	@(gr14, gr0)
+#else
+	calll	@(gr4, gr0)
+#endif	
+
+	/* ffi_prep_args returns the new stack pointer.  */
+	mov	gr8, gr4
+		
+	ldi	@(sp, #0), gr8
+	ldi	@(sp, #4), gr9
+	ldi	@(sp, #8), gr10
+	ldi	@(sp, #12), gr11
+	ldi	@(sp, #16), gr12
+	ldi	@(sp, #20), gr13
+
+	/* Always copy the return value pointer into the hidden
+	   parameter register.  This is only strictly necessary
+	   when we're returning an aggregate type, but it doesn't
+	   hurt to do this all the time, and it saves a branch.  */
+	ldi	@(fp, #-20), gr3
+
+	/* Use the ffi_prep_args return value for the new sp.  */
+	mov	gr4, sp
+	
+	/* Call the target function.  */
+	ldi	@(fp, -24), gr4
+#ifdef __FRV_FDPIC__
+	ldd	@(gr4, gr0), gr14
+	calll	@(gr14, gr0)
+#else
+	calll	@(gr4, gr0)
+#endif	
+
+	/* Store the result. */
+	ldi	@(fp, #-16), gr10  /* fig->flags */
+	ldi	@(fp, #-20), gr4   /* ecif.rvalue */
+
+	/* Is the return value stored in two registers?  */
+	cmpi	gr10, #8, icc0
+	bne	icc0, 0, .L2
+	/*   Yes, save them.  */
+	sti	gr8, @(gr4, #0)
+	sti	gr9, @(gr4, #4)
+	bra	.L3
+.L2:
+	/* Is the return value a structure?  */
+	cmpi	gr10, #-1, icc0
+	beq	icc0, 0, .L3
+	/*   No, save a 4 byte return value.  */
+	sti	gr8, @(gr4, #0)
+.L3:	
+
+	/* Restore the stack, and return.  */
+	ldi	@(fp, 8), gr5
+	ld	@(fp, gr0), fp
+	addi	sp,#80,sp
+	jmpl	@(gr5,gr0)
+	.size ffi_call_EABI, .-ffi_call_EABI
+	
Index: libffi-3.4.6/src/frv/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/frv/ffitarget.h b/libffi-3.4.6/src/frv/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/frv/ffitarget.h	
@@ -0,0 +1,62 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2004  Red Hat, Inc.
+   Target configuration macros for FR-V
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_EABI,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_EABI
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#ifdef __FRV_FDPIC__
+/* Trampolines are 8 4-byte instructions long.  */
+#define FFI_TRAMPOLINE_SIZE (8*4)
+#else
+/* Trampolines are 5 4-byte instructions long.  */
+#define FFI_TRAMPOLINE_SIZE (5*4)
+#endif
+
+#endif
Index: libffi-3.4.6/src/kvx/asm.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/kvx/asm.h b/libffi-3.4.6/src/kvx/asm.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/kvx/asm.h	
@@ -0,0 +1,5 @@
+/* args are passed on registers from r0 up to r11 => 12*8 bytes */
+#define REG_ARGS_SIZE (12*8)
+#define KVX_REGISTER_SIZE (8)
+#define KVX_ABI_SLOT_SIZE (KVX_REGISTER_SIZE)
+#define KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE (4*KVX_ABI_SLOT_SIZE)
Index: libffi-3.4.6/src/kvx/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/kvx/ffi.c b/libffi-3.4.6/src/kvx/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/kvx/ffi.c	
@@ -0,0 +1,273 @@
+/* Copyright (c) 2020 Kalray
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#if defined(__kvx__)
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <fficonfig.h>
+#include <ffi.h>
+#include "ffi_common.h"
+#include "asm.h"
+
+#define ALIGN(x, a) ALIGN_MASK(x, (typeof(x))(a) - 1)
+#define ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
+#define KVX_ABI_STACK_ALIGNMENT (32)
+#define KVX_ABI_STACK_ARG_ALIGNMENT (8)
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+#ifdef FFI_DEBUG
+#define DEBUG_PRINT(...) do{ fprintf( stderr, __VA_ARGS__ ); } while(0)
+#else
+#define DEBUG_PRINT(...)
+#endif
+
+struct ret_value {
+	unsigned long int r0;
+	unsigned long int r1;
+	unsigned long int r2;
+	unsigned long int r3;
+};
+
+extern struct ret_value ffi_call_SYSV(unsigned total_size,
+                                      unsigned size,
+                                      extended_cif *ecif,
+                                      unsigned *rvalue_addr,
+                                      void *fn,
+                                      unsigned int_ext_method);
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  cif->flags = cif->rtype->size;
+  return FFI_OK;
+}
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void *ffi_prep_args(char *stack, unsigned int arg_slots_size, extended_cif *ecif)
+{
+  char *stacktemp = stack;
+  char *current_arg_passed_by_value = stack + arg_slots_size;
+  int i, s;
+  ffi_type **arg;
+  int count = 0;
+  ffi_cif *cif = ecif->cif;
+  void **argv = ecif->avalue;
+
+  arg = cif->arg_types;
+
+  DEBUG_PRINT("stack: %p\n", stack);
+  DEBUG_PRINT("arg_slots_size: %u\n", arg_slots_size);
+  DEBUG_PRINT("current_arg_passed_by_value: %p\n", current_arg_passed_by_value);
+  DEBUG_PRINT("ecif: %p\n", ecif);
+  DEBUG_PRINT("ecif->avalue: %p\n", ecif->avalue);
+
+  for (i = 0; i < cif->nargs; i++) {
+
+    s = KVX_ABI_SLOT_SIZE;
+    switch((*arg)->type) {
+      case FFI_TYPE_SINT8:
+      case FFI_TYPE_UINT8:
+      case FFI_TYPE_SINT16:
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_FLOAT:
+      case FFI_TYPE_DOUBLE:
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+      case FFI_TYPE_POINTER:
+        DEBUG_PRINT("INT64/32/16/8/FLOAT/DOUBLE or POINTER @%p\n", stack);
+        *(uint64_t *) stack = *(uint64_t *)(* argv);
+        break;
+
+      case FFI_TYPE_COMPLEX:
+        if ((*arg)->size == 8)
+          *(_Complex float *) stack = *(_Complex float *)(* argv);
+        else if ((*arg)->size == 16) {
+          *(_Complex double *) stack = *(_Complex double *)(* argv);
+          s = 16;
+        } else
+          abort();
+        break;
+      case FFI_TYPE_STRUCT: {
+        char *value;
+        unsigned int written_size = 0;
+        DEBUG_PRINT("struct by value @%p\n", stack);
+        if ((*arg)->size > KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE) {
+          DEBUG_PRINT("big struct\n");
+          *(uint64_t *) stack = (uintptr_t)current_arg_passed_by_value;
+          value = current_arg_passed_by_value;
+          current_arg_passed_by_value += (*arg)->size;
+          written_size = KVX_ABI_SLOT_SIZE;
+        } else {
+          value = stack;
+          written_size = (*arg)->size;
+        }
+        memcpy(value, *argv, (*arg)->size);
+        s = ALIGN(written_size, KVX_ABI_STACK_ARG_ALIGNMENT);
+        break;
+      }
+      default:
+        printf("Error: unsupported arg type %d\n", (*arg)->type);
+        abort();
+        break;
+
+    }
+    stack += s;
+    count += s;
+    argv++;
+    arg++;
+  }
+#ifdef FFI_DEBUG
+  FFI_ASSERT(((intptr_t)(stacktemp + REG_ARGS_SIZE) & (KVX_ABI_STACK_ALIGNMENT-1)) == 0);
+#endif
+  return stacktemp + REG_ARGS_SIZE;
+}
+
+/* Perform machine dependent cif processing when we have a variadic function */
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,
+                                    unsigned int ntotalargs)
+{
+  cif->flags = cif->rtype->size;
+  return FFI_OK;
+}
+
+static unsigned long handle_small_int_ext(kvx_intext_method *int_ext_method,
+                                          const ffi_type *rtype)
+{
+  switch (rtype->type) {
+    case FFI_TYPE_SINT8:
+      *int_ext_method = KVX_RET_SXBD;
+      return KVX_REGISTER_SIZE;
+
+    case FFI_TYPE_SINT16:
+      *int_ext_method = KVX_RET_SXHD;
+      return KVX_REGISTER_SIZE;
+
+    case FFI_TYPE_SINT32:
+      *int_ext_method = KVX_RET_SXWD;
+      return KVX_REGISTER_SIZE;
+
+    case FFI_TYPE_UINT8:
+      *int_ext_method = KVX_RET_ZXBD;
+      return KVX_REGISTER_SIZE;
+
+    case FFI_TYPE_UINT16:
+      *int_ext_method = KVX_RET_ZXHD;
+      return KVX_REGISTER_SIZE;
+
+    case FFI_TYPE_UINT32:
+      *int_ext_method = KVX_RET_ZXWD;
+      return KVX_REGISTER_SIZE;
+
+    default:
+      *int_ext_method = KVX_RET_NONE;
+      return rtype->size;
+  }
+}
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  int i;
+  unsigned long int slot_fitting_args_size = 0;
+  unsigned long int total_size = 0;
+  unsigned long int big_struct_size = 0;
+  kvx_intext_method int_extension_method;
+  ffi_type **arg;
+  struct ret_value local_rvalue = {0};
+  size_t wb_size;
+
+
+  /* Calculate size to allocate on stack */
+  for (i = 0, arg = cif->arg_types; i < cif->nargs; i++, arg++) {
+    DEBUG_PRINT("argument %d, type %d, size %lu\n", i, (*arg)->type, (*arg)->size);
+    if (((*arg)->type == FFI_TYPE_STRUCT) || ((*arg)->type == FFI_TYPE_COMPLEX)) {
+      if ((*arg)->size <= KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE) {
+        slot_fitting_args_size += ALIGN((*arg)->size, KVX_ABI_SLOT_SIZE);
+      } else {
+        slot_fitting_args_size += KVX_ABI_SLOT_SIZE; /* aggregate passed by reference */
+        big_struct_size += ALIGN((*arg)->size, KVX_ABI_SLOT_SIZE);
+      }
+    } else if ((*arg)->size <= KVX_ABI_SLOT_SIZE) {
+      slot_fitting_args_size += KVX_ABI_SLOT_SIZE;
+    } else {
+      printf("Error: unsupported arg size %ld arg type %d\n", (*arg)->size, (*arg)->type);
+      abort(); /* should never happen? */
+    }
+  }
+
+  extended_cif ecif;
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  ecif.rvalue = rvalue;
+
+  /* This implementation allocates anyway for all register based args */
+  slot_fitting_args_size = max(slot_fitting_args_size, REG_ARGS_SIZE);
+  total_size = slot_fitting_args_size + big_struct_size;
+  total_size = ALIGN(total_size, KVX_ABI_STACK_ALIGNMENT);
+
+  /* wb_size: write back size, the size we will need to write back to user
+   * provided buffer. In theory it should always be cif->flags which is
+   * cif->rtype->size. But libffi API mandates that for integral types
+   * of size <= system register size, then we *MUST* write back
+   * the size of system register size.
+   * in our case, if size <= 8 bytes we must write back 8 bytes.
+   * floats, complex and structs are not affected, only integrals.
+   */
+  wb_size = handle_small_int_ext(&int_extension_method, cif->rtype);
+
+  switch (cif->abi) {
+    case FFI_SYSV:
+      DEBUG_PRINT("total_size: %lu\n", total_size);
+      DEBUG_PRINT("slot fitting args size: %lu\n", slot_fitting_args_size);
+      DEBUG_PRINT("rvalue: %p\n", rvalue);
+      DEBUG_PRINT("fn: %p\n", fn);
+      DEBUG_PRINT("rsize: %u\n", cif->flags);
+      DEBUG_PRINT("wb_size: %u\n", wb_size);
+      DEBUG_PRINT("int_extension_method: %u\n", int_extension_method);
+      local_rvalue = ffi_call_SYSV(total_size, slot_fitting_args_size,
+                                   &ecif, rvalue, fn, int_extension_method);
+      if ((cif->flags <= KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE)
+          && (cif->rtype->type != FFI_TYPE_VOID))
+        memcpy(rvalue, &local_rvalue, wb_size);
+      break;
+    default:
+      abort();
+      break;
+  }
+}
+
+/* Closures not supported yet */
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  return FFI_BAD_ABI;
+}
+
+#endif /* (__kvx__) */
Index: libffi-3.4.6/src/kvx/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/kvx/sysv.S b/libffi-3.4.6/src/kvx/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/kvx/sysv.S	
@@ -0,0 +1,127 @@
+/* Copyright (c) 2020 Kalray
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#if defined(__kvx__)
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include <kvx/asm.h>
+
+.text
+.global ffi_call_SYSV
+.type ffi_call_SYSV, @function
+.type ffi_prep_args, @function
+.align 8
+
+/* ffi_call_SYSV
+
+  r0: total size to allocate on stack
+  r1: size of arg slots
+  r2: extended cif structure, DO NOT REMOVE: it is used by ffi_prep_args()
+  r3: return value address
+  r4: function to call
+  r5: integer sign extension method to be used
+*/
+ffi_call_SYSV:
+	addd $r12 = $r12, -64
+	so (-32)[$r12] = $r20r21r22r23
+	;;
+	sd (0)[$r12] = $r24
+	;;
+	get $r23 = $ra
+	copyd $r20 = $r12
+	sbfd $r12 = $r0, $r12
+	;;
+	copyd $r0 = $r12
+	copyd $r21 = $r3
+	copyd $r22 = $r4
+	copyd $r24 = $r5
+	call ffi_prep_args
+	;;
+	lo $r8r9r10r11 = (64)[$r12]
+	;;
+	lo $r4r5r6r7 = (32)[$r12]
+	;;
+	lo $r0r1r2r3 = (0)[$r12]
+	copyd $r12 = $r0
+	/* $r15 is the register used by the ABI to return big (>32 bytes)
+	 * structs by value.
+	 * It is also referred to as the "struct register" in the ABI.
+	 */
+	copyd $r15 = $r21
+	icall $r22
+	;;
+	pcrel $r4 = @pcrel(.Ltable)
+	cb.deqz $r24 ? .Lend
+	;;
+	addx8d $r24 = $r24, $r4
+	;;
+	igoto $r24
+	;;
+.Ltable:
+0: /* we should never arrive here */
+	goto .Lerror
+	nop
+	;;
+1: /* Sign extend byte to double */
+	sxbd $r0 = $r0
+	goto .Lend
+	;;
+2: /* Sign extend half to double */
+	sxhd $r0 = $r0
+	goto .Lend
+	;;
+3: /* Sign extend word to double */
+	sxwd $r0 = $r0
+	goto .Lend
+	;;
+4: /* Zero extend byte to double */
+	zxbd $r0 = $r0
+	goto .Lend
+	;;
+5: /* Zero extend half to double */
+	zxhd $r0 = $r0
+	goto .Lend
+	;;
+6: /* Zero extend word to double */
+	zxwd $r0 = $r0
+	/* Fallthrough to .Lend */
+	;;
+.Lend:
+	ld $r24 = (0)[$r12]
+	;;
+	set $ra = $r23
+	lo $r20r21r22r23 = (32)[$r20]
+	addd $r12 = $r20, 64
+	;;
+	ret
+	;;
+.Lerror:
+	errop
+	;;
+
+#endif /* __kvx__ */
+
+#if defined __ELF__ && defined __linux__
+	.section .note.GNU-stack,"",%progbits
+#endif
+
Index: libffi-3.4.6/src/kvx/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/kvx/ffitarget.h b/libffi-3.4.6/src/kvx/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/kvx/ffitarget.h	
@@ -0,0 +1,75 @@
+/* -----------------------------------------------------------------------
+   ffitarget.h - Copyright (c) 2020 Kalray
+
+   KVX Target configuration macros
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source. Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+
+/* Those values are set depending on return type
+ * they are used in the assembly code in sysv.S
+ */
+typedef enum kvx_intext_method {
+  KVX_RET_NONE = 0,
+  KVX_RET_SXBD = 1,
+  KVX_RET_SXHD = 2,
+  KVX_RET_SXWD = 3,
+  KVX_RET_ZXBD = 4,
+  KVX_RET_ZXHD = 5,
+  KVX_RET_ZXWD = 6
+} kvx_intext_method;
+
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+/* This is only to allow Python to compile
+ * but closures are not supported yet
+ */
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 0
+
+#define FFI_NATIVE_RAW_API 0
+#define FFI_TARGET_SPECIFIC_VARIADIC 1
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+
+#endif
+
Index: libffi-3.4.6/src/vax/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/vax/ffi.c b/libffi-3.4.6/src/vax/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/vax/ffi.c	
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * vax Foreign Function Interface
+ *
+ * This file attempts to provide all the FFI entry points which can reliably
+ * be implemented in C.
+ */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+
+#define CIF_FLAGS_CHAR		1	/* for struct only */
+#define CIF_FLAGS_SHORT		2	/* for struct only */
+#define CIF_FLAGS_INT		4
+#define CIF_FLAGS_DINT		8
+
+/*
+ * Foreign Function Interface API
+ */
+
+void ffi_call_elfbsd (extended_cif *, unsigned, unsigned, void *,
+		       void (*) ());
+void *ffi_prep_args (extended_cif *ecif, void *stack);
+
+void *
+ffi_prep_args (extended_cif *ecif, void *stack)
+{
+  unsigned int i;
+  void **p_argv;
+  char *argp;
+  ffi_type **p_arg;
+  void *struct_value_ptr;
+
+  argp = stack;
+
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT
+      && !ecif->cif->flags)
+    struct_value_ptr = ecif->rvalue;
+  else
+    struct_value_ptr = NULL;
+
+  p_argv = ecif->avalue;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       i != 0;
+       i--, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      if (z < sizeof (int))
+	{
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_STRUCT:
+	      memcpy (argp, *p_argv, z);
+	      break;
+
+	    default:
+	      FFI_ASSERT (0);
+	    }
+	  z = sizeof (int);
+	}
+      else
+	{
+	  memcpy (argp, *p_argv, z);
+
+	  /* Align if necessary.  */
+	  if ((sizeof(int) - 1) & z)
+	    z = FFI_ALIGN(z, sizeof(int));
+	}
+
+      p_argv++;
+      argp += z;
+    }
+
+  return struct_value_ptr;
+}
+
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      cif->flags = 0;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      if (cif->rtype->elements[0]->type == FFI_TYPE_STRUCT &&
+	  cif->rtype->elements[1])
+	{
+	  cif->flags = 0;
+	  break;
+	}
+
+      if (cif->rtype->size == sizeof (char))
+	cif->flags = CIF_FLAGS_CHAR;
+      else if (cif->rtype->size == sizeof (short))
+	cif->flags = CIF_FLAGS_SHORT;
+      else if (cif->rtype->size == sizeof (int))
+	cif->flags = CIF_FLAGS_INT;
+      else if (cif->rtype->size == 2 * sizeof (int))
+	cif->flags = CIF_FLAGS_DINT;
+      else
+	cif->flags = 0;
+      break;
+
+    default:
+      if (cif->rtype->size <= sizeof (int))
+	cif->flags = CIF_FLAGS_INT;
+      else
+	cif->flags = CIF_FLAGS_DINT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return value
+     address then we need to make one.  */
+
+  if (rvalue == NULL
+      && cif->rtype->type == FFI_TYPE_STRUCT
+      && cif->flags == 0)
+    ecif.rvalue = alloca (cif->rtype->size);
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_ELFBSD:
+      ffi_call_elfbsd (&ecif, cif->bytes, cif->flags, ecif.rvalue, fn);
+      break;
+
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+/*
+ * Closure API
+ */
+
+void ffi_closure_elfbsd (void);
+void ffi_closure_struct_elfbsd (void);
+unsigned int ffi_closure_elfbsd_inner (ffi_closure *, void *, char *);
+
+static void
+ffi_prep_closure_elfbsd (ffi_cif *cif, void **avalue, char *stackp)
+{
+  unsigned int i;
+  void **p_argv;
+  ffi_type **p_arg;
+
+  p_argv = avalue;
+
+  for (i = cif->nargs, p_arg = cif->arg_types; i != 0; i--, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+      *p_argv = stackp;
+
+      /* Align if necessary */
+      if ((sizeof (int) - 1) & z)
+	z = FFI_ALIGN(z, sizeof (int));
+
+      p_argv++;
+      stackp += z;
+    }
+}
+
+unsigned int
+ffi_closure_elfbsd_inner (ffi_closure *closure, void *resp, char *stack)
+{
+  ffi_cif *cif;
+  void **arg_area;
+
+  cif = closure->cif;
+  arg_area = (void **) alloca (cif->nargs * sizeof (void *));
+
+  ffi_prep_closure_elfbsd (cif, arg_area, stack);
+
+  (closure->fun) (cif, resp, arg_area, closure->user_data);
+
+  return cif->flags;
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure, ffi_cif *cif,
+		      void (*fun)(ffi_cif *, void *, void **, void *),
+		      void *user_data, void *codeloc)
+{
+  char *tramp = (char *) codeloc;
+  void *fn;
+
+  FFI_ASSERT (cif->abi == FFI_ELFBSD);
+
+  /* entry mask */
+  *(unsigned short *)(tramp + 0) = 0x0000;
+  /* movl #closure, r0 */
+  tramp[2] = 0xd0;
+  tramp[3] = 0x8f;
+  *(unsigned int *)(tramp + 4) = (unsigned int) closure;
+  tramp[8] = 0x50;
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+      && !cif->flags)
+    fn = &ffi_closure_struct_elfbsd;
+  else
+    fn = &ffi_closure_elfbsd;
+
+  /* jmpl #fn */
+  tramp[9] = 0x17;
+  tramp[10] = 0xef;
+  *(unsigned int *)(tramp + 11) = (unsigned int)fn + 2 -
+				  (unsigned int)tramp - 9 - 6;
+
+  closure->cif = cif;
+  closure->user_data = user_data;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/vax/elfbsd.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/vax/elfbsd.S b/libffi-3.4.6/src/vax/elfbsd.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/vax/elfbsd.S	
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * vax Foreign Function Interface
+ */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.text
+
+/*
+ * void *					%r0
+ * ffi_call_elfbsd(extended_cif *ecif,		4(%ap)
+ *		   unsigned bytes,		8(%ap)
+ *		   unsigned flags,		12(%ap)
+ *		   void *rvalue,		16(%ap)
+ *		   void (*fn)());		20(%ap)
+ */
+	.globl	ffi_call_elfbsd
+	.type	ffi_call_elfbsd,@function
+	.align	2
+ffi_call_elfbsd:
+	.word	0x00c		# save R2 and R3
+
+	# Allocate stack space for the args
+	subl2	8(%ap), %sp
+
+	# Call ffi_prep_args
+	pushl	%sp
+	pushl	4(%ap)
+	calls	$2, ffi_prep_args
+
+	# Get function pointer
+	movl	20(%ap), %r1
+
+	# Build a CALLS frame
+	ashl	$-2, 8(%ap), %r0
+	pushl	%r0		# argument stack usage
+	movl	%sp, %r0	# future %ap
+	# saved registers
+	bbc	$11, 0(%r1), 1f
+	pushl	%r11
+1:	bbc	$10, 0(%r1), 1f
+	pushl	%r10
+1:	bbc	$9, 0(%r1), 1f
+	pushl	%r9
+1:	bbc	$8, 0(%r1), 1f
+	pushl	%r8
+1:	bbc	$7, 0(%r1), 1f
+	pushl	%r7
+1:	bbc	$6, 0(%r1), 1f
+	pushl	%r6
+1:	bbc	$5, 0(%r1), 1f
+	pushl	%r5
+1:	bbc	$4, 0(%r1), 1f
+	pushl	%r4
+1:	bbc	$3, 0(%r1), 1f
+	pushl	%r3
+1:	bbc	$2, 0(%r1), 1f
+	pushl	%r2
+1:	
+	pushal	9f
+	pushl	%fp
+	pushl	%ap
+	movl	16(%ap), %r3	# struct return address, if needed
+	movl	%r0, %ap
+	movzwl	4(%fp), %r0	# previous PSW, without the saved registers mask
+	bisl2	$0x20000000, %r0 # calls frame
+	movzwl	0(%r1), %r2
+	bicw2	$0xf003, %r2	# only keep R11-R2
+	ashl	$16, %r2, %r2
+	bisl2	%r2, %r0	# saved register mask of the called function
+	pushl	%r0	
+	pushl	$0
+	movl	%sp, %fp
+
+	# Invoke the function
+	pushal	2(%r1)		# skip procedure entry mask
+	movl	%r3, %r1
+	bicpsw	$0x000f
+	rsb
+
+9:
+	# Copy return value if necessary
+	tstl	16(%ap)
+	jeql	9f
+	movl	16(%ap), %r2
+
+	bbc	$0, 12(%ap), 1f	# CIF_FLAGS_CHAR
+	movb	%r0, 0(%r2)
+	brb	9f
+1:
+	bbc	$1, 12(%ap), 1f	# CIF_FLAGS_SHORT
+	movw	%r0, 0(%r2)
+	brb	9f
+1:
+	bbc	$2, 12(%ap), 1f	# CIF_FLAGS_INT
+	movl	%r0, 0(%r2)
+	brb	9f
+1:
+	bbc	$3, 12(%ap), 1f	# CIF_FLAGS_DINT
+	movq	%r0, 0(%r2)
+	brb	9f
+1:
+	movl	%r1, %r0	# might have been a struct
+	#brb	9f
+
+9:
+	ret
+
+/*
+ * ffi_closure_elfbsd(void);
+ * invoked with	%r0: ffi_closure *closure
+ */
+	.globl	ffi_closure_elfbsd
+	.type	ffi_closure_elfbsd, @function
+	.align	2
+ffi_closure_elfbsd:
+	.word	0
+
+	# Allocate room on stack for return value
+	subl2	$8, %sp
+
+	# Invoke the closure function
+	pushal	4(%ap)		# calling stack
+	pushal	4(%sp)		# return value
+	pushl	%r0		# closure
+	calls	$3, ffi_closure_elfbsd_inner
+
+	# Copy return value if necessary
+	bitb	$1, %r0		# CIF_FLAGS_CHAR
+	beql	1f
+	movb	0(%sp), %r0
+	brb	9f
+1:
+	bitb	$2, %r0		# CIF_FLAGS_SHORT
+	beql	1f
+	movw	0(%sp), %r0
+	brb	9f
+1:
+	bitb	$4, %r0		# CIF_FLAGS_INT
+	beql	1f
+	movl	0(%sp), %r0
+	brb	9f
+1:
+	bitb	$8, %r0		# CIF_FLAGS_DINT
+	beql	1f
+	movq	0(%sp), %r0
+	#brb	9f
+1:
+
+9:
+	ret
+
+/*
+ * ffi_closure_struct_elfbsd(void);
+ * invoked with	%r0: ffi_closure *closure
+ *		%r1: struct return address
+ */
+	.globl	ffi_closure_struct_elfbsd
+	.type	ffi_closure_struct_elfbsd, @function
+	.align	2
+ffi_closure_struct_elfbsd:
+	.word	0
+
+	# Invoke the closure function
+	pushal	4(%ap)		# calling stack
+	pushl	%r1		# return value
+	pushl	%r0		# closure
+	calls	$3, ffi_closure_elfbsd_inner
+
+	ret
Index: libffi-3.4.6/src/vax/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/vax/ffitarget.h b/libffi-3.4.6/src/vax/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/vax/ffitarget.h	
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * vax Foreign Function Interface
+ */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_ASM
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_ELFBSD,
+  FFI_DEFAULT_ABI = FFI_ELFBSD,
+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 15
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/x86/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/ffi.c b/libffi-3.4.6/src/x86/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/ffi.c	
@@ -0,0 +1,832 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2017, 2022  Anthony Green
+           Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.
+           Copyright (c) 2002  Ranjit Mathew
+           Copyright (c) 2002  Bo Thorsen
+           Copyright (c) 2002  Roger Sayle
+           Copyright (C) 2008, 2010  Free Software Foundation, Inc.
+
+   x86 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#if defined(__i386__) || defined(_M_IX86)
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <tramp.h>
+#include "internal.h"
+
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 80-bit type.  */
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+#if defined(__GNUC__) && !defined(__declspec)
+# define __declspec(x)  __attribute__((x))
+#endif
+
+#if defined(_MSC_VER) && defined(_M_IX86)
+/* Stack is not 16-byte aligned on Windows.  */
+#define STACK_ALIGN(bytes) (bytes)
+#else
+#define STACK_ALIGN(bytes) FFI_ALIGN (bytes, 16)
+#endif
+
+/* Perform machine dependent cif processing.  */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  size_t bytes = 0;
+  int i, n, flags, cabi = cif->abi;
+
+  switch (cabi)
+    {
+    case FFI_SYSV:
+    case FFI_STDCALL:
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+    case FFI_MS_CDECL:
+    case FFI_PASCAL:
+    case FFI_REGISTER:
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      flags = X86_RET_VOID;
+      break;
+    case FFI_TYPE_FLOAT:
+      flags = X86_RET_FLOAT;
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = X86_RET_DOUBLE;
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      flags = X86_RET_LDOUBLE;
+      break;
+    case FFI_TYPE_UINT8:
+      flags = X86_RET_UINT8;
+      break;
+    case FFI_TYPE_UINT16:
+      flags = X86_RET_UINT16;
+      break;
+    case FFI_TYPE_SINT8:
+      flags = X86_RET_SINT8;
+      break;
+    case FFI_TYPE_SINT16:
+      flags = X86_RET_SINT16;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+      flags = X86_RET_INT32;
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      flags = X86_RET_INT64;
+      break;
+    case FFI_TYPE_STRUCT:
+      {
+#ifdef X86_WIN32
+        size_t size = cif->rtype->size;
+        if (size == 1)
+          flags = X86_RET_STRUCT_1B;
+        else if (size == 2)
+          flags = X86_RET_STRUCT_2B;
+        else if (size == 4)
+          flags = X86_RET_INT32;
+        else if (size == 8)
+          flags = X86_RET_INT64;
+        else
+#endif
+          {
+          do_struct:
+            switch (cabi)
+              {
+              case FFI_THISCALL:
+              case FFI_FASTCALL:
+              case FFI_STDCALL:
+              case FFI_MS_CDECL:
+                flags = X86_RET_STRUCTARG;
+                break;
+              default:
+                flags = X86_RET_STRUCTPOP;
+                break;
+              }
+            /* Allocate space for return value pointer.  */
+            bytes += FFI_ALIGN (sizeof(void*), FFI_SIZEOF_ARG);
+          }
+      }
+      break;
+    case FFI_TYPE_COMPLEX:
+      switch (cif->rtype->elements[0]->type)
+	{
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  goto do_struct;
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	  flags = X86_RET_INT64;
+	  break;
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  flags = X86_RET_INT32;
+	  break;
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  flags = X86_RET_STRUCT_2B;
+	  break;
+	default:
+	  return FFI_BAD_TYPEDEF;
+	}
+      break;
+    default:
+      return FFI_BAD_TYPEDEF;
+    }
+  cif->flags = flags;
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *t = cif->arg_types[i];
+
+#if defined(X86_WIN32)
+      if (cabi == FFI_STDCALL)
+        bytes = FFI_ALIGN (bytes, FFI_SIZEOF_ARG);
+      else
+#endif
+        bytes = FFI_ALIGN (bytes, t->alignment);
+      bytes += FFI_ALIGN (t->size, FFI_SIZEOF_ARG);
+    }
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+static ffi_arg
+extend_basic_type(void *arg, int type)
+{
+  switch (type)
+    {
+    case FFI_TYPE_SINT8:
+      return *(SINT8 *)arg;
+    case FFI_TYPE_UINT8:
+      return *(UINT8 *)arg;
+    case FFI_TYPE_SINT16:
+      return *(SINT16 *)arg;
+    case FFI_TYPE_UINT16:
+      return *(UINT16 *)arg;
+
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_FLOAT:
+      return *(UINT32 *)arg;
+
+    default:
+      abort();
+    }
+}
+
+struct call_frame
+{
+  void *ebp;		/* 0 */
+  void *retaddr;	/* 4 */
+  void (*fn)(void);	/* 8 */
+  int flags;		/* 12 */
+  void *rvalue;		/* 16 */
+  unsigned regs[3];	/* 20-28 */
+};
+
+struct abi_params
+{
+  int dir;		/* parameter growth direction */
+  int static_chain;	/* the static chain register used by gcc */
+  int nregs;		/* number of register parameters */
+  int regs[3];
+};
+
+static const struct abi_params abi_params[FFI_LAST_ABI] = {
+  [FFI_SYSV] = { 1, R_ECX, 0 },
+  [FFI_THISCALL] = { 1, R_EAX, 1, { R_ECX } },
+  [FFI_FASTCALL] = { 1, R_EAX, 2, { R_ECX, R_EDX } },
+  [FFI_STDCALL] = { 1, R_ECX, 0 },
+  [FFI_PASCAL] = { -1, R_ECX, 0 },
+  /* ??? No defined static chain; gcc does not support REGISTER.  */
+  [FFI_REGISTER] = { -1, R_ECX, 3, { R_EAX, R_EDX, R_ECX } },
+  [FFI_MS_CDECL] = { 1, R_ECX, 0 }
+};
+
+#ifdef HAVE_FASTCALL
+  #ifdef _MSC_VER
+    #define FFI_DECLARE_FASTCALL __fastcall
+  #else
+    #define FFI_DECLARE_FASTCALL __declspec(fastcall)
+  #endif
+#else
+  #define FFI_DECLARE_FASTCALL
+#endif
+
+extern void FFI_DECLARE_FASTCALL ffi_call_i386(struct call_frame *, char *) FFI_HIDDEN;
+
+/* We perform some black magic here to use some of the parent's stack frame in
+ * ffi_call_i386() that breaks with the MSVC compiler with the /RTCs or /GZ
+ * flags.  Disable the 'Stack frame run time error checking' for this function
+ * so we don't hit weird exceptions in debug builds. */
+#if defined(_MSC_VER)
+#pragma runtime_checks("s", off)
+#endif
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  size_t rsize, bytes;
+  struct call_frame *frame;
+  char *stack, *argp;
+  ffi_type **arg_types;
+  int flags, cabi, i, n, dir, narg_reg;
+  const struct abi_params *pabi;
+
+  flags = cif->flags;
+  cabi = cif->abi;
+  pabi = &abi_params[cabi];
+  dir = pabi->dir;
+
+  rsize = 0;
+  if (rvalue == NULL)
+    {
+      switch (flags)
+	{
+	case X86_RET_FLOAT:
+	case X86_RET_DOUBLE:
+	case X86_RET_LDOUBLE:
+	case X86_RET_STRUCTPOP:
+	case X86_RET_STRUCTARG:
+	  /* The float cases need to pop the 387 stack.
+	     The struct cases need to pass a valid pointer to the callee.  */
+	  rsize = cif->rtype->size;
+	  break;
+	default:
+	  /* We can pretend that the callee returns nothing.  */
+	  flags = X86_RET_VOID;
+	  break;
+	}
+    }
+
+  bytes = STACK_ALIGN (cif->bytes);
+  stack = alloca(bytes + sizeof(*frame) + rsize);
+  argp = (dir < 0 ? stack + bytes : stack);
+  frame = (struct call_frame *)(stack + bytes);
+  if (rsize)
+    rvalue = frame + 1;
+
+  frame->fn = fn;
+  frame->flags = flags;
+  frame->rvalue = rvalue;
+  frame->regs[pabi->static_chain] = (unsigned)closure;
+
+  narg_reg = 0;
+  switch (flags)
+    {
+    case X86_RET_STRUCTARG:
+      /* The pointer is passed as the first argument.  */
+      if (pabi->nregs > 0)
+	{
+	  frame->regs[pabi->regs[0]] = (unsigned)rvalue;
+	  narg_reg = 1;
+	  break;
+	}
+      /* fallthru */
+    case X86_RET_STRUCTPOP:
+      *(void **)argp = rvalue;
+      argp += sizeof(void *);
+      break;
+    }
+
+  arg_types = cif->arg_types;
+  for (i = 0, n = cif->nargs; i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      void *valp = avalue[i];
+      size_t z = ty->size;
+      int t = ty->type;
+
+      if (z <= FFI_SIZEOF_ARG && t != FFI_TYPE_STRUCT)
+        {
+	  ffi_arg val = extend_basic_type (valp, t);
+
+	  if (t != FFI_TYPE_FLOAT && narg_reg < pabi->nregs)
+	    frame->regs[pabi->regs[narg_reg++]] = val;
+	  else if (dir < 0)
+	    {
+	      argp -= 4;
+	      *(ffi_arg *)argp = val;
+	    }
+	  else
+	    {
+	      *(ffi_arg *)argp = val;
+	      argp += 4;
+	    }
+	}
+      else
+	{
+	  size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);
+	  size_t align = FFI_SIZEOF_ARG;
+
+	  /* Issue 434: For thiscall and fastcall, if the paramter passed
+	     as 64-bit integer or struct, all following integer parameters
+	     will be passed on stack.  */
+	  if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)
+	      && (t == FFI_TYPE_SINT64
+		  || t == FFI_TYPE_UINT64
+		  || t == FFI_TYPE_STRUCT))
+	    narg_reg = 2;
+
+	  /* Alignment rules for arguments are quite complex.  Vectors and
+	     structures with 16 byte alignment get it.  Note that long double
+	     on Darwin does have 16 byte alignment, and does not get this
+	     alignment if passed directly; a structure with a long double
+	     inside, however, would get 16 byte alignment.  Since libffi does
+	     not support vectors, we need non concern ourselves with other
+	     cases.  */
+	  if (t == FFI_TYPE_STRUCT && ty->alignment >= 16)
+	    align = 16;
+
+	  if (dir < 0)
+	    {
+	      /* ??? These reverse argument ABIs are probably too old
+		 to have cared about alignment.  Someone should check.  */
+	      argp -= za;
+	      memcpy (argp, valp, z);
+	    }
+	  else
+	    {
+	      argp = (char *)FFI_ALIGN (argp, align);
+	      memcpy (argp, valp, z);
+	      argp += za;
+	    }
+	}
+    }
+  FFI_ASSERT (dir > 0 || argp == stack);
+
+  ffi_call_i386 (frame, stack);
+}
+#if defined(_MSC_VER)
+#pragma runtime_checks("s", restore)
+#endif
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+#ifdef FFI_GO_CLOSURES
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+#endif
+
+/** private members **/
+
+void FFI_HIDDEN ffi_closure_i386(void);
+void FFI_HIDDEN ffi_closure_STDCALL(void);
+void FFI_HIDDEN ffi_closure_REGISTER(void);
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void FFI_HIDDEN ffi_closure_i386_alt(void);
+void FFI_HIDDEN ffi_closure_STDCALL_alt(void);
+void FFI_HIDDEN ffi_closure_REGISTER_alt(void);
+#endif
+
+struct closure_frame
+{
+  unsigned rettemp[4];				/* 0 */
+  unsigned regs[3];				/* 16-24 */
+  ffi_cif *cif;					/* 28 */
+  void (*fun)(ffi_cif*,void*,void**,void*);	/* 32 */
+  void *user_data;				/* 36 */
+};
+
+int FFI_HIDDEN FFI_DECLARE_FASTCALL
+ffi_closure_inner (struct closure_frame *frame, char *stack)
+{
+  ffi_cif *cif = frame->cif;
+  int cabi, i, n, flags, dir, narg_reg;
+  const struct abi_params *pabi;
+  ffi_type **arg_types;
+  char *argp;
+  void *rvalue;
+  void **avalue;
+
+  cabi = cif->abi;
+  flags = cif->flags;
+  narg_reg = 0;
+  rvalue = frame->rettemp;
+  pabi = &abi_params[cabi];
+  dir = pabi->dir;
+  argp = (dir < 0 ? stack + STACK_ALIGN (cif->bytes) : stack);
+
+  switch (flags)
+    {
+    case X86_RET_STRUCTARG:
+      if (pabi->nregs > 0)
+	{
+	  rvalue = (void *)frame->regs[pabi->regs[0]];
+	  narg_reg = 1;
+	  frame->rettemp[0] = (unsigned)rvalue;
+	  break;
+	}
+      /* fallthru */
+    case X86_RET_STRUCTPOP:
+      rvalue = *(void **)argp;
+      argp += sizeof(void *);
+      frame->rettemp[0] = (unsigned)rvalue;
+      break;
+    }
+
+  n = cif->nargs;
+  avalue = alloca(sizeof(void *) * n);
+
+  arg_types = cif->arg_types;
+  for (i = 0; i < n; ++i)
+    {
+      ffi_type *ty = arg_types[i];
+      size_t z = ty->size;
+      int t = ty->type;
+      void *valp;
+
+      if (z <= FFI_SIZEOF_ARG && t != FFI_TYPE_STRUCT)
+	{
+	  if (t != FFI_TYPE_FLOAT && narg_reg < pabi->nregs)
+	    valp = &frame->regs[pabi->regs[narg_reg++]];
+	  else if (dir < 0)
+	    {
+	      argp -= 4;
+	      valp = argp;
+	    }
+	  else
+	    {
+	      valp = argp;
+	      argp += 4;
+	    }
+	}
+      else
+	{
+	  size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);
+	  size_t align = FFI_SIZEOF_ARG;
+
+	  /* See the comment in ffi_call_int.  */
+	  if (t == FFI_TYPE_STRUCT && ty->alignment >= 16)
+	    align = 16;
+
+	  /* Issue 434: For thiscall and fastcall, if the paramter passed
+	     as 64-bit integer or struct, all following integer parameters
+	     will be passed on stack.  */
+	  if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)
+	      && (t == FFI_TYPE_SINT64
+		  || t == FFI_TYPE_UINT64
+		  || t == FFI_TYPE_STRUCT))
+	    narg_reg = 2;
+
+	  if (dir < 0)
+	    {
+	      /* ??? These reverse argument ABIs are probably too old
+		 to have cared about alignment.  Someone should check.  */
+	      argp -= za;
+	      valp = argp;
+	    }
+	  else
+	    {
+	      argp = (char *)FFI_ALIGN (argp, align);
+	      valp = argp;
+	      argp += za;
+	    }
+	}
+
+      avalue[i] = valp;
+    }
+
+  frame->fun (cif, rvalue, avalue, frame->user_data);
+
+  switch (cabi)
+    {
+    case FFI_STDCALL:
+      return flags | (cif->bytes << X86_RET_POP_SHIFT);
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+      return flags | ((cif->bytes - (narg_reg * FFI_SIZEOF_ARG))
+          << X86_RET_POP_SHIFT);
+    default:
+      return flags;
+    }
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  char *tramp = closure->tramp;
+  void (*dest)(void);
+  int op = 0xb8;  /* movl imm, %eax */
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+    case FFI_MS_CDECL:
+      dest = ffi_closure_i386;
+      break;
+    case FFI_STDCALL:
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+    case FFI_PASCAL:
+      dest = ffi_closure_STDCALL;
+      break;
+    case FFI_REGISTER:
+      dest = ffi_closure_REGISTER;
+      op = 0x68;  /* pushl imm */
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      /* Initialize the static trampoline's parameters. */
+      if (dest == ffi_closure_i386)
+        dest = ffi_closure_i386_alt;
+      else if (dest == ffi_closure_STDCALL)
+        dest = ffi_closure_STDCALL_alt;
+      else
+        dest = ffi_closure_REGISTER_alt;
+      ffi_tramp_set_parms (closure->ftramp, dest, closure);
+      goto out;
+    }
+#endif
+
+  /* Initialize the dynamic trampoline. */
+  /* endbr32.  */
+  *(UINT32 *) tramp = 0xfb1e0ff3;
+
+  /* movl or pushl immediate.  */
+  tramp[4] = op;
+  *(void **)(tramp + 5) = codeloc;
+
+  /* jmp dest */
+  tramp[9] = 0xe9;
+  *(unsigned *)(tramp + 10) = (unsigned)dest - ((unsigned)codeloc + 14);
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+#endif
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+#ifdef FFI_GO_CLOSURES
+
+void FFI_HIDDEN ffi_go_closure_EAX(void);
+void FFI_HIDDEN ffi_go_closure_ECX(void);
+void FFI_HIDDEN ffi_go_closure_STDCALL(void);
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,
+		     void (*fun)(ffi_cif*,void*,void**,void*))
+{
+  void (*dest)(void);
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+    case FFI_MS_CDECL:
+      dest = ffi_go_closure_ECX;
+      break;
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+      dest = ffi_go_closure_EAX;
+      break;
+    case FFI_STDCALL:
+    case FFI_PASCAL:
+      dest = ffi_go_closure_STDCALL;
+      break;
+    case FFI_REGISTER:
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  closure->tramp = dest;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+#endif /* FFI_GO_CLOSURES */
+
+/* ------- Native raw API support -------------------------------- */
+
+#if !FFI_NO_RAW_API
+
+void FFI_HIDDEN ffi_closure_raw_SYSV(void);
+void FFI_HIDDEN ffi_closure_raw_THISCALL(void);
+
+ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure *closure,
+                          ffi_cif *cif,
+                          void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+                          void *user_data,
+                          void *codeloc)
+{
+  char *tramp = closure->tramp;
+  void (*dest)(void);
+  int i;
+
+  /* We currently don't support certain kinds of arguments for raw
+     closures.  This should be implemented by a separate assembly
+     language routine, since it would require argument processing,
+     something we don't do now for performance.  */
+  for (i = cif->nargs-1; i >= 0; i--)
+    switch (cif->arg_types[i]->type)
+      {
+      case FFI_TYPE_STRUCT:
+      case FFI_TYPE_LONGDOUBLE:
+	return FFI_BAD_TYPEDEF;
+      }
+
+  switch (cif->abi)
+    {
+    case FFI_THISCALL:
+      dest = ffi_closure_raw_THISCALL;
+      break;
+    case FFI_SYSV:
+      dest = ffi_closure_raw_SYSV;
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  /* movl imm, %eax.  */
+  tramp[0] = 0xb8;
+  *(void **)(tramp + 1) = codeloc;
+
+  /* jmp dest */
+  tramp[5] = 0xe9;
+  *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+void
+ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *avalue)
+{
+  size_t rsize, bytes;
+  struct call_frame *frame;
+  char *stack, *argp;
+  ffi_type **arg_types;
+  int flags, cabi, i, n, narg_reg;
+  const struct abi_params *pabi;
+
+  flags = cif->flags;
+  cabi = cif->abi;
+  pabi = &abi_params[cabi];
+
+  rsize = 0;
+  if (rvalue == NULL)
+    {
+      switch (flags)
+	{
+	case X86_RET_FLOAT:
+	case X86_RET_DOUBLE:
+	case X86_RET_LDOUBLE:
+	case X86_RET_STRUCTPOP:
+	case X86_RET_STRUCTARG:
+	  /* The float cases need to pop the 387 stack.
+	     The struct cases need to pass a valid pointer to the callee.  */
+	  rsize = cif->rtype->size;
+	  break;
+	default:
+	  /* We can pretend that the callee returns nothing.  */
+	  flags = X86_RET_VOID;
+	  break;
+	}
+    }
+
+  bytes = STACK_ALIGN (cif->bytes);
+  argp = stack =
+      (void *)((uintptr_t)alloca(bytes + sizeof(*frame) + rsize + 15) & ~16);
+  frame = (struct call_frame *)(stack + bytes);
+  if (rsize)
+    rvalue = frame + 1;
+
+  frame->fn = fn;
+  frame->flags = flags;
+  frame->rvalue = rvalue;
+
+  narg_reg = 0;
+  switch (flags)
+    {
+    case X86_RET_STRUCTARG:
+      /* The pointer is passed as the first argument.  */
+      if (pabi->nregs > 0)
+	{
+	  frame->regs[pabi->regs[0]] = (unsigned)rvalue;
+	  narg_reg = 1;
+	  break;
+	}
+      /* fallthru */
+    case X86_RET_STRUCTPOP:
+      *(void **)argp = rvalue;
+      argp += sizeof(void *);
+      bytes -= sizeof(void *);
+      break;
+    }
+
+  arg_types = cif->arg_types;
+  for (i = 0, n = cif->nargs; narg_reg < pabi->nregs && i < n; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      size_t z = ty->size;
+      int t = ty->type;
+
+      if (z <= FFI_SIZEOF_ARG && t != FFI_TYPE_STRUCT && t != FFI_TYPE_FLOAT)
+	{
+	  ffi_arg val = extend_basic_type (avalue, t);
+	  frame->regs[pabi->regs[narg_reg++]] = val;
+	  z = FFI_SIZEOF_ARG;
+	}
+      else
+	{
+	  memcpy (argp, avalue, z);
+	  z = FFI_ALIGN (z, FFI_SIZEOF_ARG);
+	  argp += z;
+	}
+      avalue += z;
+      bytes -= z;
+    }
+  if (i < n)
+    memcpy (argp, avalue, bytes);
+
+  ffi_call_i386 (frame, stack);
+}
+#endif /* !FFI_NO_RAW_API */
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void *
+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)
+{
+  extern void *trampoline_code_table;
+
+  *map_size = X86_TRAMP_MAP_SIZE;
+  *tramp_size = X86_TRAMP_SIZE;
+  return &trampoline_code_table;
+}
+#endif
+
+#endif /* __i386__ */
Index: libffi-3.4.6/src/x86/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/sysv.S b/libffi-3.4.6/src/x86/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/sysv.S	
@@ -0,0 +1,1272 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2017  Anthony Green
+          - Copyright (c) 2013  The Written Word, Inc.
+          - Copyright (c) 1996,1998,2001-2003,2005,2008,2010  Red Hat, Inc.
+   
+   X86 Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifdef __i386__
+#ifndef _MSC_VER
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#include "internal.h"
+
+#define C2(X, Y)  X ## Y
+#define C1(X, Y)  C2(X, Y)
+#ifdef __USER_LABEL_PREFIX__
+# define C(X)     C1(__USER_LABEL_PREFIX__, X)
+#else
+# define C(X)     X
+#endif
+
+#ifdef X86_DARWIN
+# define L(X)     C1(L, X)
+#else
+# define L(X)     C1(.L, X)
+#endif
+
+#ifdef __ELF__
+# define ENDF(X)  .type	X,@function; .size X, . - X
+#else
+# define ENDF(X)
+#endif
+
+/* Handle win32 fastcall name mangling.  */
+#ifdef X86_WIN32
+# define ffi_call_i386		"@ffi_call_i386@8"
+# define ffi_closure_inner	"@ffi_closure_inner@8"
+#else
+# define ffi_call_i386		C(ffi_call_i386)
+# define ffi_closure_inner	C(ffi_closure_inner)
+#endif
+
+/* This macro allows the safe creation of jump tables without an
+   actual table.  The entry points into the table are all 8 bytes.
+   The use of ORG asserts that we're at the correct location.  */
+/* ??? The clang assembler doesn't handle .org with symbolic expressions.  */
+#if defined(__clang__) || defined(__APPLE__) || (defined (__sun__) && defined(__svr4__))
+# define E(BASE, X)	.balign 8
+#else
+# define E(BASE, X)	.balign 8; .org BASE + X * 8
+#endif
+
+	.text
+	.balign	16
+	.globl	ffi_call_i386
+	FFI_HIDDEN(ffi_call_i386)
+
+/* This is declared as
+
+   void ffi_call_i386(struct call_frame *frame, char *argp)
+        __attribute__((fastcall));
+
+   Thus the arguments are present in
+
+        ecx: frame
+        edx: argp
+*/
+
+ffi_call_i386:
+L(UW0):
+	# cfi_startproc
+	_CET_ENDBR
+#if !HAVE_FASTCALL
+	movl	4(%esp), %ecx
+	movl	8(%esp), %edx
+#endif
+	movl	(%esp), %eax		/* move the return address */
+	movl	%ebp, (%ecx)		/* store %ebp into local frame */
+	movl	%eax, 4(%ecx)		/* store retaddr into local frame */
+
+	/* New stack frame based off ebp.  This is a itty bit of unwind
+	   trickery in that the CFA *has* changed.  There is no easy way
+	   to describe it correctly on entry to the function.  Fortunately,
+	   it doesn't matter too much since at all points we can correctly
+	   unwind back to ffi_call.  Note that the location to which we
+	   moved the return address is (the new) CFA-4, so from the
+	   perspective of the unwind info, it hasn't moved.  */
+	movl	%ecx, %ebp
+L(UW1):
+	# cfi_def_cfa(%ebp, 8)
+	# cfi_rel_offset(%ebp, 0)
+
+	movl	%edx, %esp		/* set outgoing argument stack */
+	movl	20+R_EAX*4(%ebp), %eax	/* set register arguments */
+	movl	20+R_EDX*4(%ebp), %edx
+	movl	20+R_ECX*4(%ebp), %ecx
+
+	call	*8(%ebp)
+
+	movl	12(%ebp), %ecx		/* load return type code */
+	movl	%ebx, 8(%ebp)		/* preserve %ebx */
+L(UW2):
+	# cfi_rel_offset(%ebx, 8)
+
+	andl	$X86_RET_TYPE_MASK, %ecx
+#ifdef __PIC__
+	call	C(__x86.get_pc_thunk.bx)
+L(pc1):
+	leal	L(store_table)-L(pc1)(%ebx, %ecx, 8), %ebx
+#else
+	leal	L(store_table)(,%ecx, 8), %ebx
+#endif
+	movl	16(%ebp), %ecx		/* load result address */
+	_CET_NOTRACK jmp *%ebx
+
+	.balign	8
+L(store_table):
+E(L(store_table), X86_RET_FLOAT)
+	fstps	(%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_DOUBLE)
+	fstpl	(%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_LDOUBLE)
+	fstpt	(%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_SINT8)
+	movsbl	%al, %eax
+	mov	%eax, (%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_SINT16)
+	movswl	%ax, %eax
+	mov	%eax, (%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_UINT8)
+	movzbl	%al, %eax
+	mov	%eax, (%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_UINT16)
+	movzwl	%ax, %eax
+	mov	%eax, (%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_INT64)
+	movl	%edx, 4(%ecx)
+	/* fallthru */
+E(L(store_table), X86_RET_INT32)
+	movl	%eax, (%ecx)
+	/* fallthru */
+E(L(store_table), X86_RET_VOID)
+L(e1):
+	movl	8(%ebp), %ebx
+	movl	%ebp, %esp
+	popl	%ebp
+L(UW3):
+	# cfi_remember_state
+	# cfi_def_cfa(%esp, 4)
+	# cfi_restore(%ebx)
+	# cfi_restore(%ebp)
+	ret
+L(UW4):
+	# cfi_restore_state
+
+E(L(store_table), X86_RET_STRUCTPOP)
+	jmp	L(e1)
+E(L(store_table), X86_RET_STRUCTARG)
+	jmp	L(e1)
+E(L(store_table), X86_RET_STRUCT_1B)
+	movb	%al, (%ecx)
+	jmp	L(e1)
+E(L(store_table), X86_RET_STRUCT_2B)
+	movw	%ax, (%ecx)
+	jmp	L(e1)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(store_table), X86_RET_UNUSED14)
+	ud2
+E(L(store_table), X86_RET_UNUSED15)
+	ud2
+
+L(UW5):
+	# cfi_endproc
+ENDF(ffi_call_i386)
+
+/* The inner helper is declared as
+
+   void ffi_closure_inner(struct closure_frame *frame, char *argp)
+	__attribute_((fastcall))
+
+   Thus the arguments are placed in
+
+	ecx:	frame
+	edx:	argp
+*/
+
+/* Macros to help setting up the closure_data structure.  */
+
+#if HAVE_FASTCALL
+# define closure_FS	(40 + 4)
+# define closure_CF	0
+#else
+# define closure_FS	(8 + 40 + 12)
+# define closure_CF	8
+#endif
+
+#define FFI_CLOSURE_SAVE_REGS		\
+	movl	%eax, closure_CF+16+R_EAX*4(%esp);	\
+	movl	%edx, closure_CF+16+R_EDX*4(%esp);	\
+	movl	%ecx, closure_CF+16+R_ECX*4(%esp)
+
+#define FFI_CLOSURE_COPY_TRAMP_DATA					\
+	movl	FFI_TRAMPOLINE_SIZE(%eax), %edx;	/* copy cif */	\
+	movl	FFI_TRAMPOLINE_SIZE+4(%eax), %ecx;	/* copy fun */	\
+	movl	FFI_TRAMPOLINE_SIZE+8(%eax), %eax;	/* copy user_data */ \
+	movl	%edx, closure_CF+28(%esp);				\
+	movl	%ecx, closure_CF+32(%esp);				\
+	movl	%eax, closure_CF+36(%esp)
+
+#if HAVE_FASTCALL
+# define FFI_CLOSURE_PREP_CALL						\
+	movl	%esp, %ecx;			/* load closure_data */	\
+	leal	closure_FS+4(%esp), %edx;	/* load incoming stack */
+#else
+# define FFI_CLOSURE_PREP_CALL						\
+	leal	closure_CF(%esp), %ecx;		/* load closure_data */	\
+	leal	closure_FS+4(%esp), %edx;	/* load incoming stack */ \
+	movl	%ecx, (%esp);						\
+	movl	%edx, 4(%esp)
+#endif
+
+#define FFI_CLOSURE_CALL_INNER(UWN) \
+	call	ffi_closure_inner
+
+#define FFI_CLOSURE_MASK_AND_JUMP(N, UW)				\
+	andl	$X86_RET_TYPE_MASK, %eax;				\
+	leal	L(C1(load_table,N))(, %eax, 8), %edx;			\
+	movl	closure_CF(%esp), %eax;		/* optimiztic load */	\
+	_CET_NOTRACK jmp *%edx
+
+#ifdef __PIC__
+# if defined X86_DARWIN || defined HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+#  undef FFI_CLOSURE_MASK_AND_JUMP
+#  define FFI_CLOSURE_MASK_AND_JUMP(N, UW)				\
+	andl	$X86_RET_TYPE_MASK, %eax;				\
+	call	C(__x86.get_pc_thunk.dx);				\
+L(C1(pc,N)):								\
+	leal	L(C1(load_table,N))-L(C1(pc,N))(%edx, %eax, 8), %edx;	\
+	movl	closure_CF(%esp), %eax;		/* optimiztic load */	\
+	_CET_NOTRACK jmp *%edx
+# else
+#  define FFI_CLOSURE_CALL_INNER_SAVE_EBX
+#  undef FFI_CLOSURE_CALL_INNER
+#  define FFI_CLOSURE_CALL_INNER(UWN)					\
+	movl	%ebx, 40(%esp);			/* save ebx */		\
+L(C1(UW,UWN)):								\
+	/* cfi_rel_offset(%ebx, 40); */					\
+	call	C(__x86.get_pc_thunk.bx);	/* load got register */	\
+	addl	$C(_GLOBAL_OFFSET_TABLE_), %ebx;			\
+	call	ffi_closure_inner@PLT
+#  undef FFI_CLOSURE_MASK_AND_JUMP
+#  define FFI_CLOSURE_MASK_AND_JUMP(N, UWN)				\
+	andl	$X86_RET_TYPE_MASK, %eax;				\
+	leal	L(C1(load_table,N))@GOTOFF(%ebx, %eax, 8), %edx;	\
+	movl	40(%esp), %ebx;			/* restore ebx */	\
+L(C1(UW,UWN)):								\
+	/* cfi_restore(%ebx); */					\
+	movl	closure_CF(%esp), %eax;		/* optimiztic load */	\
+	_CET_NOTRACK jmp *%edx
+# endif /* DARWIN || HIDDEN */
+#endif /* __PIC__ */
+
+	.balign	16
+	.globl	C(ffi_go_closure_EAX)
+	FFI_HIDDEN(C(ffi_go_closure_EAX))
+C(ffi_go_closure_EAX):
+L(UW6):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$closure_FS, %esp
+L(UW7):
+	# cfi_def_cfa_offset(closure_FS + 4)
+	FFI_CLOSURE_SAVE_REGS
+	movl	4(%eax), %edx			/* copy cif */
+	movl	8(%eax), %ecx			/* copy fun */
+	movl	%edx, closure_CF+28(%esp)
+	movl	%ecx, closure_CF+32(%esp)
+	movl	%eax, closure_CF+36(%esp)	/* closure is user_data */
+	jmp	L(do_closure_i386)
+L(UW8):
+	# cfi_endproc
+ENDF(C(ffi_go_closure_EAX))
+
+	.balign	16
+	.globl	C(ffi_go_closure_ECX)
+	FFI_HIDDEN(C(ffi_go_closure_ECX))
+C(ffi_go_closure_ECX):
+L(UW9):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$closure_FS, %esp
+L(UW10):
+	# cfi_def_cfa_offset(closure_FS + 4)
+	FFI_CLOSURE_SAVE_REGS
+	movl	4(%ecx), %edx			/* copy cif */
+	movl	8(%ecx), %eax			/* copy fun */
+	movl	%edx, closure_CF+28(%esp)
+	movl	%eax, closure_CF+32(%esp)
+	movl	%ecx, closure_CF+36(%esp)	/* closure is user_data */
+	jmp	L(do_closure_i386)
+L(UW11):
+	# cfi_endproc
+ENDF(C(ffi_go_closure_ECX))
+
+/* The closure entry points are reached from the ffi_closure trampoline.
+   On entry, %eax contains the address of the ffi_closure.  */
+
+	.balign	16
+	.globl	C(ffi_closure_i386)
+	FFI_HIDDEN(C(ffi_closure_i386))
+
+C(ffi_closure_i386):
+L(UW12):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$closure_FS, %esp
+L(UW13):
+	# cfi_def_cfa_offset(closure_FS + 4)
+
+	FFI_CLOSURE_SAVE_REGS
+	FFI_CLOSURE_COPY_TRAMP_DATA
+
+	/* Entry point from preceeding Go closures.  */
+L(do_closure_i386):
+
+	FFI_CLOSURE_PREP_CALL
+	FFI_CLOSURE_CALL_INNER(14)
+	FFI_CLOSURE_MASK_AND_JUMP(2, 15)
+
+	.balign	8
+L(load_table2):
+E(L(load_table2), X86_RET_FLOAT)
+	flds	closure_CF(%esp)
+	jmp	L(e2)
+E(L(load_table2), X86_RET_DOUBLE)
+	fldl	closure_CF(%esp)
+	jmp	L(e2)
+E(L(load_table2), X86_RET_LDOUBLE)
+	fldt	closure_CF(%esp)
+	jmp	L(e2)
+E(L(load_table2), X86_RET_SINT8)
+	movsbl	%al, %eax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_SINT16)
+	movswl	%ax, %eax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_UINT8)
+	movzbl	%al, %eax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_UINT16)
+	movzwl	%ax, %eax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_INT64)
+	movl	closure_CF+4(%esp), %edx
+	jmp	L(e2)
+E(L(load_table2), X86_RET_INT32)
+	nop
+	/* fallthru */
+E(L(load_table2), X86_RET_VOID)
+L(e2):
+	addl	$closure_FS, %esp
+L(UW16):
+	# cfi_adjust_cfa_offset(-closure_FS)
+	ret
+L(UW17):
+	# cfi_adjust_cfa_offset(closure_FS)
+E(L(load_table2), X86_RET_STRUCTPOP)
+	addl	$closure_FS, %esp
+L(UW18):
+	# cfi_adjust_cfa_offset(-closure_FS)
+	ret	$4
+L(UW19):
+	# cfi_adjust_cfa_offset(closure_FS)
+E(L(load_table2), X86_RET_STRUCTARG)
+	jmp	L(e2)
+E(L(load_table2), X86_RET_STRUCT_1B)
+	movzbl	%al, %eax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_STRUCT_2B)
+	movzwl	%ax, %eax
+	jmp	L(e2)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table2), X86_RET_UNUSED14)
+	ud2
+E(L(load_table2), X86_RET_UNUSED15)
+	ud2
+
+L(UW20):
+	# cfi_endproc
+ENDF(C(ffi_closure_i386))
+
+	.balign	16
+	.globl	C(ffi_go_closure_STDCALL)
+	FFI_HIDDEN(C(ffi_go_closure_STDCALL))
+C(ffi_go_closure_STDCALL):
+L(UW21):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$closure_FS, %esp
+L(UW22):
+	# cfi_def_cfa_offset(closure_FS + 4)
+	FFI_CLOSURE_SAVE_REGS
+	movl	4(%ecx), %edx			/* copy cif */
+	movl	8(%ecx), %eax			/* copy fun */
+	movl	%edx, closure_CF+28(%esp)
+	movl	%eax, closure_CF+32(%esp)
+	movl	%ecx, closure_CF+36(%esp)	/* closure is user_data */
+	jmp	L(do_closure_STDCALL)
+L(UW23):
+	# cfi_endproc
+ENDF(C(ffi_go_closure_STDCALL))
+
+/* For REGISTER, we have no available parameter registers, and so we
+   enter here having pushed the closure onto the stack.  */
+
+	.balign	16
+	.globl	C(ffi_closure_REGISTER)
+	FFI_HIDDEN(C(ffi_closure_REGISTER))
+C(ffi_closure_REGISTER):
+L(UW24):
+	# cfi_startproc
+	# cfi_def_cfa(%esp, 8)
+	# cfi_offset(%eip, -8)
+	_CET_ENDBR
+	subl	$closure_FS-4, %esp
+L(UW25):
+	# cfi_def_cfa_offset(closure_FS + 4)
+	FFI_CLOSURE_SAVE_REGS
+	movl	closure_FS-4(%esp), %ecx	/* load retaddr */
+	movl	closure_FS(%esp), %eax		/* load closure */
+	movl	%ecx, closure_FS(%esp)		/* move retaddr */
+	jmp	L(do_closure_REGISTER)
+L(UW26):
+	# cfi_endproc
+ENDF(C(ffi_closure_REGISTER))
+
+/* For STDCALL (and others), we need to pop N bytes of arguments off
+   the stack following the closure.  The amount needing to be popped
+   is returned to us from ffi_closure_inner.  */
+
+	.balign	16
+	.globl	C(ffi_closure_STDCALL)
+	FFI_HIDDEN(C(ffi_closure_STDCALL))
+C(ffi_closure_STDCALL):
+L(UW27):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$closure_FS, %esp
+L(UW28):
+	# cfi_def_cfa_offset(closure_FS + 4)
+
+	FFI_CLOSURE_SAVE_REGS
+
+	/* Entry point from ffi_closure_REGISTER.  */
+L(do_closure_REGISTER):
+
+	FFI_CLOSURE_COPY_TRAMP_DATA
+
+	/* Entry point from preceeding Go closure.  */
+L(do_closure_STDCALL):
+
+	FFI_CLOSURE_PREP_CALL
+	FFI_CLOSURE_CALL_INNER(29)
+
+	movl	%eax, %ecx
+	shrl	$X86_RET_POP_SHIFT, %ecx	/* isolate pop count */
+	leal	closure_FS(%esp, %ecx), %ecx	/* compute popped esp */
+	movl	closure_FS(%esp), %edx		/* move return address */
+	movl	%edx, (%ecx)
+
+	/* From this point on, the value of %esp upon return is %ecx+4,
+	   and we've copied the return address to %ecx to make return easy.
+	   There's no point in representing this in the unwind info, as
+	   there is always a window between the mov and the ret which
+	   will be wrong from one point of view or another.  */
+
+	FFI_CLOSURE_MASK_AND_JUMP(3, 30)
+
+	.balign	8
+L(load_table3):
+E(L(load_table3), X86_RET_FLOAT)
+	flds    closure_CF(%esp)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_DOUBLE)
+	fldl    closure_CF(%esp)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_LDOUBLE)
+	fldt    closure_CF(%esp)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_SINT8)
+	movsbl  %al, %eax
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_SINT16)
+	movswl  %ax, %eax
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_UINT8)
+	movzbl  %al, %eax
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_UINT16)
+	movzwl  %ax, %eax
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_INT64)
+	movl	closure_CF+4(%esp), %edx
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_INT32)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_VOID)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_STRUCTPOP)
+	movl    %ecx, %esp
+	ret
+E(L(load_table3), X86_RET_STRUCTARG)
+	movl	%ecx, %esp
+	ret
+E(L(load_table3), X86_RET_STRUCT_1B)
+	movzbl	%al, %eax
+	movl	%ecx, %esp
+	ret
+E(L(load_table3), X86_RET_STRUCT_2B)
+	movzwl	%ax, %eax
+	movl	%ecx, %esp
+	ret
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table3), X86_RET_UNUSED14)
+	ud2
+E(L(load_table3), X86_RET_UNUSED15)
+	ud2
+
+L(UW31):
+	# cfi_endproc
+ENDF(C(ffi_closure_STDCALL))
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+	.balign	16
+	.globl	C(ffi_closure_i386_alt)
+	FFI_HIDDEN(C(ffi_closure_i386_alt))
+C(ffi_closure_i386_alt):
+	/* See the comments above trampoline_code_table. */
+	_CET_ENDBR
+	movl	4(%esp), %eax			/* Load closure in eax */
+	add	$8, %esp			/* Restore the stack */
+	jmp	C(ffi_closure_i386)
+ENDF(C(ffi_closure_i386_alt))
+
+	.balign	16
+	.globl	C(ffi_closure_REGISTER_alt)
+	FFI_HIDDEN(C(ffi_closure_REGISTER_alt))
+C(ffi_closure_REGISTER_alt):
+	/* See the comments above trampoline_code_table. */
+	_CET_ENDBR
+	movl	(%esp), %eax			/* Restore eax */
+	add	$4, %esp			/* Leave closure on stack */
+	jmp	C(ffi_closure_REGISTER)
+ENDF(C(ffi_closure_REGISTER_alt))
+
+	.balign	16
+	.globl	C(ffi_closure_STDCALL_alt)
+	FFI_HIDDEN(C(ffi_closure_STDCALL_alt))
+C(ffi_closure_STDCALL_alt):
+	/* See the comments above trampoline_code_table. */
+	_CET_ENDBR
+	movl	4(%esp), %eax			/* Load closure in eax */
+	add	$8, %esp			/* Restore the stack */
+	jmp	C(ffi_closure_STDCALL)
+ENDF(C(ffi_closure_STDCALL_alt))
+
+/*
+ * Below is the definition of the trampoline code table. Each element in
+ * the code table is a trampoline.
+ *
+ * Because we jump to the trampoline, we place a _CET_ENDBR at the
+ * beginning of the trampoline to mark it as a valid branch target. This is
+ * part of the the Intel CET (Control Flow Enforcement Technology).
+ */
+/*
+ * The trampoline uses register eax.  It saves the original value of eax on
+ * the stack.
+ *
+ * The trampoline has two parameters - target code to jump to and data for
+ * the target code. The trampoline extracts the parameters from its parameter
+ * block (see tramp_table_map()). The trampoline saves the data address on
+ * the stack. Finally, it jumps to the target code.
+ *
+ * The target code can choose to:
+ *
+ * - restore the value of eax
+ * - load the data address in a register
+ * - restore the stack pointer to what it was when the trampoline was invoked.
+ */
+#ifdef ENDBR_PRESENT
+#define X86_DATA_OFFSET		4081
+#define X86_CODE_OFFSET		4070
+#else
+#define X86_DATA_OFFSET		4085
+#define X86_CODE_OFFSET		4074
+#endif
+
+	.align	X86_TRAMP_MAP_SIZE
+	.globl	C(trampoline_code_table)
+	FFI_HIDDEN(C(trampoline_code_table))
+C(trampoline_code_table):
+	.rept	X86_TRAMP_MAP_SIZE / X86_TRAMP_SIZE
+	_CET_ENDBR
+	sub	$8, %esp
+	movl	%eax, (%esp)			/* Save %eax on stack */
+	call	1f				/* Get next PC into %eax */
+	movl	X86_DATA_OFFSET(%eax), %eax	/* Copy data into %eax */
+	movl	%eax, 4(%esp)			/* Save data on stack */
+	call	1f				/* Get next PC into %eax */
+	movl	X86_CODE_OFFSET(%eax), %eax	/* Copy code into %eax */
+	jmp	*%eax				/* Jump to code */
+1:
+	mov	(%esp), %eax
+	ret
+	.align	4
+	.endr
+ENDF(C(trampoline_code_table))
+	.align	X86_TRAMP_MAP_SIZE
+#endif /* FFI_EXEC_STATIC_TRAMP */
+
+#if !FFI_NO_RAW_API
+
+#define raw_closure_S_FS	(16+16+12)
+
+	.balign	16
+	.globl	C(ffi_closure_raw_SYSV)
+	FFI_HIDDEN(C(ffi_closure_raw_SYSV))
+C(ffi_closure_raw_SYSV):
+L(UW32):
+	# cfi_startproc
+	_CET_ENDBR
+	subl	$raw_closure_S_FS, %esp
+L(UW33):
+	# cfi_def_cfa_offset(raw_closure_S_FS + 4)
+	movl	%ebx, raw_closure_S_FS-4(%esp)
+L(UW34):
+	# cfi_rel_offset(%ebx, raw_closure_S_FS-4)
+
+	movl	FFI_TRAMPOLINE_SIZE+8(%eax), %edx	/* load cl->user_data */
+	movl	%edx, 12(%esp)
+	leal	raw_closure_S_FS+4(%esp), %edx		/* load raw_args */
+	movl	%edx, 8(%esp)
+	leal	16(%esp), %edx				/* load &res */
+	movl	%edx, 4(%esp)
+	movl	FFI_TRAMPOLINE_SIZE(%eax), %ebx		/* load cl->cif */
+	movl	%ebx, (%esp)
+	call	*FFI_TRAMPOLINE_SIZE+4(%eax)		/* call cl->fun */
+
+	movl	20(%ebx), %eax				/* load cif->flags */
+	andl	$X86_RET_TYPE_MASK, %eax
+#ifdef __PIC__
+	call	C(__x86.get_pc_thunk.bx)
+L(pc4):
+	leal	L(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx
+#else
+	leal	L(load_table4)(,%eax, 8), %ecx
+#endif
+	movl	raw_closure_S_FS-4(%esp), %ebx
+L(UW35):
+	# cfi_restore(%ebx)
+	movl	16(%esp), %eax				/* Optimistic load */
+	jmp	*%ecx
+
+	.balign	8
+L(load_table4):
+E(L(load_table4), X86_RET_FLOAT)
+	flds	16(%esp)
+	jmp	L(e4)
+E(L(load_table4), X86_RET_DOUBLE)
+	fldl	16(%esp)
+	jmp	L(e4)
+E(L(load_table4), X86_RET_LDOUBLE)
+	fldt	16(%esp)
+	jmp	L(e4)
+E(L(load_table4), X86_RET_SINT8)
+	movsbl	%al, %eax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_SINT16)
+	movswl	%ax, %eax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_UINT8)
+	movzbl	%al, %eax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_UINT16)
+	movzwl	%ax, %eax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_INT64)
+	movl	16+4(%esp), %edx
+	jmp	L(e4)
+E(L(load_table4), X86_RET_INT32)
+	nop
+	/* fallthru */
+E(L(load_table4), X86_RET_VOID)
+L(e4):
+	addl	$raw_closure_S_FS, %esp
+L(UW36):
+	# cfi_adjust_cfa_offset(-raw_closure_S_FS)
+	ret
+L(UW37):
+	# cfi_adjust_cfa_offset(raw_closure_S_FS)
+E(L(load_table4), X86_RET_STRUCTPOP)
+	addl	$raw_closure_S_FS, %esp
+L(UW38):
+	# cfi_adjust_cfa_offset(-raw_closure_S_FS)
+	ret	$4
+L(UW39):
+	# cfi_adjust_cfa_offset(raw_closure_S_FS)
+E(L(load_table4), X86_RET_STRUCTARG)
+	jmp	L(e4)
+E(L(load_table4), X86_RET_STRUCT_1B)
+	movzbl	%al, %eax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_STRUCT_2B)
+	movzwl	%ax, %eax
+	jmp	L(e4)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table4), X86_RET_UNUSED14)
+	ud2
+E(L(load_table4), X86_RET_UNUSED15)
+	ud2
+
+L(UW40):
+	# cfi_endproc
+ENDF(C(ffi_closure_raw_SYSV))
+
+#define raw_closure_T_FS	(16+16+8)
+
+	.balign	16
+	.globl	C(ffi_closure_raw_THISCALL)
+	FFI_HIDDEN(C(ffi_closure_raw_THISCALL))
+C(ffi_closure_raw_THISCALL):
+L(UW41):
+	# cfi_startproc
+	_CET_ENDBR
+	/* Rearrange the stack such that %ecx is the first argument.
+	   This means moving the return address.  */
+	popl	%edx
+L(UW42):
+	# cfi_def_cfa_offset(0)
+	# cfi_register(%eip, %edx)
+	pushl	%ecx
+L(UW43):
+	# cfi_adjust_cfa_offset(4)
+	pushl	%edx
+L(UW44):
+	# cfi_adjust_cfa_offset(4)
+	# cfi_rel_offset(%eip, 0)
+	subl	$raw_closure_T_FS, %esp
+L(UW45):
+	# cfi_adjust_cfa_offset(raw_closure_T_FS)
+	movl	%ebx, raw_closure_T_FS-4(%esp)
+L(UW46):
+	# cfi_rel_offset(%ebx, raw_closure_T_FS-4)
+
+	movl	FFI_TRAMPOLINE_SIZE+8(%eax), %edx	/* load cl->user_data */
+	movl	%edx, 12(%esp)
+	leal	raw_closure_T_FS+4(%esp), %edx		/* load raw_args */
+	movl	%edx, 8(%esp)
+	leal	16(%esp), %edx				/* load &res */
+	movl	%edx, 4(%esp)
+	movl	FFI_TRAMPOLINE_SIZE(%eax), %ebx		/* load cl->cif */
+	movl	%ebx, (%esp)
+	call	*FFI_TRAMPOLINE_SIZE+4(%eax)		/* call cl->fun */
+
+	movl	20(%ebx), %eax				/* load cif->flags */
+	andl	$X86_RET_TYPE_MASK, %eax
+#ifdef __PIC__
+	call	C(__x86.get_pc_thunk.bx)
+L(pc5):
+	leal	L(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx
+#else
+	leal	L(load_table5)(,%eax, 8), %ecx
+#endif
+	movl	raw_closure_T_FS-4(%esp), %ebx
+L(UW47):
+	# cfi_restore(%ebx)
+	movl	16(%esp), %eax				/* Optimistic load */
+	jmp	*%ecx
+
+	.balign	8
+L(load_table5):
+E(L(load_table5), X86_RET_FLOAT)
+	flds	16(%esp)
+	jmp	L(e5)
+E(L(load_table5), X86_RET_DOUBLE)
+	fldl	16(%esp)
+	jmp	L(e5)
+E(L(load_table5), X86_RET_LDOUBLE)
+	fldt	16(%esp)
+	jmp	L(e5)
+E(L(load_table5), X86_RET_SINT8)
+	movsbl	%al, %eax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_SINT16)
+	movswl	%ax, %eax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_UINT8)
+	movzbl	%al, %eax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_UINT16)
+	movzwl	%ax, %eax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_INT64)
+	movl	16+4(%esp), %edx
+	jmp	L(e5)
+E(L(load_table5), X86_RET_INT32)
+	nop
+	/* fallthru */
+E(L(load_table5), X86_RET_VOID)
+L(e5):
+	addl	$raw_closure_T_FS, %esp
+L(UW48):
+	# cfi_adjust_cfa_offset(-raw_closure_T_FS)
+	/* Remove the extra %ecx argument we pushed.  */
+	ret	$4
+L(UW49):
+	# cfi_adjust_cfa_offset(raw_closure_T_FS)
+E(L(load_table5), X86_RET_STRUCTPOP)
+	addl	$raw_closure_T_FS, %esp
+L(UW50):
+	# cfi_adjust_cfa_offset(-raw_closure_T_FS)
+	ret	$8
+L(UW51):
+	# cfi_adjust_cfa_offset(raw_closure_T_FS)
+E(L(load_table5), X86_RET_STRUCTARG)
+	jmp	L(e5)
+E(L(load_table5), X86_RET_STRUCT_1B)
+	movzbl	%al, %eax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_STRUCT_2B)
+	movzwl	%ax, %eax
+	jmp	L(e5)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table5), X86_RET_UNUSED14)
+	ud2
+E(L(load_table5), X86_RET_UNUSED15)
+	ud2
+
+L(UW52):
+	# cfi_endproc
+ENDF(C(ffi_closure_raw_THISCALL))
+
+#endif /* !FFI_NO_RAW_API */
+
+#ifdef X86_DARWIN
+/* The linker in use on earlier Darwin needs weak definitions to be
+   placed in a coalesced section.  That section should not be called
+   __TEXT,__text since that would be re-defining the attributes of the
+   .text section (which is an error for earlier tools). Here we use
+   '__textcoal_nt' which is what GCC emits for this.
+   Later linker versions are happy to use a normal section and, after
+   Darwin12 / OSX 10.8, the tools warn that using coalesced sections
+   for this is deprecated so we must switch to avoid build fails and/or
+   deprecation warnings.  */
+# if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&		\
+   __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1080
+#  define COMDAT(X)							\
+        .section __TEXT,__textcoal_nt,coalesced,pure_instructions;	\
+        .weak_definition X;						\
+        FFI_HIDDEN(X)
+# else
+#  define COMDAT(X)							\
+        .text;								\
+        .weak_definition X;						\
+        FFI_HIDDEN(X)
+# endif
+#elif defined __ELF__ && !(defined(__sun__) && defined(__svr4__))
+# define COMDAT(X)							\
+	.section .text.X,"axG",@progbits,X,comdat;			\
+	.globl	X;							\
+	FFI_HIDDEN(X)
+#else
+# define COMDAT(X)
+#endif
+
+#if defined(__PIC__)
+	COMDAT(C(__x86.get_pc_thunk.bx))
+C(__x86.get_pc_thunk.bx):
+	movl	(%esp), %ebx
+	ret
+ENDF(C(__x86.get_pc_thunk.bx))
+# if defined X86_DARWIN || defined HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+	COMDAT(C(__x86.get_pc_thunk.dx))
+C(__x86.get_pc_thunk.dx):
+	movl	(%esp), %edx
+	ret
+ENDF(C(__x86.get_pc_thunk.dx))
+#endif /* DARWIN || HIDDEN */
+#endif /* __PIC__ */
+
+/* Sadly, OSX cctools-as does not understand .cfi directives at all so
+   we build an eh frame by hand.  */
+
+#ifdef __APPLE__
+/* The cctools assembler will try to make a difference between two local
+   symbols into a relocation against, which will not work in the eh (produces
+   link-time fails).
+   To avoid this, we compute the symbol difference with a .set directive and
+   then substitute this value.  */
+# define LEN(N, P)	.set Llen$N$P,L(N)-L(P); .long Llen$N$P
+/* Note, this assume DW_CFA_advance_loc1 fits into 7 bits.  */
+# define ADV(N, P)	.set Ladv$N$P,L(N)-L(P); .byte 2, Ladv$N$P
+/* For historical reasons, the EH reg numbers for SP and FP are swapped from
+   the DWARF ones for 32b Darwin.  */
+# define SP 5
+# define FP 4
+# define ENC 0x10
+#else
+# define LEN(N, P)	.long L(N)-L(P)
+/* Assume DW_CFA_advance_loc1 fits.  */
+# define ADV(N, P)	.byte 2, L(N)-L(P)
+# define SP 4
+# define FP 5
+# define ENC 0x1b
+#endif
+
+#ifdef HAVE_AS_X86_PCREL
+# define PCREL(X)	X-.
+#else
+# define PCREL(X)	X@rel
+#endif
+
+#ifdef __APPLE__
+.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
+EHFrame0:
+#elif defined(X86_WIN32)
+.section .eh_frame,"r"
+#elif defined(HAVE_AS_X86_64_UNWIND_SECTION_TYPE)
+.section .eh_frame,EH_FRAME_FLAGS,@unwind
+#else
+.section .eh_frame,EH_FRAME_FLAGS,@progbits
+#endif
+#ifndef __APPLE__
+/* EH sections are already suitably aligned on Darwin.  */
+	.balign 4
+#endif
+
+L(CIE):
+	.set	L(set0),L(ECIE)-L(SCIE)
+	.long	L(set0)			/* CIE Length */
+L(SCIE):
+	.long	0			/* CIE Identifier Tag */
+	.byte	1			/* CIE Version */
+	.ascii	"zR\0"			/* CIE Augmentation */
+	.byte	1			/* CIE Code Alignment Factor */
+	.byte	0x7c			/* CIE Data Alignment Factor */
+	.byte	0x8			/* CIE RA Column */
+	.byte	1			/* Augmentation size */
+	.byte	ENC			/* FDE Encoding (pcrel abs/4byte) */
+	.byte	0xc, SP, 4		/* DW_CFA_def_cfa, %esp offset 4 */
+	.byte	0x80+8, 1		/* DW_CFA_offset, %eip offset 1*-4 */
+	.balign 4
+L(ECIE):
+
+	.set	L(set1),L(EFDE1)-L(SFDE1)
+	.long	L(set1)			/* FDE Length */
+L(SFDE1):
+	LEN(SFDE1, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW0))		/* Initial location */
+	LEN(UW5, UW0)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW1, UW0)
+	.byte	0xc, FP, 8		/* DW_CFA_def_cfa, %ebp 8 */
+	.byte	0x80+FP, 2		/* DW_CFA_offset, %ebp 2*-4 */
+	ADV(UW2, UW1)
+	.byte	0x80+3, 0		/* DW_CFA_offset, %ebx 0*-4 */
+	ADV(UW3, UW2)
+	.byte	0xa			/* DW_CFA_remember_state */
+	.byte	0xc, SP, 4		/* DW_CFA_def_cfa, %esp 4 */
+	.byte	0xc0+3			/* DW_CFA_restore, %ebx */
+	.byte	0xc0+FP			/* DW_CFA_restore, %ebp */
+	ADV(UW4, UW3)
+	.byte	0xb			/* DW_CFA_restore_state */
+	.balign	4
+L(EFDE1):
+
+	.set	L(set2),L(EFDE2)-L(SFDE2)
+	.long	L(set2)			/* FDE Length */
+L(SFDE2):
+	LEN(SFDE2, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW6))		/* Initial location */
+	LEN(UW8,UW6)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW7, UW6)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE2):
+
+	.set	L(set3),L(EFDE3)-L(SFDE3)
+	.long	L(set3)			/* FDE Length */
+L(SFDE3):
+	LEN(SFDE3, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW9))		/* Initial location */
+	LEN(UW11, UW9)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW10, UW9)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE3):
+
+	.set	L(set4),L(EFDE4)-L(SFDE4)
+	.long	L(set4)			/* FDE Length */
+L(SFDE4):
+	LEN(SFDE4, CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW12))		/* Initial location */
+	LEN(UW20, UW12)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW13, UW12)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+#ifdef FFI_CLOSURE_CALL_INNER_SAVE_EBX
+	ADV(UW14, UW13)
+	.byte	0x80+3, (40-(closure_FS+4))/-4  /* DW_CFA_offset %ebx */
+	ADV(UW15, UW14)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW16, UW15)
+#else
+	ADV(UW16, UW13)
+#endif
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW17, UW16)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW18, UW17)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW19, UW18)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE4):
+
+	.set	L(set5),L(EFDE5)-L(SFDE5)
+	.long	L(set5)			/* FDE Length */
+L(SFDE5):
+	LEN(SFDE5, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW21))		/* Initial location */
+	LEN(UW23, UW21)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW22, UW21)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE5):
+
+	.set	L(set6),L(EFDE6)-L(SFDE6)
+	.long	L(set6)			/* FDE Length */
+L(SFDE6):
+	LEN(SFDE6, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW24))		/* Initial location */
+	LEN(UW26, UW24)			/* Address range */
+	.byte	0			/* Augmentation size */
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	.byte	0x80+8, 2		/* DW_CFA_offset %eip, 2*-4 */
+	ADV(UW25, UW24)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE6):
+
+	.set	L(set7),L(EFDE7)-L(SFDE7)
+	.long	L(set7)			/* FDE Length */
+L(SFDE7):
+	LEN(SFDE7, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW27))		/* Initial location */
+	LEN(UW31, UW27)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW28, UW27)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+#ifdef FFI_CLOSURE_CALL_INNER_SAVE_EBX
+	ADV(UW29, UW28)
+	.byte	0x80+3, (40-(closure_FS+4))/-4  /* DW_CFA_offset %ebx */
+	ADV(UW30, UW29)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+#endif
+	.balign	4
+L(EFDE7):
+#if !FFI_NO_RAW_API
+	.set	L(set8),L(EFDE8)-L(SFDE8)
+	.long	L(set8)			/* FDE Length */
+L(SFDE8):
+	LEN(SFDE8, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW32))		/* Initial location */
+	LEN(UW40, UW32)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW33, UW32)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW34, UW33)
+	.byte	0x80+3, 2		/* DW_CFA_offset %ebx 2*-4 */
+	ADV(UW35, UW34)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW36, UW35)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW37, UW36)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW38, UW37)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW39, UW38)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE8):
+
+	.set	L(set9),L(EFDE9)-L(SFDE9)
+	.long	L(set9)			/* FDE Length */
+L(SFDE9):
+	LEN(SFDE9, CIE)			/* FDE CIE offset */
+	.long	PCREL(L(UW41))		/* Initial location */
+	LEN(UW52, UW41)			/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW42, UW41)
+	.byte	0xe, 0			/* DW_CFA_def_cfa_offset */
+	.byte	0x9, 8, 2		/* DW_CFA_register %eip, %edx */
+	ADV(UW43, UW42)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW44, UW43)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	.byte	0x80+8, 2		/* DW_CFA_offset %eip 2*-4 */
+	ADV(UW45, UW44)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	ADV(UW46, UW45)
+	.byte	0x80+3, 3		/* DW_CFA_offset %ebx 3*-4 */
+	ADV(UW47, UW46)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW48, UW47)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	ADV(UW49, UW48)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	ADV(UW50, UW49)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	ADV(UW51, UW50)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE9):
+#endif /* !FFI_NO_RAW_API */
+
+#ifdef _WIN32
+	.def	 @feat.00;
+	.scl	3;
+	.type	0;
+	.endef
+	.globl	@feat.00
+@feat.00 = 1
+#endif
+
+#if defined(__APPLE__)
+    .subsections_via_symbols
+# if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&		\
+   __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1070 && __clang__
+/* compact unwind is not used with GCC at present, was not present before 10.6
+   but has some bugs there, so do not emit until 10.7.  */
+    .section __LD,__compact_unwind,regular,debug
+
+    /* compact unwind for ffi_call_i386 */
+    .long    C(ffi_call_i386)
+    .set     L1,L(UW5)-L(UW0)
+    .long    L1
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_go_closure_EAX */
+    .long    C(ffi_go_closure_EAX)
+    .set     L2,L(UW8)-L(UW6)
+    .long    L2
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_go_closure_ECX */
+    .long    C(ffi_go_closure_ECX)
+    .set     L3,L(UW11)-L(UW9)
+    .long    L3
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_closure_i386 */
+    .long    C(ffi_closure_i386)
+    .set     L4,L(UW20)-L(UW12)
+    .long    L4
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_go_closure_STDCALL */
+    .long    C(ffi_go_closure_STDCALL)
+    .set     L5,L(UW23)-L(UW21)
+    .long    L5
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_closure_REGISTER */
+    .long    C(ffi_closure_REGISTER)
+    .set     L6,L(UW26)-L(UW24)
+    .long    L6
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_closure_STDCALL */
+    .long    C(ffi_closure_STDCALL)
+    .set     L7,L(UW31)-L(UW27)
+    .long    L7
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_closure_raw_SYSV */
+    .long    C(ffi_closure_raw_SYSV)
+    .set     L8,L(UW40)-L(UW32)
+    .long    L8
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+
+    /* compact unwind for ffi_closure_raw_THISCALL */
+    .long    C(ffi_closure_raw_THISCALL)
+    .set     L9,L(UW52)-L(UW41)
+    .long    L9
+    .long    0x04000000 /* use dwarf unwind info */
+    .long    0
+    .long    0
+#endif /* use compact unwind */
+#endif /* __APPLE__ */
+
+#endif /* ifndef _MSC_VER */
+
+#endif /* ifdef __i386__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/x86/ffi64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/ffi64.c b/libffi-3.4.6/src/x86/ffi64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/ffi64.c	
@@ -0,0 +1,950 @@
+/* -----------------------------------------------------------------------
+   ffi64.c - Copyright (c) 2011, 2018, 2022  Anthony Green
+             Copyright (c) 2013  The Written Word, Inc.
+             Copyright (c) 2008, 2010  Red Hat, Inc.
+             Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>
+
+   x86-64 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <tramp.h>
+#include "internal64.h"
+
+#ifdef __x86_64__
+
+#define MAX_GPR_REGS 6
+#define MAX_SSE_REGS 8
+
+#if defined(__INTEL_COMPILER)
+#include "xmmintrin.h"
+#define UINT128 __m128
+#else
+#if defined(__SUNPRO_C)
+#include <sunmedia_types.h>
+#define UINT128 __m128i
+#else
+#define UINT128 __int128_t
+#endif
+#endif
+
+union big_int_union
+{
+  UINT32 i32;
+  UINT64 i64;
+  UINT128 i128;
+};
+
+struct register_args
+{
+  /* Registers for argument passing.  */
+  UINT64 gpr[MAX_GPR_REGS];
+  union big_int_union sse[MAX_SSE_REGS];
+  UINT64 rax;	/* ssecount */
+  UINT64 r10;	/* static chain */
+};
+
+extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
+			     void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;
+
+/* All reference to register classes here is identical to the code in
+   gcc/config/i386/i386.c. Do *not* change one without the other.  */
+
+/* Register class used for passing given 64bit part of the argument.
+   These represent classes as documented by the PS ABI, with the
+   exception of SSESF, SSEDF classes, that are basically SSE class,
+   just gcc will use SF or DFmode move instead of DImode to avoid
+   reformatting penalties.
+
+   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
+   whenever possible (upper half does contain padding).  */
+enum x86_64_reg_class
+  {
+    X86_64_NO_CLASS,
+    X86_64_INTEGER_CLASS,
+    X86_64_INTEGERSI_CLASS,
+    X86_64_SSE_CLASS,
+    X86_64_SSESF_CLASS,
+    X86_64_SSEDF_CLASS,
+    X86_64_SSEUP_CLASS,
+    X86_64_X87_CLASS,
+    X86_64_X87UP_CLASS,
+    X86_64_COMPLEX_X87_CLASS,
+    X86_64_MEMORY_CLASS
+  };
+
+#define MAX_CLASSES 4
+
+#define SSE_CLASS_P(X)	((X) >= X86_64_SSE_CLASS && X <= X86_64_SSEUP_CLASS)
+
+/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal
+   of this code is to classify each 8bytes of incoming argument by the register
+   class and assign registers accordingly.  */
+
+/* Return the union class of CLASS1 and CLASS2.
+   See the x86-64 PS ABI for details.  */
+
+static enum x86_64_reg_class
+merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)
+{
+  /* Rule #1: If both classes are equal, this is the resulting class.  */
+  if (class1 == class2)
+    return class1;
+
+  /* Rule #2: If one of the classes is NO_CLASS, the resulting class is
+     the other class.  */
+  if (class1 == X86_64_NO_CLASS)
+    return class2;
+  if (class2 == X86_64_NO_CLASS)
+    return class1;
+
+  /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
+  if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)
+    return X86_64_MEMORY_CLASS;
+
+  /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
+  if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)
+      || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))
+    return X86_64_INTEGERSI_CLASS;
+  if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS
+      || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)
+    return X86_64_INTEGER_CLASS;
+
+  /* Rule #5: If one of the classes is X87, X87UP, or COMPLEX_X87 class,
+     MEMORY is used.  */
+  if (class1 == X86_64_X87_CLASS
+      || class1 == X86_64_X87UP_CLASS
+      || class1 == X86_64_COMPLEX_X87_CLASS
+      || class2 == X86_64_X87_CLASS
+      || class2 == X86_64_X87UP_CLASS
+      || class2 == X86_64_COMPLEX_X87_CLASS)
+    return X86_64_MEMORY_CLASS;
+
+  /* Rule #6: Otherwise class SSE is used.  */
+  return X86_64_SSE_CLASS;
+}
+
+/* Classify the argument of type TYPE and mode MODE.
+   CLASSES will be filled by the register class used to pass each word
+   of the operand.  The number of words is returned.  In case the parameter
+   should be passed in memory, 0 is returned. As a special case for zero
+   sized containers, classes[0] will be NO_CLASS and 1 is returned.
+
+   See the x86-64 PS ABI for details.
+*/
+static size_t
+classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
+		   size_t byte_offset)
+{
+  switch (type->type)
+    {
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_POINTER:
+    do_integer:
+      {
+	size_t size = byte_offset + type->size;
+
+	if (size <= 4)
+	  {
+	    classes[0] = X86_64_INTEGERSI_CLASS;
+	    return 1;
+	  }
+	else if (size <= 8)
+	  {
+	    classes[0] = X86_64_INTEGER_CLASS;
+	    return 1;
+	  }
+	else if (size <= 12)
+	  {
+	    classes[0] = X86_64_INTEGER_CLASS;
+	    classes[1] = X86_64_INTEGERSI_CLASS;
+	    return 2;
+	  }
+	else if (size <= 16)
+	  {
+	    classes[0] = classes[1] = X86_64_INTEGER_CLASS;
+	    return 2;
+	  }
+	else
+	  FFI_ASSERT (0);
+      }
+    case FFI_TYPE_FLOAT:
+      if (!(byte_offset % 8))
+	classes[0] = X86_64_SSESF_CLASS;
+      else
+	classes[0] = X86_64_SSE_CLASS;
+      return 1;
+    case FFI_TYPE_DOUBLE:
+      classes[0] = X86_64_SSEDF_CLASS;
+      return 1;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      classes[0] = X86_64_X87_CLASS;
+      classes[1] = X86_64_X87UP_CLASS;
+      return 2;
+#endif
+    case FFI_TYPE_STRUCT:
+      {
+	const size_t UNITS_PER_WORD = 8;
+        size_t words = (type->size + byte_offset + UNITS_PER_WORD - 1)
+                       / UNITS_PER_WORD;
+	ffi_type **ptr;
+	unsigned int i;
+	enum x86_64_reg_class subclasses[MAX_CLASSES];
+
+	/* If the struct is larger than 32 bytes, pass it on the stack.  */
+	if (type->size > 32)
+	  return 0;
+
+	for (i = 0; i < words; i++)
+	  classes[i] = X86_64_NO_CLASS;
+
+	/* Zero sized arrays or structures are NO_CLASS.  We return 0 to
+	   signalize memory class, so handle it as special case.  */
+	if (!words)
+	  {
+    case FFI_TYPE_VOID:
+	    classes[0] = X86_64_NO_CLASS;
+	    return 1;
+	  }
+
+	/* Merge the fields of structure.  */
+	for (ptr = type->elements; *ptr != NULL; ptr++)
+	  {
+	    size_t num, pos;
+
+	    byte_offset = FFI_ALIGN (byte_offset, (*ptr)->alignment);
+
+	    num = classify_argument (*ptr, subclasses, byte_offset % 8);
+	    if (num == 0)
+	      return 0;
+            pos = byte_offset / 8;
+            for (i = 0; i < num && (i + pos) < words; i++)
+	      {
+		size_t pos = byte_offset / 8;
+		classes[i + pos] =
+		  merge_classes (subclasses[i], classes[i + pos]);
+	      }
+
+	    byte_offset += (*ptr)->size;
+	  }
+
+	if (words > 2)
+	  {
+	    /* When size > 16 bytes, if the first one isn't
+	       X86_64_SSE_CLASS or any other ones aren't
+	       X86_64_SSEUP_CLASS, everything should be passed in
+	       memory.  */
+	    if (classes[0] != X86_64_SSE_CLASS)
+	      return 0;
+
+	    for (i = 1; i < words; i++)
+	      if (classes[i] != X86_64_SSEUP_CLASS)
+		return 0;
+	  }
+
+	/* Final merger cleanup.  */
+	for (i = 0; i < words; i++)
+	  {
+	    /* If one class is MEMORY, everything should be passed in
+	       memory.  */
+	    if (classes[i] == X86_64_MEMORY_CLASS)
+	      return 0;
+
+	    /* The X86_64_SSEUP_CLASS should be always preceded by
+	       X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */
+	    if (i > 1 && classes[i] == X86_64_SSEUP_CLASS
+		&& classes[i - 1] != X86_64_SSE_CLASS
+		&& classes[i - 1] != X86_64_SSEUP_CLASS)
+	      {
+		/* The first one should never be X86_64_SSEUP_CLASS.  */
+		FFI_ASSERT (i != 0);
+		classes[i] = X86_64_SSE_CLASS;
+	      }
+
+	    /*  If X86_64_X87UP_CLASS isn't preceded by X86_64_X87_CLASS,
+		everything should be passed in memory.  */
+	    if (i > 1 && classes[i] == X86_64_X87UP_CLASS
+		&& (classes[i - 1] != X86_64_X87_CLASS))
+	      {
+		/* The first one should never be X86_64_X87UP_CLASS.  */
+		FFI_ASSERT (i != 0);
+		return 0;
+	      }
+	  }
+	return words;
+      }
+    case FFI_TYPE_COMPLEX:
+      {
+	ffi_type *inner = type->elements[0];
+	switch (inner->type)
+	  {
+	  case FFI_TYPE_INT:
+	  case FFI_TYPE_UINT8:
+	  case FFI_TYPE_SINT8:
+	  case FFI_TYPE_UINT16:
+	  case FFI_TYPE_SINT16:
+	  case FFI_TYPE_UINT32:
+	  case FFI_TYPE_SINT32:
+	  case FFI_TYPE_UINT64:
+	  case FFI_TYPE_SINT64:
+	    goto do_integer;
+
+	  case FFI_TYPE_FLOAT:
+	    classes[0] = X86_64_SSE_CLASS;
+	    if (byte_offset % 8)
+	      {
+		classes[1] = X86_64_SSESF_CLASS;
+		return 2;
+	      }
+	    return 1;
+	  case FFI_TYPE_DOUBLE:
+	    classes[0] = classes[1] = X86_64_SSEDF_CLASS;
+	    return 2;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	  case FFI_TYPE_LONGDOUBLE:
+	    classes[0] = X86_64_COMPLEX_X87_CLASS;
+	    return 1;
+#endif
+	  }
+      }
+    }
+  abort();
+}
+
+/* Examine the argument and return set number of register required in each
+   class.  Return zero iff parameter should be passed in memory, otherwise
+   the number of registers.  */
+
+static size_t
+examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
+		  _Bool in_return, int *pngpr, int *pnsse)
+{
+  size_t n;
+  unsigned int i;
+  int ngpr, nsse;
+
+  n = classify_argument (type, classes, 0);
+  if (n == 0)
+    return 0;
+
+  ngpr = nsse = 0;
+  for (i = 0; i < n; ++i)
+    switch (classes[i])
+      {
+      case X86_64_INTEGER_CLASS:
+      case X86_64_INTEGERSI_CLASS:
+	ngpr++;
+	break;
+      case X86_64_SSE_CLASS:
+      case X86_64_SSESF_CLASS:
+      case X86_64_SSEDF_CLASS:
+	nsse++;
+	break;
+      case X86_64_NO_CLASS:
+      case X86_64_SSEUP_CLASS:
+	break;
+      case X86_64_X87_CLASS:
+      case X86_64_X87UP_CLASS:
+      case X86_64_COMPLEX_X87_CLASS:
+	return in_return != 0;
+      default:
+	abort ();
+      }
+
+  *pngpr = ngpr;
+  *pnsse = nsse;
+
+  return n;
+}
+
+/* Perform machine dependent cif processing.  */
+
+#ifndef __ILP32__
+extern ffi_status
+ffi_prep_cif_machdep_efi64(ffi_cif *cif);
+#endif
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  int gprcount, ssecount, i, avn, ngpr, nsse;
+  unsigned flags;
+  enum x86_64_reg_class classes[MAX_CLASSES];
+  size_t bytes, n, rtype_size;
+  ffi_type *rtype;
+
+#ifndef __ILP32__
+  if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
+    return ffi_prep_cif_machdep_efi64(cif);
+#endif
+  if (cif->abi != FFI_UNIX64)
+    return FFI_BAD_ABI;
+
+  gprcount = ssecount = 0;
+
+  rtype = cif->rtype;
+  rtype_size = rtype->size;
+  switch (rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      flags = UNIX64_RET_VOID;
+      break;
+    case FFI_TYPE_UINT8:
+      flags = UNIX64_RET_UINT8;
+      break;
+    case FFI_TYPE_SINT8:
+      flags = UNIX64_RET_SINT8;
+      break;
+    case FFI_TYPE_UINT16:
+      flags = UNIX64_RET_UINT16;
+      break;
+    case FFI_TYPE_SINT16:
+      flags = UNIX64_RET_SINT16;
+      break;
+    case FFI_TYPE_UINT32:
+      flags = UNIX64_RET_UINT32;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      flags = UNIX64_RET_SINT32;
+      break;
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      flags = UNIX64_RET_INT64;
+      break;
+    case FFI_TYPE_POINTER:
+      flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);
+      break;
+    case FFI_TYPE_FLOAT:
+      flags = UNIX64_RET_XMM32;
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = UNIX64_RET_XMM64;
+      break;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      flags = UNIX64_RET_X87;
+      break;
+#endif
+    case FFI_TYPE_STRUCT:
+      n = examine_argument (cif->rtype, classes, 1, &ngpr, &nsse);
+      if (n == 0)
+	{
+	  /* The return value is passed in memory.  A pointer to that
+	     memory is the first argument.  Allocate a register for it.  */
+	  gprcount++;
+	  /* We don't have to do anything in asm for the return.  */
+	  flags = UNIX64_RET_VOID | UNIX64_FLAG_RET_IN_MEM;
+	}
+      else
+	{
+	  _Bool sse0 = SSE_CLASS_P (classes[0]);
+
+	  if (rtype_size == 4 && sse0)
+	    flags = UNIX64_RET_XMM32;
+	  else if (rtype_size == 8)
+	    flags = sse0 ? UNIX64_RET_XMM64 : UNIX64_RET_INT64;
+	  else
+	    {
+	      _Bool sse1 = n == 2 && SSE_CLASS_P (classes[1]);
+	      if (sse0 && sse1)
+		flags = UNIX64_RET_ST_XMM0_XMM1;
+	      else if (sse0)
+		flags = UNIX64_RET_ST_XMM0_RAX;
+	      else if (sse1)
+		flags = UNIX64_RET_ST_RAX_XMM0;
+	      else
+		flags = UNIX64_RET_ST_RAX_RDX;
+	      flags |= rtype_size << UNIX64_SIZE_SHIFT;
+	    }
+	}
+      break;
+    case FFI_TYPE_COMPLEX:
+      switch (rtype->elements[0]->type)
+	{
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  flags = UNIX64_RET_ST_RAX_RDX | ((unsigned) rtype_size << UNIX64_SIZE_SHIFT);
+	  break;
+	case FFI_TYPE_FLOAT:
+	  flags = UNIX64_RET_XMM64;
+	  break;
+	case FFI_TYPE_DOUBLE:
+	  flags = UNIX64_RET_ST_XMM0_XMM1 | (16 << UNIX64_SIZE_SHIFT);
+	  break;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  flags = UNIX64_RET_X87_2;
+	  break;
+#endif
+	default:
+	  return FFI_BAD_TYPEDEF;
+	}
+      break;
+    default:
+      return FFI_BAD_TYPEDEF;
+    }
+
+  /* Go over all arguments and determine the way they should be passed.
+     If it's in a register and there is space for it, let that be so. If
+     not, add it's size to the stack byte count.  */
+  for (bytes = 0, i = 0, avn = cif->nargs; i < avn; i++)
+    {
+      if (examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0
+	  || gprcount + ngpr > MAX_GPR_REGS
+	  || ssecount + nsse > MAX_SSE_REGS)
+	{
+	  long align = cif->arg_types[i]->alignment;
+
+	  if (align < 8)
+	    align = 8;
+
+	  bytes = FFI_ALIGN (bytes, align);
+	  bytes += cif->arg_types[i]->size;
+	}
+      else
+	{
+	  gprcount += ngpr;
+	  ssecount += nsse;
+	}
+    }
+  if (ssecount)
+    flags |= UNIX64_FLAG_XMM_ARGS;
+
+  cif->flags = flags;
+  cif->bytes = (unsigned) FFI_ALIGN (bytes, 8);
+
+  return FFI_OK;
+}
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  enum x86_64_reg_class classes[MAX_CLASSES];
+  char *stack, *argp;
+  ffi_type **arg_types;
+  int gprcount, ssecount, ngpr, nsse, i, avn, flags;
+  struct register_args *reg_args;
+
+  /* Can't call 32-bit mode from 64-bit mode.  */
+  FFI_ASSERT (cif->abi == FFI_UNIX64);
+
+  /* If the return value is a struct and we don't have a return value
+     address then we need to make one.  Otherwise we can ignore it.  */
+  flags = cif->flags;
+  if (rvalue == NULL)
+    {
+      if (flags & UNIX64_FLAG_RET_IN_MEM)
+	rvalue = alloca (cif->rtype->size);
+      else
+	flags = UNIX64_RET_VOID;
+    }
+
+  arg_types = cif->arg_types;
+  avn = cif->nargs;
+
+  /* Allocate the space for the arguments, plus 4 words of temp space.  */
+  stack = alloca (sizeof (struct register_args) + cif->bytes + 4*8);
+  reg_args = (struct register_args *) stack;
+  argp = stack + sizeof (struct register_args);
+
+  reg_args->r10 = (uintptr_t) closure;
+
+  gprcount = ssecount = 0;
+
+  /* If the return value is passed in memory, add the pointer as the
+     first integer argument.  */
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    reg_args->gpr[gprcount++] = (unsigned long) rvalue;
+
+  for (i = 0; i < avn; ++i)
+    {
+      size_t n, size = arg_types[i]->size;
+
+      n = examine_argument (arg_types[i], classes, 0, &ngpr, &nsse);
+      if (n == 0
+	  || gprcount + ngpr > MAX_GPR_REGS
+	  || ssecount + nsse > MAX_SSE_REGS)
+	{
+	  long align = arg_types[i]->alignment;
+
+	  /* Stack arguments are *always* at least 8 byte aligned.  */
+	  if (align < 8)
+	    align = 8;
+
+          /* Pass this argument in memory.  */
+          argp = (void *) FFI_ALIGN (argp, align);
+          memcpy (argp, avalue[i], size);
+
+          argp += size;
+        }
+      else
+	{
+	  /* The argument is passed entirely in registers.  */
+	  char *a = (char *) avalue[i];
+	  unsigned int j;
+
+	  for (j = 0; j < n; j++, a += 8, size -= 8)
+	    {
+	      switch (classes[j])
+		{
+		case X86_64_NO_CLASS:
+		case X86_64_SSEUP_CLASS:
+		  break;
+		case X86_64_INTEGER_CLASS:
+		case X86_64_INTEGERSI_CLASS:
+		  /* Sign-extend integer arguments passed in general
+		     purpose registers, to cope with the fact that
+		     LLVM incorrectly assumes that this will be done
+		     (the x86-64 PS ABI does not specify this). */
+		  switch (arg_types[i]->type)
+		    {
+		    case FFI_TYPE_SINT8:
+		      reg_args->gpr[gprcount] = (SINT64) *((SINT8 *) a);
+		      break;
+		    case FFI_TYPE_SINT16:
+		      reg_args->gpr[gprcount] = (SINT64) *((SINT16 *) a);
+		      break;
+		    case FFI_TYPE_SINT32:
+		      reg_args->gpr[gprcount] = (SINT64) *((SINT32 *) a);
+		      break;
+		    default:
+		      reg_args->gpr[gprcount] = 0;
+		      memcpy (&reg_args->gpr[gprcount], a, size);
+		    }
+		  gprcount++;
+		  break;
+		case X86_64_SSE_CLASS:
+		case X86_64_SSEDF_CLASS:
+		  memcpy (&reg_args->sse[ssecount++].i64, a, sizeof(UINT64));
+		  break;
+		case X86_64_SSESF_CLASS:
+		  memcpy (&reg_args->sse[ssecount++].i32, a, sizeof(UINT32));
+		  break;
+		default:
+		  abort();
+		}
+	    }
+	}
+    }
+  reg_args->rax = ssecount;
+
+  ffi_call_unix64 (stack, cif->bytes + sizeof (struct register_args),
+		   flags, rvalue, fn);
+}
+
+#ifndef __ILP32__
+extern void
+ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);
+#endif
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_type **arg_types = cif->arg_types;
+  int i, nargs = cif->nargs;
+  const int max_reg_struct_size = cif->abi == FFI_GNUW64 ? 8 : 16;
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT && size > max_reg_struct_size)
+        {
+          char *argcopy = alloca (size);
+          memcpy (argcopy, avalue[i], size);
+          avalue[i] = argcopy;
+        }
+    }
+
+#ifndef __ILP32__
+  if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
+    {
+      ffi_call_efi64(cif, fn, rvalue, avalue);
+      return;
+    }
+#endif
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+#ifdef FFI_GO_CLOSURES
+
+#ifndef __ILP32__
+extern void
+ffi_call_go_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue,
+		  void **avalue, void *closure);
+#endif
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+#ifndef __ILP32__
+  if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
+    {
+      ffi_call_go_efi64(cif, fn, rvalue, avalue, closure);
+      return;
+    }
+#endif
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+#endif /* FFI_GO_CLOSURES */
+
+extern void ffi_closure_unix64(void) FFI_HIDDEN;
+extern void ffi_closure_unix64_sse(void) FFI_HIDDEN;
+#if defined(FFI_EXEC_STATIC_TRAMP)
+extern void ffi_closure_unix64_alt(void) FFI_HIDDEN;
+extern void ffi_closure_unix64_sse_alt(void) FFI_HIDDEN;
+#endif
+
+#ifndef __ILP32__
+extern ffi_status
+ffi_prep_closure_loc_efi64(ffi_closure* closure,
+			   ffi_cif* cif,
+			   void (*fun)(ffi_cif*, void*, void**, void*),
+			   void *user_data,
+			   void *codeloc);
+#endif
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  static const unsigned char trampoline[24] = {
+    /* endbr64 */
+    0xf3, 0x0f, 0x1e, 0xfa,
+    /* leaq  -0xb(%rip),%r10   # 0x0  */
+    0x4c, 0x8d, 0x15, 0xf5, 0xff, 0xff, 0xff,
+    /* jmpq  *0x7(%rip)        # 0x18 */
+    0xff, 0x25, 0x07, 0x00, 0x00, 0x00,
+    /* nopl  0(%rax) */
+    0x0f, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00
+  };
+  void (*dest)(void);
+  char *tramp = closure->tramp;
+
+#ifndef __ILP32__
+  if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
+    return ffi_prep_closure_loc_efi64(closure, cif, fun, user_data, codeloc);
+#endif
+  if (cif->abi != FFI_UNIX64)
+    return FFI_BAD_ABI;
+
+  if (cif->flags & UNIX64_FLAG_XMM_ARGS)
+    dest = ffi_closure_unix64_sse;
+  else
+    dest = ffi_closure_unix64;
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      /* Initialize the static trampoline's parameters. */
+      if (dest == ffi_closure_unix64_sse)
+        dest = ffi_closure_unix64_sse_alt;
+      else
+        dest = ffi_closure_unix64_alt;
+      ffi_tramp_set_parms (closure->ftramp, dest, closure);
+      goto out;
+    }
+#endif
+
+  /* Initialize the dynamic trampoline. */
+  memcpy (tramp, trampoline, sizeof(trampoline));
+  *(UINT64 *)(tramp + sizeof (trampoline)) = (uintptr_t)dest;
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+#endif
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+int FFI_HIDDEN
+ffi_closure_unix64_inner(ffi_cif *cif,
+			 void (*fun)(ffi_cif*, void*, void**, void*),
+			 void *user_data,
+			 void *rvalue,
+			 struct register_args *reg_args,
+			 char *argp)
+{
+  void **avalue;
+  ffi_type **arg_types;
+  long i, avn;
+  int gprcount, ssecount, ngpr, nsse;
+  int flags;
+
+  avn = cif->nargs;
+  flags = cif->flags;
+  avalue = alloca(avn * sizeof(void *));
+  gprcount = ssecount = 0;
+
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    {
+      /* On return, %rax will contain the address that was passed
+	 by the caller in %rdi.  */
+      void *r = (void *)(uintptr_t)reg_args->gpr[gprcount++];
+      *(void **)rvalue = r;
+      rvalue = r;
+      flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);
+    }
+
+  arg_types = cif->arg_types;
+  for (i = 0; i < avn; ++i)
+    {
+      enum x86_64_reg_class classes[MAX_CLASSES];
+      size_t n;
+
+      n = examine_argument (arg_types[i], classes, 0, &ngpr, &nsse);
+      if (n == 0
+	  || gprcount + ngpr > MAX_GPR_REGS
+	  || ssecount + nsse > MAX_SSE_REGS)
+	{
+	  long align = arg_types[i]->alignment;
+
+	  /* Stack arguments are *always* at least 8 byte aligned.  */
+	  if (align < 8)
+	    align = 8;
+
+	  /* Pass this argument in memory.  */
+	  argp = (void *) FFI_ALIGN (argp, align);
+	  avalue[i] = argp;
+	  argp += arg_types[i]->size;
+	}
+      /* If the argument is in a single register, or two consecutive
+	 integer registers, then we can use that address directly.  */
+      else if (n == 1
+	       || (n == 2 && !(SSE_CLASS_P (classes[0])
+			       || SSE_CLASS_P (classes[1]))))
+	{
+	  /* The argument is in a single register.  */
+	  if (SSE_CLASS_P (classes[0]))
+	    {
+	      avalue[i] = &reg_args->sse[ssecount];
+	      ssecount += n;
+	    }
+	  else
+	    {
+	      avalue[i] = &reg_args->gpr[gprcount];
+	      gprcount += n;
+	    }
+	}
+      /* Otherwise, allocate space to make them consecutive.  */
+      else
+	{
+	  char *a = alloca (16);
+	  unsigned int j;
+
+	  avalue[i] = a;
+	  for (j = 0; j < n; j++, a += 8)
+	    {
+	      if (SSE_CLASS_P (classes[j]))
+		memcpy (a, &reg_args->sse[ssecount++], 8);
+	      else
+		memcpy (a, &reg_args->gpr[gprcount++], 8);
+	    }
+	}
+    }
+
+  /* Invoke the closure.  */
+  fun (cif, rvalue, avalue, user_data);
+
+  /* Tell assembly how to perform return type promotions.  */
+  return flags;
+}
+
+#ifdef FFI_GO_CLOSURES
+
+extern void ffi_go_closure_unix64(void) FFI_HIDDEN;
+extern void ffi_go_closure_unix64_sse(void) FFI_HIDDEN;
+
+#ifndef __ILP32__
+extern ffi_status
+ffi_prep_go_closure_efi64(ffi_go_closure* closure, ffi_cif* cif,
+			  void (*fun)(ffi_cif*, void*, void**, void*));
+#endif
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+#ifndef __ILP32__
+  if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
+    return ffi_prep_go_closure_efi64(closure, cif, fun);
+#endif
+  if (cif->abi != FFI_UNIX64)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (cif->flags & UNIX64_FLAG_XMM_ARGS
+		    ? ffi_go_closure_unix64_sse
+		    : ffi_go_closure_unix64);
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+#endif /* FFI_GO_CLOSURES */
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void *
+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)
+{
+  extern void *trampoline_code_table;
+
+  *map_size = UNIX64_TRAMP_MAP_SIZE;
+  *tramp_size = UNIX64_TRAMP_SIZE;
+  return &trampoline_code_table;
+}
+#endif
+
+#endif /* __x86_64__ */
Index: libffi-3.4.6/src/x86/win64.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/win64.S b/libffi-3.4.6/src/x86/win64.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/win64.S	
@@ -0,0 +1,254 @@
+#ifdef __x86_64__
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "asmnames.h"
+
+#if defined(HAVE_AS_CFI_PSEUDO_OP)
+        .cfi_sections   .debug_frame
+#endif
+
+#ifdef X86_WIN64
+#define SEH(...) __VA_ARGS__
+#define arg0	%rcx
+#define arg1	%rdx
+#define arg2	%r8
+#define arg3	%r9
+#else
+#define SEH(...)
+#define arg0	%rdi
+#define arg1	%rsi
+#define arg2	%rdx
+#define arg3	%rcx
+#endif
+
+/* This macro allows the safe creation of jump tables without an
+   actual table.  The entry points into the table are all 8 bytes.
+   The use of ORG asserts that we're at the correct location.  */
+/* ??? The clang assembler doesn't handle .org with symbolic expressions.  */
+#if defined(__clang__) || defined(__APPLE__) || (defined (__sun__) && defined(__svr4__))
+# define E(BASE, X)	.balign 8
+#else
+# define E(BASE, X)	.balign 8; .org BASE + (X) * 8
+#endif
+
+	.text
+
+/* ffi_call_win64 (void *stack, struct win64_call_frame *frame, void *r10)
+
+   Bit o trickiness here -- FRAME is the base of the stack frame
+   for this function.  This has been allocated by ffi_call.  We also
+   deallocate some of the stack that has been alloca'd.  */
+
+	.align	8
+	.globl	C(ffi_call_win64)
+	FFI_HIDDEN(C(ffi_call_win64))
+
+	SEH(.seh_proc ffi_call_win64)
+C(ffi_call_win64):
+	cfi_startproc
+	_CET_ENDBR
+	/* Set up the local stack frame and install it in rbp/rsp.  */
+	movq	(%rsp), %rax
+	movq	%rbp, (arg1)
+	movq	%rax, 8(arg1)
+	movq	arg1, %rbp
+	cfi_def_cfa(%rbp, 16)
+	cfi_rel_offset(%rbp, 0)
+	SEH(.seh_pushreg %rbp)
+	SEH(.seh_setframe %rbp, 0)
+	SEH(.seh_endprologue)
+	movq	arg0, %rsp
+
+	movq	arg2, %r10
+
+	/* Load all slots into both general and xmm registers.  */
+	movq	(%rsp), %rcx
+	movsd	(%rsp), %xmm0
+	movq	8(%rsp), %rdx
+	movsd	8(%rsp), %xmm1
+	movq	16(%rsp), %r8
+	movsd	16(%rsp), %xmm2
+	movq	24(%rsp), %r9
+	movsd	24(%rsp), %xmm3
+
+	call	*16(%rbp)
+
+	movl	24(%rbp), %ecx
+	movq	32(%rbp), %r8
+	leaq	0f(%rip), %r10
+	cmpl	$FFI_TYPE_SMALL_STRUCT_4B, %ecx
+	leaq	(%r10, %rcx, 8), %r10
+	ja	99f
+	_CET_NOTRACK jmp *%r10
+
+/* Below, we're space constrained most of the time.  Thus we eschew the
+   modern "mov, pop, ret" sequence (5 bytes) for "leave, ret" (2 bytes).  */
+#define epilogue		\
+	leaveq;			\
+	cfi_remember_state;	\
+	cfi_def_cfa(%rsp, 8);	\
+	cfi_restore(%rbp);	\
+	ret;			\
+	cfi_restore_state
+
+	.align	8
+0:
+E(0b, FFI_TYPE_VOID)
+	epilogue
+E(0b, FFI_TYPE_INT)
+	movslq	%eax, %rax
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_FLOAT)
+	movss	%xmm0, (%r8)
+	epilogue
+E(0b, FFI_TYPE_DOUBLE)
+	movsd	%xmm0, (%r8)
+	epilogue
+// FFI_TYPE_LONGDOUBLE may be FFI_TYPE_DOUBLE but we need a different value here.
+E(0b, FFI_TYPE_DOUBLE + 1)
+	call	PLT(C(abort))
+E(0b, FFI_TYPE_UINT8)
+	movzbl	%al, %eax
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT8)
+	movsbq	%al, %rax
+	jmp	98f
+E(0b, FFI_TYPE_UINT16)
+	movzwl	%ax, %eax
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT16)
+	movswq	%ax, %rax
+	jmp	98f
+E(0b, FFI_TYPE_UINT32)
+	movl	%eax, %eax
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT32)
+	movslq	%eax, %rax
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_UINT64)
+98:	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT64)
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_STRUCT)
+	epilogue
+E(0b, FFI_TYPE_POINTER)
+	movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_COMPLEX)
+	call	PLT(C(abort))
+E(0b, FFI_TYPE_SMALL_STRUCT_1B)
+	movb	%al, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SMALL_STRUCT_2B)
+	movw	%ax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SMALL_STRUCT_4B)
+	movl	%eax, (%r8)
+	epilogue
+
+	.align	8
+99:	call	PLT(C(abort))
+
+	epilogue
+
+	cfi_endproc
+	SEH(.seh_endproc)
+
+
+/* 32 bytes of outgoing register stack space, 8 bytes of alignment,
+   16 bytes of result, 32 bytes of xmm registers.  */
+#define ffi_clo_FS	(32+8+16+32)
+#define ffi_clo_OFF_R	(32+8)
+#define ffi_clo_OFF_X	(32+8+16)
+
+	.align	8
+	.globl	C(ffi_go_closure_win64)
+	FFI_HIDDEN(C(ffi_go_closure_win64))
+
+	SEH(.seh_proc ffi_go_closure_win64)
+C(ffi_go_closure_win64):
+	cfi_startproc
+	_CET_ENDBR
+	/* Save all integer arguments into the incoming reg stack space.  */
+	movq	%rcx, 8(%rsp)
+	movq	%rdx, 16(%rsp)
+	movq	%r8, 24(%rsp)
+	movq	%r9, 32(%rsp)
+
+	movq	8(%r10), %rcx			/* load cif */
+	movq	16(%r10), %rdx			/* load fun */
+	movq	%r10, %r8			/* closure is user_data */
+	jmp	0f
+	cfi_endproc
+	SEH(.seh_endproc)
+
+	.align	8
+	.globl	C(ffi_closure_win64)
+	FFI_HIDDEN(C(ffi_closure_win64))
+
+	SEH(.seh_proc ffi_closure_win64)
+C(ffi_closure_win64):
+	cfi_startproc
+	_CET_ENDBR
+	/* Save all integer arguments into the incoming reg stack space.  */
+	movq	%rcx, 8(%rsp)
+	movq	%rdx, 16(%rsp)
+	movq	%r8, 24(%rsp)
+	movq	%r9, 32(%rsp)
+
+	movq	FFI_TRAMPOLINE_SIZE(%r10), %rcx		/* load cif */
+	movq	FFI_TRAMPOLINE_SIZE+8(%r10), %rdx	/* load fun */
+	movq	FFI_TRAMPOLINE_SIZE+16(%r10), %r8	/* load user_data */
+0:
+	subq	$ffi_clo_FS, %rsp
+	cfi_adjust_cfa_offset(ffi_clo_FS)
+	SEH(.seh_stackalloc ffi_clo_FS)
+	SEH(.seh_endprologue)
+
+	/* Save all sse arguments into the stack frame.  */
+	movsd	%xmm0, ffi_clo_OFF_X(%rsp)
+	movsd	%xmm1, ffi_clo_OFF_X+8(%rsp)
+	movsd	%xmm2, ffi_clo_OFF_X+16(%rsp)
+	movsd	%xmm3, ffi_clo_OFF_X+24(%rsp)
+
+	leaq	ffi_clo_OFF_R(%rsp), %r9
+	call	PLT(C(ffi_closure_win64_inner))
+
+	/* Load the result into both possible result registers.  */
+	movq    ffi_clo_OFF_R(%rsp), %rax
+	movsd   ffi_clo_OFF_R(%rsp), %xmm0
+
+	addq	$ffi_clo_FS, %rsp
+	cfi_adjust_cfa_offset(-ffi_clo_FS)
+	ret
+
+	cfi_endproc
+	SEH(.seh_endproc)
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+	.align	8
+	.globl	C(ffi_closure_win64_alt)
+	FFI_HIDDEN(C(ffi_closure_win64_alt))
+
+	SEH(.seh_proc ffi_closure_win64_alt)
+C(ffi_closure_win64_alt):
+	_CET_ENDBR
+	movq	8(%rsp), %r10
+	addq	$16, %rsp
+	jmp	C(ffi_closure_win64)
+	SEH(.seh_endproc)
+#endif
+#endif /* __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/x86/ffiw64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/ffiw64.c b/libffi-3.4.6/src/x86/ffiw64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/ffiw64.c	
@@ -0,0 +1,361 @@
+/* -----------------------------------------------------------------------
+   ffiw64.c - Copyright (c) 2018 Anthony Green
+              Copyright (c) 2014 Red Hat, Inc.
+
+   x86 win64 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#if defined(__x86_64__) || defined(_M_AMD64)
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <tramp.h>
+
+#ifdef X86_WIN64
+#define EFI64(name) name
+#else
+#define EFI64(name) FFI_HIDDEN name##_efi64
+#endif
+
+struct win64_call_frame
+{
+  UINT64 rbp;		/* 0 */
+  UINT64 retaddr;	/* 8 */
+  UINT64 fn;		/* 16 */
+  UINT64 flags;		/* 24 */
+  UINT64 rvalue;	/* 32 */
+};
+
+extern void ffi_call_win64 (void *stack, struct win64_call_frame *,
+			    void *closure) FFI_HIDDEN;
+
+ffi_status FFI_HIDDEN
+EFI64(ffi_prep_cif_machdep)(ffi_cif *cif)
+{
+  int flags, n;
+
+  switch (cif->abi)
+    {
+    case FFI_WIN64:
+    case FFI_GNUW64:
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  flags = cif->rtype->type;
+  switch (flags)
+    {
+    default:
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      /* GCC returns long double values by reference, like a struct */
+      if (cif->abi == FFI_GNUW64)
+	flags = FFI_TYPE_STRUCT;
+      break;
+    case FFI_TYPE_COMPLEX:
+      flags = FFI_TYPE_STRUCT;
+      /* FALLTHRU */
+    case FFI_TYPE_STRUCT:
+      switch (cif->rtype->size)
+	{
+	case 8:
+	  flags = FFI_TYPE_UINT64;
+	  break;
+	case 4:
+	  flags = FFI_TYPE_SMALL_STRUCT_4B;
+	  break;
+	case 2:
+	  flags = FFI_TYPE_SMALL_STRUCT_2B;
+	  break;
+	case 1:
+	  flags = FFI_TYPE_SMALL_STRUCT_1B;
+	  break;
+	}
+      break;
+    }
+  cif->flags = flags;
+
+  /* Each argument either fits in a register, an 8 byte slot, or is
+     passed by reference with the pointer in the 8 byte slot.  */
+  n = cif->nargs;
+  n += (flags == FFI_TYPE_STRUCT);
+  if (n < 4)
+    n = 4;
+  cif->bytes = n * 8;
+
+  return FFI_OK;
+}
+
+/* We perform some black magic here to use some of the parent's stack frame in
+ * ffi_call_win64() that breaks with the MSVC compiler with the /RTCs or /GZ
+ * flags.  Disable the 'Stack frame run time error checking' for this function
+ * so we don't hit weird exceptions in debug builds. */
+#if defined(_MSC_VER)
+#pragma runtime_checks("s", off)
+#endif
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  int i, j, n, flags;
+  UINT64 *stack;
+  size_t rsize;
+  struct win64_call_frame *frame;
+  ffi_type **arg_types = cif->arg_types;
+  int nargs = cif->nargs;
+
+  FFI_ASSERT(cif->abi == FFI_GNUW64 || cif->abi == FFI_WIN64);
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT && size > 8)
+        {
+          char *argcopy = alloca (size);
+          memcpy (argcopy, avalue[i], size);
+          avalue[i] = argcopy;
+        }
+    }
+
+  flags = cif->flags;
+  rsize = 0;
+
+  /* If we have no return value for a structure, we need to create one.
+     Otherwise we can ignore the return type entirely.  */
+  if (rvalue == NULL)
+    {
+      if (flags == FFI_TYPE_STRUCT)
+	rsize = cif->rtype->size;
+      else
+	flags = FFI_TYPE_VOID;
+    }
+
+  stack = alloca(cif->bytes + sizeof(struct win64_call_frame) + rsize);
+  frame = (struct win64_call_frame *)((char *)stack + cif->bytes);
+  if (rsize)
+    rvalue = frame + 1;
+
+  frame->fn = (uintptr_t)fn;
+  frame->flags = flags;
+  frame->rvalue = (uintptr_t)rvalue;
+
+  j = 0;
+  if (flags == FFI_TYPE_STRUCT)
+    {
+      stack[0] = (uintptr_t)rvalue;
+      j = 1;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; ++i, ++j)
+    {
+      switch (cif->arg_types[i]->size)
+	{
+	case 8:
+	  stack[j] = *(UINT64 *)avalue[i];
+	  break;
+	case 4:
+	  stack[j] = *(UINT32 *)avalue[i];
+	  break;
+	case 2:
+	  stack[j] = *(UINT16 *)avalue[i];
+	  break;
+	case 1:
+	  stack[j] = *(UINT8 *)avalue[i];
+	  break;
+	default:
+	  stack[j] = (uintptr_t)avalue[i];
+	  break;
+	}
+    }
+
+  ffi_call_win64 (stack, frame, closure);
+}
+#if defined(_MSC_VER)
+#pragma runtime_checks("s", restore)
+#endif
+
+void
+EFI64(ffi_call)(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+void
+EFI64(ffi_call_go)(ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+
+extern void ffi_closure_win64(void) FFI_HIDDEN;
+#if defined(FFI_EXEC_STATIC_TRAMP)
+extern void ffi_closure_win64_alt(void) FFI_HIDDEN;
+#endif
+
+#ifdef FFI_GO_CLOSURES
+extern void ffi_go_closure_win64(void) FFI_HIDDEN;
+#endif
+
+ffi_status
+EFI64(ffi_prep_closure_loc)(ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc MAYBE_UNUSED)
+{
+  static const unsigned char trampoline[FFI_TRAMPOLINE_SIZE - 8] = {
+    /* endbr64 */
+    0xf3, 0x0f, 0x1e, 0xfa,
+    /* leaq  -0xb(%rip),%r10   # 0x0  */
+    0x4c, 0x8d, 0x15, 0xf5, 0xff, 0xff, 0xff,
+    /* jmpq  *0x7(%rip)        # 0x18 */
+    0xff, 0x25, 0x07, 0x00, 0x00, 0x00,
+    /* nopl  0(%rax) */
+    0x0f, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00
+  };
+  char *tramp = closure->tramp;
+
+  switch (cif->abi)
+    {
+    case FFI_WIN64:
+    case FFI_GNUW64:
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      /* Initialize the static trampoline's parameters. */
+      ffi_tramp_set_parms (closure->ftramp, ffi_closure_win64_alt, closure);
+      goto out;
+    }
+#endif
+
+  /* Initialize the dynamic trampoline. */
+  memcpy (tramp, trampoline, sizeof(trampoline));
+  *(UINT64 *)(tramp + sizeof (trampoline)) = (uintptr_t)ffi_closure_win64;
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+#endif
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+#ifdef FFI_GO_CLOSURES
+ffi_status
+EFI64(ffi_prep_go_closure)(ffi_go_closure* closure, ffi_cif* cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+  switch (cif->abi)
+    {
+    case FFI_WIN64:
+    case FFI_GNUW64:
+      break;
+    default:
+      return FFI_BAD_ABI;
+    }
+
+  closure->tramp = ffi_go_closure_win64;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+#endif
+
+struct win64_closure_frame
+{
+  UINT64 rvalue[2];
+  UINT64 fargs[4];
+  UINT64 retaddr;
+  UINT64 args[];
+};
+
+/* Force the inner function to use the MS ABI.  When compiling on win64
+   this is a nop.  When compiling on unix, this simplifies the assembly,
+   and places the burden of saving the extra call-saved registers on
+   the compiler.  */
+int FFI_HIDDEN __attribute__((ms_abi))
+ffi_closure_win64_inner(ffi_cif *cif,
+			void (*fun)(ffi_cif*, void*, void**, void*),
+			void *user_data,
+			struct win64_closure_frame *frame)
+{
+  void **avalue;
+  void *rvalue;
+  int i, n, nreg, flags;
+
+  avalue = alloca(cif->nargs * sizeof(void *));
+  rvalue = frame->rvalue;
+  nreg = 0;
+
+  /* When returning a structure, the address is in the first argument.
+     We must also be prepared to return the same address in eax, so
+     install that address in the frame and pretend we return a pointer.  */
+  flags = cif->flags;
+  if (flags == FFI_TYPE_STRUCT)
+    {
+      rvalue = (void *)(uintptr_t)frame->args[0];
+      frame->rvalue[0] = frame->args[0];
+      nreg = 1;
+    }
+
+  for (i = 0, n = cif->nargs; i < n; ++i, ++nreg)
+    {
+      size_t size = cif->arg_types[i]->size;
+      size_t type = cif->arg_types[i]->type;
+      void *a;
+
+      if (type == FFI_TYPE_DOUBLE || type == FFI_TYPE_FLOAT)
+	{
+	  if (nreg < 4)
+	    a = &frame->fargs[nreg];
+	  else
+	    a = &frame->args[nreg];
+	}
+      else if (size == 1 || size == 2 || size == 4 || size == 8)
+	a = &frame->args[nreg];
+      else
+	a = (void *)(uintptr_t)frame->args[nreg];
+
+      avalue[i] = a;
+    }
+
+  /* Invoke the closure.  */
+  fun (cif, rvalue, avalue, user_data);
+  return flags;
+}
+
+#endif /* __x86_64__ */
Index: libffi-3.4.6/src/x86/unix64.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/unix64.S b/libffi-3.4.6/src/x86/unix64.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/unix64.S	
@@ -0,0 +1,711 @@
+/* -----------------------------------------------------------------------
+   unix64.S - Copyright (c) 2013  The Written Word, Inc.
+	    - Copyright (c) 2008  Red Hat, Inc
+	    - Copyright (c) 2002  Bo Thorsen <bo@suse.de>
+
+   x86-64 Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifdef __x86_64__
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#include "internal64.h"
+#include "asmnames.h"
+
+	.text
+
+/* This macro allows the safe creation of jump tables without an
+   actual table.  The entry points into the table are all 8 bytes.
+   The use of ORG asserts that we're at the correct location.  */
+/* ??? The clang assembler doesn't handle .org with symbolic expressions.  */
+#ifdef __CET__
+/* Double slot size to 16 byte to add 4 bytes of ENDBR64.  */
+# define E(BASE, X)	.balign 8; .org BASE + X * 16
+#elif defined(__clang__) || defined(__APPLE__) || (defined (__sun__) && defined(__svr4__))
+# define E(BASE, X)	.balign 8
+#else
+# define E(BASE, X)	.balign 8; .org BASE + X * 8
+#endif
+
+/* ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
+	            void *raddr, void (*fnaddr)(void));
+
+   Bit o trickiness here -- ARGS+BYTES is the base of the stack frame
+   for this function.  This has been allocated by ffi_call.  We also
+   deallocate some of the stack that has been alloca'd.  */
+
+	.balign	8
+	.globl	C(ffi_call_unix64)
+	FFI_HIDDEN(C(ffi_call_unix64))
+
+C(ffi_call_unix64):
+L(UW0):
+	_CET_ENDBR
+	movq	(%rsp), %r10		/* Load return address.  */
+	leaq	(%rdi, %rsi), %rax	/* Find local stack base.  */
+	movq	%rdx, (%rax)		/* Save flags.  */
+	movq	%rcx, 8(%rax)		/* Save raddr.  */
+	movq	%rbp, 16(%rax)		/* Save old frame pointer.  */
+	movq	%r10, 24(%rax)		/* Relocate return address.  */
+	movq	%rax, %rbp		/* Finalize local stack frame.  */
+
+	/* New stack frame based off rbp.  This is a itty bit of unwind
+	   trickery in that the CFA *has* changed.  There is no easy way
+	   to describe it correctly on entry to the function.  Fortunately,
+	   it doesn't matter too much since at all points we can correctly
+	   unwind back to ffi_call.  Note that the location to which we
+	   moved the return address is (the new) CFA-8, so from the
+	   perspective of the unwind info, it hasn't moved.  */
+L(UW1):
+	/* cfi_def_cfa(%rbp, 32) */
+	/* cfi_rel_offset(%rbp, 16) */
+
+	movq	%rdi, %r10		/* Save a copy of the register area. */
+	movq	%r8, %r11		/* Save a copy of the target fn.  */
+
+	/* Load up all argument registers.  */
+	movq	(%r10), %rdi
+	movq	0x08(%r10), %rsi
+	movq	0x10(%r10), %rdx
+	movq	0x18(%r10), %rcx
+	movq	0x20(%r10), %r8
+	movq	0x28(%r10), %r9
+	movl	0xb0(%r10), %eax	/* Set number of SSE registers.  */
+	testl	%eax, %eax
+	jnz	L(load_sse)
+L(ret_from_load_sse):
+
+	/* Deallocate the reg arg area, except for r10, then load via pop.  */
+	leaq	0xb8(%r10), %rsp
+	popq	%r10
+
+	/* Call the user function.  */
+	call	*%r11
+
+	/* Deallocate stack arg area; local stack frame in redzone.  */
+	leaq	24(%rbp), %rsp
+
+	movq	0(%rbp), %rcx		/* Reload flags.  */
+	movq	8(%rbp), %rdi		/* Reload raddr.  */
+	movq	16(%rbp), %rbp		/* Reload old frame pointer.  */
+L(UW2):
+	/* cfi_remember_state */
+	/* cfi_def_cfa(%rsp, 8) */
+	/* cfi_restore(%rbp) */
+
+	/* The first byte of the flags contains the FFI_TYPE.  */
+	cmpb	$UNIX64_RET_LAST, %cl
+	movzbl	%cl, %r10d
+	leaq	L(store_table)(%rip), %r11
+	ja	L(sa)
+#ifdef __CET__
+	/* NB: Originally, each slot is 8 byte.  4 bytes of ENDBR64 +
+	   4 bytes NOP padding double slot size to 16 bytes.  */
+	addl	%r10d, %r10d
+#endif
+	leaq	(%r11, %r10, 8), %r10
+
+	/* Prep for the structure cases: scratch area in redzone.  */
+	leaq	-20(%rsp), %rsi
+	jmp	*%r10
+
+	.balign	8
+L(store_table):
+E(L(store_table), UNIX64_RET_VOID)
+	_CET_ENDBR
+	ret
+E(L(store_table), UNIX64_RET_UINT8)
+	_CET_ENDBR
+	movzbl	%al, %eax
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_UINT16)
+	_CET_ENDBR
+	movzwl	%ax, %eax
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_UINT32)
+	_CET_ENDBR
+	movl	%eax, %eax
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_SINT8)
+	_CET_ENDBR
+	movsbq	%al, %rax
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_SINT16)
+	_CET_ENDBR
+	movswq	%ax, %rax
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_SINT32)
+	_CET_ENDBR
+	cltq
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_INT64)
+	_CET_ENDBR
+	movq	%rax, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_XMM32)
+	_CET_ENDBR
+	movd	%xmm0, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_XMM64)
+	_CET_ENDBR
+	movq	%xmm0, (%rdi)
+	ret
+E(L(store_table), UNIX64_RET_X87)
+	_CET_ENDBR
+	fstpt	(%rdi)
+	ret
+E(L(store_table), UNIX64_RET_X87_2)
+	_CET_ENDBR
+	fstpt	(%rdi)
+	fstpt	16(%rdi)
+	ret
+E(L(store_table), UNIX64_RET_ST_XMM0_RAX)
+	_CET_ENDBR
+	movq	%rax, 8(%rsi)
+	jmp	L(s3)
+E(L(store_table), UNIX64_RET_ST_RAX_XMM0)
+	_CET_ENDBR
+	movq	%xmm0, 8(%rsi)
+	jmp	L(s2)
+E(L(store_table), UNIX64_RET_ST_XMM0_XMM1)
+	_CET_ENDBR
+	movq	%xmm1, 8(%rsi)
+	jmp	L(s3)
+E(L(store_table), UNIX64_RET_ST_RAX_RDX)
+	_CET_ENDBR
+	movq	%rdx, 8(%rsi)
+L(s2):
+	movq	%rax, (%rsi)
+	shrl	$UNIX64_SIZE_SHIFT, %ecx
+	rep movsb
+	ret
+	.balign 8
+L(s3):
+	movq	%xmm0, (%rsi)
+	shrl	$UNIX64_SIZE_SHIFT, %ecx
+	rep movsb
+	ret
+
+L(sa):	call	PLT(C(abort))
+
+	/* Many times we can avoid loading any SSE registers at all.
+	   It's not worth an indirect jump to load the exact set of
+	   SSE registers needed; zero or all is a good compromise.  */
+	.balign 2
+L(UW3):
+	/* cfi_restore_state */
+L(load_sse):
+	movdqa	0x30(%r10), %xmm0
+	movdqa	0x40(%r10), %xmm1
+	movdqa	0x50(%r10), %xmm2
+	movdqa	0x60(%r10), %xmm3
+	movdqa	0x70(%r10), %xmm4
+	movdqa	0x80(%r10), %xmm5
+	movdqa	0x90(%r10), %xmm6
+	movdqa	0xa0(%r10), %xmm7
+	jmp	L(ret_from_load_sse)
+
+L(UW4):
+ENDF(C(ffi_call_unix64))
+
+/* 6 general registers, 8 vector registers,
+   32 bytes of rvalue, 8 bytes of alignment.  */
+#define ffi_closure_OFS_G	0
+#define ffi_closure_OFS_V	(6*8)
+#define ffi_closure_OFS_RVALUE	(ffi_closure_OFS_V + 8*16)
+#define ffi_closure_FS		(ffi_closure_OFS_RVALUE + 32 + 8)
+
+/* The location of rvalue within the red zone after deallocating the frame.  */
+#define ffi_closure_RED_RVALUE	(ffi_closure_OFS_RVALUE - ffi_closure_FS)
+
+	.balign	2
+	.globl	C(ffi_closure_unix64_sse)
+	FFI_HIDDEN(C(ffi_closure_unix64_sse))
+
+C(ffi_closure_unix64_sse):
+L(UW5):
+	_CET_ENDBR
+	subq	$ffi_closure_FS, %rsp
+L(UW6):
+	/* cfi_adjust_cfa_offset(ffi_closure_FS) */
+
+	movdqa	%xmm0, ffi_closure_OFS_V+0x00(%rsp)
+	movdqa	%xmm1, ffi_closure_OFS_V+0x10(%rsp)
+	movdqa	%xmm2, ffi_closure_OFS_V+0x20(%rsp)
+	movdqa	%xmm3, ffi_closure_OFS_V+0x30(%rsp)
+	movdqa	%xmm4, ffi_closure_OFS_V+0x40(%rsp)
+	movdqa	%xmm5, ffi_closure_OFS_V+0x50(%rsp)
+	movdqa	%xmm6, ffi_closure_OFS_V+0x60(%rsp)
+	movdqa	%xmm7, ffi_closure_OFS_V+0x70(%rsp)
+	jmp	L(sse_entry1)
+
+L(UW7):
+ENDF(C(ffi_closure_unix64_sse))
+
+	.balign	2
+	.globl	C(ffi_closure_unix64)
+	FFI_HIDDEN(C(ffi_closure_unix64))
+
+C(ffi_closure_unix64):
+L(UW8):
+	_CET_ENDBR
+	subq	$ffi_closure_FS, %rsp
+L(UW9):
+	/* cfi_adjust_cfa_offset(ffi_closure_FS) */
+L(sse_entry1):
+	movq	%rdi, ffi_closure_OFS_G+0x00(%rsp)
+	movq    %rsi, ffi_closure_OFS_G+0x08(%rsp)
+	movq    %rdx, ffi_closure_OFS_G+0x10(%rsp)
+	movq    %rcx, ffi_closure_OFS_G+0x18(%rsp)
+	movq    %r8,  ffi_closure_OFS_G+0x20(%rsp)
+	movq    %r9,  ffi_closure_OFS_G+0x28(%rsp)
+
+#ifdef __ILP32__
+	movl	FFI_TRAMPOLINE_SIZE(%r10), %edi		/* Load cif */
+	movl	FFI_TRAMPOLINE_SIZE+4(%r10), %esi	/* Load fun */
+	movl	FFI_TRAMPOLINE_SIZE+8(%r10), %edx	/* Load user_data */
+#else
+	movq	FFI_TRAMPOLINE_SIZE(%r10), %rdi		/* Load cif */
+	movq	FFI_TRAMPOLINE_SIZE+8(%r10), %rsi	/* Load fun */
+	movq	FFI_TRAMPOLINE_SIZE+16(%r10), %rdx	/* Load user_data */
+#endif
+L(do_closure):
+	leaq	ffi_closure_OFS_RVALUE(%rsp), %rcx	/* Load rvalue */
+	movq	%rsp, %r8				/* Load reg_args */
+	leaq	ffi_closure_FS+8(%rsp), %r9		/* Load argp */
+	call	PLT(C(ffi_closure_unix64_inner))
+
+	/* Deallocate stack frame early; return value is now in redzone.  */
+	addq	$ffi_closure_FS, %rsp
+L(UW10):
+	/* cfi_adjust_cfa_offset(-ffi_closure_FS) */
+
+	/* The first byte of the return value contains the FFI_TYPE.  */
+	cmpb	$UNIX64_RET_LAST, %al
+	movzbl	%al, %r10d
+	leaq	L(load_table)(%rip), %r11
+	ja	L(la)
+#ifdef __CET__
+	/* NB: Originally, each slot is 8 byte.  4 bytes of ENDBR64 +
+	   4 bytes NOP padding double slot size to 16 bytes.  */
+	addl	%r10d, %r10d
+#endif
+	leaq	(%r11, %r10, 8), %r10
+	leaq	ffi_closure_RED_RVALUE(%rsp), %rsi
+	jmp	*%r10
+
+	.balign	8
+L(load_table):
+E(L(load_table), UNIX64_RET_VOID)
+	_CET_ENDBR
+	ret
+E(L(load_table), UNIX64_RET_UINT8)
+	_CET_ENDBR
+	movzbl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_UINT16)
+	_CET_ENDBR
+	movzwl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_UINT32)
+	_CET_ENDBR
+	movl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_SINT8)
+	_CET_ENDBR
+	movsbl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_SINT16)
+	_CET_ENDBR
+	movswl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_SINT32)
+	_CET_ENDBR
+	movl	(%rsi), %eax
+	ret
+E(L(load_table), UNIX64_RET_INT64)
+	_CET_ENDBR
+	movq	(%rsi), %rax
+	ret
+E(L(load_table), UNIX64_RET_XMM32)
+	_CET_ENDBR
+	movd	(%rsi), %xmm0
+	ret
+E(L(load_table), UNIX64_RET_XMM64)
+	_CET_ENDBR
+	movq	(%rsi), %xmm0
+	ret
+E(L(load_table), UNIX64_RET_X87)
+	_CET_ENDBR
+	fldt	(%rsi)
+	ret
+E(L(load_table), UNIX64_RET_X87_2)
+	_CET_ENDBR
+	fldt	16(%rsi)
+	fldt	(%rsi)
+	ret
+E(L(load_table), UNIX64_RET_ST_XMM0_RAX)
+	_CET_ENDBR
+	movq	8(%rsi), %rax
+	jmp	L(l3)
+E(L(load_table), UNIX64_RET_ST_RAX_XMM0)
+	_CET_ENDBR
+	movq	8(%rsi), %xmm0
+	jmp	L(l2)
+E(L(load_table), UNIX64_RET_ST_XMM0_XMM1)
+	_CET_ENDBR
+	movq	8(%rsi), %xmm1
+	jmp	L(l3)
+E(L(load_table), UNIX64_RET_ST_RAX_RDX)
+	_CET_ENDBR
+	movq	8(%rsi), %rdx
+L(l2):
+	movq	(%rsi), %rax
+	ret
+	.balign	8
+L(l3):
+	movq	(%rsi), %xmm0
+	ret
+
+L(la):	call	PLT(C(abort))
+
+L(UW11):
+ENDF(C(ffi_closure_unix64))
+
+	.balign	2
+	.globl	C(ffi_go_closure_unix64_sse)
+	FFI_HIDDEN(C(ffi_go_closure_unix64_sse))
+
+C(ffi_go_closure_unix64_sse):
+L(UW12):
+	_CET_ENDBR
+	subq	$ffi_closure_FS, %rsp
+L(UW13):
+	/* cfi_adjust_cfa_offset(ffi_closure_FS) */
+
+	movdqa	%xmm0, ffi_closure_OFS_V+0x00(%rsp)
+	movdqa	%xmm1, ffi_closure_OFS_V+0x10(%rsp)
+	movdqa	%xmm2, ffi_closure_OFS_V+0x20(%rsp)
+	movdqa	%xmm3, ffi_closure_OFS_V+0x30(%rsp)
+	movdqa	%xmm4, ffi_closure_OFS_V+0x40(%rsp)
+	movdqa	%xmm5, ffi_closure_OFS_V+0x50(%rsp)
+	movdqa	%xmm6, ffi_closure_OFS_V+0x60(%rsp)
+	movdqa	%xmm7, ffi_closure_OFS_V+0x70(%rsp)
+	jmp	L(sse_entry2)
+
+L(UW14):
+ENDF(C(ffi_go_closure_unix64_sse))
+
+	.balign	2
+	.globl	C(ffi_go_closure_unix64)
+	FFI_HIDDEN(C(ffi_go_closure_unix64))
+
+C(ffi_go_closure_unix64):
+L(UW15):
+	_CET_ENDBR
+	subq	$ffi_closure_FS, %rsp
+L(UW16):
+	/* cfi_adjust_cfa_offset(ffi_closure_FS) */
+L(sse_entry2):
+	movq	%rdi, ffi_closure_OFS_G+0x00(%rsp)
+	movq    %rsi, ffi_closure_OFS_G+0x08(%rsp)
+	movq    %rdx, ffi_closure_OFS_G+0x10(%rsp)
+	movq    %rcx, ffi_closure_OFS_G+0x18(%rsp)
+	movq    %r8,  ffi_closure_OFS_G+0x20(%rsp)
+	movq    %r9,  ffi_closure_OFS_G+0x28(%rsp)
+
+#ifdef __ILP32__
+	movl	4(%r10), %edi		/* Load cif */
+	movl	8(%r10), %esi		/* Load fun */
+	movl	%r10d, %edx		/* Load closure (user_data) */
+#else
+	movq	8(%r10), %rdi		/* Load cif */
+	movq	16(%r10), %rsi		/* Load fun */
+	movq	%r10, %rdx		/* Load closure (user_data) */
+#endif
+	jmp	L(do_closure)
+
+L(UW17):
+ENDF(C(ffi_go_closure_unix64))
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+	.balign	8
+	.globl	C(ffi_closure_unix64_sse_alt)
+	FFI_HIDDEN(C(ffi_closure_unix64_sse_alt))
+
+C(ffi_closure_unix64_sse_alt):
+	/* See the comments above trampoline_code_table. */
+	_CET_ENDBR
+	movq	8(%rsp), %r10			/* Load closure in r10 */
+	addq	$16, %rsp			/* Restore the stack */
+	jmp	C(ffi_closure_unix64_sse)
+ENDF(C(ffi_closure_unix64_sse_alt))
+
+	.balign	8
+	.globl	C(ffi_closure_unix64_alt)
+	FFI_HIDDEN(C(ffi_closure_unix64_alt))
+
+C(ffi_closure_unix64_alt):
+	/* See the comments above trampoline_code_table. */
+	_CET_ENDBR
+	movq	8(%rsp), %r10			/* Load closure in r10 */
+	addq	$16, %rsp			/* Restore the stack */
+	jmp	C(ffi_closure_unix64)
+	ENDF(C(ffi_closure_unix64_alt))
+
+/*
+ * Below is the definition of the trampoline code table. Each element in
+ * the code table is a trampoline.
+ *
+ * Because we jump to the trampoline, we place a _CET_ENDBR at the
+ * beginning of the trampoline to mark it as a valid branch target. This is
+ * part of the the Intel CET (Control Flow Enforcement Technology).
+ */
+/*
+ * The trampoline uses register r10. It saves the original value of r10 on
+ * the stack.
+ *
+ * The trampoline has two parameters - target code to jump to and data for
+ * the target code. The trampoline extracts the parameters from its parameter
+ * block (see tramp_table_map()). The trampoline saves the data address on
+ * the stack. Finally, it jumps to the target code.
+ *
+ * The target code can choose to:
+ *
+ * - restore the value of r10
+ * - load the data address in a register
+ * - restore the stack pointer to what it was when the trampoline was invoked.
+ */
+#ifdef ENDBR_PRESENT
+# define X86_DATA_OFFSET	4077
+# ifdef __ILP32__
+#  define X86_CODE_OFFSET	4069
+# else
+#  define X86_CODE_OFFSET	4073
+# endif
+#else
+# define X86_DATA_OFFSET	4081
+# ifdef __ILP32__
+#  define X86_CODE_OFFSET	4073
+# else
+#  define X86_CODE_OFFSET	4077
+# endif
+#endif
+
+	.align	UNIX64_TRAMP_MAP_SIZE
+	.globl	trampoline_code_table
+	FFI_HIDDEN(C(trampoline_code_table))
+
+C(trampoline_code_table):
+	.rept	UNIX64_TRAMP_MAP_SIZE / UNIX64_TRAMP_SIZE
+	_CET_ENDBR
+	subq	$16, %rsp			/* Make space on the stack */
+	movq	%r10, (%rsp)			/* Save %r10 on stack */
+#ifdef __ILP32__
+	movl	X86_DATA_OFFSET(%rip), %r10d	/* Copy data into %r10 */
+#else
+	movq	X86_DATA_OFFSET(%rip), %r10	/* Copy data into %r10 */
+#endif
+	movq	%r10, 8(%rsp)			/* Save data on stack */
+#ifdef __ILP32__
+	movl	X86_CODE_OFFSET(%rip), %r10d	/* Copy code into %r10 */
+#else
+	movq	X86_CODE_OFFSET(%rip), %r10	/* Copy code into %r10 */
+#endif
+	jmp	*%r10				/* Jump to code */
+	.align	8
+	.endr
+ENDF(C(trampoline_code_table))
+	.align	UNIX64_TRAMP_MAP_SIZE
+#endif /* FFI_EXEC_STATIC_TRAMP */
+
+/* Sadly, OSX cctools-as doesn't understand .cfi directives at all.  */
+
+#ifdef __APPLE__
+.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
+EHFrame0:
+#elif defined(HAVE_AS_X86_64_UNWIND_SECTION_TYPE)
+.section .eh_frame,"a",@unwind
+#else
+.section .eh_frame,"a",@progbits
+#endif
+
+#ifdef HAVE_AS_X86_PCREL
+# define PCREL(X)	X - .
+#else
+# define PCREL(X)	X@rel
+#endif
+
+/* Simplify advancing between labels.  Assume DW_CFA_advance_loc1 fits.  */
+#ifdef __CET__
+/* Use DW_CFA_advance_loc2 when IBT is enabled.  */
+# define ADV(N, P)	.byte 3; .2byte L(N)-L(P)
+#else
+# define ADV(N, P)	.byte 2, L(N)-L(P)
+#endif
+
+	.balign 8
+L(CIE):
+	.set	L(set0),L(ECIE)-L(SCIE)
+	.long	L(set0)			/* CIE Length */
+L(SCIE):
+	.long	0			/* CIE Identifier Tag */
+	.byte	1			/* CIE Version */
+	.ascii	"zR\0"			/* CIE Augmentation */
+	.byte	1			/* CIE Code Alignment Factor */
+	.byte	0x78			/* CIE Data Alignment Factor */
+	.byte	0x10			/* CIE RA Column */
+	.byte	1			/* Augmentation size */
+	.byte	0x1b			/* FDE Encoding (pcrel sdata4) */
+	.byte	0xc, 7, 8		/* DW_CFA_def_cfa, %rsp offset 8 */
+	.byte	0x80+16, 1		/* DW_CFA_offset, %rip offset 1*-8 */
+	.balign 8
+L(ECIE):
+
+	.set	L(set1),L(EFDE1)-L(SFDE1)
+	.long	L(set1)			/* FDE Length */
+L(SFDE1):
+	.long	L(SFDE1)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW0))		/* Initial location */
+	.long	L(UW4)-L(UW0)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW1, UW0)
+	.byte	0xc, 6, 32		/* DW_CFA_def_cfa, %rbp 32 */
+	.byte	0x80+6, 2		/* DW_CFA_offset, %rbp 2*-8 */
+	ADV(UW2, UW1)
+	.byte	0xa			/* DW_CFA_remember_state */
+	.byte	0xc, 7, 8		/* DW_CFA_def_cfa, %rsp 8 */
+	.byte	0xc0+6			/* DW_CFA_restore, %rbp */
+	ADV(UW3, UW2)
+	.byte	0xb			/* DW_CFA_restore_state */
+	.balign	8
+L(EFDE1):
+
+	.set	L(set2),L(EFDE2)-L(SFDE2)
+	.long	L(set2)			/* FDE Length */
+L(SFDE2):
+	.long	L(SFDE2)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW5))		/* Initial location */
+	.long	L(UW7)-L(UW5)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW6, UW5)
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	ffi_closure_FS + 8, 1	/* uleb128, assuming 128 <= FS < 255 */
+	.balign	8
+L(EFDE2):
+
+	.set	L(set3),L(EFDE3)-L(SFDE3)
+	.long	L(set3)			/* FDE Length */
+L(SFDE3):
+	.long	L(SFDE3)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW8))		/* Initial location */
+	.long	L(UW11)-L(UW8)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW9, UW8)
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	ffi_closure_FS + 8, 1	/* uleb128, assuming 128 <= FS < 255 */
+	ADV(UW10, UW9)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset 8 */
+L(EFDE3):
+
+	.set	L(set4),L(EFDE4)-L(SFDE4)
+	.long	L(set4)			/* FDE Length */
+L(SFDE4):
+	.long	L(SFDE4)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW12))		/* Initial location */
+	.long	L(UW14)-L(UW12)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW13, UW12)
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	ffi_closure_FS + 8, 1	/* uleb128, assuming 128 <= FS < 255 */
+	.balign	8
+L(EFDE4):
+
+	.set	L(set5),L(EFDE5)-L(SFDE5)
+	.long	L(set5)			/* FDE Length */
+L(SFDE5):
+	.long	L(SFDE5)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW15))		/* Initial location */
+	.long	L(UW17)-L(UW15)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW16, UW15)
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	ffi_closure_FS + 8, 1	/* uleb128, assuming 128 <= FS < 255 */
+	.balign	8
+L(EFDE5):
+#ifdef __APPLE__
+	.subsections_via_symbols
+	.section __LD,__compact_unwind,regular,debug
+
+	/* compact unwind for ffi_call_unix64 */
+	.quad    C(ffi_call_unix64)
+	.set     L1,L(UW4)-L(UW0)
+	.long    L1
+	.long    0x04000000 /* use dwarf unwind info */
+	.quad    0
+	.quad    0
+
+	/* compact unwind for ffi_closure_unix64_sse */
+	.quad    C(ffi_closure_unix64_sse)
+	.set     L2,L(UW7)-L(UW5)
+	.long    L2
+	.long    0x04000000 /* use dwarf unwind info */
+	.quad    0
+	.quad    0
+
+	/* compact unwind for ffi_closure_unix64 */
+	.quad    C(ffi_closure_unix64)
+	.set     L3,L(UW11)-L(UW8)
+	.long    L3
+	.long    0x04000000 /* use dwarf unwind info */
+	.quad    0
+	.quad    0
+
+	/* compact unwind for ffi_go_closure_unix64_sse */
+	.quad    C(ffi_go_closure_unix64_sse)
+	.set     L4,L(UW14)-L(UW12)
+	.long    L4
+	.long    0x04000000 /* use dwarf unwind info */
+	.quad    0
+	.quad    0
+
+	/* compact unwind for ffi_go_closure_unix64 */
+	.quad    C(ffi_go_closure_unix64)
+	.set     L5,L(UW17)-L(UW15)
+	.long    L5
+	.long    0x04000000 /* use dwarf unwind info */
+	.quad    0
+	.quad    0
+#endif
+
+#endif /* __x86_64__ */
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/x86/asmnames.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/asmnames.h b/libffi-3.4.6/src/x86/asmnames.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/asmnames.h	
@@ -0,0 +1,30 @@
+#ifndef ASMNAMES_H
+#define ASMNAMES_H
+
+#define C2(X, Y)  X ## Y
+#define C1(X, Y)  C2(X, Y)
+#ifdef __USER_LABEL_PREFIX__
+# define C(X)     C1(__USER_LABEL_PREFIX__, X)
+#else
+# define C(X)     X
+#endif
+
+#ifdef __APPLE__
+# define L(X)     C1(L, X)
+#else
+# define L(X)     C1(.L, X)
+#endif
+
+#if defined(__ELF__) && defined(__PIC__)
+# define PLT(X)	  X@PLT
+#else
+# define PLT(X)	  X
+#endif
+
+#ifdef __ELF__
+# define ENDF(X)  .type	X,@function; .size X, . - X
+#else
+# define ENDF(X)
+#endif
+
+#endif /* ASMNAMES_H */
Index: libffi-3.4.6/src/x86/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/internal.h b/libffi-3.4.6/src/x86/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/internal.h	
@@ -0,0 +1,43 @@
+#define X86_RET_FLOAT		0
+#define X86_RET_DOUBLE		1
+#define X86_RET_LDOUBLE		2
+#define X86_RET_SINT8		3
+#define X86_RET_SINT16		4
+#define X86_RET_UINT8		5
+#define X86_RET_UINT16		6
+#define X86_RET_INT64		7
+#define X86_RET_INT32		8
+#define X86_RET_VOID		9
+#define X86_RET_STRUCTPOP	10
+#define X86_RET_STRUCTARG       11
+#define X86_RET_STRUCT_1B	12
+#define X86_RET_STRUCT_2B	13
+#define X86_RET_UNUSED14	14
+#define X86_RET_UNUSED15	15
+
+#define X86_RET_TYPE_MASK	15
+#define X86_RET_POP_SHIFT	4
+
+#define R_EAX	0
+#define R_EDX	1
+#define R_ECX	2
+
+#ifdef __PCC__
+# define HAVE_FASTCALL 0
+#else
+# define HAVE_FASTCALL 1
+#endif
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+/*
+ * For the trampoline code table mapping, a mapping size of 4K (base page size)
+ * is chosen.
+ */
+#define X86_TRAMP_MAP_SHIFT	12
+#define X86_TRAMP_MAP_SIZE	(1 << X86_TRAMP_MAP_SHIFT)
+#ifdef ENDBR_PRESENT
+#define X86_TRAMP_SIZE		44
+#else
+#define X86_TRAMP_SIZE		40
+#endif
+#endif
Index: libffi-3.4.6/src/x86/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/ffitarget.h b/libffi-3.4.6/src/x86/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/ffitarget.h	
@@ -0,0 +1,164 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012, 2014, 2018  Anthony Green
+                 Copyright (c) 1996-2003, 2010  Red Hat, Inc.
+                 Copyright (C) 2008  Free Software Foundation, Inc.
+
+   Target configuration macros for x86 and x86-64.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+/* For code common to all platforms on x86 and x86_64. */
+#define X86_ANY
+
+#if defined (X86_64) && defined (__i386__)
+#undef X86_64
+#warning ******************************************************
+#warning ********** X86 IS DEFINED ****************************
+#warning ******************************************************
+#define X86
+#endif
+
+#ifdef X86_WIN64
+#define FFI_SIZEOF_ARG 8
+#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+#ifndef _MSC_VER
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+#ifdef X86_WIN64
+#ifdef _MSC_VER
+typedef unsigned __int64       ffi_arg;
+typedef __int64                ffi_sarg;
+#else
+typedef unsigned long long     ffi_arg;
+typedef long long              ffi_sarg;
+#endif
+#else
+#if defined __x86_64__ && defined __ILP32__
+#define FFI_SIZEOF_ARG 8
+#define FFI_SIZEOF_JAVA_RAW  4
+typedef unsigned long long     ffi_arg;
+typedef long long              ffi_sarg;
+#else
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+#endif
+#endif
+
+typedef enum ffi_abi {
+#if defined(X86_WIN64)
+  FFI_FIRST_ABI = 0,
+  FFI_WIN64,            /* sizeof(long double) == 8  - microsoft compilers */
+  FFI_GNUW64,           /* sizeof(long double) == 16 - GNU compilers */
+  FFI_LAST_ABI,
+#ifdef __GNUC__
+  FFI_DEFAULT_ABI = FFI_GNUW64
+#else
+  FFI_DEFAULT_ABI = FFI_WIN64
+#endif
+
+#elif defined(X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))
+  FFI_FIRST_ABI = 1,
+  FFI_UNIX64,
+  FFI_WIN64,
+  FFI_EFI64 = FFI_WIN64,
+  FFI_GNUW64,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_UNIX64
+
+#elif defined(X86_WIN32)
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV      = 1,
+  FFI_STDCALL   = 2,
+  FFI_THISCALL  = 3,
+  FFI_FASTCALL  = 4,
+  FFI_MS_CDECL  = 5,
+  FFI_PASCAL    = 6,
+  FFI_REGISTER  = 7,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_MS_CDECL
+#else
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV      = 1,
+  FFI_THISCALL  = 3,
+  FFI_FASTCALL  = 4,
+  FFI_STDCALL   = 5,
+  FFI_PASCAL    = 6,
+  FFI_REGISTER  = 7,
+  FFI_MS_CDECL  = 8,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+#endif
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+
+#define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
+#define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
+#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)
+#define FFI_TYPE_MS_STRUCT       (FFI_TYPE_LAST + 4)
+
+#if defined (X86_64) || defined(X86_WIN64) \
+    || (defined (__x86_64__) && defined (X86_DARWIN))
+/* 4 bytes of ENDBR64 + 7 bytes of LEA + 6 bytes of JMP + 7 bytes of NOP
+   + 8 bytes of pointer.  */
+# define FFI_TRAMPOLINE_SIZE 32
+# define FFI_NATIVE_RAW_API 0
+#else
+/* 4 bytes of ENDBR32 + 5 bytes of MOV + 5 bytes of JMP + 2 unused
+   bytes.  */
+# define FFI_TRAMPOLINE_SIZE 16
+# define FFI_NATIVE_RAW_API 1  /* x86 has native raw api support */
+#endif
+
+#if !defined(GENERATE_LIBFFI_MAP) && defined(__CET__)
+# include <cet.h>
+# if (__CET__ & 1) != 0
+#   define ENDBR_PRESENT
+# endif
+# define _CET_NOTRACK notrack
+#else
+# define _CET_ENDBR
+# define _CET_NOTRACK
+#endif
+
+#endif
Index: libffi-3.4.6/src/x86/internal64.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/internal64.h b/libffi-3.4.6/src/x86/internal64.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/internal64.h	
@@ -0,0 +1,36 @@
+#define UNIX64_RET_VOID		0
+#define UNIX64_RET_UINT8	1
+#define UNIX64_RET_UINT16	2
+#define UNIX64_RET_UINT32	3
+#define UNIX64_RET_SINT8	4
+#define UNIX64_RET_SINT16	5
+#define UNIX64_RET_SINT32	6
+#define UNIX64_RET_INT64	7
+#define UNIX64_RET_XMM32	8
+#define UNIX64_RET_XMM64	9
+#define UNIX64_RET_X87		10
+#define UNIX64_RET_X87_2	11
+#define UNIX64_RET_ST_XMM0_RAX	12
+#define UNIX64_RET_ST_RAX_XMM0	13
+#define UNIX64_RET_ST_XMM0_XMM1	14
+#define UNIX64_RET_ST_RAX_RDX	15
+
+#define UNIX64_RET_LAST		15
+
+#define UNIX64_FLAG_RET_IN_MEM	(1 << 10)
+#define UNIX64_FLAG_XMM_ARGS	(1 << 11)
+#define UNIX64_SIZE_SHIFT	12
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+/*
+ * For the trampoline code table mapping, a mapping size of 4K (base page size)
+ * is chosen.
+ */
+#define UNIX64_TRAMP_MAP_SHIFT	12
+#define UNIX64_TRAMP_MAP_SIZE	(1 << UNIX64_TRAMP_MAP_SHIFT)
+#ifdef ENDBR_PRESENT
+#define UNIX64_TRAMP_SIZE	40
+#else
+#define UNIX64_TRAMP_SIZE	32
+#endif
+#endif
Index: libffi-3.4.6/src/x86/sysv_intel.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/sysv_intel.S b/libffi-3.4.6/src/x86/sysv_intel.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/sysv_intel.S	
@@ -0,0 +1,998 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2017, 2022  Anthony Green
+          - Copyright (c) 2013  The Written Word, Inc.
+          - Copyright (c) 1996,1998,2001-2003,2005,2008,2010  Red Hat, Inc.
+
+   X86 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef __x86_64__
+#ifdef _MSC_VER
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+
+#define C2(X, Y)  X ## Y
+#define C1(X, Y)  C2(X, Y)
+#define L(X)     C1(L, X)
+# define ENDF(X) X ENDP
+
+/* This macro allows the safe creation of jump tables without an
+   actual table.  The entry points into the table are all 8 bytes.
+   The use of ORG asserts that we're at the correct location.  */
+/* ??? The clang assembler doesn't handle .org with symbolic expressions.  */
+#if defined(__clang__) || defined(__APPLE__) || (defined (__sun__) && defined(__svr4__))
+# define E(BASE, X)	ALIGN 8
+#else
+# define E(BASE, X)	ALIGN 8; ORG BASE + X * 8
+#endif
+
+    .686P
+    .MODEL FLAT
+
+EXTRN	@ffi_closure_inner@8:PROC
+_TEXT SEGMENT
+
+/* This is declared as
+
+   void ffi_call_i386(struct call_frame *frame, char *argp)
+        __attribute__((fastcall));
+
+   Thus the arguments are present in
+
+        ecx: frame
+        edx: argp
+*/
+
+ALIGN 16
+PUBLIC @ffi_call_i386@8
+@ffi_call_i386@8 PROC
+L(UW0):
+	cfi_startproc
+ #if !HAVE_FASTCALL
+	mov	    ecx, [esp+4]
+	mov 	edx, [esp+8]
+ #endif
+	mov	    eax, [esp]		/* move the return address */
+	mov	    [ecx], ebp		/* store ebp into local frame */
+	mov 	[ecx+4], eax	/* store retaddr into local frame */
+
+	/* New stack frame based off ebp.  This is a itty bit of unwind
+	   trickery in that the CFA *has* changed.  There is no easy way
+	   to describe it correctly on entry to the function.  Fortunately,
+	   it doesn't matter too much since at all points we can correctly
+	   unwind back to ffi_call.  Note that the location to which we
+	   moved the return address is (the new) CFA-4, so from the
+	   perspective of the unwind info, it hasn't moved.  */
+	mov 	ebp, ecx
+L(UW1):
+	/* cfi_def_cfa(%ebp, 8) */
+	/* cfi_rel_offset(%ebp, 0) */
+
+	mov 	esp, edx		/* set outgoing argument stack */
+	mov 	eax, [20+R_EAX*4+ebp]	/* set register arguments */
+	mov 	edx, [20+R_EDX*4+ebp]
+	mov	    ecx, [20+R_ECX*4+ebp]
+
+	call	dword ptr [ebp+8]
+
+	mov	    ecx, [12+ebp]		/* load return type code */
+	mov 	[ebp+8], ebx		/* preserve %ebx */
+L(UW2):
+	/* cfi_rel_offset(%ebx, 8) */
+
+	and 	ecx, X86_RET_TYPE_MASK
+	lea 	ebx, [L(store_table) + ecx * 8]
+	mov 	ecx, [ebp+16]		/* load result address */
+	jmp	    ebx
+
+	ALIGN	8
+L(store_table):
+E(L(store_table), X86_RET_FLOAT)
+	fstp	DWORD PTR [ecx]
+	jmp	L(e1)
+E(L(store_table), X86_RET_DOUBLE)
+	fstp	QWORD PTR [ecx]
+	jmp	L(e1)
+E(L(store_table), X86_RET_LDOUBLE)
+	fstp	QWORD PTR [ecx]
+	jmp	L(e1)
+E(L(store_table), X86_RET_SINT8)
+	movsx	eax, al
+	mov	[ecx], eax
+	jmp	L(e1)
+E(L(store_table), X86_RET_SINT16)
+	movsx	eax, ax
+	mov	[ecx], eax
+	jmp	L(e1)
+E(L(store_table), X86_RET_UINT8)
+	movzx	eax, al
+	mov	[ecx], eax
+	jmp	L(e1)
+E(L(store_table), X86_RET_UINT16)
+	movzx	eax, ax
+	mov	[ecx], eax
+	jmp	L(e1)
+E(L(store_table), X86_RET_INT64)
+	mov	[ecx+4], edx
+	/* fallthru */
+E(L(store_table), X86_RET_int 32)
+	mov	[ecx], eax
+	/* fallthru */
+E(L(store_table), X86_RET_VOID)
+L(e1):
+	mov	    ebx, [ebp+8]
+	mov	    esp, ebp
+	pop 	ebp
+L(UW3):
+	/* cfi_remember_state */
+	/* cfi_def_cfa(%esp, 4) */
+	/* cfi_restore(%ebx) */
+	/* cfi_restore(%ebp) */
+	ret
+L(UW4):
+	/* cfi_restore_state */
+
+E(L(store_table), X86_RET_STRUCTPOP)
+	jmp	    L(e1)
+E(L(store_table), X86_RET_STRUCTARG)
+	jmp	    L(e1)
+E(L(store_table), X86_RET_STRUCT_1B)
+	mov 	[ecx], al
+	jmp	    L(e1)
+E(L(store_table), X86_RET_STRUCT_2B)
+	mov 	[ecx], ax
+	jmp	    L(e1)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(store_table), X86_RET_UNUSED14)
+	int 3
+E(L(store_table), X86_RET_UNUSED15)
+	int 3
+
+L(UW5):
+	/* cfi_endproc */
+ENDF(@ffi_call_i386@8)
+
+/* The inner helper is declared as
+
+   void ffi_closure_inner(struct closure_frame *frame, char *argp)
+	__attribute_((fastcall))
+
+   Thus the arguments are placed in
+
+	ecx:	frame
+	edx:	argp
+*/
+
+/* Macros to help setting up the closure_data structure.  */
+
+#if HAVE_FASTCALL
+# define closure_FS	(40 + 4)
+# define closure_CF	0
+#else
+# define closure_FS	(8 + 40 + 12)
+# define closure_CF	8
+#endif
+
+FFI_CLOSURE_SAVE_REGS MACRO
+	mov 	[esp + closure_CF+16+R_EAX*4], eax
+	mov 	[esp + closure_CF+16+R_EDX*4], edx
+	mov 	[esp + closure_CF+16+R_ECX*4], ecx
+ENDM
+
+FFI_CLOSURE_COPY_TRAMP_DATA MACRO
+	mov 	edx, [eax+FFI_TRAMPOLINE_SIZE]      /* copy cif */
+	mov 	ecx, [eax+FFI_TRAMPOLINE_SIZE+4]    /* copy fun */
+	mov 	eax, [eax+FFI_TRAMPOLINE_SIZE+8];   /* copy user_data */
+	mov 	[esp+closure_CF+28], edx
+	mov 	[esp+closure_CF+32], ecx
+	mov 	[esp+closure_CF+36], eax
+ENDM
+
+#if HAVE_FASTCALL
+FFI_CLOSURE_PREP_CALL MACRO
+	mov	    ecx, esp                    /* load closure_data */
+	lea 	edx, [esp+closure_FS+4]     /* load incoming stack */
+ENDM
+#else
+FFI_CLOSURE_PREP_CALL MACRO
+	lea 	ecx, [esp+closure_CF]       /* load closure_data */
+	lea 	edx, [esp+closure_FS+4]     /* load incoming stack */
+	mov 	[esp], ecx
+	mov 	[esp+4], edx
+ENDM
+#endif
+
+FFI_CLOSURE_CALL_INNER MACRO UWN
+	call	@ffi_closure_inner@8
+ENDM
+
+FFI_CLOSURE_MASK_AND_JUMP MACRO LABEL
+	and	    eax, X86_RET_TYPE_MASK
+	lea 	edx, [LABEL+eax*8]
+	mov 	eax, [esp+closure_CF]       /* optimiztic load */
+	jmp	    edx
+ENDM
+
+ALIGN 16
+PUBLIC ffi_go_closure_EAX
+ffi_go_closure_EAX PROC C
+L(UW6):
+	/* cfi_startproc */
+	sub	esp, closure_FS
+L(UW7):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+	FFI_CLOSURE_SAVE_REGS
+	mov     edx, [eax+4]			/* copy cif */
+	mov 	ecx, [eax +8]			/* copy fun */
+	mov 	[esp+closure_CF+28], edx
+	mov 	[esp+closure_CF+32], ecx
+	mov 	[esp+closure_CF+36], eax	/* closure is user_data */
+	jmp	L(do_closure_i386)
+L(UW8):
+	/* cfi_endproc */
+ENDF(ffi_go_closure_EAX)
+
+ALIGN 16
+PUBLIC ffi_go_closure_ECX
+ffi_go_closure_ECX PROC C
+L(UW9):
+	/* cfi_startproc */
+	sub 	esp, closure_FS
+L(UW10):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+	FFI_CLOSURE_SAVE_REGS
+	mov 	edx, [ecx+4]			/* copy cif */
+	mov 	eax, [ecx+8]			/* copy fun */
+	mov 	[esp+closure_CF+28], edx
+	mov 	[esp+closure_CF+32], eax
+	mov 	[esp+closure_CF+36], ecx	/* closure is user_data */
+	jmp	L(do_closure_i386)
+L(UW11):
+	/* cfi_endproc */
+ENDF(ffi_go_closure_ECX)
+
+/* The closure entry points are reached from the ffi_closure trampoline.
+   On entry, %eax contains the address of the ffi_closure.  */
+
+ALIGN 16
+PUBLIC ffi_closure_i386
+ffi_closure_i386 PROC C
+L(UW12):
+	/* cfi_startproc */
+	sub	    esp, closure_FS
+L(UW13):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+
+	FFI_CLOSURE_SAVE_REGS
+	FFI_CLOSURE_COPY_TRAMP_DATA
+
+	/* Entry point from preceeding Go closures.  */
+L(do_closure_i386)::
+
+	FFI_CLOSURE_PREP_CALL
+	FFI_CLOSURE_CALL_INNER(14)
+	FFI_CLOSURE_MASK_AND_JUMP L(C1(load_table,2))
+
+    ALIGN 8
+L(load_table2):
+E(L(load_table2), X86_RET_FLOAT)
+	fld 	dword ptr [esp+closure_CF]
+	jmp	L(e2)
+E(L(load_table2), X86_RET_DOUBLE)
+	fld 	qword ptr [esp+closure_CF]
+	jmp	L(e2)
+E(L(load_table2), X86_RET_LDOUBLE)
+	fld 	qword ptr [esp+closure_CF]
+	jmp	L(e2)
+E(L(load_table2), X86_RET_SINT8)
+	movsx	eax, al
+	jmp	L(e2)
+E(L(load_table2), X86_RET_SINT16)
+	movsx	eax, ax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_UINT8)
+	movzx	eax, al
+	jmp	L(e2)
+E(L(load_table2), X86_RET_UINT16)
+	movzx	eax, ax
+	jmp	L(e2)
+E(L(load_table2), X86_RET_INT64)
+	mov 	edx, [esp+closure_CF+4]
+	jmp	L(e2)
+E(L(load_table2), X86_RET_INT32)
+	nop
+	/* fallthru */
+E(L(load_table2), X86_RET_VOID)
+L(e2):
+	add 	esp, closure_FS
+L(UW16):
+	/* cfi_adjust_cfa_offset(-closure_FS) */
+	ret
+L(UW17):
+	/* cfi_adjust_cfa_offset(closure_FS) */
+E(L(load_table2), X86_RET_STRUCTPOP)
+	add 	esp, closure_FS
+L(UW18):
+	/* cfi_adjust_cfa_offset(-closure_FS) */
+	ret	4
+L(UW19):
+	/* cfi_adjust_cfa_offset(closure_FS) */
+E(L(load_table2), X86_RET_STRUCTARG)
+	jmp	L(e2)
+E(L(load_table2), X86_RET_STRUCT_1B)
+	movzx	eax, al
+	jmp	L(e2)
+E(L(load_table2), X86_RET_STRUCT_2B)
+	movzx	eax, ax
+	jmp	L(e2)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table2), X86_RET_UNUSED14)
+	int 3
+E(L(load_table2), X86_RET_UNUSED15)
+	int 3
+
+L(UW20):
+	/* cfi_endproc */
+ENDF(ffi_closure_i386)
+
+ALIGN 16
+PUBLIC	ffi_go_closure_STDCALL
+ffi_go_closure_STDCALL PROC C
+L(UW21):
+	/* cfi_startproc */
+	sub 	esp, closure_FS
+L(UW22):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+	FFI_CLOSURE_SAVE_REGS
+	mov 	edx, [ecx+4]			/* copy cif */
+	mov 	eax, [ecx+8]			/* copy fun */
+	mov 	[esp+closure_CF+28], edx
+	mov 	[esp+closure_CF+32], eax
+	mov 	[esp+closure_CF+36], ecx	/* closure is user_data */
+	jmp	L(do_closure_STDCALL)
+L(UW23):
+	/* cfi_endproc */
+ENDF(ffi_go_closure_STDCALL)
+
+/* For REGISTER, we have no available parameter registers, and so we
+   enter here having pushed the closure onto the stack.  */
+
+ALIGN 16
+PUBLIC ffi_closure_REGISTER
+ffi_closure_REGISTER PROC C
+L(UW24):
+	/* cfi_startproc */
+	/* cfi_def_cfa(%esp, 8) */
+	/* cfi_offset(%eip, -8) */
+	sub 	esp, closure_FS-4
+L(UW25):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+	FFI_CLOSURE_SAVE_REGS
+	mov	ecx, [esp+closure_FS-4] 	/* load retaddr */
+	mov	eax, [esp+closure_FS]		/* load closure */
+	mov	[esp+closure_FS], ecx		/* move retaddr */
+	jmp	L(do_closure_REGISTER)
+L(UW26):
+	/* cfi_endproc */
+ENDF(ffi_closure_REGISTER)
+
+/* For STDCALL (and others), we need to pop N bytes of arguments off
+   the stack following the closure.  The amount needing to be popped
+   is returned to us from ffi_closure_inner.  */
+
+ALIGN 16
+PUBLIC ffi_closure_STDCALL
+ffi_closure_STDCALL PROC C
+L(UW27):
+	/* cfi_startproc */
+	sub 	esp, closure_FS
+L(UW28):
+	/* cfi_def_cfa_offset(closure_FS + 4) */
+
+	FFI_CLOSURE_SAVE_REGS
+
+	/* Entry point from ffi_closure_REGISTER.  */
+L(do_closure_REGISTER)::
+
+	FFI_CLOSURE_COPY_TRAMP_DATA
+
+	/* Entry point from preceeding Go closure.  */
+L(do_closure_STDCALL)::
+
+	FFI_CLOSURE_PREP_CALL
+	FFI_CLOSURE_CALL_INNER(29)
+
+	mov 	ecx, eax
+	shr 	ecx, X86_RET_POP_SHIFT	    /* isolate pop count */
+	lea 	ecx, [esp+closure_FS+ecx]	/* compute popped esp */
+	mov 	edx, [esp+closure_FS]		/* move return address */
+	mov 	[ecx], edx
+
+	/* From this point on, the value of %esp upon return is %ecx+4,
+	   and we've copied the return address to %ecx to make return easy.
+	   There's no point in representing this in the unwind info, as
+	   there is always a window between the mov and the ret which
+	   will be wrong from one point of view or another.  */
+
+	FFI_CLOSURE_MASK_AND_JUMP  L(C1(load_table,3))
+
+    ALIGN 8
+L(load_table3):
+E(L(load_table3), X86_RET_FLOAT)
+	fld    DWORD PTR [esp+closure_CF]
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_DOUBLE)
+	fld    QWORD PTR [esp+closure_CF]
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_LDOUBLE)
+	fld    QWORD PTR [esp+closure_CF]
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_SINT8)
+	movsx   eax, al
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_SINT16)
+	movsx   eax, ax
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_UINT8)
+	movzx   eax, al
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_UINT16)
+	movzx   eax, ax
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_INT64)
+	mov 	edx, [esp+closure_CF+4]
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_int 32)
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_VOID)
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_STRUCTPOP)
+	mov     esp, ecx
+	ret
+E(L(load_table3), X86_RET_STRUCTARG)
+	mov 	esp, ecx
+	ret
+E(L(load_table3), X86_RET_STRUCT_1B)
+	movzx	eax, al
+	mov 	esp, ecx
+	ret
+E(L(load_table3), X86_RET_STRUCT_2B)
+	movzx	eax, ax
+	mov 	esp, ecx
+	ret
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table3), X86_RET_UNUSED14)
+	int 3
+E(L(load_table3), X86_RET_UNUSED15)
+	int 3
+
+L(UW31):
+	/* cfi_endproc */
+ENDF(ffi_closure_STDCALL)
+
+#if !FFI_NO_RAW_API
+
+#define raw_closure_S_FS	(16+16+12)
+
+ALIGN 16
+PUBLIC ffi_closure_raw_SYSV
+ffi_closure_raw_SYSV PROC C
+L(UW32):
+	/* cfi_startproc */
+	sub 	esp, raw_closure_S_FS
+L(UW33):
+	/* cfi_def_cfa_offset(raw_closure_S_FS + 4) */
+	mov 	[esp+raw_closure_S_FS-4], ebx
+L(UW34):
+	/* cfi_rel_offset(%ebx, raw_closure_S_FS-4) */
+
+	mov 	edx, [eax+FFI_TRAMPOLINE_SIZE+8]	/* load cl->user_data */
+	mov 	[esp+12], edx
+	lea 	edx, [esp+raw_closure_S_FS+4]		/* load raw_args */
+	mov 	[esp+8], edx
+	lea 	edx, [esp+16]				/* load &res */
+	mov 	[esp+4], edx
+	mov 	ebx, [eax+FFI_TRAMPOLINE_SIZE]		/* load cl->cif */
+	mov 	[esp], ebx
+	call	DWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]		/* call cl->fun */
+
+	mov 	eax, [ebx+20]			/* load cif->flags */
+	and 	eax, X86_RET_TYPE_MASK
+/* #ifdef __PIC__ */
+/* 	call	__x86.get_pc_thunk.bx */
+/* L(pc4): */
+/* 	lea 	ecx, L(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx */
+/* #else */
+	lea 	ecx, [L(load_table4)+eax+8]
+/* #endif */
+	mov 	ebx, [esp+raw_closure_S_FS-4]
+L(UW35):
+	/* cfi_restore(%ebx) */
+	mov 	eax, [esp+16]				/* Optimistic load */
+	jmp	    dword ptr [ecx]
+
+	ALIGN 8
+L(load_table4):
+E(L(load_table4), X86_RET_FLOAT)
+	fld 	DWORD PTR [esp +16]
+	jmp	L(e4)
+E(L(load_table4), X86_RET_DOUBLE)
+	fld 	QWORD PTR [esp +16]
+	jmp	L(e4)
+E(L(load_table4), X86_RET_LDOUBLE)
+	fld 	QWORD PTR [esp +16]
+	jmp	L(e4)
+E(L(load_table4), X86_RET_SINT8)
+	movsx	eax, al
+	jmp	L(e4)
+E(L(load_table4), X86_RET_SINT16)
+	movsx	eax, ax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_UINT8)
+	movzx	eax, al
+	jmp	L(e4)
+E(L(load_table4), X86_RET_UINT16)
+	movzx	eax, ax
+	jmp	L(e4)
+E(L(load_table4), X86_RET_INT64)
+	mov 	edx, [esp+16+4]
+	jmp	L(e4)
+E(L(load_table4), X86_RET_int 32)
+	nop
+	/* fallthru */
+E(L(load_table4), X86_RET_VOID)
+L(e4):
+	add 	esp, raw_closure_S_FS
+L(UW36):
+	/* cfi_adjust_cfa_offset(-raw_closure_S_FS) */
+	ret
+L(UW37):
+	/* cfi_adjust_cfa_offset(raw_closure_S_FS) */
+E(L(load_table4), X86_RET_STRUCTPOP)
+	add 	esp, raw_closure_S_FS
+L(UW38):
+	/* cfi_adjust_cfa_offset(-raw_closure_S_FS) */
+	ret	4
+L(UW39):
+	/* cfi_adjust_cfa_offset(raw_closure_S_FS) */
+E(L(load_table4), X86_RET_STRUCTARG)
+	jmp	L(e4)
+E(L(load_table4), X86_RET_STRUCT_1B)
+	movzx	eax, al
+	jmp	L(e4)
+E(L(load_table4), X86_RET_STRUCT_2B)
+	movzx	eax, ax
+	jmp	L(e4)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table4), X86_RET_UNUSED14)
+	int 3
+E(L(load_table4), X86_RET_UNUSED15)
+	int 3
+
+L(UW40):
+	/* cfi_endproc */
+ENDF(ffi_closure_raw_SYSV)
+
+#define raw_closure_T_FS	(16+16+8)
+
+ALIGN 16
+PUBLIC ffi_closure_raw_THISCALL
+ffi_closure_raw_THISCALL PROC C
+L(UW41):
+	/* cfi_startproc */
+	/* Rearrange the stack such that %ecx is the first argument.
+	   This means moving the return address.  */
+	pop 	edx
+L(UW42):
+	/* cfi_def_cfa_offset(0) */
+	/* cfi_register(%eip, %edx) */
+	push	ecx
+L(UW43):
+	/* cfi_adjust_cfa_offset(4) */
+	push 	edx
+L(UW44):
+	/* cfi_adjust_cfa_offset(4) */
+	/* cfi_rel_offset(%eip, 0) */
+	sub 	esp, raw_closure_T_FS
+L(UW45):
+	/* cfi_adjust_cfa_offset(raw_closure_T_FS) */
+	mov 	[esp+raw_closure_T_FS-4], ebx
+L(UW46):
+	/* cfi_rel_offset(%ebx, raw_closure_T_FS-4) */
+
+	mov 	edx, [eax+FFI_TRAMPOLINE_SIZE+8]	/* load cl->user_data */
+	mov 	[esp+12], edx
+	lea 	edx, [esp+raw_closure_T_FS+4]		/* load raw_args */
+	mov 	[esp+8], edx
+	lea 	edx, [esp+16]				/* load &res */
+	mov 	[esp+4], edx
+	mov 	ebx, [eax+FFI_TRAMPOLINE_SIZE]		/* load cl->cif */
+	mov 	[esp], ebx
+	call	DWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]		/* call cl->fun */
+
+	mov 	eax, [ebx+20]				/* load cif->flags */
+	and 	eax, X86_RET_TYPE_MASK
+/* #ifdef __PIC__ */
+/* 	call	__x86.get_pc_thunk.bx */
+/* L(pc5): */
+/* 	leal	L(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx */
+/* #else */
+	lea 	ecx, [L(load_table5)+eax*8]
+/*#endif */
+	mov 	ebx, [esp+raw_closure_T_FS-4]
+L(UW47):
+	/* cfi_restore(%ebx) */
+	mov 	eax, [esp+16]				/* Optimistic load */
+	jmp	    DWORD PTR [ecx]
+
+	AlIGN 4
+L(load_table5):
+E(L(load_table5), X86_RET_FLOAT)
+	fld	DWORD PTR [esp +16]
+	jmp	L(e5)
+E(L(load_table5), X86_RET_DOUBLE)
+	fld	QWORD PTR [esp +16]
+	jmp	L(e5)
+E(L(load_table5), X86_RET_LDOUBLE)
+	fld	QWORD PTR [esp+16]
+	jmp	L(e5)
+E(L(load_table5), X86_RET_SINT8)
+	movsx	eax, al
+	jmp	L(e5)
+E(L(load_table5), X86_RET_SINT16)
+	movsx	eax, ax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_UINT8)
+	movzx	eax, al
+	jmp	L(e5)
+E(L(load_table5), X86_RET_UINT16)
+	movzx	eax, ax
+	jmp	L(e5)
+E(L(load_table5), X86_RET_INT64)
+	mov 	edx, [esp+16+4]
+	jmp	L(e5)
+E(L(load_table5), X86_RET_int 32)
+	nop
+	/* fallthru */
+E(L(load_table5), X86_RET_VOID)
+L(e5):
+	add 	esp, raw_closure_T_FS
+L(UW48):
+	/* cfi_adjust_cfa_offset(-raw_closure_T_FS) */
+	/* Remove the extra %ecx argument we pushed.  */
+	ret	4
+L(UW49):
+	/* cfi_adjust_cfa_offset(raw_closure_T_FS) */
+E(L(load_table5), X86_RET_STRUCTPOP)
+	add 	esp, raw_closure_T_FS
+L(UW50):
+	/* cfi_adjust_cfa_offset(-raw_closure_T_FS) */
+	ret	8
+L(UW51):
+	/* cfi_adjust_cfa_offset(raw_closure_T_FS) */
+E(L(load_table5), X86_RET_STRUCTARG)
+	jmp	L(e5)
+E(L(load_table5), X86_RET_STRUCT_1B)
+	movzx	eax, al
+	jmp	L(e5)
+E(L(load_table5), X86_RET_STRUCT_2B)
+	movzx	eax, ax
+	jmp	L(e5)
+
+	/* Fill out the table so that bad values are predictable.  */
+E(L(load_table5), X86_RET_UNUSED14)
+	int 3
+E(L(load_table5), X86_RET_UNUSED15)
+	int 3
+
+L(UW52):
+	/* cfi_endproc */
+ENDF(ffi_closure_raw_THISCALL)
+
+#endif /* !FFI_NO_RAW_API */
+
+#ifdef X86_DARWIN
+# define COMDAT(X)							\
+        .section __TEXT,__text,coalesced,pure_instructions;		\
+        .weak_definition X;						\
+        FFI_HIDDEN(X)
+#elif defined __ELF__ && !(defined(__sun__) && defined(__svr4__))
+# define COMDAT(X)							\
+	.section .text.X,"axG",@progbits,X,comdat;			\
+	PUBLIC	X;							\
+	FFI_HIDDEN(X)
+#else
+# define COMDAT(X)
+#endif
+
+#if 0
+#if defined(__PIC__)
+	COMDAT(C(__x86.get_pc_thunk.bx))
+C(__x86.get_pc_thunk.bx):
+	movl	(%esp), %ebx
+	ret
+ENDF(C(__x86.get_pc_thunk.bx))
+# if defined X86_DARWIN || defined HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+	COMDAT(C(__x86.get_pc_thunk.dx))
+C(__x86.get_pc_thunk.dx):
+	movl	(%esp), %edx
+	ret
+ENDF(C(__x86.get_pc_thunk.dx))
+#endif /* DARWIN || HIDDEN */
+#endif /* __PIC__ */
+#endif
+
+
+#if 0
+/* Sadly, OSX cctools-as doesn't understand .cfi directives at all.  */
+
+#ifdef __APPLE__
+.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
+EHFrame0:
+#elif defined(X86_WIN32)
+.section .eh_frame,"r"
+#elif defined(HAVE_AS_X86_64_UNWIND_SECTION_TYPE)
+.section .eh_frame,EH_FRAME_FLAGS,@unwind
+#else
+.section .eh_frame,EH_FRAME_FLAGS,@progbits
+#endif
+
+#ifdef HAVE_AS_X86_PCREL
+# define PCREL(X)	X - .
+#else
+# define PCREL(X)	X@rel
+#endif
+
+/* Simplify advancing between labels.  Assume DW_CFA_advance_loc1 fits.  */
+#define ADV(N, P)	.byte 2, L(N)-L(P)
+
+	.balign 4
+L(CIE):
+	.set	L(set0),L(ECIE)-L(SCIE)
+	.long	L(set0)			/* CIE Length */
+L(SCIE):
+	.long	0			/* CIE Identifier Tag */
+	.byte	1			/* CIE Version */
+	.ascii	"zR\0"			/* CIE Augmentation */
+	.byte	1			/* CIE Code Alignment Factor */
+	.byte	0x7c			/* CIE Data Alignment Factor */
+	.byte	0x8			/* CIE RA Column */
+	.byte	1			/* Augmentation size */
+	.byte	0x1b			/* FDE Encoding (pcrel sdata4) */
+	.byte	0xc, 4, 4		/* DW_CFA_def_cfa, %esp offset 4 */
+	.byte	0x80+8, 1		/* DW_CFA_offset, %eip offset 1*-4 */
+	.balign 4
+L(ECIE):
+
+	.set	L(set1),L(EFDE1)-L(SFDE1)
+	.long	L(set1)			/* FDE Length */
+L(SFDE1):
+	.long	L(SFDE1)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW0))		/* Initial location */
+	.long	L(UW5)-L(UW0)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW1, UW0)
+	.byte	0xc, 5, 8		/* DW_CFA_def_cfa, %ebp 8 */
+	.byte	0x80+5, 2		/* DW_CFA_offset, %ebp 2*-4 */
+	ADV(UW2, UW1)
+	.byte	0x80+3, 0		/* DW_CFA_offset, %ebx 0*-4 */
+	ADV(UW3, UW2)
+	.byte	0xa			/* DW_CFA_remember_state */
+	.byte	0xc, 4, 4		/* DW_CFA_def_cfa, %esp 4 */
+	.byte	0xc0+3			/* DW_CFA_restore, %ebx */
+	.byte	0xc0+5			/* DW_CFA_restore, %ebp */
+	ADV(UW4, UW3)
+	.byte	0xb			/* DW_CFA_restore_state */
+	.balign	4
+L(EFDE1):
+
+	.set	L(set2),L(EFDE2)-L(SFDE2)
+	.long	L(set2)			/* FDE Length */
+L(SFDE2):
+	.long	L(SFDE2)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW6))		/* Initial location */
+	.long	L(UW8)-L(UW6)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW7, UW6)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE2):
+
+	.set	L(set3),L(EFDE3)-L(SFDE3)
+	.long	L(set3)			/* FDE Length */
+L(SFDE3):
+	.long	L(SFDE3)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW9))		/* Initial location */
+	.long	L(UW11)-L(UW9)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW10, UW9)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE3):
+
+	.set	L(set4),L(EFDE4)-L(SFDE4)
+	.long	L(set4)			/* FDE Length */
+L(SFDE4):
+	.long	L(SFDE4)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW12))		/* Initial location */
+	.long	L(UW20)-L(UW12)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW13, UW12)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+#ifdef FFI_CLOSURE_CALL_INNER_SAVE_EBX
+	ADV(UW14, UW13)
+	.byte	0x80+3, (40-(closure_FS+4))/-4  /* DW_CFA_offset %ebx */
+	ADV(UW15, UW14)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW16, UW15)
+#else
+	ADV(UW16, UW13)
+#endif
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW17, UW16)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW18, UW17)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW19, UW18)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE4):
+
+	.set	L(set5),L(EFDE5)-L(SFDE5)
+	.long	L(set5)			/* FDE Length */
+L(SFDE5):
+	.long	L(SFDE5)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW21))		/* Initial location */
+	.long	L(UW23)-L(UW21)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW22, UW21)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE5):
+
+	.set	L(set6),L(EFDE6)-L(SFDE6)
+	.long	L(set6)			/* FDE Length */
+L(SFDE6):
+	.long	L(SFDE6)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW24))		/* Initial location */
+	.long	L(UW26)-L(UW24)		/* Address range */
+	.byte	0			/* Augmentation size */
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	.byte	0x80+8, 2		/* DW_CFA_offset %eip, 2*-4 */
+	ADV(UW25, UW24)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE6):
+
+	.set	L(set7),L(EFDE7)-L(SFDE7)
+	.long	L(set7)			/* FDE Length */
+L(SFDE7):
+	.long	L(SFDE7)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW27))		/* Initial location */
+	.long	L(UW31)-L(UW27)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW28, UW27)
+	.byte	0xe, closure_FS+4	/* DW_CFA_def_cfa_offset */
+#ifdef FFI_CLOSURE_CALL_INNER_SAVE_EBX
+	ADV(UW29, UW28)
+	.byte	0x80+3, (40-(closure_FS+4))/-4  /* DW_CFA_offset %ebx */
+	ADV(UW30, UW29)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+#endif
+	.balign	4
+L(EFDE7):
+
+#if !FFI_NO_RAW_API
+	.set	L(set8),L(EFDE8)-L(SFDE8)
+	.long	L(set8)			/* FDE Length */
+L(SFDE8):
+	.long	L(SFDE8)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW32))		/* Initial location */
+	.long	L(UW40)-L(UW32)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW33, UW32)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW34, UW33)
+	.byte	0x80+3, 2		/* DW_CFA_offset %ebx 2*-4 */
+	ADV(UW35, UW34)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW36, UW35)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW37, UW36)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	ADV(UW38, UW37)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW39, UW38)
+	.byte	0xe, raw_closure_S_FS+4	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE8):
+
+	.set	L(set9),L(EFDE9)-L(SFDE9)
+	.long	L(set9)			/* FDE Length */
+L(SFDE9):
+	.long	L(SFDE9)-L(CIE)		/* FDE CIE offset */
+	.long	PCREL(L(UW41))		/* Initial location */
+	.long	L(UW52)-L(UW41)		/* Address range */
+	.byte	0			/* Augmentation size */
+	ADV(UW42, UW41)
+	.byte	0xe, 0			/* DW_CFA_def_cfa_offset */
+	.byte	0x9, 8, 2		/* DW_CFA_register %eip, %edx */
+	ADV(UW43, UW42)
+	.byte	0xe, 4			/* DW_CFA_def_cfa_offset */
+	ADV(UW44, UW43)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	.byte	0x80+8, 2		/* DW_CFA_offset %eip 2*-4 */
+	ADV(UW45, UW44)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	ADV(UW46, UW45)
+	.byte	0x80+3, 3		/* DW_CFA_offset %ebx 3*-4 */
+	ADV(UW47, UW46)
+	.byte	0xc0+3			/* DW_CFA_restore %ebx */
+	ADV(UW48, UW47)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	ADV(UW49, UW48)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	ADV(UW50, UW49)
+	.byte	0xe, 8			/* DW_CFA_def_cfa_offset */
+	ADV(UW51, UW50)
+	.byte	0xe, raw_closure_T_FS+8	/* DW_CFA_def_cfa_offset */
+	.balign	4
+L(EFDE9):
+#endif /* !FFI_NO_RAW_API */
+
+#ifdef _WIN32
+	.def	 @feat.00;
+	.scl	3;
+	.type	0;
+	.endef
+	PUBLIC	@feat.00
+@feat.00 = 1
+#endif
+
+#endif /* ifndef _MSC_VER */
+#endif /* ifndef __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+#endif
+
+END
Index: libffi-3.4.6/src/x86/win64_intel.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/x86/win64_intel.S b/libffi-3.4.6/src/x86/win64_intel.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/x86/win64_intel.S	
@@ -0,0 +1,238 @@
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "asmnames.h"
+
+#if defined(HAVE_AS_CFI_PSEUDO_OP)
+        .cfi_sections   .debug_frame
+#endif
+
+#ifdef X86_WIN64
+#define SEH(...) __VA_ARGS__
+#define arg0	rcx
+#define arg1	rdx
+#define arg2	r8
+#define arg3	r9
+#else
+#define SEH(...)
+#define arg0	rdi
+#define arg1	rsi
+#define arg2	rdx
+#define arg3	rcx
+#endif
+
+/* This macro allows the safe creation of jump tables without an
+   actual table.  The entry points into the table are all 8 bytes.
+   The use of ORG asserts that we're at the correct location.  */
+/* ??? The clang assembler doesn't handle .org with symbolic expressions.  */
+#if defined(__clang__) || defined(__APPLE__) || (defined (__sun__) && defined(__svr4__))
+# define E(BASE, X)	ALIGN 8
+#else
+# define E(BASE, X)	ALIGN 8; ORG BASE + (X) * 8
+#endif
+
+	.CODE
+	extern PLT(C(abort)):near
+	extern C(ffi_closure_win64_inner):near
+
+/* ffi_call_win64 (void *stack, struct win64_call_frame *frame, void *r10)
+
+   Bit o trickiness here -- FRAME is the base of the stack frame
+   for this function.  This has been allocated by ffi_call.  We also
+   deallocate some of the stack that has been alloca'd.  */
+
+	ALIGN	8
+	PUBLIC	C(ffi_call_win64)
+
+	; SEH(.safesh ffi_call_win64)
+C(ffi_call_win64) proc SEH(frame)
+	cfi_startproc
+	/* Set up the local stack frame and install it in rbp/rsp.  */
+	mov	RAX, [RSP] ; 	movq	(%rsp), %rax
+	mov [arg1], RBP ; movq	%rbp, (arg1)
+	mov [arg1 + 8], RAX;	movq	%rax, 8(arg1)
+	mov	 RBP, arg1; movq	arg1, %rbp
+	cfi_def_cfa(rbp, 16)
+	cfi_rel_offset(rbp, 0)
+	SEH(.pushreg rbp)
+	SEH(.setframe rbp, 0)
+	SEH(.endprolog)
+	mov	RSP, arg0 ;	movq	arg0, %rsp
+
+	mov	R10, arg2 ; movq	arg2, %r10
+
+	/* Load all slots into both general and xmm registers.  */
+	mov	RCX, [RSP] ;	movq	(%rsp), %rcx
+	movsd XMM0, qword ptr [RSP] ; movsd	(%rsp), %xmm0
+	mov	RDX, [RSP + 8] ;movq	8(%rsp), %rdx
+	movsd XMM1, qword ptr [RSP + 8];	movsd	8(%rsp), %xmm1
+	mov R8, [RSP + 16] ; movq	16(%rsp), %r8
+	movsd	XMM2, qword ptr [RSP + 16] ; movsd	16(%rsp), %xmm2
+	mov	R9, [RSP + 24] ; movq	24(%rsp), %r9
+	movsd	XMM3, qword ptr [RSP + 24] ;movsd	24(%rsp), %xmm3
+
+	CALL qword ptr [RBP + 16] ; call	*16(%rbp)
+
+	mov	 ECX, [RBP + 24] ; movl	24(%rbp), %ecx
+	mov	R8, [RBP + 32] ; movq	32(%rbp), %r8
+	LEA	R10, ffi_call_win64_tab ; leaq	0f(%rip), %r10
+	CMP	ECX, FFI_TYPE_SMALL_STRUCT_4B ; cmpl	$FFI_TYPE_SMALL_STRUCT_4B, %ecx
+	LEA	R10, [R10 + RCX*8] ; leaq	(%r10, %rcx, 8), %r10
+	JA	L99 ; ja	99f
+	JMP	R10 ; jmp	*%r10
+
+/* Below, we're space constrained most of the time.  Thus we eschew the
+   modern "mov, pop, ret" sequence (5 bytes) for "leave, ret" (2 bytes).  */
+epilogue macro
+	LEAVE
+	cfi_remember_state
+	cfi_def_cfa(rsp, 8)
+	cfi_restore(rbp)
+	RET
+	cfi_restore_state
+endm
+
+	ALIGN 8
+ffi_call_win64_tab LABEL NEAR
+E(0b, FFI_TYPE_VOID)
+	epilogue
+E(0b, FFI_TYPE_INT)
+	movsxd rax, eax ; movslq	%eax, %rax
+	mov qword ptr [r8], rax; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_FLOAT)
+	movss dword ptr [r8], xmm0 ; movss	%xmm0, (%r8)
+	epilogue
+E(0b, FFI_TYPE_DOUBLE)
+	movsd qword ptr[r8], xmm0; movsd	%xmm0, (%r8)
+	epilogue
+// FFI_TYPE_LONGDOUBLE may be FFI_TYPE_DOUBLE but we need a different value here.
+E(0b, FFI_TYPE_DOUBLE + 1)
+	call	PLT(C(abort))
+E(0b, FFI_TYPE_UINT8)
+	movzx eax, al ;movzbl	%al, %eax
+	mov qword ptr[r8], rax; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT8)
+	movsx rax, al ; movsbq	%al, %rax
+	jmp	L98
+E(0b, FFI_TYPE_UINT16)
+	movzx eax, ax ; movzwl	%ax, %eax
+	mov qword ptr[r8], rax; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT16)
+	movsx rax, ax; movswq	%ax, %rax
+	jmp	L98
+E(0b, FFI_TYPE_UINT32)
+	mov eax, eax; movl	%eax, %eax
+	mov qword ptr[r8], rax ; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT32)
+	movsxd rax, eax; movslq	%eax, %rax
+	mov qword ptr [r8], rax; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_UINT64)
+L98 LABEL near
+	mov qword ptr [r8], rax ; movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SINT64)
+	mov qword ptr [r8], rax;movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_STRUCT)
+	epilogue
+E(0b, FFI_TYPE_POINTER)
+	mov qword ptr [r8], rax ;movq	%rax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_COMPLEX)
+	call	PLT(C(abort))
+E(0b, FFI_TYPE_SMALL_STRUCT_1B)
+	mov byte ptr [r8], al ; movb	%al, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SMALL_STRUCT_2B)
+	mov word ptr [r8], ax ; movw	%ax, (%r8)
+	epilogue
+E(0b, FFI_TYPE_SMALL_STRUCT_4B)
+	mov dword ptr [r8], eax ; movl	%eax, (%r8)
+	epilogue
+
+	align	8
+L99 LABEL near
+	call	PLT(C(abort))
+
+	epilogue
+
+	cfi_endproc
+	C(ffi_call_win64) endp
+
+
+/* 32 bytes of outgoing register stack space, 8 bytes of alignment,
+   16 bytes of result, 32 bytes of xmm registers.  */
+#define ffi_clo_FS	(32+8+16+32)
+#define ffi_clo_OFF_R	(32+8)
+#define ffi_clo_OFF_X	(32+8+16)
+
+	align	8
+	PUBLIC	C(ffi_go_closure_win64)
+
+C(ffi_go_closure_win64) proc
+	cfi_startproc
+	/* Save all integer arguments into the incoming reg stack space.  */
+	mov qword ptr [rsp + 8], rcx; movq	%rcx, 8(%rsp)
+	mov qword ptr [rsp + 16], rdx; movq	%rdx, 16(%rsp)
+	mov qword ptr [rsp + 24], r8; movq	%r8, 24(%rsp)
+	mov qword ptr [rsp + 32], r9 ;movq	%r9, 32(%rsp)
+
+	mov rcx, qword ptr [r10 + 8]; movq	8(%r10), %rcx			/* load cif */
+	mov rdx, qword ptr [r10 + 16];  movq	16(%r10), %rdx			/* load fun */
+	mov r8, r10 ; movq	%r10, %r8			/* closure is user_data */
+	jmp	ffi_closure_win64_2
+	cfi_endproc
+	C(ffi_go_closure_win64) endp
+
+	align	8
+	
+PUBLIC C(ffi_closure_win64)
+C(ffi_closure_win64) PROC FRAME
+	cfi_startproc
+	/* Save all integer arguments into the incoming reg stack space.  */
+	mov qword ptr [rsp + 8], rcx; movq	%rcx, 8(%rsp)
+	mov qword ptr [rsp + 16], rdx;	movq	%rdx, 16(%rsp)
+	mov qword ptr [rsp + 24], r8; 	movq	%r8, 24(%rsp)
+	mov qword ptr [rsp + 32], r9;	movq	%r9, 32(%rsp)
+
+	mov rcx, qword ptr [FFI_TRAMPOLINE_SIZE + r10]	;movq	FFI_TRAMPOLINE_SIZE(%r10), %rcx		/* load cif */
+	mov rdx, qword ptr [FFI_TRAMPOLINE_SIZE + 8 + r10] ;	movq	FFI_TRAMPOLINE_SIZE+8(%r10), %rdx	/* load fun */
+	mov r8, qword ptr [FFI_TRAMPOLINE_SIZE+16+r10] ;movq	FFI_TRAMPOLINE_SIZE+16(%r10), %r8	/* load user_data */
+ffi_closure_win64_2 LABEL near
+	sub rsp, ffi_clo_FS ;subq	$ffi_clo_FS, %rsp
+	cfi_adjust_cfa_offset(ffi_clo_FS)
+	SEH(.allocstack ffi_clo_FS)
+	SEH(.endprolog)
+
+	/* Save all sse arguments into the stack frame.  */
+	movsd qword ptr [ffi_clo_OFF_X + rsp], xmm0	; movsd	%xmm0, ffi_clo_OFF_X(%rsp)
+	movsd qword ptr [ffi_clo_OFF_X+8+rsp], xmm1 ; movsd	%xmm1, ffi_clo_OFF_X+8(%rsp)
+	movsd qword ptr [ffi_clo_OFF_X+16+rsp], xmm2 ; movsd %xmm2, ffi_clo_OFF_X+16(%rsp)
+	movsd qword ptr [ffi_clo_OFF_X+24+rsp], xmm3 ; movsd %xmm3, ffi_clo_OFF_X+24(%rsp)
+
+	lea	r9, [ffi_clo_OFF_R + rsp] ; leaq	ffi_clo_OFF_R(%rsp), %r9
+	call C(ffi_closure_win64_inner)
+
+	/* Load the result into both possible result registers.  */
+	
+	mov rax, qword ptr [ffi_clo_OFF_R + rsp] ;movq    ffi_clo_OFF_R(%rsp), %rax
+	movsd xmm0, qword ptr [rsp + ffi_clo_OFF_R] ;movsd   ffi_clo_OFF_R(%rsp), %xmm0
+
+	add rsp, ffi_clo_FS ;addq	$ffi_clo_FS, %rsp
+	cfi_adjust_cfa_offset(-ffi_clo_FS)
+	ret
+
+	cfi_endproc
+	C(ffi_closure_win64) endp
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+_text ends
+end
\ No newline at end of file
Index: libffi-3.4.6/src/bfin/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/bfin/ffi.c b/libffi-3.4.6/src/bfin/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/bfin/ffi.c	
@@ -0,0 +1,196 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>,
+							   Paulo Pizarro <paulo.pizarro@gmail.com>
+
+   Blackfin Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+/* Maximum number of GPRs available for argument passing.  */
+#define MAX_GPRARGS 3
+
+/*
+ * Return types
+ */
+#define FFIBFIN_RET_VOID 0
+#define FFIBFIN_RET_BYTE 1
+#define FFIBFIN_RET_HALFWORD 2
+#define FFIBFIN_RET_INT64 3
+#define FFIBFIN_RET_INT32 4
+
+/*====================================================================*/
+/*                          PROTOTYPE          *
+ /*====================================================================*/
+void ffi_prep_args(unsigned char *, extended_cif *);
+
+/*====================================================================*/
+/*                          Externals                                 */
+/*                          (Assembly)                                */
+/*====================================================================*/
+
+extern void ffi_call_SYSV(unsigned, extended_cif *, void(*)(unsigned char *, extended_cif *), unsigned, void *, void(*fn)(void));
+
+/*====================================================================*/
+/*                          Implementation                            */
+/*                                                            */
+/*====================================================================*/
+
+
+/*
+ * This function calculates the return type (size) based on type.
+ */
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+   /* --------------------------------------*
+    *   Return handling                *
+    * --------------------------------------*/
+   switch (cif->rtype->type) {
+      case FFI_TYPE_VOID:
+         cif->flags = FFIBFIN_RET_VOID;
+         break;
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_SINT16:
+         cif->flags = FFIBFIN_RET_HALFWORD;
+         break;
+      case FFI_TYPE_UINT8:
+         cif->flags = FFIBFIN_RET_BYTE;
+         break;
+      case FFI_TYPE_INT:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_FLOAT:
+      case FFI_TYPE_POINTER:
+      case FFI_TYPE_SINT8:
+         cif->flags = FFIBFIN_RET_INT32;
+         break;
+      case FFI_TYPE_SINT64:
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_DOUBLE:
+          cif->flags = FFIBFIN_RET_INT64;
+          break;
+      case FFI_TYPE_STRUCT:
+         if (cif->rtype->size <= 4){
+        	 cif->flags = FFIBFIN_RET_INT32;
+         }else if (cif->rtype->size == 8){
+        	 cif->flags = FFIBFIN_RET_INT64;
+         }else{
+        	 //it will return via a hidden pointer in P0
+        	 cif->flags = FFIBFIN_RET_VOID;
+         }
+         break;
+      default:
+         FFI_ASSERT(0);
+         break;
+   }
+   return FFI_OK;
+}
+
+/*
+ * This will prepare the arguments and will call the assembly routine
+ * cif = the call interface
+ * fn = the function to be called
+ * rvalue = the return value
+ * avalue = the arguments
+ */
+void ffi_call(ffi_cif *cif, void(*fn)(void), void *rvalue, void **avalue)
+{
+   int ret_type = cif->flags;
+   extended_cif ecif;
+   ecif.cif = cif;
+   ecif.avalue = avalue;
+   ecif.rvalue = rvalue;
+
+   switch (cif->abi) {
+      case FFI_SYSV:
+         ffi_call_SYSV(cif->bytes, &ecif, ffi_prep_args, ret_type, ecif.rvalue, fn);
+         break;
+      default:
+         FFI_ASSERT(0);
+         break;
+   }
+}
+
+
+/*
+* This function prepares the parameters (copies them from the ecif to the stack)
+*  to call the function (ffi_prep_args is called by the assembly routine in file
+*  sysv.S, which also calls the actual function)
+*/
+void ffi_prep_args(unsigned char *stack, extended_cif *ecif)
+{
+   register unsigned int i = 0;
+   void **p_argv;
+   unsigned char *argp;
+   ffi_type **p_arg;
+   argp = stack;
+   p_argv = ecif->avalue;
+   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+        (i != 0);
+        i--, p_arg++) {
+      size_t z;
+      z = (*p_arg)->size;
+      if (z < sizeof(int)) {
+         z = sizeof(int);
+         switch ((*p_arg)->type) {
+            case FFI_TYPE_SINT8: {
+                  signed char v = *(SINT8 *)(* p_argv);
+                  signed int t = v;
+                  *(signed int *) argp = t;
+               }
+               break;
+            case FFI_TYPE_UINT8: {
+                  unsigned char v = *(UINT8 *)(* p_argv);
+                  unsigned int t = v;
+                  *(unsigned int *) argp = t;
+               }
+               break;
+            case FFI_TYPE_SINT16:
+               *(signed int *) argp = (signed int) * (SINT16 *)(* p_argv);
+               break;
+            case FFI_TYPE_UINT16:
+               *(unsigned int *) argp = (unsigned int) * (UINT16 *)(* p_argv);
+               break;
+            case FFI_TYPE_STRUCT:
+               memcpy(argp, *p_argv, (*p_arg)->size);
+               break;
+            default:
+               FFI_ASSERT(0);
+               break;
+         }
+      } else if (z == sizeof(int)) {
+         *(unsigned int *) argp = (unsigned int) * (UINT32 *)(* p_argv);
+      } else {
+         memcpy(argp, *p_argv, z);
+      }
+      p_argv++;
+      argp += z;
+   }
+}
+
+
+
Index: libffi-3.4.6/src/bfin/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/bfin/sysv.S b/libffi-3.4.6/src/bfin/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/bfin/sysv.S	
@@ -0,0 +1,179 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>,
+                                Paulo Pizarro <paulo.pizarro@gmail.com>
+
+   Blackfin Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+.text
+.align 4
+
+	/*
+	 There is a "feature" in the bfin toolchain that it puts a _ before function names
+	 that's why the function here it's called _ffi_call_SYSV and not ffi_call_SYSV
+	 */
+	.global _ffi_call_SYSV;
+	.type _ffi_call_SYSV, STT_FUNC;
+	.func ffi_call_SYSV
+
+	/*
+         cif->bytes    = R0    (fp+8)
+         &ecif         = R1    (fp+12)
+         ffi_prep_args = R2    (fp+16)
+         ret_type      = stack (fp+20)
+         ecif.rvalue   = stack (fp+24)
+         fn            = stack (fp+28)
+                           got (fp+32)
+
+        There is room for improvement here (we can use temporary registers
+        instead of saving the values in the memory)
+        REGS:
+        P5 => Stack pointer (function arguments)
+        R5 => cif->bytes
+        R4 => ret->type
+
+        FP-20 = P3
+        FP-16 = SP (parameters area)
+        FP-12 = SP (temp)
+        FP-08 = function return part 1 [R0]
+        FP-04 = function return part 2 [R1]
+	*/
+
+_ffi_call_SYSV:
+.prologue:
+	LINK 20;
+	[FP-20] = P3;
+	[FP+8] = R0;
+	[FP+12] = R1;
+	[FP+16] = R2;
+
+.allocate_stack:
+	//alocate cif->bytes into the stack
+	R1 = [FP+8];
+	R0 = SP;
+	R0 = R0 - R1;
+	R1 = 4;
+	R0 = R0 - R1;
+	[FP-12] = SP;
+	SP = R0;
+	[FP-16] = SP;
+
+.call_prep_args:
+	//get the addr of prep_args
+	P0 = [P3 + _ffi_prep_args@FUNCDESC_GOT17M4];
+	P1 = [P0];
+	P3 = [P0+4];
+	R0 = [FP-16];//SP (parameter area)
+	R1 = [FP+12];//ecif
+	call (P1);
+
+.call_user_function:
+	//ajust SP so as to allow the user function access the parameters on the stack
+	SP = [FP-16]; //point to function parameters
+	R0 = [SP];
+	R1 = [SP+4];
+	R2 = [SP+8];
+	//load user function address
+	P0 = FP;
+	P0 +=28;
+	P1 = [P0];
+	P1 = [P1];
+	P3 = [P0+4];
+	/*
+		For functions returning aggregate values (struct) occupying more than 8 bytes,
+		the caller allocates the return value object on the stack and the address
+		of this object is passed to the callee as a hidden argument in register P0.
+	*/
+	P0 = [FP+24];
+
+	call (P1);
+	SP = [FP-12];
+.compute_return:
+	P2 = [FP-20];
+	[FP-8] = R0;
+	[FP-4] = R1;
+
+	R0 = [FP+20];
+	R1 = R0 << 2;
+
+	R0 = [P2+.rettable@GOT17M4];
+	R0 = R1 + R0;
+	P2 = R0;
+	R1 = [P2];
+
+	P2 = [FP+-20];
+	R0 = [P2+.rettable@GOT17M4];
+	R0 = R1 + R0;
+	P2 = R0;
+	R0 = [FP-8];
+	R1 = [FP-4];
+	jump (P2);
+
+/*
+#define FFIBFIN_RET_VOID 0
+#define FFIBFIN_RET_BYTE 1
+#define FFIBFIN_RET_HALFWORD 2
+#define FFIBFIN_RET_INT64 3
+#define FFIBFIN_RET_INT32 4
+*/
+.align 4
+.align 4
+.rettable:
+	.dd .epilogue - .rettable
+	.dd	.rbyte - .rettable;
+	.dd	.rhalfword - .rettable;
+	.dd	.rint64 - .rettable;
+	.dd	.rint32 - .rettable;
+
+.rbyte:
+	P0 = [FP+24];
+	R0 = R0.B (Z);
+	[P0] = R0;
+	JUMP .epilogue
+.rhalfword:
+	P0 = [FP+24];
+	R0 = R0.L;
+	[P0] = R0;
+	JUMP .epilogue
+.rint64:
+	P0 = [FP+24];// &rvalue
+	[P0] = R0;
+	[P0+4] = R1;
+	JUMP .epilogue
+.rint32:
+	P0 = [FP+24];
+	[P0] = R0;
+.epilogue:
+	R0 = [FP+8];
+	R1 = [FP+12];
+	R2 = [FP+16];
+	P3 = [FP-20];
+	UNLINK;
+	RTS;
+
+.size _ffi_call_SYSV,.-_ffi_call_SYSV;
+.endfunc
Index: libffi-3.4.6/src/bfin/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/bfin/ffitarget.h b/libffi-3.4.6/src/bfin/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/bfin/ffitarget.h	
@@ -0,0 +1,43 @@
+/* -----------------------------------------------------------------------
+   ffitarget.h - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>
+
+   Blackfin Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed 	 long          ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+#endif
+
Index: libffi-3.4.6/src/cris/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/cris/ffi.c b/libffi-3.4.6/src/cris/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/cris/ffi.c	
@@ -0,0 +1,386 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 1998 Cygnus Solutions
+           Copyright (c) 2004 Simon Posnjak
+	   Copyright (c) 2005 Axis Communications AB
+	   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   CRIS Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL SIMON POSNJAK BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#define STACK_ARG_SIZE(x) FFI_ALIGN(x, FFI_SIZEOF_ARG)
+
+static ffi_status
+initialize_aggregate_packed_struct (ffi_type * arg)
+{
+  ffi_type **ptr;
+
+  FFI_ASSERT (arg != NULL);
+
+  FFI_ASSERT (arg->elements != NULL);
+  FFI_ASSERT (arg->size == 0);
+  FFI_ASSERT (arg->alignment == 0);
+
+  ptr = &(arg->elements[0]);
+
+  while ((*ptr) != NULL)
+    {
+      if (((*ptr)->size == 0)
+	  && (initialize_aggregate_packed_struct ((*ptr)) != FFI_OK))
+	return FFI_BAD_TYPEDEF;
+
+      FFI_ASSERT (ffi_type_test ((*ptr)));
+
+      arg->size += (*ptr)->size;
+
+      arg->alignment = (arg->alignment > (*ptr)->alignment) ?
+	arg->alignment : (*ptr)->alignment;
+
+      ptr++;
+    }
+
+  if (arg->size == 0)
+    return FFI_BAD_TYPEDEF;
+  else
+    return FFI_OK;
+}
+
+int
+ffi_prep_args (char *stack, extended_cif * ecif)
+{
+  unsigned int i;
+  unsigned int struct_count = 0;
+  void **p_argv;
+  char *argp;
+  ffi_type **p_arg;
+
+  argp = stack;
+
+  p_argv = ecif->avalue;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       (i != 0); i--, p_arg++)
+    {
+      size_t z;
+
+      switch ((*p_arg)->type)
+	{
+	case FFI_TYPE_STRUCT:
+	  {
+	    z = (*p_arg)->size;
+	    if (z <= 4)
+	      {
+		memcpy (argp, *p_argv, z);
+		z = 4;
+	      }
+	    else if (z <= 8)
+	      {
+		memcpy (argp, *p_argv, z);
+		z = 8;
+	      }
+	    else
+	      {
+		unsigned int uiLocOnStack;
+		z = sizeof (void *);
+		uiLocOnStack = 4 * ecif->cif->nargs + struct_count;
+		struct_count = struct_count + (*p_arg)->size;
+		*(unsigned int *) argp =
+		  (unsigned int) (UINT32 *) (stack + uiLocOnStack);
+		memcpy ((stack + uiLocOnStack), *p_argv, (*p_arg)->size);
+	      }
+	    break;
+	  }
+	default:
+	  z = (*p_arg)->size;
+	  if (z < sizeof (int))
+	    {
+	      switch ((*p_arg)->type)
+		{
+		case FFI_TYPE_SINT8:
+		  *(signed int *) argp = (signed int) *(SINT8 *) (*p_argv);
+		  break;
+
+		case FFI_TYPE_UINT8:
+		  *(unsigned int *) argp =
+		    (unsigned int) *(UINT8 *) (*p_argv);
+		  break;
+
+		case FFI_TYPE_SINT16:
+		  *(signed int *) argp = (signed int) *(SINT16 *) (*p_argv);
+		  break;
+
+		case FFI_TYPE_UINT16:
+		  *(unsigned int *) argp =
+		    (unsigned int) *(UINT16 *) (*p_argv);
+		  break;
+
+		default:
+		  FFI_ASSERT (0);
+		}
+	      z = sizeof (int);
+	    }
+	  else if (z == sizeof (int))
+	    *(unsigned int *) argp = (unsigned int) *(UINT32 *) (*p_argv);
+	  else
+	    memcpy (argp, *p_argv, z);
+	  break;
+	}
+      p_argv++;
+      argp += z;
+    }
+
+  return (struct_count);
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_core (ffi_cif * cif,
+	           ffi_abi abi, unsigned int isvariadic,
+		   unsigned int nfixedargs, unsigned int ntotalargs,
+	           ffi_type * rtype, ffi_type ** atypes)
+{
+  unsigned bytes = 0;
+  unsigned int i;
+  ffi_type **ptr;
+
+  FFI_ASSERT (cif != NULL);
+  FFI_ASSERT((!isvariadic) || (nfixedargs >= 1));
+  FFI_ASSERT(nfixedargs <= ntotalargs);
+  FFI_ASSERT (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI);
+
+  cif->abi = abi;
+  cif->arg_types = atypes;
+  cif->nargs = ntotalargs;
+  cif->rtype = rtype;
+
+  cif->flags = 0;
+
+  if ((cif->rtype->size == 0)
+      && (initialize_aggregate_packed_struct (cif->rtype) != FFI_OK))
+    return FFI_BAD_TYPEDEF;
+
+  FFI_ASSERT_VALID_TYPE (cif->rtype);
+
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+      if (((*ptr)->size == 0)
+	  && (initialize_aggregate_packed_struct ((*ptr)) != FFI_OK))
+	return FFI_BAD_TYPEDEF;
+
+      FFI_ASSERT_VALID_TYPE (*ptr);
+
+      if (((*ptr)->alignment - 1) & bytes)
+	bytes = FFI_ALIGN (bytes, (*ptr)->alignment);
+      if ((*ptr)->type == FFI_TYPE_STRUCT)
+	{
+	  if ((*ptr)->size > 8)
+	    {
+	      bytes += (*ptr)->size;
+	      bytes += sizeof (void *);
+	    }
+	  else
+	    {
+	      if ((*ptr)->size > 4)
+		bytes += 8;
+	      else
+		bytes += 4;
+	    }
+	}
+      else
+	bytes += STACK_ARG_SIZE ((*ptr)->size);
+    }
+
+  cif->bytes = bytes;
+
+  return ffi_prep_cif_machdep (cif);
+}
+
+ffi_status
+ffi_prep_cif_machdep (ffi_cif * cif)
+{
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+extern void ffi_call_SYSV (int (*)(char *, extended_cif *),
+			   extended_cif *,
+			   unsigned, unsigned, unsigned *, void (*fn) ())
+     __attribute__ ((__visibility__ ("hidden")));
+
+void
+ffi_call (ffi_cif * cif, void (*fn) (), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca (cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV (ffi_prep_args, &ecif, cif->bytes,
+		     cif->flags, ecif.rvalue, fn);
+      break;
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+/* Because the following variables are not exported outside libffi, we
+   mark them hidden.  */
+
+/* Assembly code for the jump stub.  */
+extern const char ffi_cris_trampoline_template[]
+ __attribute__ ((__visibility__ ("hidden")));
+
+/* Offset into ffi_cris_trampoline_template of where to put the
+   ffi_prep_closure_inner function.  */
+extern const int ffi_cris_trampoline_fn_offset
+ __attribute__ ((__visibility__ ("hidden")));
+
+/* Offset into ffi_cris_trampoline_template of where to put the
+   closure data.  */
+extern const int ffi_cris_trampoline_closure_offset
+ __attribute__ ((__visibility__ ("hidden")));
+
+/* This function is sibling-called (jumped to) by the closure
+   trampoline.  We get R10..R13 at PARAMS[0..3] and a copy of [SP] at
+   PARAMS[4] to simplify handling of a straddling parameter.  A copy
+   of R9 is at PARAMS[5] and SP at PARAMS[6].  These parameters are
+   put at the appropriate place in CLOSURE which is then executed and
+   the return value is passed back to the caller.  */
+
+static unsigned long long
+ffi_prep_closure_inner (void **params, ffi_closure* closure)
+{
+  char *register_args = (char *) params;
+  void *struct_ret = params[5];
+  char *stack_args = params[6];
+  char *ptr = register_args;
+  ffi_cif *cif = closure->cif;
+  ffi_type **arg_types = cif->arg_types;
+
+  /* Max room needed is number of arguments as 64-bit values.  */
+  void **avalue = alloca (closure->cif->nargs * sizeof(void *));
+  int i;
+  int doing_regs;
+  long long llret = 0;
+
+  /* Find the address of each argument.  */
+  for (i = 0, doing_regs = 1; i < cif->nargs; i++)
+    {
+      /* Types up to and including 8 bytes go by-value.  */
+      if (arg_types[i]->size <= 4)
+	{
+	  avalue[i] = ptr;
+	  ptr += 4;
+	}
+      else if (arg_types[i]->size <= 8)
+	{
+	  avalue[i] = ptr;
+	  ptr += 8;
+	}
+      else
+	{
+	  FFI_ASSERT (arg_types[i]->type == FFI_TYPE_STRUCT);
+
+	  /* Passed by-reference, so copy the pointer.  */
+	  avalue[i] = *(void **) ptr;
+	  ptr += 4;
+	}
+
+      /* If we've handled more arguments than fit in registers, start
+	 looking at the those passed on the stack.  Step over the
+	 first one if we had a straddling parameter.  */
+      if (doing_regs && ptr >= register_args + 4*4)
+	{
+	  ptr = stack_args + ((ptr > register_args + 4*4) ? 4 : 0);
+	  doing_regs = 0;
+	}
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif,
+
+		  cif->rtype->type == FFI_TYPE_STRUCT
+		  /* The caller allocated space for the return
+		     structure, and passed a pointer to this space in
+		     R9.  */
+		  ? struct_ret
+
+		  /* We take advantage of being able to ignore that
+		     the high part isn't set if the return value is
+		     not in R10:R11, but in R10 only.  */
+		  : (void *) &llret,
+
+		  avalue, closure->user_data);
+
+  return llret;
+}
+
+/* API function: Prepare the trampoline.  */
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif *, void *, void **, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  void *innerfn = ffi_prep_closure_inner;
+  FFI_ASSERT (cif->abi == FFI_SYSV);
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+  memcpy (closure->tramp, ffi_cris_trampoline_template,
+	  FFI_CRIS_TRAMPOLINE_CODE_PART_SIZE);
+  memcpy (closure->tramp + ffi_cris_trampoline_fn_offset,
+	  &innerfn, sizeof (void *));
+  memcpy (closure->tramp + ffi_cris_trampoline_closure_offset,
+	  &codeloc, sizeof (void *));
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/cris/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/cris/sysv.S b/libffi-3.4.6/src/cris/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/cris/sysv.S	
@@ -0,0 +1,215 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2004 Simon Posnjak
+	    Copyright (c) 2005 Axis Communications AB
+
+   CRIS Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL SIMON POSNJAK BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <ffi.h>
+#define CONCAT(x,y) x ## y
+#define XCONCAT(x,y) CONCAT (x, y)
+#define L(x) XCONCAT (__USER_LABEL_PREFIX__, x)
+
+	.text
+
+	;; OK, when we get called we should have this (according to
+	;; AXIS ETRAX 100LX Programmer's Manual chapter 6.3).
+	;;
+	;; R10:	 ffi_prep_args (func. pointer)
+	;; R11:  &ecif
+	;; R12:  cif->bytes
+	;; R13:  fig->flags
+	;; sp+0: ecif.rvalue
+	;; sp+4: fn (function pointer to the function that we need to call)
+
+	.globl  L(ffi_call_SYSV)
+	.type   L(ffi_call_SYSV),@function
+	.hidden	L(ffi_call_SYSV)
+
+L(ffi_call_SYSV):
+	;; Save the regs to the stack.
+	push $srp
+	;; Used for stack pointer saving.
+	push $r6
+	;; Used for function address pointer.
+	push $r7
+	;; Used for stack pointer saving.
+	push $r8
+	;; We save fig->flags to stack we will need them after we
+	;; call The Function.
+	push $r13
+
+	;; Saving current stack pointer.
+	move.d $sp,$r8
+	move.d $sp,$r6
+
+	;; Move address of ffi_prep_args to r13.
+	move.d $r10,$r13
+
+	;; Make room on the stack for the args of fn.
+	sub.d  $r12,$sp
+
+	;; Function void ffi_prep_args(char *stack, extended_cif *ecif) parameters are:
+	;; 	r10 <-- stack pointer
+	;; 	r11 <-- &ecif (already there)
+	move.d $sp,$r10
+
+	;; Call the function.
+	jsr $r13
+
+	;; Save the size of the structures which are passed on stack.
+	move.d $r10,$r7
+
+	;; Move first four args in to r10..r13.
+	move.d [$sp+0],$r10
+	move.d [$sp+4],$r11
+	move.d [$sp+8],$r12
+	move.d [$sp+12],$r13
+
+	;; Adjust the stack and check if any parameters are given on stack.
+	addq 16,$sp
+	sub.d $r7,$r6
+	cmp.d $sp,$r6
+
+	bpl go_on
+	nop
+
+go_on_no_params_on_stack:
+	move.d $r6,$sp
+
+go_on:
+	;; Discover if we need to put rval address in to r9.
+	move.d [$r8+0],$r7
+	cmpq FFI_TYPE_STRUCT,$r7
+	bne call_now
+	nop
+
+	;; Move rval address to $r9.
+	move.d [$r8+20],$r9
+
+call_now:
+	;; Move address of The Function in to r7.
+	move.d [$r8+24],$r7
+
+	;; Call The Function.
+	jsr $r7
+
+	;; Reset stack.
+	move.d $r8,$sp
+
+	;; Load rval type (fig->flags) in to r13.
+	pop $r13
+
+	;; Detect rval type.
+	cmpq FFI_TYPE_VOID,$r13
+	beq epilogue
+
+	cmpq FFI_TYPE_STRUCT,$r13
+	beq epilogue
+
+	cmpq FFI_TYPE_DOUBLE,$r13
+	beq return_double_or_longlong
+
+	cmpq FFI_TYPE_UINT64,$r13
+	beq return_double_or_longlong
+
+	cmpq FFI_TYPE_SINT64,$r13
+	beq return_double_or_longlong
+	nop
+
+	;; Just return the 32 bit value.
+	ba return
+	nop
+
+return_double_or_longlong:
+	;; Load half of the rval to r10 and the other half to r11.
+	move.d [$sp+16],$r13
+	move.d $r10,[$r13]
+	addq 4,$r13
+	move.d $r11,[$r13]
+	ba epilogue
+	nop
+
+return:
+	;; Load the rval to r10.
+	move.d [$sp+16],$r13
+	move.d $r10,[$r13]
+
+epilogue:
+	pop $r8
+	pop $r7
+	pop $r6
+	Jump [$sp+]
+
+	.size   ffi_call_SYSV,.-ffi_call_SYSV
+
+/* Save R10..R13 into an array, somewhat like varargs.  Copy the next
+   argument too, to simplify handling of any straddling parameter.
+   Save R9 and SP after those.  Jump to function handling the rest.
+   Since this is a template, copied and the main function filled in by
+   the user.  */
+
+	.globl	L(ffi_cris_trampoline_template)
+	.type	L(ffi_cris_trampoline_template),@function
+	.hidden	L(ffi_cris_trampoline_template)
+
+L(ffi_cris_trampoline_template):
+0:
+	/* The value we get for "PC" is right after the prefix instruction,
+	   two bytes from the beginning, i.e. 0b+2. */
+	move.d $r10,[$pc+2f-(0b+2)]
+	move.d $pc,$r10
+1:
+	addq 2f-1b+4,$r10
+	move.d $r11,[$r10+]
+	move.d $r12,[$r10+]
+	move.d $r13,[$r10+]
+	move.d [$sp],$r11
+	move.d $r11,[$r10+]
+	move.d $r9,[$r10+]
+	move.d $sp,[$r10+]
+	subq FFI_CRIS_TRAMPOLINE_DATA_PART_SIZE,$r10
+	move.d 0,$r11
+3:
+        jump 0
+2:
+	.size	ffi_cris_trampoline_template,.-0b
+
+/* This macro create a constant usable as "extern const int \name" in
+   C from within libffi, when \name has no prefix decoration.  */
+
+	.macro const name,value
+	.globl	\name
+	.type	\name,@object
+	.hidden	\name
+\name:
+	.dword  \value
+	.size	\name,4
+	.endm
+
+/* Constants for offsets within the trampoline.  We could do this with
+   just symbols, avoiding memory contents and memory accesses, but the
+   C usage code would look a bit stranger.  */
+
+	const L(ffi_cris_trampoline_fn_offset),2b-4-0b
+	const L(ffi_cris_trampoline_closure_offset),3b-4-0b
Index: libffi-3.4.6/src/cris/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/cris/ffitarget.h b/libffi-3.4.6/src/cris/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/cris/ffitarget.h	
@@ -0,0 +1,56 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for CRIS.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_CRIS_TRAMPOLINE_CODE_PART_SIZE 36
+#define FFI_CRIS_TRAMPOLINE_DATA_PART_SIZE (7*4)
+#define FFI_TRAMPOLINE_SIZE \
+ (FFI_CRIS_TRAMPOLINE_CODE_PART_SIZE + FFI_CRIS_TRAMPOLINE_DATA_PART_SIZE)
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/csky/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/csky/ffi.c b/libffi-3.4.6/src/csky/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/csky/ffi.c	
@@ -0,0 +1,395 @@
+/* -----------------------------------------------------------------------
+   ffi.c
+
+   CSKY Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments
+*/
+void ffi_prep_args(char *stack, extended_cif *ecif)
+{
+ register unsigned int i;
+ register void **p_argv;
+ register char *argp;
+ register ffi_type **p_arg;
+
+ argp = stack;
+
+ if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {
+  *(void **) argp = ecif->rvalue;
+  argp += 4;
+ }
+
+ p_argv = ecif->avalue;
+
+ for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+   (i != 0);
+   i--, p_arg++)
+ {
+  size_t z;
+  size_t alignment;
+
+  /* Align if necessary */
+  alignment = (*p_arg)->alignment;
+#ifdef __CSKYABIV1__
+  /*
+   * Adapt ABIV1 bug.
+   * If struct's size is larger than 8 bytes, then it always alignment as 4 bytes.
+   */
+  if (((*p_arg)->type == FFI_TYPE_STRUCT) && ((*p_arg)->size > 8) && (alignment == 8)) {
+   alignment = 4;
+  }
+#endif
+
+  if ((alignment - 1) & (unsigned) argp) {
+   argp = (char *) FFI_ALIGN(argp, alignment);
+  }
+
+  if ((*p_arg)->type == FFI_TYPE_STRUCT)
+   argp = (char *) FFI_ALIGN(argp, 4);
+
+  z = (*p_arg)->size;
+  if (z < sizeof(int))
+  {
+   z = sizeof(int);
+   switch ((*p_arg)->type)
+   {
+   case FFI_TYPE_SINT8:
+    *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+    break;
+
+   case FFI_TYPE_UINT8:
+    *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+    break;
+
+   case FFI_TYPE_SINT16:
+    *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+    break;
+
+   case FFI_TYPE_UINT16:
+    *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+    break;
+
+   case FFI_TYPE_STRUCT:
+#ifdef __CSKYBE__
+    memcpy((argp + 4 - (*p_arg)->size), *p_argv, (*p_arg)->size);
+#else
+    memcpy(argp, *p_argv, (*p_arg)->size);
+#endif
+    break;
+
+   default:
+    FFI_ASSERT(0);
+   }
+  }
+  else if (z == sizeof(int))
+  {
+   *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+  }
+  else
+  {
+   memcpy(argp, *p_argv, z);
+  }
+  p_argv++;
+  argp += z;
+ }
+
+ return;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Round the stack up to a multiple of 8 bytes.  This isn't needed
+     everywhere, but it is on some platforms, and it doesn't hcsky anything
+     when it isn't needed.  */
+  cif->bytes = (cif->bytes + 7) & ~7;
+
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags = (unsigned) FFI_TYPE_SINT64;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      if (cif->rtype->size <= 4)
+ /* A Composite Type not larger than 4 bytes is returned in r0.  */
+ cif->flags = (unsigned)FFI_TYPE_INT;
+      else if (cif->rtype->size <= 8)
+ /* A Composite Type not larger than 8 bytes is returned in r0, r1.  */
+ cif->flags = (unsigned)FFI_TYPE_SINT64;
+      else
+ /* A Composite Type larger than 8 bytes, or whose size cannot
+    be determined statically ... is stored in memory at an
+    address passed [in r0].  */
+ cif->flags = (unsigned)FFI_TYPE_STRUCT;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+/* Perform machine dependent cif processing for variadic calls */
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
+        unsigned int nfixedargs,
+        unsigned int ntotalargs)
+{
+  return ffi_prep_cif_machdep(cif);
+}
+
+/* Prototypes for assembly functions, in sysv.S */
+extern void ffi_call_SYSV (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  int small_struct = (cif->flags == FFI_TYPE_INT
+        && cif->rtype->type == FFI_TYPE_STRUCT);
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  unsigned int temp;
+
+  /* If the return value is a struct and we don't have a return */
+  /* value address then we need to make one          */
+
+  if ((rvalue == NULL) &&
+      (cif->flags == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else if (small_struct)
+    ecif.rvalue = &temp;
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+  if (small_struct)
+#ifdef __CSKYBE__
+    memcpy (rvalue, ((unsigned char *)&temp + (4 - cif->rtype->size)), cif->rtype->size);
+#else
+    memcpy (rvalue, &temp, cif->rtype->size);
+#endif
+}
+
+/** private members **/
+
+static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,
+      void** args, ffi_cif* cif);
+
+void ffi_closure_SYSV (ffi_closure *);
+
+/* This function is jumped to by the trampoline */
+
+unsigned int
+ffi_closure_SYSV_inner (closure, respp, args)
+     ffi_closure *closure;
+     void **respp;
+     void *args;
+{
+  // our various things...
+  ffi_cif       *cif;
+  void         **arg_area;
+
+  cif         = closure->cif;
+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));
+
+  /* this call will initialize ARG_AREA, such that each
+   * element in that array points to the corresponding
+   * value on the stack; and if the function returns
+   * a structure, it will re-set RESP to point to the
+   * structure return address.  */
+
+  ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);
+
+  (closure->fun) (cif, *respp, arg_area, closure->user_data);
+
+#ifdef __CSKYBE__
+  if (cif->flags == FFI_TYPE_INT && cif->rtype->type == FFI_TYPE_STRUCT) {
+      unsigned int tmp = 0;
+      tmp = *(unsigned int *)(*respp);
+      *(unsigned int *)(*respp) = (tmp >> ((4 - cif->rtype->size) * 8));
+  }
+#endif
+
+  return cif->flags;
+}
+
+
+static void
+ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,
+       void **avalue, ffi_cif *cif)
+{
+  register unsigned int i;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+
+  argp = stack;
+
+  if ( cif->flags == FFI_TYPE_STRUCT ) {
+    *rvalue = *(void **) argp;
+    argp += 4;
+  }
+
+  p_argv = avalue;
+
+  for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)
+    {
+      size_t z;
+      size_t alignment;
+
+      alignment = (*p_arg)->alignment;
+      if (alignment < 4)
+ alignment = 4;
+
+#ifdef __CSKYABIV1__
+      /*
+       * Adapt ABIV1 bug.
+       * If struct's size is larger than 8 bytes, then it always alignment as 4 bytes.
+       */
+      if (((*p_arg)->type == FFI_TYPE_STRUCT) && ((*p_arg)->size > 8) && (alignment == 8)) {
+        alignment = 4;
+      }
+#endif
+
+      /* Align if necessary */
+      if ((alignment - 1) & (unsigned) argp) {
+ argp = (char *) FFI_ALIGN(argp, alignment);
+      }
+
+      z = (*p_arg)->size;
+
+#ifdef __CSKYBE__
+      unsigned int tmp = 0;
+      if ((*p_arg)->size < 4) {
+        tmp = *(unsigned int *)argp;
+        memcpy(argp, ((unsigned char *)&tmp + (4 - (*p_arg)->size)), (*p_arg)->size);
+      }
+#else
+      /* because we're little endian, this is what it turns into.   */
+#endif
+      *p_argv = (void*) argp;
+
+      p_argv++;
+      argp += z;
+    }
+
+  return;
+}
+
+/* How to make a trampoline.  */
+
+extern unsigned char ffi_csky_trampoline[TRAMPOLINE_SIZE];
+
+/*
+ * Since there is no __clear_cache in libgcc in csky toolchain.
+ * define ffi_csky_cacheflush in sysv.S.
+ * void ffi_csky_cacheflush(uint32 start_addr, uint32 size, int cache)
+ */
+#define CACHEFLUSH_IN_FFI 1
+#if CACHEFLUSH_IN_FFI
+extern void ffi_csky_cacheflush(unsigned char *__tramp, unsigned int k,
+  int i);
+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)                              \
+({ unsigned char *__tramp = (unsigned char*)(TRAMP);                    \
+   unsigned int  __fun = (unsigned int)(FUN);                           \
+   unsigned int  __ctx = (unsigned int)(CTX);                           \
+   unsigned char *insns = (unsigned char *)(CTX);                       \
+   memcpy (__tramp, ffi_csky_trampoline, TRAMPOLINE_SIZE);              \
+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE] = __ctx;                  \
+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE + 4] = __fun;              \
+   ffi_csky_cacheflush(&__tramp[0], TRAMPOLINE_SIZE, 3); /* Clear data mapping.  */ \
+   ffi_csky_cacheflush(insns, TRAMPOLINE_SIZE, 3);                       \
+                                                 /* Clear instruction   \
+                                                    mapping.  */        \
+ })
+#else
+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)                              \
+({ unsigned char *__tramp = (unsigned char*)(TRAMP);                    \
+   unsigned int  __fun = (unsigned int)(FUN);                           \
+   unsigned int  __ctx = (unsigned int)(CTX);                           \
+   unsigned char *insns = (unsigned char *)(CTX);                       \
+   memcpy (__tramp, ffi_csky_trampoline, TRAMPOLINE_SIZE);              \
+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE] = __ctx;                  \
+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE + 4] = __fun;              \
+   __clear_cache((&__tramp[0]), (&__tramp[TRAMPOLINE_SIZE-1])); /* Clear data mapping.  */ \
+   __clear_cache(insns, insns + TRAMPOLINE_SIZE);                       \
+                                                 /* Clear instruction   \
+                                                    mapping.  */        \
+ })
+#endif
+
+/* the cif must already be prep'ed */
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+        ffi_cif* cif,
+        void (*fun)(ffi_cif*,void*,void**,void*),
+        void *user_data,
+        void *codeloc)
+{
+  void (*closure_func)(ffi_closure*) = NULL;
+
+  if (cif->abi == FFI_SYSV)
+    closure_func = &ffi_closure_SYSV;
+  else
+    return FFI_BAD_ABI;
+
+  FFI_INIT_TRAMPOLINE (&closure->tramp[0], \
+         closure_func,  \
+         codeloc);
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+
+
Index: libffi-3.4.6/src/csky/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/csky/sysv.S b/libffi-3.4.6/src/csky/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/csky/sysv.S	
@@ -0,0 +1,371 @@
+/* -----------------------------------------------------------------------
+   sysv.S
+
+   CSKY Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+.macro CSKY_FUNC_START name
+ .text
+ .align 2
+ .globl \name
+ .type \name, @function
+ \name:
+.endm
+
+#ifdef __CSKYABIV2__
+
+ /*
+  * a0:   fn
+  * a1:   &ecif
+  * a2:   cif->bytes
+  * a3:   fig->flags
+  * sp+0: ecif.rvalue
+  */
+CSKY_FUNC_START ffi_call_SYSV
+ /* Save registers */
+ .cfi_startproc
+ subi sp, 28
+ .cfi_def_cfa_offset 28
+ stw a0, (sp, 0x0)
+ .cfi_offset 0, -28
+ stw a1, (sp, 0x4)
+ .cfi_offset 1, -24
+ stw a2, (sp, 0x8)
+ .cfi_offset 2, -20
+ stw a3, (sp, 0xC)
+ .cfi_offset 3, -16
+ stw l0, (sp, 0x10)
+ .cfi_offset 4, -12
+ stw l1, (sp, 0x14)
+ .cfi_offset 5, -8
+ stw lr, (sp, 0x18)
+ .cfi_offset 15, -4
+
+ mov l0, sp
+ .cfi_def_cfa_register 4
+
+ /* Make room for all of the new args. */
+ subu sp, sp, a2
+
+ /* Place all of the ffi_prep_args in position */
+ mov a0, sp
+ /*     a1 already set */
+
+ /* Call ffi_prep_args(stack, &ecif) */
+ jsri ffi_prep_args
+
+ /* move first 4 parameters in registers */
+ ldw a0, (sp, 0x0)
+ ldw a1, (sp, 0x4)
+ ldw a2, (sp, 0x8)
+ ldw a3, (sp, 0xC)
+
+ /* and adjust stack */
+ subu lr, l0, sp /* cif->bytes == l0 - sp */
+ cmphsi lr, 16
+ movi l1, 16
+ movt lr, l1
+ addu sp, sp, lr
+
+ ldw l1, (l0, 0) /* load fn() in advance */
+
+ /* call (fn) (...) */
+ jsr l1
+
+ /* Remove the space we pushed for the args */
+ mov sp, l0
+
+ /* Load r2 with the pointer to storage for the return value */
+ ldw a2, (sp, 0x1C)
+
+ /* Load r3 with the return type code */
+ ldw a3, (sp, 0xC)
+
+ /* If the return value pointer is NULL, assume no return value. */
+ cmpnei a2, 0
+ bf .Lepilogue
+
+ cmpnei a3, FFI_TYPE_STRUCT
+ bf .Lepilogue
+
+ /* return INT64 */
+ cmpnei a3, FFI_TYPE_SINT64
+ bt .Lretint
+ /* stw a0, (a2, 0x0) at .Lretint */
+ stw a1, (a2, 0x4)
+
+.Lretint:
+ /* return INT */
+ stw a0, (a2, 0x0)
+
+.Lepilogue:
+ ldw a0, (sp, 0x0)
+ ldw a1, (sp, 0x4)
+ ldw a2, (sp, 0x8)
+ ldw a3, (sp, 0xC)
+ ldw l0, (sp, 0x10)
+ ldw l1, (sp, 0x14)
+ ldw lr, (sp, 0x18)
+ addi sp, sp, 28
+ rts
+ .cfi_endproc
+        .size    ffi_call_SYSV, .-ffi_call_SYSV
+
+
+ /*
+  * unsigned int FFI_HIDDEN
+  * ffi_closure_SYSV_inner (closure, respp, args)
+  *      ffi_closure *closure;
+  *      void **respp;
+  *      void *args;
+  */
+CSKY_FUNC_START ffi_closure_SYSV
+ .cfi_startproc
+ mov a2, sp
+ addi a1, sp, 16
+ subi sp, sp, 24
+ .cfi_def_cfa_offset 40
+ stw a1, (sp, 0x10)
+ .cfi_offset 1, -24
+ stw lr, (sp, 0x14)
+ .cfi_offset 15, -20
+ stw sp, (sp, 0x8)
+ addi a1, sp, 8
+ jsri ffi_closure_SYSV_inner
+ ldw a0, (sp, 0x0)
+ /*
+  * if FFI_TYPE_SINT64, need a1.
+  * if FFI_TYPE_INT, ignore a1.
+  */
+ ldw a1, (sp, 0x4)
+
+ ldw lr, (sp, 0x14)
+ addi sp, sp, 40
+ rts
+ .cfi_endproc
+        .size    ffi_closure_SYSV, .-ffi_closure_SYSV
+
+CSKY_FUNC_START ffi_csky_trampoline
+ subi sp, sp, 16
+ stw a0, (sp, 0x0)
+ stw a1, (sp, 0x4)
+ stw a2, (sp, 0x8)
+ stw a3, (sp, 0xC)
+ lrw a0, [.Lctx]
+ lrw a1, [.Lfun]
+ jmp a1
+.Lctx:
+ mov a0, a0
+ mov a0, a0
+.Lfun:
+
+        .size    ffi_csky_trampoline, .-ffi_csky_trampoline
+
+CSKY_FUNC_START ffi_csky_cacheflush
+ mov t0, r7
+ movi r7, 123
+ trap 0
+ mov r7, t0
+ rts
+
+        .size    ffi_csky_cacheflush, .-ffi_csky_cacheflush
+
+#else /* !__CSKYABIV2__ */
+
+ /*
+  * a0:   fn
+  * a1:   &ecif
+  * a2:   cif->bytes
+  * a3:   fig->flags
+  * a4:   ecif.rvalue
+  */
+CSKY_FUNC_START ffi_call_SYSV
+ /* Save registers */
+ .cfi_startproc
+ subi sp, 32
+ subi sp, 8
+ .cfi_def_cfa_offset 40
+ stw a0, (sp, 0x0)
+ .cfi_offset 2, -40
+ stw a1, (sp, 0x4)
+ .cfi_offset 3, -36
+ stw a2, (sp, 0x8)
+ .cfi_offset 4, -32
+ stw a3, (sp, 0xC)
+ .cfi_offset 5, -28
+ stw a4, (sp, 0x10)
+ .cfi_offset 6, -24
+ stw a5, (sp, 0x14)
+ .cfi_offset 7, -20
+ stw l0, (sp, 0x18)
+ .cfi_offset 8, -16
+ stw l1, (sp, 0x1C)
+ .cfi_offset 9, -12
+ stw lr, (sp, 0x20)
+ .cfi_offset 15, -8
+
+ mov l0, sp
+ .cfi_def_cfa_register 8
+
+ /* Make room for all of the new args. */
+ subu sp, sp, a2
+
+ /* Place all of the ffi_prep_args in position */
+ mov a0, sp
+ /*     a1 already set */
+
+ /* Call ffi_prep_args(stack, &ecif) */
+ jsri ffi_prep_args
+
+ /* move first 4 parameters in registers */
+ ldw a0, (sp, 0x0)
+ ldw a1, (sp, 0x4)
+ ldw a2, (sp, 0x8)
+ ldw a3, (sp, 0xC)
+ ldw a4, (sp, 0x10)
+ ldw a5, (sp, 0x14)
+
+ /* and adjust stack */
+ mov lr, l0
+ subu lr, sp  /* cif->bytes == l0 - sp */
+ movi l1, 24
+ cmphs lr, l1
+ movt lr, l1
+ addu sp, sp, lr
+
+ ldw l1, (l0, 0) /* load fn() in advance */
+
+ /* call (fn) (...) */
+ jsr l1
+
+ /* Remove the space we pushed for the args */
+ mov sp, l0
+
+ /* Load r2 with the pointer to storage for the return value */
+ ldw a2, (sp, 0x10)
+
+ /* Load r3 with the return type code */
+ ldw a3, (sp, 0xC)
+
+ /* If the return value pointer is NULL, assume no return value. */
+ cmpnei a2, 0
+ bf .Lepilogue
+
+ cmpnei a3, FFI_TYPE_STRUCT
+ bf .Lepilogue
+
+ /* return INT64 */
+ cmpnei a3, FFI_TYPE_SINT64
+ bt .Lretint
+ /* stw a0, (a2, 0x0) at .Lretint */
+ stw a1, (a2, 0x4)
+
+.Lretint:
+ /* return INT */
+ stw a0, (a2, 0x0)
+
+.Lepilogue:
+ ldw a0, (sp, 0x0)
+ ldw a1, (sp, 0x4)
+ ldw a2, (sp, 0x8)
+ ldw a3, (sp, 0xC)
+ ldw a4, (sp, 0x10)
+ ldw a5, (sp, 0x14)
+ ldw l0, (sp, 0x18)
+ ldw l1, (sp, 0x1C)
+ ldw lr, (sp, 0x20)
+ addi sp, sp, 32
+ addi sp, sp, 8
+ rts
+ .cfi_endproc
+
+        .size    ffi_call_SYSV, .-ffi_call_SYSV
+
+
+ /*
+  * unsigned int FFI_HIDDEN
+  * ffi_closure_SYSV_inner (closure, respp, args)
+  *      ffi_closure *closure;
+  *      void **respp;
+  *      void *args;
+  */
+CSKY_FUNC_START ffi_closure_SYSV
+ .cfi_startproc
+ mov a2, sp
+ mov a1, sp
+ addi a1, 24
+ subi sp, sp, 24
+ .cfi_def_cfa_offset 48
+ stw a1, (sp, 0x10)
+ .cfi_offset 3, -32
+ stw lr, (sp, 0x14)
+ .cfi_offset 15, -28
+ stw sp, (sp, 0x8)
+ mov a1, sp
+ addi a1, 8
+ jsri ffi_closure_SYSV_inner
+ ldw a0, (sp, 0x0)
+ /*
+  * if FFI_TYPE_SINT64, need a1.
+  * if FFI_TYPE_INT, ignore a1.
+  */
+ ldw a1, (sp, 0x4)
+
+ ldw lr, (sp, 0x14)
+ addi sp, sp, 24
+ addi sp, sp, 24
+ rts
+ .cfi_endproc
+
+        .size    ffi_closure_SYSV, .-ffi_closure_SYSV
+
+CSKY_FUNC_START ffi_csky_trampoline
+ subi sp, 24
+ stw a0, (sp, 0x0)
+ stw a1, (sp, 0x4)
+ stw a2, (sp, 0x8)
+ stw a3, (sp, 0xC)
+ stw a4, (sp, 0x10)
+ stw a5, (sp, 0x14)
+ lrw a0, [.Lctx]
+ lrw a1, [.Lfun]
+ jmp a1
+.Lctx:
+ mov a0, a0
+ mov a0, a0
+.Lfun:
+
+        .size    ffi_csky_trampoline, .-ffi_csky_trampoline
+
+CSKY_FUNC_START ffi_csky_cacheflush
+ lrw r1, 123
+ trap 0
+ rts
+
+        .size    ffi_csky_cacheflush, .-ffi_csky_cacheflush
+
+#endif /* __CSKYABIV2__ */
Index: libffi-3.4.6/src/csky/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/csky/ffitarget.h b/libffi-3.4.6/src/csky/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/csky/ffitarget.h	
@@ -0,0 +1,63 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 2010  CodeSourcery
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+
+   Target configuration macros for CSKY.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV,
+} ffi_abi;
+#endif
+
+#ifdef __CSKYABIV2__
+#define FFI_ASM_ARGREG_SIZE 16
+#define TRAMPOLINE_SIZE 16
+#define FFI_TRAMPOLINE_SIZE 24
+#else
+#define FFI_ASM_ARGREG_SIZE 24
+#define TRAMPOLINE_SIZE 20
+#define FFI_TRAMPOLINE_SIZE 28
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+#endif
Index: libffi-3.4.6/src/ia64/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/ia64/ffi.c b/libffi-3.4.6/src/ia64/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/ia64/ffi.c	
@@ -0,0 +1,616 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 1998, 2007, 2008, 2012 Red Hat, Inc.
+	   Copyright (c) 2000 Hewlett Packard Company
+	   Copyright (c) 2011 Anthony Green
+   
+   IA64 Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <float.h>
+
+#include "ia64_flags.h"
+
+/* A 64-bit pointer value.  In LP64 mode, this is effectively a plain
+   pointer.  In ILP32 mode, it's a pointer that's been extended to 
+   64 bits by "addp4".  */
+#ifdef __hpux
+typedef void *PTR64;
+#else // some other unix
+typedef void *PTR64 __attribute__((mode(DI)));
+#endif
+
+/* Memory image of fp register contents.  This is the implementation
+   specific format used by ldf.fill/stf.spill.  All we care about is
+   that it wants a 16 byte aligned slot.  */
+typedef struct
+{
+  UINT64 x[2] __attribute__((aligned(16)));
+} fpreg;
+
+
+/* The stack layout given to ffi_call_unix and ffi_closure_unix_inner.  */
+
+struct ia64_args
+{
+  fpreg fp_regs[8];	/* Contents of 8 fp arg registers.  */
+  UINT64 gp_regs[8];	/* Contents of 8 gp arg registers.  */
+  UINT64 other_args[];	/* Arguments passed on stack, variable size.  */
+};
+
+
+/* Adjust ADDR, a pointer to an 8 byte slot, to point to the low LEN bytes.  */
+
+static inline void *
+endian_adjust (void *addr, size_t len)
+{
+#ifdef __BIG_ENDIAN__
+  return addr + (8 - len);
+#else
+  return addr;
+#endif
+}
+
+/* Store VALUE to ADDR in the current cpu implementation's fp spill format.
+   This is a macro instead of a function, so that it works for all 3 floating
+   point types without type conversions.  Type conversion to long double breaks
+   the denorm support.  */
+
+#ifdef __hpux
+#define stf_spill(addr, value)
+#else
+#define stf_spill(addr, value)	\
+  asm ("stf.spill %0 = %1%P0" : "=m" (*addr) : "f"(value));
+#endif
+
+/* Load a value from ADDR, which is in the current cpu implementation's
+   fp spill format.  As above, this must also be a macro.  */
+
+#ifdef __hpux
+#define ldf_fill(result, addr)
+#else
+#define ldf_fill(result, addr)	\
+  asm ("ldf.fill %0 = %1%P1" : "=f"(result) : "m"(*addr));
+#endif
+
+/* Return the size of the C type associated with with TYPE.  Which will
+   be one of the FFI_IA64_TYPE_HFA_* values.  */
+
+static size_t
+hfa_type_size (int type)
+{
+  switch (type)
+    {
+    case FFI_IA64_TYPE_HFA_FLOAT:
+      return sizeof(float);
+    case FFI_IA64_TYPE_HFA_DOUBLE:
+      return sizeof(double);
+    case FFI_IA64_TYPE_HFA_LDOUBLE:
+      return sizeof(__float80);
+    default:
+      abort ();
+    }
+}
+
+/* Load from ADDR a value indicated by TYPE.  Which will be one of
+   the FFI_IA64_TYPE_HFA_* values.  */
+
+static void
+hfa_type_load (fpreg *fpaddr, int type, void *addr)
+{
+  switch (type)
+    {
+    case FFI_IA64_TYPE_HFA_FLOAT:
+      stf_spill (fpaddr, *(float *) addr);
+      return;
+    case FFI_IA64_TYPE_HFA_DOUBLE:
+      stf_spill (fpaddr, *(double *) addr);
+      return;
+    case FFI_IA64_TYPE_HFA_LDOUBLE:
+      stf_spill (fpaddr, *(__float80 *) addr);
+      return;
+    default:
+      abort ();
+    }
+}
+
+/* Load VALUE into ADDR as indicated by TYPE.  Which will be one of
+   the FFI_IA64_TYPE_HFA_* values.  */
+
+static void
+hfa_type_store (int type, void *addr, fpreg *fpaddr)
+{
+  switch (type)
+    {
+    case FFI_IA64_TYPE_HFA_FLOAT:
+      {
+	float result;
+	ldf_fill (result, fpaddr);
+	*(float *) addr = result;
+	break;
+      }
+    case FFI_IA64_TYPE_HFA_DOUBLE:
+      {
+	double result;
+	ldf_fill (result, fpaddr);
+	*(double *) addr = result;
+	break;
+      }
+    case FFI_IA64_TYPE_HFA_LDOUBLE:
+      {
+	__float80 result;
+	ldf_fill (result, fpaddr);
+	*(__float80 *) addr = result;
+	break;
+      }
+    default:
+      abort ();
+    }
+}
+
+/* Is TYPE a struct containing floats, doubles, or extended doubles,
+   all of the same fp type?  If so, return the element type.  Return
+   FFI_TYPE_VOID if not.  */
+
+static int
+hfa_element_type (ffi_type *type, int nested)
+{
+  int element = FFI_TYPE_VOID;
+
+  switch (type->type)
+    {
+    case FFI_TYPE_FLOAT:
+      /* We want to return VOID for raw floating-point types, but the
+	 synthetic HFA type if we're nested within an aggregate.  */
+      if (nested)
+	element = FFI_IA64_TYPE_HFA_FLOAT;
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      /* Similarly.  */
+      if (nested)
+	element = FFI_IA64_TYPE_HFA_DOUBLE;
+      break;
+
+    case FFI_TYPE_LONGDOUBLE:
+      /* Similarly, except that that HFA is true for double extended,
+	 but not quad precision.  Both have sizeof == 16, so tell the
+	 difference based on the precision.  */
+      if (LDBL_MANT_DIG == 64 && nested)
+	element = FFI_IA64_TYPE_HFA_LDOUBLE;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      {
+	ffi_type **ptr = &type->elements[0];
+
+	for (ptr = &type->elements[0]; *ptr ; ptr++)
+	  {
+	    int sub_element = hfa_element_type (*ptr, 1);
+	    if (sub_element == FFI_TYPE_VOID)
+	      return FFI_TYPE_VOID;
+
+	    if (element == FFI_TYPE_VOID)
+	      element = sub_element;
+	    else if (element != sub_element)
+	      return FFI_TYPE_VOID;
+	  }
+      }
+      break;
+
+    default:
+      return FFI_TYPE_VOID;
+    }
+
+  return element;
+}
+
+
+/* Perform machine dependent cif processing. */
+
+static ffi_status
+ffi_prep_cif_machdep_core(ffi_cif *cif)
+{
+  int flags;
+
+  /* Adjust cif->bytes to include space for the bits of the ia64_args frame
+     that precedes the integer register portion.  The estimate that the
+     generic bits did for the argument space required is good enough for the
+     integer component.  */
+  cif->bytes += offsetof(struct ia64_args, gp_regs[0]);
+  if (cif->bytes < sizeof(struct ia64_args))
+    cif->bytes = sizeof(struct ia64_args);
+
+  /* Set the return type flag. */
+  flags = cif->rtype->type;
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_LONGDOUBLE:
+      /* Leave FFI_TYPE_LONGDOUBLE as meaning double extended precision,
+	 and encode quad precision as a two-word integer structure.  */
+      if (LDBL_MANT_DIG != 64)
+	flags = FFI_IA64_TYPE_SMALL_STRUCT | (16 << 8);
+      break;
+
+    case FFI_TYPE_STRUCT:
+      {
+        size_t size = cif->rtype->size;
+  	int hfa_type = hfa_element_type (cif->rtype, 0);
+
+	if (hfa_type != FFI_TYPE_VOID)
+	  {
+	    size_t nelts = size / hfa_type_size (hfa_type);
+	    if (nelts <= 8)
+	      flags = hfa_type | (size << 8);
+	  }
+	else
+	  {
+	    if (size <= 32)
+	      flags = FFI_IA64_TYPE_SMALL_STRUCT | (size << 8);
+	  }
+      }
+      break;
+
+    default:
+      break;
+    }
+  cif->flags = flags;
+
+  return FFI_OK;
+}
+
+ffi_status
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  cif->nfixedargs = cif->nargs;
+  return ffi_prep_cif_machdep_core(cif);
+}
+
+ffi_status
+ffi_prep_cif_machdep_var(ffi_cif *cif,
+			 unsigned int nfixedargs,
+			 unsigned int ntotalargs MAYBE_UNUSED)
+{
+  cif->nfixedargs = nfixedargs;
+  return ffi_prep_cif_machdep_core(cif);
+}
+
+extern int ffi_call_unix (struct ia64_args *, PTR64, void (*)(void), UINT64);
+
+void
+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  struct ia64_args *stack;
+  long i, avn, gpcount, fpcount;
+  ffi_type **p_arg;
+
+  FFI_ASSERT (cif->abi == FFI_UNIX);
+
+  /* If we have no spot for a return value, make one.  */
+  if (rvalue == NULL && cif->rtype->type != FFI_TYPE_VOID)
+    rvalue = alloca (cif->rtype->size);
+    
+  /* Allocate the stack frame.  */
+  stack = alloca (cif->bytes);
+
+  gpcount = fpcount = 0;
+  avn = cif->nargs;
+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)
+    {
+      switch ((*p_arg)->type)
+	{
+	case FFI_TYPE_SINT8:
+	  stack->gp_regs[gpcount++] = *(SINT8 *)avalue[i];
+	  break;
+	case FFI_TYPE_UINT8:
+	  stack->gp_regs[gpcount++] = *(UINT8 *)avalue[i];
+	  break;
+	case FFI_TYPE_SINT16:
+	  stack->gp_regs[gpcount++] = *(SINT16 *)avalue[i];
+	  break;
+	case FFI_TYPE_UINT16:
+	  stack->gp_regs[gpcount++] = *(UINT16 *)avalue[i];
+	  break;
+	case FFI_TYPE_SINT32:
+	  stack->gp_regs[gpcount++] = *(SINT32 *)avalue[i];
+	  break;
+	case FFI_TYPE_UINT32:
+	  stack->gp_regs[gpcount++] = *(UINT32 *)avalue[i];
+	  break;
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  stack->gp_regs[gpcount++] = *(UINT64 *)avalue[i];
+	  break;
+
+	case FFI_TYPE_POINTER:
+	  stack->gp_regs[gpcount++] = (UINT64)(PTR64) *(void **)avalue[i];
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  if (gpcount < 8 && fpcount < 8)
+	    stf_spill (&stack->fp_regs[fpcount++], *(float *)avalue[i]);
+	  {
+	    UINT32 tmp;
+	    memcpy (&tmp, avalue[i], sizeof (UINT32));
+	    stack->gp_regs[gpcount++] = tmp;
+	  }
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (gpcount < 8 && fpcount < 8)
+	    stf_spill (&stack->fp_regs[fpcount++], *(double *)avalue[i]);
+	  memcpy (&stack->gp_regs[gpcount++], avalue[i], sizeof (UINT64));
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	  if (gpcount & 1)
+	    gpcount++;
+	  if (LDBL_MANT_DIG == 64 && gpcount < 8 && fpcount < 8)
+	    stf_spill (&stack->fp_regs[fpcount++], *(__float80 *)avalue[i]);
+	  memcpy (&stack->gp_regs[gpcount], avalue[i], 16);
+	  gpcount += 2;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  {
+	    size_t size = (*p_arg)->size;
+	    size_t align = (*p_arg)->alignment;
+	    int hfa_type = hfa_element_type (*p_arg, 0);
+
+	    FFI_ASSERT (align <= 16);
+	    if (align == 16 && (gpcount & 1))
+	      gpcount++;
+
+	    if (hfa_type != FFI_TYPE_VOID)
+	      {
+		size_t hfa_size = hfa_type_size (hfa_type);
+		size_t offset = 0;
+		size_t gp_offset = gpcount * 8;
+
+		while (fpcount < 8
+		       && offset < size
+		       && gp_offset < 8 * 8)
+		  {
+		    hfa_type_load (&stack->fp_regs[fpcount], hfa_type,
+				   avalue[i] + offset);
+		    offset += hfa_size;
+		    gp_offset += hfa_size;
+		    fpcount += 1;
+		  }
+	      }
+
+	    memcpy (&stack->gp_regs[gpcount], avalue[i], size);
+	    gpcount += (size + 7) / 8;
+	  }
+	  break;
+
+	default:
+	  abort ();
+	}
+    }
+
+  ffi_call_unix (stack, rvalue, fn, cif->flags);
+}
+
+/* Closures represent a pair consisting of a function pointer, and
+   some user data.  A closure is invoked by reinterpreting the closure
+   as a function pointer, and branching to it.  Thus we can make an
+   interpreted function callable as a C function: We turn the
+   interpreter itself, together with a pointer specifying the
+   interpreted procedure, into a closure.
+
+   For IA64, function pointer are already pairs consisting of a code
+   pointer, and a gp pointer.  The latter is needed to access global
+   variables.  Here we set up such a pair as the first two words of
+   the closure (in the "trampoline" area), but we replace the gp
+   pointer with a pointer to the closure itself.  We also add the real
+   gp pointer to the closure.  This allows the function entry code to
+   both retrieve the user data, and to restore the correct gp pointer.  */
+
+extern void ffi_closure_unix ();
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  /* The layout of a function descriptor.  A C function pointer really 
+     points to one of these.  */
+  struct ia64_fd
+  {
+    UINT64 code_pointer;
+    UINT64 gp;
+  };
+
+  struct ffi_ia64_trampoline_struct
+  {
+    UINT64 code_pointer;	/* Pointer to ffi_closure_unix.  */
+    UINT64 fake_gp;		/* Pointer to closure, installed as gp.  */
+    UINT64 real_gp;		/* Real gp value.  */
+  };
+
+  struct ffi_ia64_trampoline_struct *tramp;
+  struct ia64_fd *fd;
+
+  if (cif->abi != FFI_UNIX)
+    return FFI_BAD_ABI;
+
+  tramp = (struct ffi_ia64_trampoline_struct *)closure->tramp;
+  fd = (struct ia64_fd *)(void *)ffi_closure_unix;
+
+  tramp->code_pointer = fd->code_pointer;
+  tramp->real_gp = fd->gp;
+  tramp->fake_gp = (UINT64)(PTR64)codeloc;
+  closure->cif = cif;
+  closure->user_data = user_data;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+
+UINT64
+ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,
+			void *rvalue, void *r8)
+{
+  ffi_cif *cif;
+  void **avalue;
+  ffi_type **p_arg;
+  long i, avn, gpcount, fpcount, nfixedargs;
+
+  cif = closure->cif;
+  avn = cif->nargs;
+  nfixedargs = cif->nfixedargs;
+  avalue = alloca (avn * sizeof (void *));
+
+  /* If the structure return value is passed in memory get that location
+     from r8 so as to pass the value directly back to the caller.  */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    rvalue = r8;
+
+  gpcount = fpcount = 0;
+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)
+    {
+      int named = i < nfixedargs;
+      switch ((*p_arg)->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 1);
+	  break;
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 2);
+	  break;
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 4);
+	  break;
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  avalue[i] = &stack->gp_regs[gpcount++];
+	  break;
+	case FFI_TYPE_POINTER:
+	  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], sizeof(void*));
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  if (named && gpcount < 8 && fpcount < 8)
+	    {
+	      fpreg *addr = &stack->fp_regs[fpcount++];
+	      float result;
+	      avalue[i] = addr;
+	      ldf_fill (result, addr);
+	      *(float *)addr = result;
+	    }
+	  else
+	    avalue[i] = endian_adjust(&stack->gp_regs[gpcount], 4);
+	  gpcount++;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (named && gpcount < 8 && fpcount < 8)
+	    {
+	      fpreg *addr = &stack->fp_regs[fpcount++];
+	      double result;
+	      avalue[i] = addr;
+	      ldf_fill (result, addr);
+	      *(double *)addr = result;
+	    }
+	  else
+	    avalue[i] = &stack->gp_regs[gpcount];
+	  gpcount++;
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	  if (gpcount & 1)
+	    gpcount++;
+	  if (LDBL_MANT_DIG == 64 && named && gpcount < 8 && fpcount < 8)
+	    {
+	      fpreg *addr = &stack->fp_regs[fpcount++];
+	      __float80 result;
+	      avalue[i] = addr;
+	      ldf_fill (result, addr);
+	      *(__float80 *)addr = result;
+	    }
+	  else
+	    avalue[i] = &stack->gp_regs[gpcount];
+	  gpcount += 2;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  {
+	    size_t size = (*p_arg)->size;
+	    size_t align = (*p_arg)->alignment;
+	    int hfa_type = hfa_element_type (*p_arg, 0);
+
+	    FFI_ASSERT (align <= 16);
+	    if (align == 16 && (gpcount & 1))
+	      gpcount++;
+
+	    if (hfa_type != FFI_TYPE_VOID)
+	      {
+		size_t hfa_size = hfa_type_size (hfa_type);
+		size_t offset = 0;
+		size_t gp_offset = gpcount * 8;
+		void *addr = alloca (size);
+
+		avalue[i] = addr;
+
+		while (fpcount < 8
+		       && offset < size
+		       && gp_offset < 8 * 8)
+		  {
+		    hfa_type_store (hfa_type, addr + offset,
+				    &stack->fp_regs[fpcount]);
+		    offset += hfa_size;
+		    gp_offset += hfa_size;
+		    fpcount += 1;
+		  }
+
+		if (offset < size)
+		  memcpy (addr + offset, (char *)stack->gp_regs + gp_offset,
+			  size - offset);
+	      }
+	    else
+	      avalue[i] = &stack->gp_regs[gpcount];
+
+	    gpcount += (size + 7) / 8;
+	  }
+	  break;
+
+	default:
+	  abort ();
+	}
+    }
+
+  closure->fun (cif, rvalue, avalue, closure->user_data);
+
+  return cif->flags;
+}
Index: libffi-3.4.6/src/ia64/unix.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/ia64/unix.S b/libffi-3.4.6/src/ia64/unix.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/ia64/unix.S	
@@ -0,0 +1,585 @@
+/* -----------------------------------------------------------------------
+   unix.S - Copyright (c) 1998, 2008 Red Hat, Inc.
+            Copyright (c) 2000 Hewlett Packard Company
+   
+   IA64/unix Foreign Function Interface 
+
+   Primary author: Hans Boehm, HP Labs
+
+   Loosely modeled on Cygnus code for other platforms.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#include "ia64_flags.h"
+
+	.pred.safe_across_calls p1-p5,p16-p63
+.text
+/* HPUX assembler needs to see these symbols, otherwise compilation
+   fails */
+#ifdef __hpux
+      .global memcpy
+      .global ffi_closure_unix_inner
+#endif
+
+/* int ffi_call_unix (struct ia64_args *stack, PTR64 rvalue,
+		      void (*fn)(void), int flags);
+ */
+
+        .align 16
+        .global	ffi_call_unix
+        .proc	ffi_call_unix
+ffi_call_unix:
+	.prologue
+	/* Bit o trickiness.  We actually share a stack frame with ffi_call.
+	   Rely on the fact that ffi_call uses a vframe and don't bother
+	   tracking one here at all.  */
+	.fframe	0
+	.save	ar.pfs, r36 // loc0
+	alloc   loc0 = ar.pfs, 4, 3, 8, 0
+	.save	rp, loc1
+	mov 	loc1 = b0
+	.body
+	add	r16 = 16, in0
+	mov	loc2 = gp
+	mov	r8 = in1
+	;;
+
+	/* Load up all of the argument registers.  */
+	ldf.fill f8 = [in0], 32
+	ldf.fill f9 = [r16], 32
+	;;
+	ldf.fill f10 = [in0], 32
+	ldf.fill f11 = [r16], 32
+	;;
+	ldf.fill f12 = [in0], 32
+	ldf.fill f13 = [r16], 32
+	;;
+	ldf.fill f14 = [in0], 32
+	ldf.fill f15 = [r16], 24
+	;;
+	ld8	out0 = [in0], 16
+	ld8	out1 = [r16], 16
+	;;
+	ld8	out2 = [in0], 16
+	ld8	out3 = [r16], 16
+	;;
+	ld8	out4 = [in0], 16
+	ld8	out5 = [r16], 16
+	;;
+	ld8	out6 = [in0]
+	ld8	out7 = [r16]
+	;;
+
+	/* Deallocate the register save area from the stack frame.  */
+	mov	sp = in0
+
+	/* Call the target function.  */
+	ld8	r16 = [in2], 8
+	;;
+	ld8	gp = [in2]
+	mov	b6 = r16
+	br.call.sptk.many b0 = b6
+	;;
+
+	/* Dispatch to handle return value.  */
+	mov	gp = loc2
+	zxt1	r16 = in3
+	;;
+	mov	ar.pfs = loc0
+	addl	r18 = @ltoffx(.Lst_table), gp
+	;;
+	/* default assembler on HP-UX does not support LDXMOV */
+#ifdef __hpux
+	ld8	r18 = [r18]
+#else
+	ld8.mov	r18 = [r18], .Lst_table
+#endif
+	mov	b0 = loc1
+	;;
+	shladd	r18 = r16, 3, r18
+	;;
+	ld8	r17 = [r18]
+	shr	in3 = in3, 8
+	;;
+	add	r17 = r17, r18
+	;;
+	mov	b6 = r17
+	br	b6
+	;;
+
+.Lst_void:
+	br.ret.sptk.many b0
+	;;
+.Lst_uint8:
+	zxt1	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_sint8:
+	sxt1	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_uint16:
+	zxt2	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_sint16:
+	sxt2	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_uint32:
+	zxt4	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_sint32:
+	sxt4	r8 = r8
+	;;
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_int64:
+	st8	[in1] = r8
+	br.ret.sptk.many b0
+	;;
+.Lst_float:
+	stfs	[in1] = f8
+	br.ret.sptk.many b0
+	;;
+.Lst_double:
+	stfd	[in1] = f8
+	br.ret.sptk.many b0
+	;;
+.Lst_ldouble:
+	stfe	[in1] = f8
+	br.ret.sptk.many b0
+	;;
+
+.Lst_small_struct:
+	cmp.lt	p6, p0 = 8, in3
+	cmp.lt	p7, p0 = 16, in3
+	cmp.lt	p8, p0 = 24, in3
+	;;
+	add	r16 = 8, sp
+	add	r17 = 16, sp
+	add	r18 = 24, sp
+	;;
+	st8	[sp] = r8
+(p6)	st8	[r16] = r9
+	mov	out0 = in1
+(p7)	st8	[r17] = r10
+(p8)	st8	[r18] = r11
+	mov	out1 = sp
+	mov	out2 = in3
+	;;
+	// ia64 software calling convention requires
+	// top 16 bytes of stack to be scratch space
+	// PLT resolver uses that scratch space at
+	// 'memcpy' symbol reolution time
+	add	sp = -16, sp
+	br.call.sptk.many b0 = memcpy#
+	;;
+	mov	ar.pfs = loc0
+	mov	b0 = loc1
+	mov	gp = loc2
+	br.ret.sptk.many b0
+
+.Lst_hfa_float:
+	add	r16 = 4, in1
+	cmp.lt	p6, p0 = 4, in3
+	;;
+	stfs	[in1] = f8, 8
+(p6)	stfs	[r16] = f9, 8
+	cmp.lt	p7, p0 = 8, in3
+	cmp.lt	p8, p0 = 12, in3
+	;;
+(p7)	stfs	[in1] = f10, 8
+(p8)	stfs	[r16] = f11, 8
+	cmp.lt	p9, p0 = 16, in3
+	cmp.lt	p10, p0 = 20, in3
+	;;
+(p9)	stfs	[in1] = f12, 8
+(p10)	stfs	[r16] = f13, 8
+	cmp.lt	p6, p0 = 24, in3
+	cmp.lt	p7, p0 = 28, in3
+	;;
+(p6)	stfs	[in1] = f14
+(p7)	stfs	[r16] = f15
+	br.ret.sptk.many b0
+	;;
+
+.Lst_hfa_double:
+	add	r16 = 8, in1
+	cmp.lt	p6, p0 = 8, in3
+	;;
+	stfd	[in1] = f8, 16
+(p6)	stfd	[r16] = f9, 16
+	cmp.lt	p7, p0 = 16, in3
+	cmp.lt	p8, p0 = 24, in3
+	;;
+(p7)	stfd	[in1] = f10, 16
+(p8)	stfd	[r16] = f11, 16
+	cmp.lt	p9, p0 = 32, in3
+	cmp.lt	p10, p0 = 40, in3
+	;;
+(p9)	stfd	[in1] = f12, 16
+(p10)	stfd	[r16] = f13, 16
+	cmp.lt	p6, p0 = 48, in3
+	cmp.lt	p7, p0 = 56, in3
+	;;
+(p6)	stfd	[in1] = f14
+(p7)	stfd	[r16] = f15
+	br.ret.sptk.many b0
+	;;
+
+.Lst_hfa_ldouble:
+	add	r16 = 16, in1
+	cmp.lt	p6, p0 = 16, in3
+	;;
+	stfe	[in1] = f8, 32
+(p6)	stfe	[r16] = f9, 32
+	cmp.lt	p7, p0 = 32, in3
+	cmp.lt	p8, p0 = 48, in3
+	;;
+(p7)	stfe	[in1] = f10, 32
+(p8)	stfe	[r16] = f11, 32
+	cmp.lt	p9, p0 = 64, in3
+	cmp.lt	p10, p0 = 80, in3
+	;;
+(p9)	stfe	[in1] = f12, 32
+(p10)	stfe	[r16] = f13, 32
+	cmp.lt	p6, p0 = 96, in3
+	cmp.lt	p7, p0 = 112, in3
+	;;
+(p6)	stfe	[in1] = f14
+(p7)	stfe	[r16] = f15
+	br.ret.sptk.many b0
+	;;
+
+        .endp ffi_call_unix
+
+        .align 16
+        .global ffi_closure_unix
+        .proc ffi_closure_unix
+
+#define FRAME_SIZE	(8*16 + 8*8 + 8*16)
+
+ffi_closure_unix:
+	.prologue
+	.save	ar.pfs, r40 // loc0
+	alloc   loc0 = ar.pfs, 8, 4, 4, 0
+	.fframe	FRAME_SIZE
+	add	r12 = -FRAME_SIZE, r12
+	.save	rp, loc1
+	mov	loc1 = b0
+	.save	ar.unat, loc2
+	mov	loc2 = ar.unat
+	.body
+
+	/* Retrieve closure pointer and real gp.  */
+#ifdef _ILP32
+	addp4	out0 = 0, gp
+	addp4	gp = 16, gp
+#else
+	mov	out0 = gp
+	add	gp = 16, gp
+#endif
+	;;
+	ld8	gp = [gp]
+
+	/* Spill all of the possible argument registers.  */
+	add	r16 = 16 + 8*16, sp
+	add	r17 = 16 + 8*16 + 16, sp
+	;;
+	stf.spill [r16] = f8, 32
+	stf.spill [r17] = f9, 32
+	mov	loc3 = gp
+	;;
+	stf.spill [r16] = f10, 32
+	stf.spill [r17] = f11, 32
+	;;
+	stf.spill [r16] = f12, 32
+	stf.spill [r17] = f13, 32
+	;;
+	stf.spill [r16] = f14, 32
+	stf.spill [r17] = f15, 24
+	;;
+	.mem.offset 0, 0
+	st8.spill [r16] = in0, 16
+	.mem.offset 8, 0
+	st8.spill [r17] = in1, 16
+	add	out1 = 16 + 8*16, sp
+	;;
+	.mem.offset 0, 0
+	st8.spill [r16] = in2, 16
+	.mem.offset 8, 0
+	st8.spill [r17] = in3, 16
+	add	out2 = 16, sp
+	;;
+	.mem.offset 0, 0
+	st8.spill [r16] = in4, 16
+	.mem.offset 8, 0
+	st8.spill [r17] = in5, 16
+	mov	out3 = r8
+	;;
+	.mem.offset 0, 0
+	st8.spill [r16] = in6
+	.mem.offset 8, 0
+	st8.spill [r17] = in7
+
+	/* Invoke ffi_closure_unix_inner for the hard work.  */
+	br.call.sptk.many b0 = ffi_closure_unix_inner
+	;;
+
+	/* Dispatch to handle return value.  */
+	mov	gp = loc3
+	zxt1	r16 = r8
+	;;
+	addl	r18 = @ltoffx(.Lld_table), gp
+	mov	ar.pfs = loc0
+	;;
+#ifdef __hpux
+	ld8	r18 = [r18]
+#else
+	ld8.mov	r18 = [r18], .Lst_table
+#endif
+	mov	b0 = loc1
+	;;
+	shladd	r18 = r16, 3, r18
+	mov	ar.unat = loc2
+	;;
+	ld8	r17 = [r18]
+	shr	r8 = r8, 8
+	;;
+	add	r17 = r17, r18
+	add	r16 = 16, sp
+	;;
+	mov	b6 = r17
+	br	b6
+	;;
+	.label_state 1
+
+.Lld_void:
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+.Lld_int:
+	.body
+	.copy_state 1
+	ld8	r8 = [r16]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+.Lld_float:
+	.body
+	.copy_state 1
+	ldfs	f8 = [r16]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+.Lld_double:
+	.body
+	.copy_state 1
+	ldfd	f8 = [r16]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+.Lld_ldouble:
+	.body
+	.copy_state 1
+	ldfe	f8 = [r16]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+
+.Lld_small_struct:
+	.body
+	.copy_state 1
+	add	r17 = 8, r16
+	cmp.lt	p6, p0 = 8, r8
+	cmp.lt	p7, p0 = 16, r8
+	cmp.lt	p8, p0 = 24, r8
+	;;
+	ld8	r8 = [r16], 16
+(p6)	ld8	r9 = [r17], 16
+	;;
+(p7)	ld8	r10 = [r16]
+(p8)	ld8	r11 = [r17]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+
+.Lld_hfa_float:
+	.body
+	.copy_state 1
+	add	r17 = 4, r16
+	cmp.lt	p6, p0 = 4, r8
+	;;
+	ldfs	f8 = [r16], 8
+(p6)	ldfs	f9 = [r17], 8
+	cmp.lt	p7, p0 = 8, r8
+	cmp.lt	p8, p0 = 12, r8
+	;;
+(p7)	ldfs	f10 = [r16], 8
+(p8)	ldfs	f11 = [r17], 8
+	cmp.lt	p9, p0 = 16, r8
+	cmp.lt	p10, p0 = 20, r8
+	;;
+(p9)	ldfs	f12 = [r16], 8
+(p10)	ldfs	f13 = [r17], 8
+	cmp.lt	p6, p0 = 24, r8
+	cmp.lt	p7, p0 = 28, r8
+	;;
+(p6)	ldfs	f14 = [r16]
+(p7)	ldfs	f15 = [r17]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+
+.Lld_hfa_double:
+	.body
+	.copy_state 1
+	add	r17 = 8, r16
+	cmp.lt	p6, p0 = 8, r8
+	;;
+	ldfd	f8 = [r16], 16
+(p6)	ldfd	f9 = [r17], 16
+	cmp.lt	p7, p0 = 16, r8
+	cmp.lt	p8, p0 = 24, r8
+	;;
+(p7)	ldfd	f10 = [r16], 16
+(p8)	ldfd	f11 = [r17], 16
+	cmp.lt	p9, p0 = 32, r8
+	cmp.lt	p10, p0 = 40, r8
+	;;
+(p9)	ldfd	f12 = [r16], 16
+(p10)	ldfd	f13 = [r17], 16
+	cmp.lt	p6, p0 = 48, r8
+	cmp.lt	p7, p0 = 56, r8
+	;;
+(p6)	ldfd	f14 = [r16]
+(p7)	ldfd	f15 = [r17]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+
+.Lld_hfa_ldouble:
+	.body
+	.copy_state 1
+	add	r17 = 16, r16
+	cmp.lt	p6, p0 = 16, r8
+	;;
+	ldfe	f8 = [r16], 32
+(p6)	ldfe	f9 = [r17], 32
+	cmp.lt	p7, p0 = 32, r8
+	cmp.lt	p8, p0 = 48, r8
+	;;
+(p7)	ldfe	f10 = [r16], 32
+(p8)	ldfe	f11 = [r17], 32
+	cmp.lt	p9, p0 = 64, r8
+	cmp.lt	p10, p0 = 80, r8
+	;;
+(p9)	ldfe	f12 = [r16], 32
+(p10)	ldfe	f13 = [r17], 32
+	cmp.lt	p6, p0 = 96, r8
+	cmp.lt	p7, p0 = 112, r8
+	;;
+(p6)	ldfe	f14 = [r16]
+(p7)	ldfe	f15 = [r17]
+	.restore sp
+	add	sp = FRAME_SIZE, sp
+	br.ret.sptk.many b0
+	;;
+
+	.endp	ffi_closure_unix
+#ifdef __hpux
+	.rodata
+#else
+	.section .rodata
+#endif
+	.align	8
+.Lst_table:
+	data8	@pcrel(.Lst_void)		// FFI_TYPE_VOID
+	data8	@pcrel(.Lst_sint32)		// FFI_TYPE_INT
+	data8	@pcrel(.Lst_float)		// FFI_TYPE_FLOAT
+	data8	@pcrel(.Lst_double)		// FFI_TYPE_DOUBLE
+	data8	@pcrel(.Lst_ldouble)		// FFI_TYPE_LONGDOUBLE
+	data8	@pcrel(.Lst_uint8)		// FFI_TYPE_UINT8
+	data8	@pcrel(.Lst_sint8)		// FFI_TYPE_SINT8
+	data8	@pcrel(.Lst_uint16)		// FFI_TYPE_UINT16
+	data8	@pcrel(.Lst_sint16)		// FFI_TYPE_SINT16
+	data8	@pcrel(.Lst_uint32)		// FFI_TYPE_UINT32
+	data8	@pcrel(.Lst_sint32)		// FFI_TYPE_SINT32
+	data8	@pcrel(.Lst_int64)		// FFI_TYPE_UINT64
+	data8	@pcrel(.Lst_int64)		// FFI_TYPE_SINT64
+	data8	@pcrel(.Lst_void)		// FFI_TYPE_STRUCT
+	data8	@pcrel(.Lst_int64)		// FFI_TYPE_POINTER
+	data8	@pcrel(.Lst_void)		// FFI_TYPE_COMPLEX (not implemented)
+	data8 	@pcrel(.Lst_small_struct)	// FFI_IA64_TYPE_SMALL_STRUCT
+	data8	@pcrel(.Lst_hfa_float)		// FFI_IA64_TYPE_HFA_FLOAT
+	data8	@pcrel(.Lst_hfa_double)		// FFI_IA64_TYPE_HFA_DOUBLE
+	data8	@pcrel(.Lst_hfa_ldouble)	// FFI_IA64_TYPE_HFA_LDOUBLE
+
+.Lld_table:
+	data8	@pcrel(.Lld_void)		// FFI_TYPE_VOID
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_INT
+	data8	@pcrel(.Lld_float)		// FFI_TYPE_FLOAT
+	data8	@pcrel(.Lld_double)		// FFI_TYPE_DOUBLE
+	data8	@pcrel(.Lld_ldouble)		// FFI_TYPE_LONGDOUBLE
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_UINT8
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_SINT8
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_UINT16
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_SINT16
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_UINT32
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_SINT32
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_UINT64
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_SINT64
+	data8	@pcrel(.Lld_void)		// FFI_TYPE_STRUCT
+	data8	@pcrel(.Lld_int)		// FFI_TYPE_POINTER
+	data8	@pcrel(.Lld_void)		// FFI_TYPE_COMPLEX (not implemented)
+	data8 	@pcrel(.Lld_small_struct)	// FFI_IA64_TYPE_SMALL_STRUCT
+	data8	@pcrel(.Lld_hfa_float)		// FFI_IA64_TYPE_HFA_FLOAT
+	data8	@pcrel(.Lld_hfa_double)		// FFI_IA64_TYPE_HFA_DOUBLE
+	data8	@pcrel(.Lld_hfa_ldouble)	// FFI_IA64_TYPE_HFA_LDOUBLE
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/ia64/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/ia64/ffitarget.h b/libffi-3.4.6/src/ia64/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/ia64/ffitarget.h	
@@ -0,0 +1,56 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for IA-64.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long long          ffi_arg;
+typedef signed long long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_UNIX,   	/* Linux and all Unix variants use the same conventions	*/
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_UNIX
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24  /* Really the following struct, which 	*/
+				/* can be interpreted as a C function	*/
+				/* descriptor:				*/
+#define FFI_TARGET_SPECIFIC_VARIADIC 1
+#define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs
+
+#endif
Index: libffi-3.4.6/src/ia64/ia64_flags.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/ia64/ia64_flags.h b/libffi-3.4.6/src/ia64/ia64_flags.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/ia64/ia64_flags.h	
@@ -0,0 +1,40 @@
+/* -----------------------------------------------------------------------
+   ia64_flags.h - Copyright (c) 2000 Hewlett Packard Company
+   
+   IA64/unix Foreign Function Interface 
+
+   Original author: Hans Boehm, HP Labs
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+/* "Type" codes used between assembly and C.  When used as a part of
+   a cfi->flags value, the low byte will be these extra type codes,
+   and bits 8-31 will be the actual size of the type.  */
+
+/* Small structures containing N words in integer registers.  */
+#define FFI_IA64_TYPE_SMALL_STRUCT	(FFI_TYPE_LAST + 1)
+
+/* Homogeneous Floating Point Aggregates (HFAs) which are returned
+   in FP registers.  */
+#define FFI_IA64_TYPE_HFA_FLOAT		(FFI_TYPE_LAST + 2)
+#define FFI_IA64_TYPE_HFA_DOUBLE	(FFI_TYPE_LAST + 3)
+#define FFI_IA64_TYPE_HFA_LDOUBLE	(FFI_TYPE_LAST + 4)
Index: libffi-3.4.6/src/m32r/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m32r/ffi.c b/libffi-3.4.6/src/m32r/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m32r/ffi.c	
@@ -0,0 +1,249 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2004  Renesas Technology
+           Copyright (c) 2008  Red Hat, Inc.
+           Copyright (c) 2022  Anthony Green
+
+   M32R Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* ffi_prep_args is called by the assembly routine once stack
+   space has been allocated for the function's arguments.  */
+
+void ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  unsigned int i;
+  int tmp;
+  unsigned int avn;
+  void **p_argv;
+  char *argp;
+  ffi_type **p_arg;
+
+  tmp = 0;
+  argp = stack;
+
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT && ecif->cif->rtype->size > 8)
+    {
+      *(void **) argp = ecif->rvalue;
+      argp += 4;
+    }
+
+  avn = ecif->cif->nargs;
+  p_argv = ecif->avalue;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       (i != 0) && (avn != 0);
+       i--, p_arg++)
+    {
+      size_t z;
+
+      /* Align if necessary.  */
+      if (((*p_arg)->alignment - 1) & (unsigned) argp)
+	argp = (char *) FFI_ALIGN (argp, (*p_arg)->alignment);
+
+      if (avn != 0)
+	{
+	  avn--;
+	  z = (*p_arg)->size;
+	  if (z < sizeof (int))
+	    {
+	      z = sizeof (int);
+
+	      switch ((*p_arg)->type)
+		{
+		case FFI_TYPE_SINT8:
+		  *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+		  break;
+
+		case FFI_TYPE_UINT8:
+		  *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+		  break;
+
+		case FFI_TYPE_SINT16:
+		  *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+		  break;
+
+		case FFI_TYPE_UINT16:
+		  *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+		  break;
+
+		case FFI_TYPE_STRUCT:
+	  	  z = (*p_arg)->size;
+	  	  if ((*p_arg)->alignment != 1)
+		    memcpy (argp, *p_argv, z);
+		  else
+		    memcpy (argp + 4 - z, *p_argv, z);
+	  	  z = sizeof (int);
+		  break;
+
+		default:
+		  FFI_ASSERT(0);
+		}
+	    }
+	  else if (z == sizeof (int))
+	    {
+	       *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	    }
+	  else
+	    {
+	      if ((*p_arg)->type == FFI_TYPE_STRUCT)
+	        {
+		  if (z > 8)
+		    {
+		      *(unsigned int *) argp = (unsigned int)(void *)(* p_argv);
+		      z = sizeof(void *);
+		    }
+		  else
+		    {
+	              memcpy(argp, *p_argv, z);
+		      z = 8;
+		    }
+	        }
+	      else
+	        {
+		  /* Double or long long 64bit.  */
+	          memcpy (argp, *p_argv, z);
+	        }
+	    }
+	  p_argv++;
+	  argp += z;
+	}
+    }
+
+  return;
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Set the return type flag.  */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      if (cif->rtype->size <= 4)
+	cif->flags = FFI_TYPE_INT;
+
+      else if (cif->rtype->size <= 8)
+	cif->flags = FFI_TYPE_DOUBLE;
+
+      else
+	cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_DOUBLE:
+      cif->flags = FFI_TYPE_DOUBLE;
+      break;
+
+    case FFI_TYPE_FLOAT:
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)(void));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+  ffi_type **arg_types = cif->arg_types;
+  int i, nargs = cif->nargs;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have
+     a return value address then we need to make one.  */
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca (cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT && size > 4)
+        {
+          char *argcopy = alloca (size);
+          memcpy (argcopy, avalue[i], size);
+          avalue[i] = argcopy;
+        }
+    }
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes,
+		    cif->flags, ecif.rvalue, fn);
+      if (cif->rtype->type == FFI_TYPE_STRUCT)
+	{
+	  int size = cif->rtype->size;
+	  int align = cif->rtype->alignment;
+
+	  if (size < 4)
+	    {
+	      if (align == 1)
+	        *(unsigned long *)(ecif.rvalue) <<= (4 - size) * 8;
+	    }
+	  else if (4 < size && size < 8)
+	    {
+	      if (align == 1)
+		{
+		  memcpy (ecif.rvalue, ecif.rvalue + 8-size, size);
+		}
+	      else if (align == 2)
+		{
+		  if (size & 1)
+		    size += 1;
+
+		  if (size != 8)
+		    memcpy (ecif.rvalue, ecif.rvalue + 8-size, size);
+		}
+	    }
+	}
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
Index: libffi-3.4.6/src/m32r/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m32r/sysv.S b/libffi-3.4.6/src/m32r/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m32r/sysv.S	
@@ -0,0 +1,121 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2004 Renesas Technology
+   
+   M32R Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+/* XXX these lose for some platforms, I'm sure.  */
+#define CNAME(x) x
+#define ENTRY(x) .globl CNAME(x)! .type CNAME(x),%function! CNAME(x):
+#endif
+
+.text
+
+	/* R0:   ffi_prep_args */
+	/* R1:   &ecif */
+	/* R2:   cif->bytes */
+	/* R3:   fig->flags */
+	/* sp+0: ecif.rvalue */
+	/* sp+4: fn */
+
+	/* This assumes we are using gas.  */
+ENTRY(ffi_call_SYSV)
+	/* Save registers.  */
+	push	fp
+	push	lr
+	push	r3
+	push	r2
+	push	r1
+	push	r0
+	mv	fp, sp
+
+	/* Make room for all of the new args.  */
+	sub	sp, r2
+
+	/* Place all of the ffi_prep_args in position.  */
+	mv	lr, r0	
+	mv	r0, sp
+	/* R1 already set.  */
+
+	/* And call.  */
+	jl	lr
+
+	/* Move first 4 parameters in registers...  */
+	ld	r0, @(0,sp)
+	ld	r1, @(4,sp)
+	ld	r2, @(8,sp)
+        ld	r3, @(12,sp)
+
+	/* ...and adjust the stack.  */
+	ld	lr, @(8,fp)
+        cmpi	lr, #16
+	bc	adjust_stack
+	ldi	lr, #16
+adjust_stack:
+        add	sp, lr
+
+	/* Call the function.  */
+	ld	lr, @(28,fp)
+	jl	lr	
+
+	/* Remove the space we pushed for the args.  */
+	mv	sp, fp	
+
+	/* Load R2 with the pointer to storage for the return value.  */
+	ld	r2, @(24,sp)
+
+	/* Load R3 with the return type code.  */
+	ld	r3, @(12,sp)
+
+	/* If the return value pointer is NULL, assume no return value.  */
+	beqz	r2, epilogue
+
+	/* Return INT.  */
+	ldi	r4, #FFI_TYPE_INT
+	bne	r3, r4, return_double
+	st	r0, @r2	
+	bra	epilogue
+
+return_double:
+	/* Return DOUBLE or LONGDOUBLE.  */
+	ldi	r4, #FFI_TYPE_DOUBLE
+	bne	r3, r4, epilogue
+	st	r0, @r2	
+	st	r1, @(4,r2)
+
+epilogue:
+	pop	r0
+	pop	r1
+	pop	r2
+	pop	r3
+	pop	lr
+	pop	fp
+        jmp lr
+
+.ffi_call_SYSV_end:
+        .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
Index: libffi-3.4.6/src/m32r/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m32r/ffitarget.h b/libffi-3.4.6/src/m32r/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m32r/ffitarget.h	
@@ -0,0 +1,53 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 2004  Renesas Technology.
+   Target configuration macros for M32R.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi
+  {
+    FFI_FIRST_ABI = 0,
+    FFI_SYSV,
+    FFI_LAST_ABI,
+    FFI_DEFAULT_ABI = FFI_SYSV
+  } ffi_abi;
+#endif
+
+#define FFI_CLOSURES 		0
+#define FFI_TRAMPOLINE_SIZE	24
+#define FFI_NATIVE_RAW_API 	0
+
+#endif
Index: libffi-3.4.6/src/m68k/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m68k/ffi.c b/libffi-3.4.6/src/m68k/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m68k/ffi.c	
@@ -0,0 +1,362 @@
+/* -----------------------------------------------------------------------
+   ffi.c
+
+   m68k Foreign Function Interface
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+#ifdef __rtems__
+void rtems_cache_flush_multiple_data_lines( const void *, size_t );
+#else
+#include <sys/syscall.h>
+#ifdef __MINT__
+#include <mint/mintbind.h>
+#include <mint/ssystem.h>
+#else
+#include <asm/cachectl.h>
+#endif
+#endif
+
+void ffi_call_SYSV (extended_cif *,
+		    unsigned, unsigned,
+		    void *, void (*fn) ());
+void *ffi_prep_args (void *stack, extended_cif *ecif);
+void ffi_closure_SYSV (ffi_closure *);
+void ffi_closure_struct_SYSV (ffi_closure *);
+unsigned int ffi_closure_SYSV_inner (ffi_closure *closure,
+				     void *resp, void *args);
+
+/* ffi_prep_args is called by the assembly routine once stack space has
+   been allocated for the function's arguments.  */
+
+void *
+ffi_prep_args (void *stack, extended_cif *ecif)
+{
+  unsigned int i;
+  void **p_argv;
+  char *argp;
+  ffi_type **p_arg;
+  void *struct_value_ptr;
+
+  argp = stack;
+
+  if (
+#ifdef __MINT__
+      (ecif->cif->rtype->type == FFI_TYPE_LONGDOUBLE) ||
+#endif
+      (((ecif->cif->rtype->type == FFI_TYPE_STRUCT)
+        && !ecif->cif->flags)))
+    struct_value_ptr = ecif->rvalue;
+  else
+    struct_value_ptr = NULL;
+
+  p_argv = ecif->avalue;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       i != 0;
+       i--, p_arg++)
+    {
+      size_t z = (*p_arg)->size;
+      int type = (*p_arg)->type;
+
+      if (z < sizeof (int))
+	{
+	  switch (type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;
+	      break;
+
+	    case FFI_TYPE_STRUCT:
+#ifdef __MINT__
+	      if (z == 1 || z == 2)
+		memcpy (argp + 2, *p_argv, z);
+              else
+		memcpy (argp, *p_argv, z);
+#else
+	      memcpy (argp + sizeof (int) - z, *p_argv, z);
+#endif
+	      break;
+
+	    default:
+	      FFI_ASSERT (0);
+	    }
+	  z = sizeof (int);
+	}
+      else
+	{
+	  memcpy (argp, *p_argv, z);
+
+	  /* Align if necessary.  */
+	  if ((sizeof(int) - 1) & z)
+	    z = FFI_ALIGN(z, sizeof(int));
+	}
+
+      p_argv++;
+      argp += z;
+    }
+
+  return struct_value_ptr;
+}
+
+#define CIF_FLAGS_INT		1
+#define CIF_FLAGS_DINT		2
+#define CIF_FLAGS_FLOAT		4
+#define CIF_FLAGS_DOUBLE	8
+#define CIF_FLAGS_LDOUBLE	16
+#define CIF_FLAGS_POINTER	32
+#define CIF_FLAGS_STRUCT1	64
+#define CIF_FLAGS_STRUCT2	128
+#define CIF_FLAGS_SINT8		256
+#define CIF_FLAGS_SINT16	512
+
+/* Perform machine dependent cif processing */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      cif->flags = 0;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      if (cif->rtype->elements[0]->type == FFI_TYPE_STRUCT &&
+          cif->rtype->elements[1])
+        {
+          cif->flags = 0;
+          break;
+        }
+
+      switch (cif->rtype->size)
+	{
+	case 1:
+#ifdef __MINT__
+	  cif->flags = CIF_FLAGS_STRUCT2;
+#else
+	  cif->flags = CIF_FLAGS_STRUCT1;
+#endif
+	  break;
+	case 2:
+	  cif->flags = CIF_FLAGS_STRUCT2;
+	  break;
+#ifdef __MINT__
+	case 3:
+#endif
+	case 4:
+	  cif->flags = CIF_FLAGS_INT;
+	  break;
+#ifdef __MINT__
+	case 7:
+#endif
+	case 8:
+	  cif->flags = CIF_FLAGS_DINT;
+	  break;
+	default:
+	  cif->flags = 0;
+	  break;
+	}
+      break;
+
+    case FFI_TYPE_FLOAT:
+      cif->flags = CIF_FLAGS_FLOAT;
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      cif->flags = CIF_FLAGS_DOUBLE;
+      break;
+
+#if (FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE)
+    case FFI_TYPE_LONGDOUBLE:
+#ifdef __MINT__
+      cif->flags = 0;
+#else
+      cif->flags = CIF_FLAGS_LDOUBLE;
+#endif
+      break;
+#endif
+
+    case FFI_TYPE_POINTER:
+      cif->flags = CIF_FLAGS_POINTER;
+      break;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags = CIF_FLAGS_DINT;
+      break;
+
+    case FFI_TYPE_SINT16:
+      cif->flags = CIF_FLAGS_SINT16;
+      break;
+
+    case FFI_TYPE_SINT8:
+      cif->flags = CIF_FLAGS_SINT8;
+      break;
+
+    default:
+      cif->flags = CIF_FLAGS_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return value
+     address then we need to make one.  */
+
+  if (rvalue == NULL
+      && cif->rtype->type == FFI_TYPE_STRUCT
+      && cif->rtype->size > 8)
+    ecif.rvalue = alloca (cif->rtype->size);
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV (&ecif, cif->bytes, cif->flags,
+		     ecif.rvalue, fn);
+      break;
+
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+static void
+ffi_prep_incoming_args_SYSV (char *stack, void **avalue, ffi_cif *cif)
+{
+  unsigned int i;
+  void **p_argv;
+  char *argp;
+  ffi_type **p_arg;
+
+  argp = stack;
+  p_argv = avalue;
+
+  for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+#ifdef __MINT__
+      if (cif->flags &&
+          cif->rtype->type == FFI_TYPE_STRUCT &&
+          (z == 1 || z == 2))
+ 	{
+	  *p_argv = (void *) (argp + 2);
+
+	  z = 4;
+	}
+      else
+      if (cif->flags &&
+          cif->rtype->type == FFI_TYPE_STRUCT &&
+          (z == 3 || z == 4))
+ 	{
+	  *p_argv = (void *) (argp);
+
+	  z = 4;
+	}
+      else
+#endif
+      if (z <= 4)
+	{
+	  *p_argv = (void *) (argp + 4 - z);
+
+	  z = 4;
+	}
+      else
+	{
+	  *p_argv = (void *) argp;
+
+	  /* Align if necessary */
+	  if ((sizeof(int) - 1) & z)
+	    z = FFI_ALIGN(z, sizeof(int));
+	}
+
+      p_argv++;
+      argp += z;
+    }
+}
+
+unsigned int
+ffi_closure_SYSV_inner (ffi_closure *closure, void *resp, void *args)
+{
+  ffi_cif *cif;
+  void **arg_area;
+
+  cif = closure->cif;
+  arg_area = (void**) alloca (cif->nargs * sizeof (void *));
+
+  ffi_prep_incoming_args_SYSV(args, arg_area, cif);
+
+  (closure->fun) (cif, resp, arg_area, closure->user_data);
+
+  return cif->flags;
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  *(unsigned short *)closure->tramp = 0x207c;
+  *(void **)(closure->tramp + 2) = codeloc;
+  *(unsigned short *)(closure->tramp + 6) = 0x4ef9;
+
+  if (
+#ifdef __MINT__
+      (cif->rtype->type == FFI_TYPE_LONGDOUBLE) ||
+#endif
+      (((cif->rtype->type == FFI_TYPE_STRUCT)
+         && !cif->flags)))
+    *(void **)(closure->tramp + 8) = ffi_closure_struct_SYSV;
+  else
+    *(void **)(closure->tramp + 8) = ffi_closure_SYSV;
+
+#ifdef __rtems__
+  rtems_cache_flush_multiple_data_lines( codeloc, FFI_TRAMPOLINE_SIZE );
+#elif defined(__MINT__)
+  Ssystem(S_FLUSHCACHE, codeloc, FFI_TRAMPOLINE_SIZE);
+#else
+  syscall(SYS_cacheflush, codeloc, FLUSH_SCOPE_LINE,
+	  FLUSH_CACHE_BOTH, FFI_TRAMPOLINE_SIZE);
+#endif
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/m68k/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m68k/sysv.S b/libffi-3.4.6/src/m68k/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m68k/sysv.S	
@@ -0,0 +1,357 @@
+/* -----------------------------------------------------------------------
+	
+   sysv.S - Copyright (c) 2012 Alan Hourihane
+	    Copyright (c) 1998, 2012 Andreas Schwab
+	    Copyright (c) 2008 Red Hat, Inc.
+	    Copyright (c) 2012, 2016 Thorsten Glaser
+
+   m68k Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+#ifdef HAVE_AS_CFI_PSEUDO_OP
+#define CFI_STARTPROC()		.cfi_startproc
+#define CFI_OFFSET(reg,off)	.cfi_offset	reg,off
+#define CFI_DEF_CFA(reg,off)	.cfi_def_cfa	reg,off
+#define CFI_ENDPROC()		.cfi_endproc
+#else
+#define CFI_STARTPROC()
+#define CFI_OFFSET(reg,off)
+#define CFI_DEF_CFA(reg,off)
+#define CFI_ENDPROC()
+#endif
+
+#ifdef __MINT__
+#define CALLFUNC(funcname) _ ## funcname
+#else
+#define CALLFUNC(funcname) funcname
+#endif
+
+	.text
+
+	.globl	CALLFUNC(ffi_call_SYSV)
+	.type	CALLFUNC(ffi_call_SYSV),@function
+	.align	4
+
+CALLFUNC(ffi_call_SYSV):
+	CFI_STARTPROC()
+	link	%fp,#0
+	CFI_OFFSET(14,-8)
+	CFI_DEF_CFA(14,8)
+	move.l	%d2,-(%sp)
+	CFI_OFFSET(2,-12)
+
+	| Make room for all of the new args.
+	sub.l	12(%fp),%sp
+
+	| Call ffi_prep_args
+	move.l	8(%fp),-(%sp)
+	pea	4(%sp)
+#if !defined __PIC__
+	jsr	CALLFUNC(ffi_prep_args)
+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)
+	move.l  _current_shared_library_a5_offset_(%a5),%a0
+	move.l  CALLFUNC(ffi_prep_args@GOT)(%a0),%a0
+	jsr     (%a0)
+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)
+	move.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0
+	lea     (-6,%pc,%a0),%a0
+	move.l  CALLFUNC(ffi_prep_args@GOT)(%a0),%a0
+	jsr     (%a0)
+#else
+	bsr.l	CALLFUNC(ffi_prep_args@PLTPC)
+#endif
+	addq.l	#8,%sp	
+
+	| Pass pointer to struct value, if any
+#ifdef __MINT__
+	move.l	%d0,%a1
+#else
+	move.l	%a0,%a1
+#endif
+
+	| Call the function
+	move.l	24(%fp),%a0
+	jsr	(%a0)
+
+	| Remove the space we pushed for the args
+	add.l	12(%fp),%sp
+
+	| Load the pointer to storage for the return value
+	move.l	20(%fp),%a1
+
+	| Load the return type code 
+	move.l	16(%fp),%d2
+
+	| If the return value pointer is NULL, assume no return value.
+	| NOTE: On the mc68000, tst on an address register is not supported.
+#if !defined(__mc68020__) && !defined(__mc68030__) && !defined(__mc68040__) && !defined(__mc68060__) && !defined(__mcoldfire__)
+	cmp.w	#0, %a1
+#else
+	tst.l	%a1
+#endif
+	jbeq	noretval
+
+	btst	#0,%d2
+	jbeq	retlongint
+	move.l	%d0,(%a1)
+	jbra	epilogue
+
+retlongint:
+	btst	#1,%d2
+	jbeq	retfloat
+	move.l	%d0,(%a1)
+	move.l	%d1,4(%a1)
+	jbra	epilogue
+
+retfloat:
+	btst	#2,%d2
+	jbeq	retdouble
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.s	%fp0,(%a1)
+#else
+	move.l	%d0,(%a1)
+#endif
+	jbra	epilogue
+
+retdouble:
+	btst	#3,%d2
+	jbeq	retlongdouble
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.d	%fp0,(%a1)
+#else
+	move.l	%d0,(%a1)+
+	move.l	%d1,(%a1)
+#endif
+	jbra	epilogue
+
+retlongdouble:
+	btst	#4,%d2
+	jbeq	retpointer
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.x	%fp0,(%a1)
+#else
+	move.l	%d0,(%a1)+
+	move.l	%d1,(%a1)+
+	move.l	%d2,(%a1)
+#endif
+	jbra	epilogue
+
+retpointer:
+	btst	#5,%d2
+	jbeq	retstruct1
+#ifdef __MINT__
+	move.l	%d0,(%a1)
+#else
+	move.l	%a0,(%a1)
+#endif
+	jbra	epilogue
+
+retstruct1:
+	btst	#6,%d2
+	jbeq	retstruct2
+	move.b	%d0,(%a1)
+	jbra	epilogue
+
+retstruct2:
+	btst	#7,%d2
+	jbeq	retsint8
+	move.w	%d0,(%a1)
+	jbra	epilogue
+
+retsint8:
+	btst	#8,%d2
+	jbeq	retsint16
+	| NOTE: On the mc68000, extb is not supported. 8->16, then 16->32.
+#if !defined(__mc68020__) && !defined(__mc68030__) && !defined(__mc68040__) && !defined(__mc68060__) && !defined(__mcoldfire__)
+	ext.w	%d0
+	ext.l	%d0
+#else
+	extb.l	%d0
+#endif
+	move.l	%d0,(%a1)
+	jbra	epilogue
+
+retsint16:
+	btst	#9,%d2
+	jbeq	noretval
+	ext.l	%d0
+	move.l	%d0,(%a1)
+
+noretval:
+epilogue:
+	move.l	(%sp)+,%d2
+	unlk	%fp
+	rts
+	CFI_ENDPROC()
+	.size	CALLFUNC(ffi_call_SYSV),.-CALLFUNC(ffi_call_SYSV)
+
+	.globl	CALLFUNC(ffi_closure_SYSV)
+	.type	CALLFUNC(ffi_closure_SYSV), @function
+	.align	4
+
+CALLFUNC(ffi_closure_SYSV):
+	CFI_STARTPROC()
+	link	%fp,#-12
+	CFI_OFFSET(14,-8)
+	CFI_DEF_CFA(14,8)
+	move.l	%sp,-12(%fp)
+	pea	8(%fp)
+	pea	-12(%fp)
+	move.l	%a0,-(%sp)
+#if !defined __PIC__
+	jsr	CALLFUNC(ffi_closure_SYSV_inner)
+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)
+	move.l  _current_shared_library_a5_offset_(%a5),%a0
+	move.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0
+	jsr     (%a0)
+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)
+	move.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0
+	lea     (-6,%pc,%a0),%a0
+	move.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0
+	jsr     (%a0)
+#else
+	bsr.l	CALLFUNC(ffi_closure_SYSV_inner@PLTPC)
+#endif
+
+	lsr.l	#1,%d0
+	jne	1f
+	jcc	.Lcls_epilogue
+	| CIF_FLAGS_INT
+	move.l	-12(%fp),%d0
+.Lcls_epilogue:
+	| no CIF_FLAGS_*
+	unlk	%fp
+	rts
+1:
+	lea	-12(%fp),%a0
+	lsr.l	#2,%d0
+	jne	1f
+	jcs	.Lcls_ret_float
+	| CIF_FLAGS_DINT
+	move.l	(%a0)+,%d0
+	move.l	(%a0),%d1
+	jra	.Lcls_epilogue
+.Lcls_ret_float:
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.s	(%a0),%fp0
+#else
+	move.l	(%a0),%d0
+#endif
+	jra	.Lcls_epilogue
+1:
+	lsr.l	#2,%d0
+	jne	1f
+	jcs	.Lcls_ret_ldouble
+	| CIF_FLAGS_DOUBLE
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.d	(%a0),%fp0
+#else
+	move.l	(%a0)+,%d0
+	move.l	(%a0),%d1
+#endif
+	jra	.Lcls_epilogue
+.Lcls_ret_ldouble:
+#if defined(__MC68881__) || defined(__HAVE_68881__)
+	fmove.x	(%a0),%fp0
+#else
+	move.l	(%a0)+,%d0
+	move.l	(%a0)+,%d1
+	move.l	(%a0),%d2
+#endif
+	jra	.Lcls_epilogue
+1:
+	lsr.l	#2,%d0
+	jne	1f
+	jcs	.Lcls_ret_struct1
+	| CIF_FLAGS_POINTER
+	move.l	(%a0),%a0
+	move.l	%a0,%d0
+	jra	.Lcls_epilogue
+.Lcls_ret_struct1:
+	move.b	(%a0),%d0
+	jra	.Lcls_epilogue
+1:
+	lsr.l	#2,%d0
+	jne	1f
+	jcs	.Lcls_ret_sint8
+	| CIF_FLAGS_STRUCT2
+	move.w	(%a0),%d0
+	jra	.Lcls_epilogue
+.Lcls_ret_sint8:
+	move.l	(%a0),%d0
+	| NOTE: On the mc68000, extb is not supported. 8->16, then 16->32.
+#if !defined(__mc68020__) && !defined(__mc68030__) && !defined(__mc68040__) && !defined(__mc68060__) && !defined(__mcoldfire__)
+	ext.w	%d0
+	ext.l	%d0
+#else
+	extb.l	%d0
+#endif
+	jra	.Lcls_epilogue
+1:
+	| CIF_FLAGS_SINT16
+	move.l	(%a0),%d0
+	ext.l	%d0
+	jra	.Lcls_epilogue
+	CFI_ENDPROC()
+
+	.size	CALLFUNC(ffi_closure_SYSV),.-CALLFUNC(ffi_closure_SYSV)
+
+	.globl	CALLFUNC(ffi_closure_struct_SYSV)
+	.type	CALLFUNC(ffi_closure_struct_SYSV), @function
+	.align	4
+
+CALLFUNC(ffi_closure_struct_SYSV):
+	CFI_STARTPROC()
+	link	%fp,#0
+	CFI_OFFSET(14,-8)
+	CFI_DEF_CFA(14,8)
+	move.l	%sp,-12(%fp)
+	pea	8(%fp)
+	move.l	%a1,-(%sp)
+	move.l	%a0,-(%sp)
+#if !defined __PIC__
+	jsr	CALLFUNC(ffi_closure_SYSV_inner)
+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)
+	move.l  _current_shared_library_a5_offset_(%a5),%a0
+	move.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0
+	jsr     (%a0)
+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)
+	move.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0
+	lea     (-6,%pc,%a0),%a0
+	move.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0
+	jsr     (%a0)
+#else
+	bsr.l	CALLFUNC(ffi_closure_SYSV_inner@PLTPC)
+#endif
+	unlk	%fp
+	rts
+	CFI_ENDPROC()
+	.size	CALLFUNC(ffi_closure_struct_SYSV),.-CALLFUNC(ffi_closure_struct_SYSV)
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/m68k/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m68k/ffitarget.h b/libffi-3.4.6/src/m68k/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m68k/ffitarget.h	
@@ -0,0 +1,54 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for Motorola 68K.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 16
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
Index: libffi-3.4.6/src/m88k/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m88k/ffi.c b/libffi-3.4.6/src/m88k/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m88k/ffi.c	
@@ -0,0 +1,400 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * m88k Foreign Function Interface
+ *
+ * This file attempts to provide all the FFI entry points which can reliably
+ * be implemented in C.
+ *
+ * Only OpenBSD/m88k is currently supported; other platforms (such as
+ * Motorola's SysV/m88k) could be supported with the following tweaks:
+ *
+ * - non-OpenBSD systems use an `outgoing parameter area' as part of the
+ *   88BCS calling convention, which is not supported under OpenBSD from
+ *   release 3.6 onwards.  Supporting it should be as easy as taking it
+ *   into account when adjusting the stack, in the assembly code.
+ *
+ * - the logic deciding whether a function argument gets passed through
+ *   registers, or on the stack, has changed several times in OpenBSD in
+ *   edge cases (especially for structs larger than 32 bytes being passed
+ *   by value). The code below attemps to match the logic used by the
+ *   system compiler of OpenBSD 5.3, i.e. gcc 3.3.6 with many m88k backend
+ *   fixes.
+ */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+
+void ffi_call_OBSD (unsigned int, extended_cif *, unsigned int, void *,
+		    void (*fn) ());
+void *ffi_prep_args (void *, extended_cif *);
+void ffi_closure_OBSD (ffi_closure *);
+void ffi_closure_struct_OBSD (ffi_closure *);
+unsigned int ffi_closure_OBSD_inner (ffi_closure *, void *, unsigned int *,
+				     char *);
+void ffi_cacheflush_OBSD (unsigned int, unsigned int);
+
+#define CIF_FLAGS_INT		(1 << 0)
+#define CIF_FLAGS_DINT		(1 << 1)
+
+/*
+ * Foreign Function Interface API
+ */
+
+/* ffi_prep_args is called by the assembly routine once stack space has
+   been allocated for the function's arguments.  */
+
+void *
+ffi_prep_args (void *stack, extended_cif *ecif)
+{
+  unsigned int i;
+  void **p_argv;
+  char *argp, *stackp;
+  unsigned int *regp;
+  unsigned int regused;
+  ffi_type **p_arg;
+  void *struct_value_ptr;
+
+  regp = (unsigned int *)stack;
+  stackp = (char *)(regp + 8);
+  regused = 0;
+
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT
+      && !ecif->cif->flags)
+    struct_value_ptr = ecif->rvalue;
+  else
+    struct_value_ptr = NULL;
+
+  p_argv = ecif->avalue;
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i != 0; i--, p_arg++)
+    {
+      size_t z;
+      unsigned short t, a;
+
+      z = (*p_arg)->size;
+      t = (*p_arg)->type;
+      a = (*p_arg)->alignment;
+
+      /*
+       * Figure out whether the argument can be passed through registers
+       * or on the stack.
+       * The rule is that registers can only receive simple types not larger
+       * than 64 bits, or structs the exact size of a register and aligned to
+       * the size of a register.
+       */
+      if (t == FFI_TYPE_STRUCT)
+	{
+	  if (z == sizeof (int) && a == sizeof (int) && regused < 8)
+	    argp = (char *)regp;
+	  else
+	    argp = stackp;
+	}
+      else
+	{
+	  if (z > sizeof (int) && regused < 8 - 1)
+	    {
+	      /* align to an even register pair */
+	      if (regused & 1)
+		{
+		  regp++;
+		  regused++;
+		}
+	    }
+	  if (regused < 8)
+	    argp = (char *)regp;
+	  else
+	    argp = stackp;
+	}
+
+      /* Enforce proper stack alignment of 64-bit types */
+      if (argp == stackp && a > sizeof (int))
+	{
+	  stackp = (char *) FFI_ALIGN(stackp, a);
+	  argp = stackp;
+	}
+
+      switch (t)
+	{
+	case FFI_TYPE_SINT8:
+	  *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;
+	  break;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  *(unsigned int *) argp = *(unsigned int *) *p_argv;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_STRUCT:
+	  memcpy (argp, *p_argv, z);
+	  break;
+
+	default:
+	  FFI_ASSERT (0);
+	}
+
+      /* Align if necessary.  */
+      if ((sizeof (int) - 1) & z)
+	z = FFI_ALIGN(z, sizeof (int));
+
+      p_argv++;
+
+      /* Be careful, once all registers are filled, and about to continue
+         on stack, regp == stackp.  Therefore the check for regused as well. */
+      if (argp == (char *)regp && regused < 8)
+	{
+	  regp += z / sizeof (int);
+	  regused += z / sizeof (int);
+	}
+      else
+	stackp += z;
+    }
+
+  return struct_value_ptr;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      cif->flags = 0;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      if (cif->rtype->size == sizeof (int) &&
+	  cif->rtype->alignment == sizeof (int))
+	cif->flags = CIF_FLAGS_INT;
+      else
+	cif->flags = 0;
+      break;
+
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags = CIF_FLAGS_DINT;
+      break;
+
+    default:
+      cif->flags = CIF_FLAGS_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return value
+     address then we need to make one.  */
+
+  if (rvalue == NULL
+      && cif->rtype->type == FFI_TYPE_STRUCT
+      && (cif->rtype->size != sizeof (int)
+	  || cif->rtype->alignment != sizeof (int)))
+    ecif.rvalue = alloca (cif->rtype->size);
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_OBSD:
+      ffi_call_OBSD (cif->bytes, &ecif, cif->flags, ecif.rvalue, fn);
+      break;
+
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+/*
+ * Closure API
+ */
+
+static void
+ffi_prep_closure_args_OBSD (ffi_cif *cif, void **avalue, unsigned int *regp,
+			    char *stackp)
+{
+  unsigned int i;
+  void **p_argv;
+  char *argp;
+  unsigned int regused;
+  ffi_type **p_arg;
+
+  regused = 0;
+
+  p_argv = avalue;
+
+  for (i = cif->nargs, p_arg = cif->arg_types; i != 0; i--, p_arg++)
+    {
+      size_t z;
+      unsigned short t, a;
+
+      z = (*p_arg)->size;
+      t = (*p_arg)->type;
+      a = (*p_arg)->alignment;
+
+      /*
+       * Figure out whether the argument has been passed through registers
+       * or on the stack.
+       * The rule is that registers can only receive simple types not larger
+       * than 64 bits, or structs the exact size of a register and aligned to
+       * the size of a register.
+       */
+      if (t == FFI_TYPE_STRUCT)
+	{
+	  if (z == sizeof (int) && a == sizeof (int) && regused < 8)
+	    argp = (char *)regp;
+	  else
+	    argp = stackp;
+	}
+      else
+	{
+	  if (z > sizeof (int) && regused < 8 - 1)
+	    {
+	      /* align to an even register pair */
+	      if (regused & 1)
+		{
+		  regp++;
+		  regused++;
+		}
+	    }
+	  if (regused < 8)
+	    argp = (char *)regp;
+	  else
+	    argp = stackp;
+	}
+
+      /* Enforce proper stack alignment of 64-bit types */
+      if (argp == stackp && a > sizeof (int))
+	{
+	  stackp = (char *) FFI_ALIGN(stackp, a);
+	  argp = stackp;
+	}
+
+      if (z < sizeof (int) && t != FFI_TYPE_STRUCT)
+	*p_argv = (void *) (argp + sizeof (int) - z);
+      else
+	*p_argv = (void *) argp;
+
+      /* Align if necessary */
+      if ((sizeof (int) - 1) & z)
+	z = FFI_ALIGN(z, sizeof (int));
+
+      p_argv++;
+
+      /* Be careful, once all registers are exhausted, and about to fetch from
+	 stack, regp == stackp.  Therefore the check for regused as well. */
+      if (argp == (char *)regp && regused < 8)
+	{
+	  regp += z / sizeof (int);
+	  regused += z / sizeof (int);
+	}
+      else
+	stackp += z;
+    }
+}
+
+unsigned int
+ffi_closure_OBSD_inner (ffi_closure *closure, void *resp, unsigned int *regp,
+			char *stackp)
+{
+  ffi_cif *cif;
+  void **arg_area;
+
+  cif = closure->cif;
+  arg_area = (void**) alloca (cif->nargs * sizeof (void *));
+
+  ffi_prep_closure_args_OBSD(cif, arg_area, regp, stackp);
+
+  (closure->fun) (cif, resp, arg_area, closure->user_data);
+
+  return cif->flags;
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure, ffi_cif* cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data, void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) codeloc;
+  void *fn;
+
+  FFI_ASSERT (cif->abi == FFI_OBSD);
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT && !cif->flags)
+    fn = &ffi_closure_struct_OBSD;
+  else
+    fn = &ffi_closure_OBSD;
+
+  /* or.u %r10, %r0, %hi16(fn) */
+  tramp[0] = 0x5d400000 | (((unsigned int)fn) >> 16);
+  /* or.u %r13, %r0, %hi16(closure) */
+  tramp[1] = 0x5da00000 | ((unsigned int)closure >> 16);
+  /* or %r10, %r10, %lo16(fn) */
+  tramp[2] = 0x594a0000 | (((unsigned int)fn) & 0xffff);
+  /* jmp.n %r10 */
+  tramp[3] = 0xf400c40a;
+  /* or %r13, %r13, %lo16(closure) */
+  tramp[4] = 0x59ad0000 | ((unsigned int)closure & 0xffff);
+
+  ffi_cacheflush_OBSD((unsigned int)codeloc, FFI_TRAMPOLINE_SIZE);
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/m88k/obsd.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m88k/obsd.S b/libffi-3.4.6/src/m88k/obsd.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m88k/obsd.S	
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * m88k Foreign Function Interface
+ */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.text
+
+/*
+ * ffi_cacheflush_OBSD(unsigned int addr,	%r2
+ *		       unsigned int size);	%r3
+ */
+	.align	4
+	.globl	ffi_cacheflush_OBSD
+	.type	ffi_cacheflush_OBSD,@function
+ffi_cacheflush_OBSD:
+	tb0	0,   %r0, 451
+	or	%r0, %r0, %r0
+	jmp	%r1
+	.size	ffi_cacheflush_OBSD, . - ffi_cacheflush_OBSD
+
+/*
+ * ffi_call_OBSD(unsigned bytes,		%r2
+ *		 extended_cif *ecif,		%r3
+ *		 unsigned flags,		%r4
+ *		 void *rvalue,			%r5
+ *		 void (*fn)());			%r6
+ */
+	.align	4
+	.globl	ffi_call_OBSD
+	.type	ffi_call_OBSD,@function
+ffi_call_OBSD:
+	subu	%r31, %r31, 32
+	st	%r30, %r31, 4
+	st	%r1,  %r31, 0
+	addu	%r30, %r31, 32
+
+	| Save the few arguments we'll need after ffi_prep_args()
+	st.d	%r4, %r31, 8
+	st	%r6, %r31, 16
+
+	| Allocate room for the image of r2-r9, and the stack space for
+	| the args (rounded to a 16-byte boundary)
+	addu	%r2,  %r2,  (8 * 4) + 15
+	clr	%r2,  %r2,  4<0>
+	subu	%r31, %r31, %r2
+
+	| Fill register and stack image
+	or	%r2, %r31, %r0
+#ifdef PIC
+	bsr	ffi_prep_args#plt
+#else
+	bsr	ffi_prep_args
+#endif
+
+	| Save pointer to return struct address, if any
+	or	%r12, %r2, %r0
+
+	| Get function pointer
+	subu	%r4,  %r30, 32
+	ld	%r1,  %r4,  16
+
+	| Fetch the register arguments
+	ld.d	%r2, %r31, (0 * 4)
+	ld.d	%r4, %r31, (2 * 4)
+	ld.d	%r6, %r31, (4 * 4)
+	ld.d	%r8, %r31, (6 * 4)
+	addu	%r31, %r31, (8 * 4)
+
+	| Invoke the function
+	jsr	%r1
+
+	| Restore stack now that we don't need the args anymore
+	subu	%r31, %r30, 32
+
+	| Figure out what to return as the function's return value
+	ld	%r5, %r31, 12		| rvalue
+	ld	%r4, %r31, 8		| flags
+
+	bcnd	eq0, %r5, 9f
+
+	bb0	0, %r4, 1f		| CIF_FLAGS_INT
+	st	%r2, %r5, 0
+	br	9f
+
+1:
+	bb0	1, %r4, 1f		| CIF_FLAGS_DINT
+	st.d	%r2, %r5, 0
+	br	9f
+
+1:
+9:
+	ld	%r1,  %r31, 0
+	ld	%r30, %r31, 4
+	jmp.n	%r1
+	 addu	%r31, %r31, 32
+	.size	ffi_call_OBSD, . - ffi_call_OBSD
+
+/*
+ * ffi_closure_OBSD(ffi_closure *closure);	%r13
+ */
+	.align	4
+	.globl	ffi_closure_OBSD
+	.type	ffi_closure_OBSD, @function
+ffi_closure_OBSD:
+	subu	%r31, %r31, 16
+	st	%r30, %r31, 4
+	st	%r1,  %r31, 0
+	addu	%r30, %r31, 16
+
+	| Make room on the stack for saved register arguments and return
+	| value
+	subu	%r31, %r31, (8 * 4) + (2 * 4)
+	st.d	%r2,  %r31, (0 * 4)
+	st.d	%r4,  %r31, (2 * 4)
+	st.d	%r6,  %r31, (4 * 4)
+	st.d	%r8,  %r31, (6 * 4)
+
+	| Invoke the closure function
+	or	%r5,  %r30, 0			| calling stack
+	addu	%r4,  %r31, 0			| saved registers
+	addu	%r3,  %r31, (8 * 4)		| return value
+	or	%r2,  %r13, %r0			| closure
+#ifdef PIC
+	bsr	ffi_closure_OBSD_inner#plt
+#else
+	bsr	ffi_closure_OBSD_inner
+#endif
+
+	| Figure out what to return as the function's return value
+	bb0	0, %r2, 1f		| CIF_FLAGS_INT
+	ld	%r2, %r31, (8 * 4)
+	br	9f
+
+1:
+	bb0	1, %r2, 1f		| CIF_FLAGS_DINT
+	ld.d	%r2, %r31, (8 * 4)
+	br	9f
+
+1:
+9:
+	subu	%r31, %r30, 16
+	ld	%r1,  %r31, 0
+	ld	%r30, %r31, 4
+	jmp.n	%r1
+	 addu	%r31, %r31, 16
+	.size	ffi_closure_OBSD,.-ffi_closure_OBSD
+
+/*
+ * ffi_closure_struct_OBSD(ffi_closure *closure);	%r13
+ */
+	.align	4
+	.globl	ffi_closure_struct_OBSD
+	.type	ffi_closure_struct_OBSD, @function
+ffi_closure_struct_OBSD:
+	subu	%r31, %r31, 16
+	st	%r30, %r31, 4
+	st	%r1,  %r31, 0
+	addu	%r30, %r31, 16
+
+	| Make room on the stack for saved register arguments
+	subu	%r31, %r31, (8 * 4)
+	st.d	%r2,  %r31, (0 * 4)
+	st.d	%r4,  %r31, (2 * 4)
+	st.d	%r6,  %r31, (4 * 4)
+	st.d	%r8,  %r31, (6 * 4)
+
+	| Invoke the closure function
+	or	%r5,  %r30, 0			| calling stack
+	addu	%r4,  %r31, 0			| saved registers
+	or	%r3,  %r12, 0			| return value
+	or	%r2,  %r13, %r0			| closure
+#ifdef PIC
+	bsr	ffi_closure_OBSD_inner#plt
+#else
+	bsr	ffi_closure_OBSD_inner
+#endif
+
+	subu	%r31, %r30, 16
+	ld	%r1,  %r31, 0
+	ld	%r30, %r31, 4
+	jmp.n	%r1
+	 addu	%r31, %r31, 16
+	.size	ffi_closure_struct_OBSD,.-ffi_closure_struct_OBSD
Index: libffi-3.4.6/src/m88k/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/m88k/ffitarget.h b/libffi-3.4.6/src/m88k/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/m88k/ffitarget.h	
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * m88k Foreign Function Interface
+ */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_ASM
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_OBSD,
+  FFI_DEFAULT_ABI = FFI_OBSD,
+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 0x14
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/mips/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/mips/ffi.c b/libffi-3.4.6/src/mips/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/mips/ffi.c	
@@ -0,0 +1,1317 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2011  Anthony Green
+           Copyright (c) 2008  David Daney
+           Copyright (c) 1996, 2007, 2008, 2011  Red Hat, Inc.
+   
+   MIPS Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef __GNUC__
+#  if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))
+#    define USE__BUILTIN___CLEAR_CACHE 1
+#  endif
+#endif
+
+#ifndef USE__BUILTIN___CLEAR_CACHE
+#  if defined(__FreeBSD__)
+#    include <machine/sysarch.h>
+#  elif defined(__OpenBSD__)
+#    include <mips64/sysarch.h>
+#  else
+#    include <sys/cachectl.h>
+#  endif
+#endif
+
+#ifdef FFI_DEBUG
+# define FFI_MIPS_STOP_HERE() ffi_stop_here()
+#else
+# define FFI_MIPS_STOP_HERE() do {} while(0)
+#endif
+
+#ifdef FFI_MIPS_N32
+#define FIX_ARGP \
+FFI_ASSERT(argp <= &stack[bytes]); \
+if (argp == &stack[bytes]) \
+{ \
+  argp = stack; \
+  FFI_MIPS_STOP_HERE(); \
+}
+#else
+#define FIX_ARGP 
+#endif
+
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+static void ffi_prep_args(char *stack, 
+			  extended_cif *ecif,
+			  int bytes,
+			  int flags)
+{
+  int i;
+  void **p_argv;
+  char *argp, *argp_f;
+  ffi_type **p_arg;
+
+  memset(stack, 0, bytes);
+
+#ifdef FFI_MIPS_N32
+  int soft_float = (ecif->cif->abi == FFI_N32_SOFT_FLOAT
+		    || ecif->cif->abi == FFI_N64_SOFT_FLOAT);
+  /* If more than 8 double words are used, the remainder go
+     on the stack. We reorder stuff on the stack here to 
+     support this easily. */
+  /* if ret is _Complex long double, args reg shift2, and a0 should holds pointer to rvalue */
+  if (ecif->cif->rtype->type == FFI_TYPE_COMPLEX && ecif->cif->rtype->elements[0]->type == FFI_TYPE_LONGDOUBLE)
+    {
+      if (bytes + 16 > 8 * sizeof(ffi_arg))
+        argp = &stack[bytes - (8 * sizeof(ffi_arg))];
+      else
+        argp = stack;
+      * (unsigned long *) argp = (unsigned long) ecif->rvalue;
+      argp += 16;
+    }
+  else
+    {
+      if (bytes > 8 * sizeof(ffi_arg))
+        argp = &stack[bytes - (8 * sizeof(ffi_arg))];
+      else
+        argp = stack;
+    }
+#else
+  argp = stack;
+#endif
+
+  argp_f = argp;
+
+#ifdef FFI_MIPS_N32
+  if ( ecif->cif->rstruct_flag != 0 )
+#else
+  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT )
+#endif  
+    {
+      *(ffi_arg *) argp = (ffi_arg) ecif->rvalue;
+      argp += sizeof(ffi_arg);
+      FIX_ARGP;
+    }
+
+  p_argv = ecif->avalue;
+
+  for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs; i++, p_arg++)
+    {
+      size_t z;
+      unsigned int a;
+
+      /* Align if necessary.  */
+      a = (*p_arg)->alignment;
+      if (a < sizeof(ffi_arg))
+        a = sizeof(ffi_arg);
+      
+      if ((a - 1) & (unsigned long) argp)
+	{
+	  argp = (char *) FFI_ALIGN(argp, a);
+	  FIX_ARGP;
+	}
+
+      z = (*p_arg)->size;
+      if (z <= sizeof(ffi_arg))
+	{
+          int type = (*p_arg)->type;
+	  z = sizeof(ffi_arg);
+
+          /* The size of a pointer depends on the ABI */
+          if (type == FFI_TYPE_POINTER)
+            type = (ecif->cif->abi == FFI_N64
+		    || ecif->cif->abi == FFI_N64_SOFT_FLOAT)
+	      ? FFI_TYPE_SINT64 : FFI_TYPE_UINT32;
+
+	if (i < 8 && (ecif->cif->abi == FFI_N32_SOFT_FLOAT
+		      || ecif->cif->abi == FFI_N64_SOFT_FLOAT))
+	  {
+	    switch (type)
+	      {
+	      case FFI_TYPE_FLOAT:
+		type = FFI_TYPE_UINT32;
+		break;
+	      case FFI_TYPE_DOUBLE:
+		type = FFI_TYPE_UINT64;
+		break;
+	      default:
+		break;
+	      }
+	  }
+	  switch (type)
+	    {
+	      case FFI_TYPE_SINT8:
+		*(ffi_arg *)argp = *(SINT8 *)(* p_argv);
+		break;
+
+	      case FFI_TYPE_UINT8:
+		*(ffi_arg *)argp = *(UINT8 *)(* p_argv);
+		break;
+		  
+	      case FFI_TYPE_SINT16:
+		*(ffi_arg *)argp = *(SINT16 *)(* p_argv);
+		break;
+		  
+	      case FFI_TYPE_UINT16:
+		*(ffi_arg *)argp = *(UINT16 *)(* p_argv);
+		break;
+		  
+	      case FFI_TYPE_SINT32:
+		*(ffi_arg *)argp = *(SINT32 *)(* p_argv);
+		break;
+		  
+	      case FFI_TYPE_UINT32:
+#ifdef FFI_MIPS_N32
+		/* The N32 ABI requires that 32-bit integers
+		   be sign-extended to 64-bits, regardless of
+		   whether they are signed or unsigned. */
+		*(ffi_arg *)argp = *(SINT32 *)(* p_argv);
+#else
+		*(ffi_arg *)argp = *(UINT32 *)(* p_argv);
+#endif
+		break;
+
+#ifdef FFI_MIPS_N32
+	      case FFI_TYPE_COMPLEX:
+		/* expand from 4+4 to 8+8 if pass with fpr reg */
+		/* argp will wind back to stack when we process all of reg args */
+		/* all var_args passed with gpr, should be expand */
+	        if(!soft_float
+		    && (*p_arg)->elements[0]->type == FFI_TYPE_FLOAT
+		    && argp>=argp_f
+		    && i < ecif->cif->mips_nfixedargs)
+		  {
+		    *(float *) argp = *(float *)(* p_argv);
+		    argp += z;
+		    char *tmp = (void *) (*p_argv);
+		    *(float *) argp = *(float *)(tmp+4);
+		  }
+		else
+		  memcpy(argp, *p_argv, (*p_arg)->size);
+		break;
+#endif
+	      /* This can only happen with 64bit slots.  */
+	      case FFI_TYPE_FLOAT:
+		*(float *) argp = *(float *)(* p_argv);
+		break;
+
+	      /* Handle structures.  */
+	      default:
+		memcpy(argp, *p_argv, (*p_arg)->size);
+		break;
+	    }
+	}
+      else
+	{
+#ifdef FFI_MIPS_O32
+	  memcpy(argp, *p_argv, z);
+#else
+	  {
+	    unsigned long end = (unsigned long) argp + z;
+	    unsigned long cap = (unsigned long) stack + bytes;
+
+	    /* Check if the data will fit within the register space.
+	       Handle it if it doesn't.  */
+
+	    if (end <= cap)
+	      memcpy(argp, *p_argv, z);
+	    else
+	      {
+		unsigned long portion = cap - (unsigned long)argp;
+
+		memcpy(argp, *p_argv, portion);
+		argp = stack;
+                z -= portion;
+		memcpy(argp, (void*)((unsigned long)(*p_argv) + portion),
+                       z);
+	      }
+	  }
+#endif
+      }
+      p_argv++;
+      argp += z;
+      FIX_ARGP;
+    }
+}
+
+#ifdef FFI_MIPS_N32
+
+/* The n32 spec says that if "a chunk consists solely of a double 
+   float field (but not a double, which is part of a union), it
+   is passed in a floating point register. Any other chunk is
+   passed in an integer register". This code traverses structure
+   definitions and generates the appropriate flags. */
+
+static int
+calc_n32_struct_flags_element(unsigned *flags, ffi_type *e,
+			      unsigned *loc, unsigned *arg_reg)
+{
+  /* Align this object.  */
+  *loc = FFI_ALIGN(*loc, e->alignment);
+  if (e->type == FFI_TYPE_DOUBLE)
+    {
+      /* Already aligned to FFI_SIZEOF_ARG.  */
+      *arg_reg = *loc / FFI_SIZEOF_ARG;
+      if (*arg_reg > 7)
+	return 1;
+      *flags += (FFI_TYPE_DOUBLE << (*arg_reg * FFI_FLAG_BITS));
+    }
+  *loc += e->size;
+  return 0;
+}
+
+static unsigned
+calc_n32_struct_flags(int soft_float, ffi_type *arg,
+		      unsigned *loc, unsigned *arg_reg)
+{
+  unsigned flags = 0;
+  unsigned index = 0;
+
+  ffi_type *e;
+
+  if (soft_float)
+    return 0;
+
+  while ((e = arg->elements[index]))
+    {
+      if (e->type == FFI_TYPE_COMPLEX)
+	{
+	  if (calc_n32_struct_flags_element(&flags, e->elements[0], loc, arg_reg))
+	    break;
+	  if (calc_n32_struct_flags_element(&flags, e->elements[0], loc, arg_reg))
+	    break;
+	}
+      else
+	if (calc_n32_struct_flags_element(&flags, e, loc, arg_reg))
+	  break;
+      index++;
+    }
+  /* Next Argument register at alignment of FFI_SIZEOF_ARG.  */
+  *arg_reg = FFI_ALIGN(*loc, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+
+  return flags;
+}
+
+static unsigned
+calc_n32_return_struct_flags(int soft_float, ffi_type *arg)
+{
+  unsigned flags;
+  unsigned small = FFI_TYPE_SMALLSTRUCT;
+  ffi_type *e;
+
+  /* Returning structures under n32 is a tricky thing.
+     A struct with only one or two floating point fields 
+     is returned in $f0 (and $f2 if necessary). Any other
+     struct results at most 128 bits are returned in $2
+     (the first 64 bits) and $3 (remainder, if necessary).
+     Larger structs are handled normally. */
+  
+  if (arg->size > 16)
+    return 0;
+
+  if (arg->size > 8)
+    small = FFI_TYPE_SMALLSTRUCT2;
+
+  e = arg->elements[0];
+
+  if (e->type == FFI_TYPE_COMPLEX)
+    {
+      int type = e->elements[0]->type;
+
+      if (type != FFI_TYPE_DOUBLE && type != FFI_TYPE_FLOAT)
+	return small;
+
+      if (arg->elements[1])
+	{
+	  /* Two floating point fields with more fields!
+	     This must be passed the old way. */
+	  return small;
+	}
+
+      flags = (type << FFI_FLAG_BITS) + type;
+    }
+  else
+    {
+      if (e->type != FFI_TYPE_DOUBLE && e->type != FFI_TYPE_FLOAT)
+	return small;
+
+      flags = e->type;
+
+      if (arg->elements[1])
+	{
+	  e = arg->elements[1];
+	  if (e->type != FFI_TYPE_DOUBLE && e->type != FFI_TYPE_FLOAT)
+	    return small;
+
+	  if (arg->elements[2])
+	    {
+	      /* There are three arguments and the first two are
+		 floats! This must be passed the old way. */
+	      return small;
+	    }
+
+	  flags += e->type << FFI_FLAG_BITS;
+	}
+    }
+
+  if (soft_float)
+    flags += FFI_TYPE_STRUCT_SOFT;
+  return flags;
+}
+
+#endif
+
+/* Perform machine dependent cif processing */
+static ffi_status ffi_prep_cif_machdep_int(ffi_cif *cif, unsigned nfixedargs)
+{
+  cif->flags = 0;
+  cif->mips_nfixedargs = nfixedargs;
+
+#ifdef FFI_MIPS_O32
+  /* Set the flags necessary for O32 processing.  FFI_O32_SOFT_FLOAT
+   * does not have special handling for floating point args.
+   */
+
+  if (cif->rtype->type != FFI_TYPE_STRUCT && cif->rtype->type != FFI_TYPE_COMPLEX && cif->abi == FFI_O32)
+    {
+      if (cif->nargs > 0 && cif->nargs == nfixedargs)
+	{
+	  switch ((cif->arg_types)[0]->type)
+	    {
+	    case FFI_TYPE_FLOAT:
+	    case FFI_TYPE_DOUBLE:
+	      cif->flags += (cif->arg_types)[0]->type;
+	      break;
+	      
+	    default:
+	      break;
+	    }
+
+	  if (cif->nargs > 1)
+	    {
+	      /* Only handle the second argument if the first
+		 is a float or double. */
+	      if (cif->flags)
+		{
+		  switch ((cif->arg_types)[1]->type)
+		    {
+		    case FFI_TYPE_FLOAT:
+		    case FFI_TYPE_DOUBLE:
+		      cif->flags += (cif->arg_types)[1]->type << FFI_FLAG_BITS;
+		      break;
+		      
+		    default:
+		      break;
+		    }
+		}
+	    }
+	}
+    }
+      
+  /* Set the return type flag */
+
+  if (cif->abi == FFI_O32_SOFT_FLOAT)
+    {
+      switch (cif->rtype->type)
+        {
+        case FFI_TYPE_VOID:
+        case FFI_TYPE_STRUCT:
+          cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);
+          break;
+
+        case FFI_TYPE_SINT64:
+        case FFI_TYPE_UINT64:
+        case FFI_TYPE_DOUBLE:
+          cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);
+          break;
+      
+        case FFI_TYPE_FLOAT:
+        default:
+          cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);
+          break;
+        }
+    }
+  else
+    {
+      /* FFI_O32 */      
+      switch (cif->rtype->type)
+        {
+        case FFI_TYPE_VOID:
+        case FFI_TYPE_STRUCT:
+        case FFI_TYPE_FLOAT:
+        case FFI_TYPE_DOUBLE:
+        case FFI_TYPE_COMPLEX:
+          cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);
+	  if (cif->rtype->type == FFI_TYPE_COMPLEX)
+            cif->flags +=  ((*cif->rtype->elements[0]).type) << (FFI_FLAG_BITS * 4);
+          break;
+
+        case FFI_TYPE_SINT64:
+        case FFI_TYPE_UINT64:
+          cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);
+          break;
+      
+        default:
+          cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);
+          break;
+        }
+    }
+#endif
+
+#ifdef FFI_MIPS_N32
+  /* Set the flags necessary for N32 processing */
+  {
+    unsigned arg_reg = 0;
+    unsigned loc = 0;
+    unsigned count = (cif->nargs < 8) ? cif->nargs : 8;
+    unsigned index = 0;
+
+    unsigned struct_flags = 0;
+    int soft_float = (cif->abi == FFI_N32_SOFT_FLOAT
+		      || cif->abi == FFI_N64_SOFT_FLOAT);
+
+    if (cif->rtype->type == FFI_TYPE_STRUCT)
+      {
+	struct_flags = calc_n32_return_struct_flags(soft_float, cif->rtype);
+
+	if (struct_flags == 0)
+	  {
+	    /* This means that the structure is being passed as
+	       a hidden argument */
+
+	    arg_reg = 1;
+	    count = (cif->nargs < 7) ? cif->nargs : 7;
+
+	    cif->rstruct_flag = !0;
+	  }
+	else
+	    cif->rstruct_flag = 0;
+      }
+    else
+      cif->rstruct_flag = 0;
+
+    while (count-- > 0 && arg_reg < 8)
+      {
+	ffi_type *t = cif->arg_types[index];
+
+	switch (t->type)
+	  {
+	  case FFI_TYPE_FLOAT:
+	  case FFI_TYPE_DOUBLE:
+	    if (!soft_float && index < nfixedargs)
+              cif->flags += t->type << (arg_reg * FFI_FLAG_BITS);
+	    arg_reg++;
+	    break;
+          case FFI_TYPE_LONGDOUBLE:
+            /* Align it.  */
+            arg_reg = FFI_ALIGN(arg_reg, 2);
+            /* Treat it as two adjacent doubles.  */
+	    if (soft_float || index >= nfixedargs)
+	      {
+		arg_reg += 2;
+	      }
+	    else
+	      {
+		cif->flags +=
+		  (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));
+		arg_reg++;
+		if (arg_reg >= 8)
+		  continue;
+		cif->flags +=
+		  (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));
+		arg_reg++;
+	      }
+            break;
+
+	  case FFI_TYPE_COMPLEX:
+	    switch (t->elements[0]->type)
+	      {
+	      case FFI_TYPE_LONGDOUBLE:
+		arg_reg = FFI_ALIGN(arg_reg, 2);
+		if (soft_float || index >= nfixedargs)
+		  {
+		    arg_reg += 2;
+		  }
+		else
+		  {
+		    cif->flags +=
+		      (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));
+		    arg_reg++;
+		    if (arg_reg >= 8)
+		        continue;
+		    cif->flags +=
+		      (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));
+		    arg_reg++;
+		    if (arg_reg >= 8)
+		        continue;
+		  }
+		/* passthrough */
+	      case FFI_TYPE_FLOAT:
+		// one fpr can only holds one arg even it is single
+		cif->bytes += 16;
+		/* passthrough */
+	      case FFI_TYPE_SINT32:
+	      case FFI_TYPE_UINT32:
+	      case FFI_TYPE_DOUBLE:
+		if (soft_float || index >= nfixedargs)
+		  {
+		    arg_reg += 2;
+		  }
+		else
+		  {
+		    uint32_t type = t->elements[0]->type != FFI_TYPE_LONGDOUBLE? t->elements[0]->type: FFI_TYPE_DOUBLE;
+		    cif->flags +=
+		      (type << (arg_reg * FFI_FLAG_BITS));
+		    arg_reg++;
+		    if (arg_reg >= 8)
+		        continue;
+		    cif->flags +=
+		      (type << (arg_reg * FFI_FLAG_BITS));
+		    arg_reg++;
+		  }
+		break;
+	      default:
+		arg_reg += 2;
+		break;
+	      }
+	    break;
+
+	  case FFI_TYPE_STRUCT:
+            loc = arg_reg * FFI_SIZEOF_ARG;
+	    cif->flags += calc_n32_struct_flags(soft_float || index >= nfixedargs,
+						t, &loc, &arg_reg);
+	    break;
+
+	  default:
+	    arg_reg++;
+            break;
+	  }
+
+	index++;
+      }
+
+  /* Set the return type flag */
+    switch (cif->rtype->type)
+      {
+      case FFI_TYPE_STRUCT:
+	{
+	  if (struct_flags == 0)
+	    {
+	      /* The structure is returned through a hidden
+		 first argument. Do nothing, 'cause FFI_TYPE_VOID 
+		 is 0 */
+	    }
+	  else
+	    {
+	      /* The structure is returned via some tricky
+		 mechanism */
+	      cif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);
+	      cif->flags += struct_flags << (4 + (FFI_FLAG_BITS * 8));
+	    }
+	  break;
+	}
+      
+      case FFI_TYPE_VOID:
+	/* Do nothing, 'cause FFI_TYPE_VOID is 0 */
+	break;
+
+      case FFI_TYPE_POINTER:
+	if (cif->abi == FFI_N32_SOFT_FLOAT || cif->abi == FFI_N32)
+	  cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);
+	else
+	  cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+	break;
+
+      case FFI_TYPE_FLOAT:
+	if (soft_float)
+	  {
+	    cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);
+	    break;
+	  }
+	/* else fall through */
+      case FFI_TYPE_DOUBLE:
+	if (soft_float)
+	  cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+	else
+	  cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+	break;
+
+      case FFI_TYPE_LONGDOUBLE:
+	/* Long double is returned as if it were a struct containing
+	   two doubles.  */
+	if (soft_float)
+	  {
+	    /* if ret is long double, the ret is given by v0 and a0, no idea why
+	     * Let's us VOID | VOID | LONGDOUBLE for it*/
+	    cif->flags += FFI_TYPE_LONGDOUBLE << (FFI_FLAG_BITS * 8);
+ 	  }
+	else
+	  {
+	    cif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);
+	    cif->flags += (FFI_TYPE_DOUBLE
+			   + (FFI_TYPE_DOUBLE << FFI_FLAG_BITS))
+					      << (4 + (FFI_FLAG_BITS * 8));
+	  }
+	break;
+      case FFI_TYPE_COMPLEX:
+	{
+	  int type = cif->rtype->elements[0]->type;
+
+	  cif->flags += (FFI_TYPE_COMPLEX << (FFI_FLAG_BITS * 8));
+	  if (soft_float || (type != FFI_TYPE_FLOAT && type != FFI_TYPE_DOUBLE && type != FFI_TYPE_LONGDOUBLE))
+	    {
+	      switch (type)
+		{
+		case FFI_TYPE_DOUBLE:
+		case FFI_TYPE_SINT64:
+		case FFI_TYPE_UINT64:
+		case FFI_TYPE_INT:
+		  type = FFI_TYPE_SMALLSTRUCT2;
+		  break;
+		case FFI_TYPE_LONGDOUBLE:
+		  type = FFI_TYPE_LONGDOUBLE;
+		  break;
+		case FFI_TYPE_FLOAT:
+		default:
+		  type = FFI_TYPE_SMALLSTRUCT;
+		}
+	      cif->flags += type << (4 + (FFI_FLAG_BITS * 8));
+	    }
+	  else
+	    {
+	      //cif->flags += (type + (type << FFI_FLAG_BITS))
+		//	    << (4 + (FFI_FLAG_BITS * 8));
+	      cif->flags += type << (4 + (FFI_FLAG_BITS * 8));
+	    }
+	  break;
+	}
+      case FFI_TYPE_UINT32:
+	/* In the N32 or N64 ABI unsigned 32-bit integer should be
+	   *sign*-extended.  */
+	cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);
+	break;
+      case FFI_TYPE_SINT64:
+	cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 8);
+	break;
+      default:
+	cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+	break;
+      }
+  }
+#endif
+  return FFI_OK;
+}
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+    return ffi_prep_cif_machdep_int(cif, cif->nargs);
+}
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
+                                    unsigned nfixedargs,
+                                    unsigned ntotalargs MAYBE_UNUSED)
+{
+    return ffi_prep_cif_machdep_int(cif, nfixedargs);
+}
+
+/* Low level routine for calling O32 functions */
+extern int ffi_call_O32(void (*)(char *, extended_cif *, int, int), 
+			extended_cif *, unsigned, 
+			unsigned, unsigned *, void (*)(void), void *closure);
+
+/* Low level routine for calling N32 functions */
+extern int ffi_call_N32(void (*)(char *, extended_cif *, int, int), 
+			extended_cif *, unsigned, 
+			unsigned, void *, void (*)(void), void *closure);
+
+void ffi_call_int(ffi_cif *cif, void (*fn)(void), void *rvalue, 
+	      void **avalue, void *closure)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+  
+  if ((rvalue == NULL) && 
+      (cif->rtype->type == FFI_TYPE_STRUCT || cif->rtype->type == FFI_TYPE_COMPLEX))
+    ecif.rvalue = alloca(cif->rtype->size);
+  else
+    ecif.rvalue = rvalue;
+    
+  switch (cif->abi) 
+    {
+#ifdef FFI_MIPS_O32
+    case FFI_O32:
+    case FFI_O32_SOFT_FLOAT:
+      ffi_call_O32(ffi_prep_args, &ecif, cif->bytes, 
+		   cif->flags, ecif.rvalue, fn, closure);
+      break;
+#endif
+
+#ifdef FFI_MIPS_N32
+    case FFI_N32:
+    case FFI_N32_SOFT_FLOAT:
+    case FFI_N64:
+    case FFI_N64_SOFT_FLOAT:
+      {
+        int copy_rvalue = 0;
+	int copy_offset = 0;
+        char *rvalue_copy = ecif.rvalue;
+        if (cif->rtype->type == FFI_TYPE_STRUCT && cif->rtype->size < 16)
+          {
+            /* For structures smaller than 16 bytes we clobber memory
+               in 8 byte increments.  Make a copy so we don't clobber
+               the callers memory outside of the struct bounds.  */
+            rvalue_copy = alloca(16);
+            copy_rvalue = 1;
+          }
+	else if (cif->rtype->type == FFI_TYPE_FLOAT
+		 && (cif->abi == FFI_N64_SOFT_FLOAT
+		     || cif->abi == FFI_N32_SOFT_FLOAT))
+	  {
+	    rvalue_copy = alloca (8);
+	    copy_rvalue = 1;
+#if defined(__MIPSEB__) || defined(_MIPSEB)
+	    copy_offset = 4;
+#endif
+	  }
+        ffi_call_N32(ffi_prep_args, &ecif, cif->bytes,
+                     cif->flags, rvalue_copy, fn, closure);
+        if (copy_rvalue)
+          memcpy(ecif.rvalue, rvalue_copy + copy_offset, cif->rtype->size);
+      }
+      break;
+#endif
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+void
+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+
+#if FFI_CLOSURES
+#if defined(FFI_MIPS_O32)
+extern void ffi_closure_O32(void);
+extern void ffi_go_closure_O32(void);
+#else
+extern void ffi_closure_N32(void);
+extern void ffi_go_closure_N32(void);
+#endif /* FFI_MIPS_O32 */
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+  void * fn;
+  char *clear_location = (char *) codeloc;
+
+#if defined(FFI_MIPS_O32)
+  if (cif->abi != FFI_O32 && cif->abi != FFI_O32_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+  fn = ffi_closure_O32;
+#else
+#if _MIPS_SIM ==_ABIN32
+  if (cif->abi != FFI_N32
+      && cif->abi != FFI_N32_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+#else
+  if (cif->abi != FFI_N64
+      && cif->abi != FFI_N64_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+#endif
+  fn = ffi_closure_N32;
+#endif /* FFI_MIPS_O32 */
+
+#if defined(FFI_MIPS_O32) || (_MIPS_SIM ==_ABIN32)
+  /* lui  $25,high(fn) */
+  tramp[0] = 0x3c190000 | ((unsigned)fn >> 16);
+  /* ori  $25,low(fn)  */
+  tramp[1] = 0x37390000 | ((unsigned)fn & 0xffff);
+  /* lui  $12,high(codeloc) */
+  tramp[2] = 0x3c0c0000 | ((unsigned)codeloc >> 16);
+  /* jr   $25          */
+#if !defined(__mips_isa_rev) || (__mips_isa_rev<6)
+  tramp[3] = 0x03200008;
+#else
+  tramp[3] = 0x03200009;
+#endif
+  /* ori  $12,low(codeloc)  */
+  tramp[4] = 0x358c0000 | ((unsigned)codeloc & 0xffff);
+#else
+  /* N64 has a somewhat larger trampoline.  */
+  /* lui  $25,high(fn) */
+  tramp[0] = 0x3c190000 | ((unsigned long)fn >> 48);
+  /* lui  $12,high(codeloc) */
+  tramp[1] = 0x3c0c0000 | ((unsigned long)codeloc >> 48);
+  /* ori  $25,mid-high(fn)  */
+  tramp[2] = 0x37390000 | (((unsigned long)fn >> 32 ) & 0xffff);
+  /* ori  $12,mid-high(codeloc)  */
+  tramp[3] = 0x358c0000 | (((unsigned long)codeloc >> 32) & 0xffff);
+  /* dsll $25,$25,16 */
+  tramp[4] = 0x0019cc38;
+  /* dsll $12,$12,16 */
+  tramp[5] = 0x000c6438;
+  /* ori  $25,mid-low(fn)  */
+  tramp[6] = 0x37390000 | (((unsigned long)fn >> 16 ) & 0xffff);
+  /* ori  $12,mid-low(codeloc)  */
+  tramp[7] = 0x358c0000 | (((unsigned long)codeloc >> 16) & 0xffff);
+  /* dsll $25,$25,16 */
+  tramp[8] = 0x0019cc38;
+  /* dsll $12,$12,16 */
+  tramp[9] = 0x000c6438;
+  /* ori  $25,low(fn)  */
+  tramp[10] = 0x37390000 | ((unsigned long)fn  & 0xffff);
+  /* jr   $25          */
+#if !defined(__mips_isa_rev) || (__mips_isa_rev<6)
+  tramp[11] = 0x03200008;
+#else
+  tramp[11] = 0x03200009;
+#endif
+  /* ori  $12,low(codeloc)  */
+  tramp[12] = 0x358c0000 | ((unsigned long)codeloc & 0xffff);
+
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+#if !defined(__FreeBSD__)
+#ifdef USE__BUILTIN___CLEAR_CACHE
+  __builtin___clear_cache(clear_location, clear_location + FFI_TRAMPOLINE_SIZE);
+#else
+  cacheflush (clear_location, FFI_TRAMPOLINE_SIZE, ICACHE);
+#endif
+#endif /* ! __FreeBSD__ */
+  return FFI_OK;
+}
+
+/*
+ * Decodes the arguments to a function, which will be stored on the
+ * stack. AR is the pointer to the beginning of the integer arguments
+ * (and, depending upon the arguments, some floating-point arguments
+ * as well). FPR is a pointer to the area where floating point
+ * registers have been saved, if any.
+ *
+ * RVALUE is the location where the function return value will be
+ * stored. CLOSURE is the prepared closure to invoke.
+ *
+ * This function should only be called from assembly, which is in
+ * turn called from a trampoline.
+ *
+ * Returns the function return type.
+ *
+ * Based on the similar routine for sparc.
+ */
+int
+ffi_closure_mips_inner_O32 (ffi_cif *cif,
+                            void (*fun)(ffi_cif*, void*, void**, void*),
+			    void *user_data,
+			    void *rvalue, ffi_arg *ar,
+			    double *fpr)
+{
+  void **avaluep;
+  ffi_arg *avalue;
+  ffi_type **arg_types;
+  int i, avn, argn, seen_int;
+
+  avalue = alloca (cif->nargs * sizeof (ffi_arg));
+  avaluep = alloca (cif->nargs * sizeof (ffi_arg));
+
+  seen_int = (cif->abi == FFI_O32_SOFT_FLOAT) || (cif->mips_nfixedargs != cif->nargs);
+  argn = 0;
+
+  if ((cif->flags >> (FFI_FLAG_BITS * 2)) == FFI_TYPE_STRUCT)
+    {
+      rvalue = (void *)(uintptr_t)ar[0];
+      argn = 1;
+      seen_int = 1;
+    }
+  if ((cif->flags >> (FFI_FLAG_BITS * 2)) == FFI_TYPE_COMPLEX)
+    {
+      rvalue = fpr;
+      argn = 1;
+    }
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+
+  while (i < avn)
+    {
+      if (arg_types[i]->alignment == 8 && (argn & 0x1))
+        argn++;
+      if (i < 2 && !seen_int &&
+	  (arg_types[i]->type == FFI_TYPE_FLOAT ||
+	   arg_types[i]->type == FFI_TYPE_DOUBLE ||
+	   arg_types[i]->type == FFI_TYPE_LONGDOUBLE))
+	{
+#if defined(__MIPSEB__) || defined(_MIPSEB)
+	  if (arg_types[i]->type == FFI_TYPE_FLOAT)
+	    avaluep[i] = ((char *) &fpr[i]) + sizeof (float);
+	  else
+#endif
+	    avaluep[i] = (char *) &fpr[i];
+	}
+      else
+	{
+	  switch (arg_types[i]->type)
+	    {
+	      case FFI_TYPE_SINT8:
+		avaluep[i] = &avalue[i];
+		*(SINT8 *) &avalue[i] = (SINT8) ar[argn];
+		break;
+
+	      case FFI_TYPE_UINT8:
+		avaluep[i] = &avalue[i];
+		*(UINT8 *) &avalue[i] = (UINT8) ar[argn];
+		break;
+		  
+	      case FFI_TYPE_SINT16:
+		avaluep[i] = &avalue[i];
+		*(SINT16 *) &avalue[i] = (SINT16) ar[argn];
+		break;
+		  
+	      case FFI_TYPE_UINT16:
+		avaluep[i] = &avalue[i];
+		*(UINT16 *) &avalue[i] = (UINT16) ar[argn];
+		break;
+
+	      default:
+		avaluep[i] = (char *) &ar[argn];
+		break;
+	    }
+	  seen_int = 1;
+	}
+      argn += FFI_ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+      i++;
+    }
+
+  /* Invoke the closure. */
+  fun(cif, rvalue, avaluep, user_data);
+
+  if (cif->abi == FFI_O32_SOFT_FLOAT)
+    {
+      switch (cif->rtype->type)
+        {
+        case FFI_TYPE_FLOAT:
+          return FFI_TYPE_INT;
+        case FFI_TYPE_DOUBLE:
+          return FFI_TYPE_UINT64;
+        default:
+          return cif->rtype->type;
+        }
+    }
+  else
+    {
+      if (cif->rtype->type == FFI_TYPE_COMPLEX) {
+          __asm__ volatile ("move $v1, %0" : : "r"(cif->rtype->size));
+      }
+      return cif->rtype->type;
+    }
+}
+
+#if defined(FFI_MIPS_N32)
+
+static void
+copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,
+                int argn, unsigned arg_offset, ffi_arg *ar,
+                ffi_arg *fpr, int soft_float)
+{
+  ffi_type **elt_typep = type->elements;
+  while(*elt_typep)
+    {
+      ffi_type *elt_type = *elt_typep;
+      unsigned o;
+      char *tp;
+      char *argp;
+      char *fpp;
+
+      o = FFI_ALIGN(offset, elt_type->alignment);
+      arg_offset += o - offset;
+      offset = o;
+      argn += arg_offset / sizeof(ffi_arg);
+      arg_offset = arg_offset % sizeof(ffi_arg);
+
+      argp = (char *)(ar + argn);
+      fpp = (char *)(argn >= 8 ? ar + argn : fpr + argn);
+
+      tp = target + offset;
+
+      if (elt_type->type == FFI_TYPE_DOUBLE && !soft_float)
+        *(double *)tp = *(double *)fpp;
+      else
+        memcpy(tp, argp + arg_offset, elt_type->size);
+
+      offset += elt_type->size;
+      arg_offset += elt_type->size;
+      elt_typep++;
+      argn += arg_offset / sizeof(ffi_arg);
+      arg_offset = arg_offset % sizeof(ffi_arg);
+    }
+}
+
+/*
+ * Decodes the arguments to a function, which will be stored on the
+ * stack. AR is the pointer to the beginning of the integer
+ * arguments. FPR is a pointer to the area where floating point
+ * registers have been saved.
+ *
+ * RVALUE is the location where the function return value will be
+ * stored. CLOSURE is the prepared closure to invoke.
+ *
+ * This function should only be called from assembly, which is in
+ * turn called from a trampoline.
+ *
+ * Returns the function return flags.
+ *
+ */
+int
+ffi_closure_mips_inner_N32 (ffi_cif *cif, 
+			    void (*fun)(ffi_cif*, void*, void**, void*),
+                            void *user_data,
+			    void *rvalue, ffi_arg *ar,
+			    ffi_arg *fpr)
+{
+  void **avaluep;
+  ffi_arg *avalue;
+  ffi_type **arg_types;
+  int i, avn, argn;
+  int soft_float;
+  ffi_arg *argp;
+
+  soft_float = cif->abi == FFI_N64_SOFT_FLOAT
+    || cif->abi == FFI_N32_SOFT_FLOAT;
+  avalue = alloca (cif->nargs * sizeof (ffi_arg));
+  avaluep = alloca (cif->nargs * sizeof (ffi_arg));
+
+  argn = 0;
+
+  if (cif->rstruct_flag)
+    {
+#if _MIPS_SIM==_ABIN32
+      rvalue = (void *)(UINT32)ar[0];
+#else /* N64 */
+      rvalue = (void *)ar[0];
+#endif
+      argn = 1;
+    }
+  if (cif->rtype->type == FFI_TYPE_COMPLEX && cif->rtype->elements[0]->type == FFI_TYPE_LONGDOUBLE)
+    argn = 2;
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+
+  while (i < avn)
+    {
+      if (arg_types[i]->type == FFI_TYPE_FLOAT
+	  || arg_types[i]->type == FFI_TYPE_DOUBLE
+	  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE)
+        {
+          argp = (argn >= 8 || i >= cif->mips_nfixedargs || soft_float) ? ar + argn : fpr + argn;
+          if ((arg_types[i]->type == FFI_TYPE_LONGDOUBLE) && ((uintptr_t)argp & (arg_types[i]->alignment-1)))
+            {
+              argp=(ffi_arg*)FFI_ALIGN(argp,arg_types[i]->alignment);
+              argn++;
+            }
+#if defined(__MIPSEB__) || defined(_MIPSEB)
+          if (arg_types[i]->type == FFI_TYPE_FLOAT && argn < 8)
+            avaluep[i] = ((char *) argp) + sizeof (float);
+          else
+#endif
+            avaluep[i] = (char *) argp;
+        }
+      else if (arg_types[i]->type == FFI_TYPE_COMPLEX && arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)
+        {
+          argp = (argn >= 8 || i >= cif->mips_nfixedargs || soft_float) ? ar + argn : fpr + argn;
+          avaluep[i] = (char *) argp;
+        }
+      else if (arg_types[i]->type == FFI_TYPE_COMPLEX && arg_types[i]->elements[0]->type == FFI_TYPE_LONGDOUBLE)
+        {
+	  /* align long double */
+	  argn += ((argn & 0x1)? 1 : 0);
+          argp = (argn >= 8 || i >= cif->mips_nfixedargs || soft_float) ? ar + argn : fpr + argn;
+          avaluep[i] = (char *) argp;
+        }
+      else if (arg_types[i]->type == FFI_TYPE_COMPLEX && arg_types[i]->elements[0]->type == FFI_TYPE_FLOAT)
+        {
+          if (argn >= 8 || i >= cif->mips_nfixedargs || soft_float)
+	     argp = ar + argn;
+	  else
+	    {
+	      argp = fpr + argn;
+	      /* the normal args for function holds 8bytes, while here we convert it to ptr */
+	      uint32_t *tmp = (uint32_t *)argp;
+	      tmp[1] = tmp[2];
+	    }
+          avaluep[i] = (char *) argp;
+        }
+      else
+        {
+          unsigned type = arg_types[i]->type;
+
+          if (arg_types[i]->alignment > sizeof(ffi_arg))
+            argn = FFI_ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));
+
+          argp = ar + argn;
+
+          /* The size of a pointer depends on the ABI */
+          if (type == FFI_TYPE_POINTER)
+            type = (cif->abi == FFI_N64 || cif->abi == FFI_N64_SOFT_FLOAT)
+	      ? FFI_TYPE_SINT64 : FFI_TYPE_UINT32;
+
+	  if (soft_float && type ==  FFI_TYPE_FLOAT)
+	    type = FFI_TYPE_SINT32;
+
+          switch (type)
+            {
+            case FFI_TYPE_SINT8:
+              avaluep[i] = &avalue[i];
+              *(SINT8 *) &avalue[i] = (SINT8) *argp;
+              break;
+
+            case FFI_TYPE_UINT8:
+              avaluep[i] = &avalue[i];
+              *(UINT8 *) &avalue[i] = (UINT8) *argp;
+              break;
+
+            case FFI_TYPE_SINT16:
+              avaluep[i] = &avalue[i];
+              *(SINT16 *) &avalue[i] = (SINT16) *argp;
+              break;
+
+            case FFI_TYPE_UINT16:
+              avaluep[i] = &avalue[i];
+              *(UINT16 *) &avalue[i] = (UINT16) *argp;
+              break;
+
+            case FFI_TYPE_SINT32:
+              avaluep[i] = &avalue[i];
+              *(SINT32 *) &avalue[i] = (SINT32) *argp;
+              break;
+
+            case FFI_TYPE_UINT32:
+              avaluep[i] = &avalue[i];
+              *(UINT32 *) &avalue[i] = (UINT32) *argp;
+              break;
+
+            case FFI_TYPE_STRUCT:
+              if (argn < 8)
+                {
+                  /* Allocate space for the struct as at least part of
+                     it was passed in registers.  */
+                  avaluep[i] = alloca(arg_types[i]->size);
+                  copy_struct_N32(avaluep[i], 0, cif->abi, arg_types[i],
+                                  argn, 0, ar, fpr, i >= cif->mips_nfixedargs || soft_float);
+
+                  break;
+                }
+              /* Else fall through.  */
+            default:
+              avaluep[i] = (char *) argp;
+              break;
+            }
+        }
+      argn += FFI_ALIGN(arg_types[i]->size, sizeof(ffi_arg)) / sizeof(ffi_arg);
+      i++;
+    }
+
+  /* Invoke the closure. */
+  fun (cif, rvalue, avaluep, user_data);
+
+  return cif->flags >> (FFI_FLAG_BITS * 8);
+}
+
+#endif /* FFI_MIPS_N32 */
+
+#if defined(FFI_MIPS_O32)
+extern void ffi_closure_O32(void);
+extern void ffi_go_closure_O32(void);
+#else
+extern void ffi_closure_N32(void);
+extern void ffi_go_closure_N32(void);
+#endif /* FFI_MIPS_O32 */
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,
+		     void (*fun)(ffi_cif*,void*,void**,void*))
+{
+  void * fn;
+
+#if defined(FFI_MIPS_O32)
+  if (cif->abi != FFI_O32 && cif->abi != FFI_O32_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+  fn = ffi_go_closure_O32;
+#else
+#if _MIPS_SIM ==_ABIN32
+  if (cif->abi != FFI_N32
+      && cif->abi != FFI_N32_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+#else
+  if (cif->abi != FFI_N64
+      && cif->abi != FFI_N64_SOFT_FLOAT)
+    return FFI_BAD_ABI;
+#endif
+  fn = ffi_go_closure_N32;
+#endif /* FFI_MIPS_O32 */
+
+  closure->tramp = (void *)fn;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+#endif /* FFI_CLOSURES */
Index: libffi-3.4.6/src/mips/n32.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/mips/n32.S b/libffi-3.4.6/src/mips/n32.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/mips/n32.S	
@@ -0,0 +1,823 @@
+/* -----------------------------------------------------------------------
+   n32.S - Copyright (c) 1996, 1998, 2005, 2007, 2009, 2010  Red Hat, Inc.
+   
+   MIPS Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Only build this code if we are compiling for n32 */	
+
+#if defined(FFI_MIPS_N32)
+
+#define callback a0
+#define bytes	 a2
+#define flags	 a3
+#define raddr    a4
+#define fn       a5
+#define closure  a6
+
+/* Note: to keep stack 16 byte aligned we need even number slots 
+   used 9 slots here
+*/
+#define SIZEOF_FRAME	( 10 * FFI_SIZEOF_ARG )
+
+#ifdef __GNUC__
+	.abicalls
+#endif
+#if !defined(__mips_isa_rev) || (__mips_isa_rev<6)
+	.set mips4
+#endif
+	.text
+	.align	2
+	.globl	ffi_call_N32
+	.ent	ffi_call_N32
+ffi_call_N32:	
+.LFB0:
+	.frame	$fp, SIZEOF_FRAME, ra
+	.mask	0xc0000000,-FFI_SIZEOF_ARG
+	.fmask	0x00000000,0
+
+	# Prologue
+	SUBU	$sp, SIZEOF_FRAME			# Frame size
+.LCFI00:
+	REG_S	$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp)	# Save frame pointer
+	REG_S	ra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)	# Save return address
+.LCFI01:
+	move	$fp, $sp
+.LCFI02:
+	move	t9, callback	# callback function pointer
+	REG_S	bytes, 2*FFI_SIZEOF_ARG($fp) # bytes
+	REG_S	flags, 3*FFI_SIZEOF_ARG($fp) # flags
+	REG_S	raddr, 4*FFI_SIZEOF_ARG($fp) # raddr
+	REG_S	fn,    5*FFI_SIZEOF_ARG($fp) # fn
+	REG_S	closure, 6*FFI_SIZEOF_ARG($fp) # closure
+
+	# Allocate at least 4 words in the argstack
+	move	v0, bytes
+	bge	bytes, 4 * FFI_SIZEOF_ARG, bigger	
+	LI	v0, 4 * FFI_SIZEOF_ARG
+	b	sixteen
+
+	bigger:	
+	ADDU	t4, v0, 2 * FFI_SIZEOF_ARG -1	# make sure it is aligned 
+	and	v0, t4, -2 * FFI_SIZEOF_ARG		# to a proper boundry.
+
+sixteen:
+	SUBU	$sp, $sp, v0	# move the stack pointer to reflect the
+				# arg space
+
+	move	a0, $sp         # 4 * FFI_SIZEOF_ARG
+	ADDU	a3, $fp, 3 * FFI_SIZEOF_ARG
+
+	# Call ffi_prep_args
+	jal	t9
+	
+	# Copy the stack pointer to t9
+	move	t9, $sp
+	
+	# Fix the stack if there are more than 8 64bit slots worth
+	# of arguments.
+
+	# Load the number of bytes
+	REG_L	t6, 2*FFI_SIZEOF_ARG($fp)
+
+	# Is it bigger than 8 * FFI_SIZEOF_ARG?
+	daddiu	t8, t6, -(8 * FFI_SIZEOF_ARG)
+	bltz	t8, loadregs
+
+	ADDU	t9, t9, t8
+	
+loadregs:	
+
+	REG_L	t6, 3*FFI_SIZEOF_ARG($fp)  # load the flags word into t6.
+
+	# when retval is _Complex long double, $f12/$a0, $f13/$a1 will be skipped
+	# no idea why, but gcc does it.
+	SRL	t4, t6, 8*FFI_FLAG_BITS
+	move	t8, t6
+	bne	t4, FFI_TYPE_COMPLEX_LDLD, loadregs1
+
+	SLL	t8, t6, 2*FFI_FLAG_BITS
+
+
+loadregs1:
+#ifdef __mips_soft_float
+	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
+	REG_L	a1, 1*FFI_SIZEOF_ARG(t9)
+	REG_L	a2, 2*FFI_SIZEOF_ARG(t9)
+	REG_L	a3, 3*FFI_SIZEOF_ARG(t9)
+	REG_L	a4, 4*FFI_SIZEOF_ARG(t9)
+	REG_L	a5, 5*FFI_SIZEOF_ARG(t9)
+	REG_L	a6, 6*FFI_SIZEOF_ARG(t9)
+	REG_L	a7, 7*FFI_SIZEOF_ARG(t9)
+#else
+	and	t4, t8, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg1_next
+	bne	t4, FFI_TYPE_FLOAT, arg1_doublep
+	l.s	$f12, 0*FFI_SIZEOF_ARG(t9)
+	b	arg1_next
+arg1_doublep:	
+	l.d	$f12, 0*FFI_SIZEOF_ARG(t9)
+arg1_next:	
+	
+	SRL	t4, t8, 1*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a1, 1*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg2_next
+	bne	t4, FFI_TYPE_FLOAT, arg2_doublep
+	l.s	$f13, 1*FFI_SIZEOF_ARG(t9)	
+	b	arg2_next
+arg2_doublep:	
+	l.d	$f13, 1*FFI_SIZEOF_ARG(t9)	
+arg2_next:	
+	
+	SRL	t4, t8, 2*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a2, 2*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg3_next
+	bne	t4, FFI_TYPE_FLOAT, arg3_doublep
+	l.s	$f14, 2*FFI_SIZEOF_ARG(t9)	
+	b	arg3_next
+arg3_doublep:	
+	l.d	$f14, 2*FFI_SIZEOF_ARG(t9)	
+arg3_next:	
+	
+	SRL	t4, t8, 3*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a3, 3*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg4_next
+	bne	t4, FFI_TYPE_FLOAT, arg4_doublep
+	l.s	$f15, 3*FFI_SIZEOF_ARG(t9)	
+	b	arg4_next
+arg4_doublep:	
+	l.d	$f15, 3*FFI_SIZEOF_ARG(t9)	
+arg4_next:	
+	
+	SRL	t4, t8, 4*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a4, 4*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg5_next
+	bne	t4, FFI_TYPE_FLOAT, arg5_doublep
+	l.s	$f16, 4*FFI_SIZEOF_ARG(t9)	
+	b	arg5_next
+arg5_doublep:	
+	l.d	$f16, 4*FFI_SIZEOF_ARG(t9)	
+arg5_next:	
+	
+	SRL	t4, t8, 5*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a5, 5*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg6_next
+	bne	t4, FFI_TYPE_FLOAT, arg6_doublep
+	l.s	$f17, 5*FFI_SIZEOF_ARG(t9)	
+	b	arg6_next
+arg6_doublep:	
+	l.d	$f17, 5*FFI_SIZEOF_ARG(t9)	
+arg6_next:	
+	
+	SRL	t4, t8, 6*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a6, 6*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg7_next
+	bne	t4, FFI_TYPE_FLOAT, arg7_doublep
+	l.s	$f18, 6*FFI_SIZEOF_ARG(t9)	
+	b	arg7_next
+arg7_doublep:	
+	l.d	$f18, 6*FFI_SIZEOF_ARG(t9)	
+arg7_next:	
+	
+	SRL	t4, t8, 7*FFI_FLAG_BITS
+	and	t4, ((1<<FFI_FLAG_BITS)-1)
+	REG_L	a7, 7*FFI_SIZEOF_ARG(t9)
+	beqz	t4, arg8_next
+	bne	t4, FFI_TYPE_FLOAT, arg8_doublep
+ 	l.s	$f19, 7*FFI_SIZEOF_ARG(t9)	
+	b	arg8_next
+arg8_doublep:	
+ 	l.d	$f19, 7*FFI_SIZEOF_ARG(t9)	
+arg8_next:	
+#endif
+
+callit:
+	# Load the function pointer
+	REG_L	t9, 5*FFI_SIZEOF_ARG($fp)
+
+	# install the static chain(t7=$15)
+	REG_L	t7, 6*FFI_SIZEOF_ARG($fp)
+
+	# If the return value pointer is NULL, assume no return value.
+	REG_L	t5, 4*FFI_SIZEOF_ARG($fp)
+	beqz	t5, noretval
+
+	# Shift the return type flag over
+	SRL	t6, 8*FFI_FLAG_BITS
+
+	bne     t6, FFI_TYPE_UINT64, retsint32
+
+retuint64:
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sd	v0, 0(t4)
+	b	epilogue
+
+retsint32:
+	bne	t6, FFI_TYPE_SINT32, retuint16
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sll	v0, v0, 0
+	sd	v0, 0(t4)
+	b	epilogue
+
+retuint16:
+	bne	t6, FFI_TYPE_UINT16, retsint16
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	andi	v0, v0, 0xffff
+	sd	v0, 0(t4)
+	b	epilogue
+
+retsint16:
+	bne	t6, FFI_TYPE_SINT16, retuint8
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	dsll	v0, v0, 48
+	dsra	v0, v0, 48
+	sd	v0, 0(t4)
+	b	epilogue
+
+retuint8:
+	bne	t6, FFI_TYPE_UINT8, retsint8
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	andi	v0, v0, 0xff
+	sd	v0, 0(t4)
+	b	epilogue
+
+retsint8:
+	bne	t6, FFI_TYPE_SINT8, retfloat
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sd	v0, 0(t4)
+	dsll	v0, v0, 56
+	dsra	v0, v0, 56
+	b	epilogue
+
+retfloat:
+#ifndef __mips_soft_float
+	bne     t6, FFI_TYPE_FLOAT, retdouble
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.s	$f0, 0(t4)
+	b	epilogue
+
+retdouble:	
+	bne	t6, FFI_TYPE_DOUBLE, retstruct_d
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.d	$f0, 0(t4)
+	b	epilogue
+
+retstruct_d:
+	bne	t6, FFI_TYPE_STRUCT_D, retstruct_f
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.d	$f0, 0(t4)
+	b	epilogue
+	
+retstruct_f:	
+	bne	t6, FFI_TYPE_STRUCT_F, retstruct_d_d
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.s	$f0, 0(t4)
+	b	epilogue
+	
+retstruct_d_d:
+	bne	t6, FFI_TYPE_STRUCT_DD, retcomplex_d_d
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.d	$f0, 0(t4)
+	s.d	$f2, 8(t4)
+	b	epilogue
+
+retcomplex_d_d:
+	bne	t6, FFI_TYPE_COMPLEX_DD, retcomplex_ld_ld
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.d	$f0, 0(t4)
+	s.d	$f2, 8(t4)
+	b	epilogue
+
+retcomplex_ld_ld:
+	bne	t6, FFI_TYPE_COMPLEX_LDLD, retstruct_f_f
+	jal	t9
+	b	epilogue
+	
+retstruct_f_f:
+	bne	t6, FFI_TYPE_STRUCT_FF, retcomplex_f_f
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.s	$f0, 0(t4)
+	s.s	$f2, 4(t4)
+	b	epilogue
+
+retcomplex_f_f:
+	bne	t6, FFI_TYPE_COMPLEX_FF, retstruct_d_f
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.s	$f0, 0(t4)
+	s.s	$f2, 4(t4)
+	b	epilogue
+	
+retstruct_d_f:	
+	bne	t6, FFI_TYPE_STRUCT_DF, retstruct_f_d
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.d	$f0, 0(t4)
+	s.s	$f2, 8(t4)
+	b	epilogue
+	
+retstruct_f_d:	
+	bne	t6, FFI_TYPE_STRUCT_FD, retstruct_d_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	s.s	$f0, 0(t4)
+	s.d	$f2, 8(t4)
+	b	epilogue
+#endif
+
+retstruct_d_soft:
+	bne	t6, FFI_TYPE_STRUCT_D_SOFT, retstruct_f_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sd	v0, 0(t4)
+	b	epilogue
+	
+retstruct_f_soft:	
+	bne	t6, FFI_TYPE_STRUCT_F_SOFT, retstruct_d_d_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sw	v0, 0(t4)
+	b	epilogue
+	
+retstruct_d_d_soft:	
+	bne	t6, FFI_TYPE_STRUCT_DD_SOFT, retstruct_f_f_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sd	v0, 0(t4)
+	sd	a0, 8(t4) # not typo, it is a0, I have no idea, gcc does do it
+	b	epilogue
+	
+retstruct_f_f_soft:	
+	bne	t6, FFI_TYPE_STRUCT_FF_SOFT, retstruct_d_f_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sw	v0, 0(t4)
+	sw	v1, 4(t4)
+	b	epilogue
+	
+retstruct_d_f_soft:	
+	bne	t6, FFI_TYPE_STRUCT_DF_SOFT, retstruct_f_d_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sd	v0, 0(t4)
+	sw	v1, 8(t4)
+	b	epilogue
+	
+retstruct_f_d_soft:	
+	bne	t6, FFI_TYPE_STRUCT_FD_SOFT, retstruct_small
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	sw	v0, 0(t4)
+	sd	a0, 8(t4) # not typo, it is a0, I have no idea, gcc does do it
+	b	epilogue
+	
+retstruct_small:	
+	bne	t6, FFI_TYPE_STRUCT_SMALL, retstruct_small2
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t4)
+	b	epilogue
+	
+retstruct_small2:	
+	bne	t6, FFI_TYPE_STRUCT_SMALL2, retlongdouble_soft
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t4)
+	REG_S	v1, 8(t4)
+	b	epilogue
+	
+retlongdouble_soft:
+	bne	t6, FFI_TYPE_LONGDOUBLE, retcomplex_small
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t4)
+	REG_S	a0, 8(t4) # not typo, it is a0, I have no idea, gcc does do it
+	b	epilogue
+
+retcomplex_small:
+	bne	t6, FFI_TYPE_COMPLEX_SMALL, retcomplex_small2
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t4)
+	b	epilogue
+
+retcomplex_small2:
+	bne	t6, FFI_TYPE_COMPLEX_SMALL2, retstruct
+	jal	t9
+	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t4)
+	REG_S	v1, 8(t4)
+	b	epilogue
+
+retstruct:
+noretval:	
+	jal	t9
+	
+	# Epilogue
+epilogue:	
+	move	$sp, $fp	
+	REG_L	$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp) # Restore frame pointer
+	REG_L	ra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)  # Restore return address
+	ADDU	$sp, SIZEOF_FRAME		      # Fix stack pointer
+	j	ra
+
+.LFE0:
+	.end	ffi_call_N32
+
+/* ffi_closure_N32. Expects address of the passed-in ffi_closure in t0
+   ($12). Stores any arguments passed in registers onto the stack,
+   then calls ffi_closure_mips_inner_N32, which then decodes
+   them.
+	
+	Stack layout:
+
+	20 - Start of parameters, original sp
+	19 - Called function a7 save
+	18 - Called function a6 save
+	17 - Called function a5 save
+	16 - Called function a4 save
+	15 - Called function a3 save
+	14 - Called function a2 save
+	13 - Called function a1 save
+	12 - Called function a0 save
+	11 - Called function f19
+	10 - Called function f18
+	 9 - Called function f17
+	 8 - Called function f16
+	 7 - Called function f15
+         6 - Called function f14
+         5 - Called function f13
+         4 - Called function f12
+	 3 - return value high (v1 or $f2)
+	 2 - return value low (v0 or $f0)
+	 1 - ra save
+	 0 - gp save our sp  points here
+	 */
+
+#define SIZEOF_FRAME2	(20 * FFI_SIZEOF_ARG)
+
+#define A7_OFF2		(19 * FFI_SIZEOF_ARG)
+#define A6_OFF2		(18 * FFI_SIZEOF_ARG)
+#define A5_OFF2		(17 * FFI_SIZEOF_ARG)
+#define A4_OFF2		(16 * FFI_SIZEOF_ARG)
+#define A3_OFF2		(15 * FFI_SIZEOF_ARG)
+#define A2_OFF2		(14 * FFI_SIZEOF_ARG)
+#define A1_OFF2		(13 * FFI_SIZEOF_ARG)
+#define A0_OFF2		(12 * FFI_SIZEOF_ARG)	
+
+#define F19_OFF2	(11 * FFI_SIZEOF_ARG)
+#define F18_OFF2	(10 * FFI_SIZEOF_ARG)
+#define F17_OFF2	(9  * FFI_SIZEOF_ARG)
+#define F16_OFF2	(8  * FFI_SIZEOF_ARG)
+#define F15_OFF2	(7  * FFI_SIZEOF_ARG)
+#define F14_OFF2	(6  * FFI_SIZEOF_ARG)
+#define F13_OFF2	(5  * FFI_SIZEOF_ARG)
+#define F12_OFF2	(4  * FFI_SIZEOF_ARG)
+
+#define V1_OFF2		(3  * FFI_SIZEOF_ARG)
+#define V0_OFF2		(2  * FFI_SIZEOF_ARG)
+
+#define RA_OFF2		(1  * FFI_SIZEOF_ARG)
+#define GP_OFF2		(0  * FFI_SIZEOF_ARG)
+
+	.align	2
+	.globl	ffi_go_closure_N32
+	.ent	ffi_go_closure_N32
+ffi_go_closure_N32:
+.LFB1:
+	.frame	$sp, SIZEOF_FRAME2, ra
+	.mask	0x90000000,-(SIZEOF_FRAME2 - RA_OFF2)
+	.fmask	0x00000000,0
+	SUBU	$sp, SIZEOF_FRAME2
+.LCFI10:
+	.cpsetup t9, GP_OFF2, ffi_go_closure_N32
+	REG_S	ra, RA_OFF2($sp)	# Save return address
+.LCFI11:
+
+	REG_S	a0, A0_OFF2($sp)
+	REG_S	a1, A1_OFF2($sp)
+	REG_S	a2, A2_OFF2($sp)
+	REG_S	a3, A3_OFF2($sp)
+	REG_S	a4, A4_OFF2($sp)
+	REG_S	a5, A5_OFF2($sp)
+
+	# Call ffi_closure_mips_inner_N32 to do the real work.
+	LA	t9, ffi_closure_mips_inner_N32
+#if _MIPS_SIM==_ABIN32
+	lw	a0, 4($15)   # cif
+	lw	a1, 8($15) # fun
+#else
+	REG_L	a0, 8($15)   # cif
+	REG_L	a1, 16($15) # fun
+#endif
+	move	a2, t7                     # userdata=closure
+	ADDU	a3, $sp, V0_OFF2           # rvalue
+	ADDU	a4, $sp, A0_OFF2           # ar
+	ADDU	a5, $sp, F12_OFF2          # fpr
+
+	b	$do_closure
+
+.LFE1:	
+	.end	ffi_go_closure_N32
+
+	.align	2
+	.globl	ffi_closure_N32
+	.ent	ffi_closure_N32
+ffi_closure_N32:
+.LFB2:
+	.frame	$sp, SIZEOF_FRAME2, ra
+	.mask	0x90000000,-(SIZEOF_FRAME2 - RA_OFF2)
+	.fmask	0x00000000,0
+	SUBU	$sp, SIZEOF_FRAME2
+.LCFI20:
+	.cpsetup t9, GP_OFF2, ffi_closure_N32
+	REG_S	ra, RA_OFF2($sp)	# Save return address
+.LCFI21:
+	REG_S	a0, A0_OFF2($sp)
+	REG_S	a1, A1_OFF2($sp)
+	REG_S	a2, A2_OFF2($sp)
+	REG_S	a3, A3_OFF2($sp)
+	REG_S	a4, A4_OFF2($sp)
+	REG_S	a5, A5_OFF2($sp)
+
+	# Call ffi_closure_mips_inner_N32 to do the real work.
+	LA	t9, ffi_closure_mips_inner_N32
+#if _MIPS_SIM==_ABIN32
+	lw	a0, 20($12)   # cif
+	lw	a1, 24($12)   # fun
+	lw	a2, 28($12) # user_data
+#else
+	REG_L	a0, 56($12)   # cif
+	REG_L	a1, 64($12)   # fun
+	REG_L	a2, 72($12) # user_data
+#endif
+	ADDU	a3, $sp, V0_OFF2
+	# FIXME: a4 does work, while if ret is _Complex long double, it will overwrite Fn_OFF2
+	ADDU	a4, $sp, A0_OFF2
+	ADDU	a5, $sp, F12_OFF2
+
+$do_closure:
+	# Store all possible argument registers. If there are more than
+	# fit in registers, then they were stored on the stack.
+	REG_S	a6, A6_OFF2($sp)
+	REG_S	a7, A7_OFF2($sp)
+
+#ifndef __mips_soft_float
+	# Store all possible float/double registers.
+	s.d	$f12, F12_OFF2($sp)
+	s.d	$f13, F13_OFF2($sp)
+	s.d	$f14, F14_OFF2($sp)
+	s.d	$f15, F15_OFF2($sp)
+	s.d	$f16, F16_OFF2($sp)
+	s.d	$f17, F17_OFF2($sp)
+	s.d	$f18, F18_OFF2($sp)
+	s.d	$f19, F19_OFF2($sp)
+#endif
+
+	jalr	t9
+
+cls_retuint64:
+	# Return flags are in v0
+	bne     v0, FFI_TYPE_UINT64, cls_retsint32
+	ld	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retsint32:
+	bne     v0, FFI_TYPE_SINT32, cls_retsint16
+	lw	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retsint16:
+	bne     v0, FFI_TYPE_SINT16, cls_retuint16
+	lh	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retuint16:
+	bne     v0, FFI_TYPE_UINT16, cls_retsint8
+	lhu	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retsint8:
+	bne     v0, FFI_TYPE_SINT8, cls_retuint8
+	lb	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retuint8:
+	bne     v0, FFI_TYPE_UINT8, cls_retfloat
+	lbu	v0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retfloat:
+#ifndef __mips_soft_float
+	bne     v0, FFI_TYPE_FLOAT, cls_retdouble
+	l.s	$f0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retdouble:	
+	bne	v0, FFI_TYPE_DOUBLE, cls_retstruct_d
+	l.d	$f0, V0_OFF2($sp)
+	b	cls_epilogue
+
+cls_retstruct_d:	
+	bne	v0, FFI_TYPE_STRUCT_D, cls_retstruct_f
+	l.d	$f0, V0_OFF2($sp)
+	b	cls_epilogue
+	
+cls_retstruct_f:	
+	bne	v0, FFI_TYPE_STRUCT_F, cls_retstruct_d_d
+	l.s	$f0, V0_OFF2($sp)
+	b	cls_epilogue
+	
+cls_retstruct_d_d:	
+	bne	v0, FFI_TYPE_STRUCT_DD, cls_retcomplex_d_d
+	l.d	$f0, V0_OFF2($sp)
+	l.d	$f2, V1_OFF2($sp)
+	b	cls_epilogue
+
+cls_retcomplex_d_d:
+	bne	v0, FFI_TYPE_COMPLEX_DD, cls_retcomplex_f_f
+	l.d	$f0, V0_OFF2($sp)
+	l.d	$f2, V1_OFF2($sp)
+	b	cls_epilogue
+	
+cls_retstruct_f_f:
+	bne	v0, FFI_TYPE_STRUCT_FF, cls_retcomplex_f_f
+	l.s	$f0, V0_OFF2($sp)
+	l.s	$f2, V1_OFF2($sp)
+	b	cls_epilogue
+	
+cls_retcomplex_f_f:
+	bne	v0, FFI_TYPE_COMPLEX_FF, cls_retstruct_d_f
+	l.s	$f0, V0_OFF2($sp)
+	l.s	$f2, (V0_OFF2+4)($sp)
+	b	cls_epilogue
+
+cls_retstruct_d_f:	
+	bne	v0, FFI_TYPE_STRUCT_DF, cls_retstruct_f_d
+	l.d	$f0, V0_OFF2($sp)
+	l.s	$f2, V1_OFF2($sp)
+	b	cls_epilogue
+	
+cls_retstruct_f_d:	
+	bne	v0, FFI_TYPE_STRUCT_FD, cls_retcomplex_ld_ld
+	l.s	$f0, V0_OFF2($sp)
+	l.d	$f2, V1_OFF2($sp)
+	b	cls_epilogue
+#else
+cls_longdouble_soft:
+	bne	v0, FFI_TYPE_LONGDOUBLE, cls_retcomplex_ld_ld
+	REG_L	v0, V0_OFF2($sp)
+	REG_L	a0, V1_OFF2($sp) # not typo, it is a0, I have no idea, gcc does do it
+	b	cls_epilogue
+#endif
+
+cls_retcomplex_ld_ld:
+	bne	v0, FFI_TYPE_COMPLEX_LDLD, cls_retstruct_small2
+	REG_L	t8, A0_OFF2($sp)
+	REG_L	t9, 16($sp)
+	REG_S	t9, 0(t8)
+	REG_L	t9, 24($sp)
+	REG_S	t9, 8(t8)
+	REG_L	t9, 32($sp)
+	REG_S	t9, 16(t8)
+	REG_L	t9, 40($sp)
+	REG_S	t9, 24(t8)
+	b	cls_epilogue
+
+cls_retstruct_small2:	
+	REG_L	v0, V0_OFF2($sp)
+	REG_L	v1, V1_OFF2($sp)
+	
+	# Epilogue
+cls_epilogue:	
+	REG_L	ra,  RA_OFF2($sp)	 # Restore return address
+	.cpreturn
+	ADDU	$sp, SIZEOF_FRAME2
+	j	ra
+.LFE2:	
+	.end	ffi_closure_N32
+
+#ifdef __GNUC__
+        .section        .eh_frame,EH_FRAME_FLAGS,@progbits
+.Lframe1:
+        .4byte  .LECIE1-.LSCIE1		# length
+.LSCIE1:
+        .4byte  0x0			# CIE
+        .byte   0x1			# Version 1
+        .ascii  "\000"			# Augmentation
+        .uleb128 0x1			# Code alignment 1
+        .sleb128 -4			# Data alignment -4
+        .byte   0x1f			# Return Address $31
+        .byte   0xc			# DW_CFA_def_cfa
+        .uleb128 0x1d			# in $sp
+        .uleb128 0x0			# offset 0
+        .align  EH_FRAME_ALIGN
+.LECIE1:
+
+.LSFDE0:
+        .4byte  .LEFDE0-.LASFDE0	# length.
+.LASFDE0:
+        .4byte  .LASFDE0-.Lframe1	# CIE_pointer.
+        FDE_ADDR_BYTES  .LFB0		# initial_location.
+        FDE_ADDR_BYTES  .LFE0-.LFB0	# address_range.
+        .byte   0x4			# DW_CFA_advance_loc4
+        .4byte  .LCFI00-.LFB0		# to .LCFI00
+        .byte   0xe			# DW_CFA_def_cfa_offset
+        .uleb128 SIZEOF_FRAME		# adjust stack.by SIZEOF_FRAME
+        .byte   0x4			# DW_CFA_advance_loc4
+        .4byte  .LCFI01-.LCFI00		# to .LCFI01
+        .byte   0x9e			# DW_CFA_offset of $fp
+        .uleb128 2*FFI_SIZEOF_ARG/4	# 
+        .byte   0x9f			# DW_CFA_offset of ra
+        .uleb128 1*FFI_SIZEOF_ARG/4	# 
+        .byte   0x4			# DW_CFA_advance_loc4
+        .4byte  .LCFI02-.LCFI01		# to .LCFI02
+        .byte   0xd			# DW_CFA_def_cfa_register
+        .uleb128 0x1e			# in $fp
+        .align  EH_FRAME_ALIGN
+.LEFDE0:
+
+.LSFDE1:
+	.4byte	.LEFDE1-.LASFDE1	# length
+.LASFDE1:
+	.4byte	.LASFDE1-.Lframe1	# CIE_pointer.
+	FDE_ADDR_BYTES	.LFB1		# initial_location.
+	FDE_ADDR_BYTES	.LFE1-.LFB1	# address_range.
+	.byte	0x4			# DW_CFA_advance_loc4
+	.4byte	.LCFI10-.LFB1		# to .LCFI10
+	.byte	0xe			# DW_CFA_def_cfa_offset
+	.uleb128 SIZEOF_FRAME2		# adjust stack.by SIZEOF_FRAME
+	.byte	0x4			# DW_CFA_advance_loc4
+	.4byte	.LCFI11-.LCFI10		# to .LCFI11
+	.byte	0x9c			# DW_CFA_offset of $gp ($28)
+	.uleb128 (SIZEOF_FRAME2 - GP_OFF2)/4
+	.byte	0x9f			# DW_CFA_offset of ra ($31)
+	.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4
+	.align	EH_FRAME_ALIGN
+.LEFDE1:
+
+.LSFDE2:
+	.4byte	.LEFDE2-.LASFDE2	# length
+.LASFDE2:
+	.4byte	.LASFDE2-.Lframe1	# CIE_pointer.
+	FDE_ADDR_BYTES	.LFB2		# initial_location.
+	FDE_ADDR_BYTES	.LFE2-.LFB2	# address_range.
+	.byte	0x4			# DW_CFA_advance_loc4
+	.4byte	.LCFI20-.LFB2		# to .LCFI20
+	.byte	0xe			# DW_CFA_def_cfa_offset
+	.uleb128 SIZEOF_FRAME2		# adjust stack.by SIZEOF_FRAME
+	.byte	0x4			# DW_CFA_advance_loc4
+	.4byte	.LCFI21-.LCFI20		# to .LCFI21
+	.byte	0x9c			# DW_CFA_offset of $gp ($28)
+	.uleb128 (SIZEOF_FRAME2 - GP_OFF2)/4
+	.byte	0x9f			# DW_CFA_offset of ra ($31)
+	.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4
+	.align	EH_FRAME_ALIGN
+.LEFDE2:
+#endif /* __GNUC__ */	
+	
+#endif
Index: libffi-3.4.6/src/mips/o32.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/mips/o32.S b/libffi-3.4.6/src/mips/o32.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/mips/o32.S	
@@ -0,0 +1,561 @@
+/* -----------------------------------------------------------------------
+   o32.S - Copyright (c) 1996, 1998, 2005  Red Hat, Inc.
+   
+   MIPS Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Only build this code if we are compiling for o32 */	
+
+#if defined(FFI_MIPS_O32)
+	
+#define callback a0
+#define bytes	 a2
+#define flags	 a3
+		
+#define SIZEOF_FRAME	(4 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG)
+#define A3_OFF		(SIZEOF_FRAME + 3 * FFI_SIZEOF_ARG)
+#define FP_OFF		(SIZEOF_FRAME - 2 * FFI_SIZEOF_ARG)
+#define RA_OFF		(SIZEOF_FRAME - 1 * FFI_SIZEOF_ARG)
+
+	.abicalls
+	.text
+	.align	2
+	.globl	ffi_call_O32
+	.ent	ffi_call_O32
+ffi_call_O32:	
+$LFB0:
+	# Prologue
+	SUBU	$sp, SIZEOF_FRAME	# Frame size
+$LCFI00:
+	REG_S	$fp, FP_OFF($sp)	# Save frame pointer
+$LCFI01:
+	REG_S	ra, RA_OFF($sp)		# Save return address
+$LCFI02:
+	move	$fp, $sp
+
+$LCFI03:
+	move	t9, callback		# callback function pointer
+	REG_S	flags, A3_OFF($fp)	# flags
+
+	# Allocate at least 4 words in the argstack
+	LI	v0, 4 * FFI_SIZEOF_ARG
+	blt	bytes, v0, sixteen
+
+	ADDU	v0, bytes, 7	# make sure it is aligned 
+	and	v0, -8		# to an 8 byte boundry
+
+sixteen:
+	SUBU	$sp, v0		# move the stack pointer to reflect the
+				# arg space
+
+	ADDU	a0, $sp, 4 * FFI_SIZEOF_ARG
+
+	jalr	t9
+	
+	REG_L	t0, A3_OFF($fp)		# load the flags word
+	SRL	t2, t0, 4		# shift our arg info
+	and     t0, ((1<<4)-1)          # mask out the return type
+		
+	ADDU	$sp, 4 * FFI_SIZEOF_ARG		# adjust $sp to new args
+
+#ifndef __mips_soft_float
+	bnez	t0, pass_d			# make it quick for int
+#endif
+	REG_L	a0, 0*FFI_SIZEOF_ARG($sp)	# just go ahead and load the
+	REG_L	a1, 1*FFI_SIZEOF_ARG($sp)	# four regs.
+	REG_L	a2, 2*FFI_SIZEOF_ARG($sp)
+	REG_L	a3, 3*FFI_SIZEOF_ARG($sp)
+	b	call_it
+
+#ifndef __mips_soft_float
+pass_d:
+	bne	t0, FFI_ARGS_D, pass_f
+	l.d	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	REG_L	a2,   2*FFI_SIZEOF_ARG($sp)	# passing a double
+	REG_L	a3,   3*FFI_SIZEOF_ARG($sp)
+	b	call_it
+
+pass_f:	
+	bne	t0, FFI_ARGS_F, pass_d_d
+	l.s	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	REG_L	a1,   1*FFI_SIZEOF_ARG($sp)	# passing a float
+	REG_L	a2,   2*FFI_SIZEOF_ARG($sp)
+	REG_L	a3,   3*FFI_SIZEOF_ARG($sp)
+	b	call_it		
+
+pass_d_d:		
+	bne	t0, FFI_ARGS_DD, pass_f_f
+	l.d	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	l.d	$f14, 2*FFI_SIZEOF_ARG($sp)	# passing two doubles
+	b	call_it
+
+pass_f_f:	
+	bne	t0, FFI_ARGS_FF, pass_d_f
+	l.s	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	l.s	$f14, 1*FFI_SIZEOF_ARG($sp)	# passing two floats
+	REG_L	a2,   2*FFI_SIZEOF_ARG($sp)
+	REG_L	a3,   3*FFI_SIZEOF_ARG($sp)
+	b	call_it
+
+pass_d_f:		
+	bne	t0, FFI_ARGS_DF, pass_f_d
+	l.d	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	l.s	$f14, 2*FFI_SIZEOF_ARG($sp)	# passing double and float
+	REG_L	a3,   3*FFI_SIZEOF_ARG($sp)
+	b	call_it
+
+pass_f_d:		
+ # assume that the only other combination must be float then double
+ #	bne	t0, FFI_ARGS_F_D, call_it
+	l.s	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
+	l.d	$f14, 2*FFI_SIZEOF_ARG($sp)	# passing double and float
+
+#endif
+
+call_it:	
+	# Load the static chain pointer
+	REG_L	t7, SIZEOF_FRAME + 6*FFI_SIZEOF_ARG($fp)
+
+	# Load the function pointer
+	REG_L	t9, SIZEOF_FRAME + 5*FFI_SIZEOF_ARG($fp)
+
+	# If the return value pointer is NULL, assume no return value.
+	REG_L	t1, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+	beqz	t1, noretval
+
+	and     t1, t2, ((1<<4)-1)
+	bne     t1, FFI_TYPE_INT, retlonglong
+	jalr	t9
+	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v0, 0(t0)
+	b	epilogue
+
+retlonglong:
+	# Really any 64-bit int, signed or not.
+	bne	t1, FFI_TYPE_UINT64, retfloat
+	jalr	t9
+	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+	REG_S	v1, 4(t0)
+	REG_S	v0, 0(t0)
+	b	epilogue
+
+retfloat:
+	bne     t1, FFI_TYPE_FLOAT, retdouble
+	jalr	t9
+	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+#ifndef __mips_soft_float
+	s.s	$f0, 0(t0)
+#else
+	REG_S	v0, 0(t0)
+#endif
+	b	epilogue
+
+retdouble:	
+	bne	t1, FFI_TYPE_DOUBLE, retcomplex
+	jalr	t9
+	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+#ifndef __mips_soft_float
+	s.d	$f0, 0(t0)
+#else
+	REG_S	v1, 4(t0)
+	REG_S	v0, 0(t0)
+#endif
+	b	epilogue
+	
+retcomplex:
+	# mask out the complex elements type.
+	# the struct of flags (bits):
+	# 0-1: arg0
+	# 2-3: arg1
+	# 4-7: return type
+	# 8-11: rtype elements type: for complex
+	# Note here: t2 is flags>>4
+	bne	t1, FFI_TYPE_COMPLEX, noretval
+	jalr	t9
+	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
+	REG_L	t1, A3_OFF($fp)		# load the flags word
+	SRL	t1, t1, 8
+	li	t3, 3
+	beq	t1, t3, 3f # double
+	li	t3, 2
+	beq	t1, t3, 2f # float
+	# FIXME: long double
+	slti	t3, t1, 5
+	beqz	t3, 5f     # (u)int8/16/32/64
+2:
+#ifndef __mips_soft_float
+	s.s	$f0, 0(t0)
+	s.s	$f2, 4(t0)
+#else
+	# FIXME: do nothing can pass all of the testsuite
+#endif
+	b	epilogue
+3:
+#ifndef __mips_soft_float
+	s.d	$f0, 0(t0)
+	s.d	$f2, 8(t0)
+#else
+	# FIXME: do nothing can pass all of the testsuite
+#endif
+	b	epilogue
+
+5:
+	REG_S	v1, 4(t0)
+	REG_S	v0, 0(t0)
+	b	epilogue
+
+noretval:	
+	jalr	t9
+	
+	# Epilogue
+epilogue:	
+	move	$sp, $fp	
+	REG_L	$fp, FP_OFF($sp)	# Restore frame pointer
+	REG_L	ra, RA_OFF($sp)		# Restore return address
+	ADDU	$sp, SIZEOF_FRAME	# Fix stack pointer
+	j	ra
+
+$LFE0:
+	.end	ffi_call_O32
+
+
+/* ffi_closure_O32. Expects address of the passed-in ffi_closure
+	in t4 ($12). Stores any arguments passed in registers onto the
+	stack, then calls ffi_closure_mips_inner_O32, which
+	then decodes them.
+	
+	Stack layout:
+
+	 3 - a3 save
+	 2 - a2 save
+	 1 - a1 save
+	 0 - a0 save, original sp
+	-1 - ra save
+	-2 - fp save
+	-3 - $16 (s0) save
+	-4 - cprestore
+	-5 - return value high (v1)
+	-6 - return value low (v0)
+	-7 - f14 (le high, be low)
+	-8 - f14 (le low, be high)
+	-9 - f12 (le high, be low)
+       -10 - f12 (le low, be high)
+       -11 - Called function a5 save
+       -12 - Called function a4 save
+       -13 - Called function a3 save
+       -14 - Called function a2 save
+       -15 - Called function a1 save
+       -16 - Called function a0 save, our sp and fp point here
+	 */
+	
+#define SIZEOF_FRAME2	(16 * FFI_SIZEOF_ARG)
+#define A3_OFF2		(SIZEOF_FRAME2 + 3 * FFI_SIZEOF_ARG)
+#define A2_OFF2		(SIZEOF_FRAME2 + 2 * FFI_SIZEOF_ARG)
+#define A1_OFF2		(SIZEOF_FRAME2 + 1 * FFI_SIZEOF_ARG)
+#define A0_OFF2		(SIZEOF_FRAME2 + 0 * FFI_SIZEOF_ARG)
+#define RA_OFF2		(SIZEOF_FRAME2 - 1 * FFI_SIZEOF_ARG)
+#define FP_OFF2		(SIZEOF_FRAME2 - 2 * FFI_SIZEOF_ARG)
+#define S0_OFF2		(SIZEOF_FRAME2 - 3 * FFI_SIZEOF_ARG)
+#define GP_OFF2		(SIZEOF_FRAME2 - 4 * FFI_SIZEOF_ARG)
+#define V1_OFF2		(SIZEOF_FRAME2 - 5 * FFI_SIZEOF_ARG)
+#define V0_OFF2		(SIZEOF_FRAME2 - 6 * FFI_SIZEOF_ARG)
+#define FA_1_1_OFF2	(SIZEOF_FRAME2 - 7 * FFI_SIZEOF_ARG)
+#define FA_1_0_OFF2	(SIZEOF_FRAME2 - 8 * FFI_SIZEOF_ARG)
+#define FA_0_1_OFF2	(SIZEOF_FRAME2 - 9 * FFI_SIZEOF_ARG)
+#define FA_0_0_OFF2	(SIZEOF_FRAME2 - 10 * FFI_SIZEOF_ARG)
+#define CALLED_A5_OFF2  (SIZEOF_FRAME2 - 11 * FFI_SIZEOF_ARG)
+#define CALLED_A4_OFF2  (SIZEOF_FRAME2 - 12 * FFI_SIZEOF_ARG)
+
+	.text
+
+	.align	2
+	.globl	ffi_go_closure_O32
+	.ent	ffi_go_closure_O32
+ffi_go_closure_O32:
+$LFB1:
+	# Prologue
+	.frame	$fp, SIZEOF_FRAME2, ra
+	.set	noreorder
+	.cpload	t9
+	.set	reorder
+	SUBU	$sp, SIZEOF_FRAME2
+	.cprestore GP_OFF2
+$LCFI10:
+
+	REG_S	$16, S0_OFF2($sp)	 # Save s0
+	REG_S	$fp, FP_OFF2($sp)	 # Save frame pointer
+	REG_S	ra, RA_OFF2($sp)	 # Save return address
+$LCFI11:
+
+	move	$fp, $sp
+$LCFI12:
+
+	REG_S	a0, A0_OFF2($fp)
+	REG_S	a1, A1_OFF2($fp)
+	REG_S	a2, A2_OFF2($fp)
+	REG_S	a3, A3_OFF2($fp)
+
+	# Load ABI enum to s0
+	REG_L	$16, 4($15)	# cif 
+	REG_L	$16, 0($16)	# abi is first member.
+
+	li	$13, 1		# FFI_O32
+	bne	$16, $13, 1f	# Skip fp save if FFI_O32_SOFT_FLOAT
+	
+#ifndef __mips_soft_float
+	# Store all possible float/double registers.
+	s.d	$f12, FA_0_0_OFF2($fp)
+	s.d	$f14, FA_1_0_OFF2($fp)
+#endif
+1:
+	# prepare arguments for ffi_closure_mips_inner_O32
+	REG_L	a0, 4($15)	 # cif 
+	REG_L	a1, 8($15)	 # fun
+	move	a2, $15		 # user_data = go closure
+	addu	a3, $fp, V0_OFF2 # rvalue
+
+	addu	t9, $fp, A0_OFF2 # ar
+	REG_S   t9, CALLED_A4_OFF2($fp)
+
+	addu	t9, $fp, FA_0_0_OFF2 #fpr
+	REG_S   t9, CALLED_A5_OFF2($fp)
+
+	b $do_closure
+
+$LFE1:
+	.end ffi_go_closure_O32
+
+	.align	2
+	.globl	ffi_closure_O32
+	.ent	ffi_closure_O32
+ffi_closure_O32:
+$LFB2:
+	# Prologue
+	.frame	$fp, SIZEOF_FRAME2, ra
+	.set	noreorder
+	.cpload	t9
+	.set	reorder
+	SUBU	$sp, SIZEOF_FRAME2
+	.cprestore GP_OFF2
+$LCFI20:
+	REG_S	$16, S0_OFF2($sp)	 # Save s0
+	REG_S	$fp, FP_OFF2($sp)	 # Save frame pointer
+	REG_S	ra, RA_OFF2($sp)	 # Save return address
+$LCFI21:
+	move	$fp, $sp
+
+$LCFI22:
+	# Store all possible argument registers. If there are more than
+	# four arguments, then they are stored above where we put a3.
+	REG_S	a0, A0_OFF2($fp)
+	REG_S	a1, A1_OFF2($fp)
+	REG_S	a2, A2_OFF2($fp)
+	REG_S	a3, A3_OFF2($fp)
+
+	# Load ABI enum to s0
+	REG_L	$16, 20($12)	# cif pointer follows tramp.
+	REG_L	$16, 0($16)	# abi is first member.
+
+	li	$13, 1		# FFI_O32
+	bne	$16, $13, 1f	# Skip fp save if FFI_O32_SOFT_FLOAT
+	
+#ifndef __mips_soft_float
+	# Store all possible float/double registers.
+	s.d	$f12, FA_0_0_OFF2($fp)
+	s.d	$f14, FA_1_0_OFF2($fp)
+#endif
+1:	
+	# prepare arguments for ffi_closure_mips_inner_O32
+	REG_L	a0, 20($12)	 # cif pointer follows tramp.
+	REG_L	a1, 24($12)	 # fun
+	REG_L	a2, 28($12)	 # user_data
+	addu	a3, $fp, V0_OFF2 # rvalue
+
+	addu	t9, $fp, A0_OFF2 # ar
+	REG_S   t9, CALLED_A4_OFF2($fp)
+
+	addu	t9, $fp, FA_0_0_OFF2 #fpr
+	REG_S   t9, CALLED_A5_OFF2($fp)
+
+$do_closure:
+	la	t9, ffi_closure_mips_inner_O32
+	# Call ffi_closure_mips_inner_O32 to do the work.
+	jalr	t9
+
+	# Load the return value into the appropriate register.
+	move	$8, $2
+	li	$9, FFI_TYPE_VOID
+	beq	$8, $9, closure_done
+
+	li	$13, 1		# FFI_O32
+	bne	$16, $13, 1f	# Skip fp restore if FFI_O32_SOFT_FLOAT
+
+#ifndef __mips_soft_float
+	li	$9, FFI_TYPE_FLOAT
+	l.s	$f0, V0_OFF2($fp)
+	beq	$8, $9, closure_done
+
+	li	$9, FFI_TYPE_DOUBLE
+	l.d	$f0, V0_OFF2($fp)
+	beq	$8, $9, closure_done
+
+	li      $9, FFI_TYPE_COMPLEX
+	bne     $8, $9, 1f
+
+	li      $9, 8
+	l.s	$f0, V0_OFF2($fp)
+	l.s	$f2, V1_OFF2($fp)
+	beq     $3, $9, closure_done
+
+	li      $9, 16
+	l.d	$f0, V0_OFF2($fp)
+	l.d	$f2, (V0_OFF2+8)($fp)
+	beq     $3, $9, closure_done
+#endif
+1:	
+	REG_L	$3, V1_OFF2($fp)
+	REG_L	$2, V0_OFF2($fp)
+
+closure_done:
+	# Epilogue
+	move	$sp, $fp
+	REG_L	$16, S0_OFF2($sp)	 # Restore s0
+	REG_L	$fp, FP_OFF2($sp)	 # Restore frame pointer
+	REG_L	ra,  RA_OFF2($sp)	 # Restore return address
+	ADDU	$sp, SIZEOF_FRAME2
+	j	ra
+$LFE2:
+	.end	ffi_closure_O32
+
+/* DWARF-2 unwind info. */
+
+	.section	.eh_frame,"a",@progbits
+$Lframe0:
+	.4byte	$LECIE0-$LSCIE0	 # Length of Common Information Entry
+$LSCIE0:
+	.4byte	0x0	 # CIE Identifier Tag
+	.byte	0x1	 # CIE Version
+	.ascii "zR\0"	 # CIE Augmentation
+	.uleb128 0x1	 # CIE Code Alignment Factor
+	.sleb128 4	 # CIE Data Alignment Factor
+	.byte	0x1f	 # CIE RA Column
+	.uleb128 0x1	 # Augmentation size
+	.byte	0x00	 # FDE Encoding (absptr)
+	.byte	0xc	 # DW_CFA_def_cfa
+	.uleb128 0x1d
+	.uleb128 0x0
+	.align	2
+$LECIE0:
+
+$LSFDE0:
+	.4byte	$LEFDE0-$LASFDE0	 # FDE Length
+$LASFDE0:
+	.4byte	$LASFDE0-$Lframe0	 # FDE CIE offset
+	.4byte	$LFB0	 # FDE initial location
+	.4byte	$LFE0-$LFB0	 # FDE address range
+	.uleb128 0x0	 # Augmentation size
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI00-$LFB0
+	.byte	0xe	 # DW_CFA_def_cfa_offset
+	.uleb128 0x18
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI01-$LCFI00
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1e	 # $fp
+	.sleb128 -2	 # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1f	 # $ra
+	.sleb128 -1	 # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI02-$LCFI01
+	.byte	0xc	 # DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x18
+	.align	2
+$LEFDE0:
+
+$LSFDE1:
+	.4byte	$LEFDE1-$LASFDE1	 # FDE Length
+$LASFDE1:
+	.4byte	$LASFDE1-$Lframe0	 # FDE CIE offset
+	.4byte	$LFB1	 # FDE initial location
+	.4byte	$LFE1-$LFB1	 # FDE address range
+	.uleb128 0x0	 # Augmentation size
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI10-$LFB1
+	.byte	0xe	 # DW_CFA_def_cfa_offset
+	.uleb128 SIZEOF_FRAME2
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI11-$LCFI10
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x10	 # $16
+	.sleb128 -3	 # SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1e	 # $fp
+	.sleb128 -2	 # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1f	 # $ra
+	.sleb128 -1	 # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI12-$LCFI11
+	.byte	0xc	 # DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 SIZEOF_FRAME2
+	.align	2
+$LEFDE1:
+
+$LSFDE2:
+	.4byte	$LEFDE2-$LASFDE2	 # FDE Length
+$LASFDE2:
+	.4byte	$LASFDE2-$Lframe0	 # FDE CIE offset
+	.4byte	$LFB2	 # FDE initial location
+	.4byte	$LFE2-$LFB2	 # FDE address range
+	.uleb128 0x0	 # Augmentation size
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI20-$LFB2
+	.byte	0xe	 # DW_CFA_def_cfa_offset
+	.uleb128 SIZEOF_FRAME2
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI21-$LCFI20
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x10	 # $16
+	.sleb128 -3	 # SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1e	 # $fp
+	.sleb128 -2	 # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)
+	.byte	0x11	 # DW_CFA_offset_extended_sf
+	.uleb128 0x1f	 # $ra
+	.sleb128 -1	 # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)
+	.byte	0x4	 # DW_CFA_advance_loc4
+	.4byte	$LCFI22-$LCFI21
+	.byte	0xc	 # DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 SIZEOF_FRAME2
+	.align	2
+$LEFDE2:
+
+#endif
Index: libffi-3.4.6/src/mips/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/mips/ffitarget.h b/libffi-3.4.6/src/mips/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/mips/ffitarget.h	
@@ -0,0 +1,251 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for MIPS.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifdef __linux__
+# include <asm/sgidefs.h>
+#elif defined(__rtems__)
+/*
+ * Subprogram calling convention - copied from sgidefs.h
+ */
+#define _MIPS_SIM_ABI32		1
+#define _MIPS_SIM_NABI32	2
+#define _MIPS_SIM_ABI64		3
+#elif !defined(__OpenBSD__) && !defined(__FreeBSD__)
+# include <sgidefs.h>
+#endif
+
+#  ifndef _ABIN32
+#    define _ABIN32 _MIPS_SIM_NABI32
+#  endif
+#  ifndef _ABI64
+#    define _ABI64 _MIPS_SIM_ABI64
+#  endif
+#  ifndef _ABIO32
+#    define _ABIO32 _MIPS_SIM_ABI32
+#  endif
+
+#if !defined(_MIPS_SIM)
+# error -- something is very wrong --
+#else
+#  if (_MIPS_SIM==_ABIN32 && defined(_ABIN32)) || (_MIPS_SIM==_ABI64 && defined(_ABI64))
+#    define FFI_MIPS_N32
+#  else
+#    if (_MIPS_SIM==_ABIO32 && defined(_ABIO32))
+#      define FFI_MIPS_O32
+#    else
+#     error -- this is an unsupported platform --
+#    endif
+#  endif
+#endif
+
+#ifdef FFI_MIPS_O32
+/* O32 stack frames have 32bit integer args */
+#  define FFI_SIZEOF_ARG    4
+#else
+/* N32 and N64 frames have 64bit integer args */
+#  define FFI_SIZEOF_ARG    8
+#  if _MIPS_SIM == _ABIN32
+#    define FFI_SIZEOF_JAVA_RAW  4
+#  endif
+#endif
+
+#define FFI_TARGET_HAS_COMPLEX_TYPE 1
+#define FFI_FLAG_BITS 2
+
+/* SGI's strange assembler requires that we multiply by 4 rather 
+   than shift left by FFI_FLAG_BITS */
+
+#define FFI_ARGS_D   FFI_TYPE_DOUBLE
+#define FFI_ARGS_F   FFI_TYPE_FLOAT
+#define FFI_ARGS_DD  FFI_TYPE_DOUBLE * 4 + FFI_TYPE_DOUBLE
+#define FFI_ARGS_FF  FFI_TYPE_FLOAT * 4 +  FFI_TYPE_FLOAT
+#define FFI_ARGS_FD  FFI_TYPE_DOUBLE * 4 + FFI_TYPE_FLOAT
+#define FFI_ARGS_DF  FFI_TYPE_FLOAT * 4 + FFI_TYPE_DOUBLE
+
+/* Needed for N32 structure returns */
+#define FFI_TYPE_SMALLSTRUCT  FFI_TYPE_UINT8
+#define FFI_TYPE_SMALLSTRUCT2 FFI_TYPE_SINT8
+
+#if 0
+/* The SGI assembler can't handle this.. */
+#define FFI_TYPE_STRUCT_DD (( FFI_ARGS_DD ) << 4) + FFI_TYPE_STRUCT
+/* (and so on) */
+#else
+/* ...so we calculate these by hand! */
+#define FFI_TYPE_STRUCT_D      61
+#define FFI_TYPE_STRUCT_F      45
+#define FFI_TYPE_STRUCT_DD     253
+#define FFI_TYPE_STRUCT_FF     173
+#define FFI_TYPE_STRUCT_FD     237
+#define FFI_TYPE_STRUCT_DF     189
+#define FFI_TYPE_STRUCT_SMALL  93
+#define FFI_TYPE_STRUCT_SMALL2 109
+
+#define FFI_TYPE_COMPLEX_SMALL    95
+#define FFI_TYPE_COMPLEX_SMALL2   111
+#define FFI_TYPE_COMPLEX_FF       47
+#define FFI_TYPE_COMPLEX_DD       63
+#define FFI_TYPE_COMPLEX_LDLD     79
+
+/* and for n32 soft float, add 16 * 2^4 */
+#define FFI_TYPE_STRUCT_D_SOFT      317
+#define FFI_TYPE_STRUCT_F_SOFT      301
+#define FFI_TYPE_STRUCT_DD_SOFT     509
+#define FFI_TYPE_STRUCT_FF_SOFT     429
+#define FFI_TYPE_STRUCT_FD_SOFT     493
+#define FFI_TYPE_STRUCT_DF_SOFT     445
+#define FFI_TYPE_STRUCT_SOFT        16
+#endif
+
+#ifdef LIBFFI_ASM
+#define v0 $2
+#define v1 $3
+#define a0 $4
+#define a1 $5
+#define a2 $6
+#define a3 $7
+#define a4 $8		
+#define a5 $9		
+#define a6 $10		
+#define a7 $11		
+#define t0 $8
+#define t1 $9
+#define t2 $10
+#define t3 $11
+#define t4 $12		
+#define t5 $13
+#define t6 $14	
+#define t7 $15
+#define t8 $24
+#define t9 $25
+#define ra $31		
+
+#ifdef FFI_MIPS_O32
+# define REG_L	lw
+# define REG_S	sw
+# define SUBU	subu
+# define ADDU	addu
+# define SRL	srl
+# define LI	li
+#else /* !FFI_MIPS_O32 */
+# define REG_L	ld
+# define REG_S	sd
+# define SUBU	dsubu
+# define ADDU	daddu
+# define SRL	dsrl
+# define LI 	dli
+# if (_MIPS_SIM==_ABI64)
+#  define LA dla
+#  define EH_FRAME_ALIGN 3
+#  define FDE_ADDR_BYTES .8byte
+# else
+#  define LA la
+#  define EH_FRAME_ALIGN 2
+#  define FDE_ADDR_BYTES .4byte
+# endif /* _MIPS_SIM==_ABI64 */
+#endif /* !FFI_MIPS_O32 */
+#else /* !LIBFFI_ASM */
+# ifdef __GNUC__
+#  ifdef FFI_MIPS_O32
+/* O32 stack frames have 32bit integer args */
+typedef unsigned int     ffi_arg __attribute__((__mode__(__SI__)));
+typedef signed   int     ffi_sarg __attribute__((__mode__(__SI__)));
+#else
+/* N32 and N64 frames have 64bit integer args */
+typedef unsigned int     ffi_arg __attribute__((__mode__(__DI__)));
+typedef signed   int     ffi_sarg __attribute__((__mode__(__DI__)));
+#  endif
+# else
+#  ifdef FFI_MIPS_O32
+/* O32 stack frames have 32bit integer args */
+typedef __uint32_t ffi_arg;
+typedef __int32_t ffi_sarg;
+#  else
+/* N32 and N64 frames have 64bit integer args */
+typedef __uint64_t ffi_arg;
+typedef __int64_t ffi_sarg;
+#  endif
+# endif /* __GNUC__ */
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_O32,
+  FFI_N32,
+  FFI_N64,
+  FFI_O32_SOFT_FLOAT,
+  FFI_N32_SOFT_FLOAT,
+  FFI_N64_SOFT_FLOAT,
+  FFI_LAST_ABI,
+
+#ifdef FFI_MIPS_O32
+#ifdef __mips_soft_float
+  FFI_DEFAULT_ABI = FFI_O32_SOFT_FLOAT
+#else
+  FFI_DEFAULT_ABI = FFI_O32
+#endif
+#else
+# if _MIPS_SIM==_ABI64
+#  ifdef __mips_soft_float
+  FFI_DEFAULT_ABI = FFI_N64_SOFT_FLOAT
+#  else
+  FFI_DEFAULT_ABI = FFI_N64
+#  endif
+# else
+#  ifdef __mips_soft_float
+  FFI_DEFAULT_ABI = FFI_N32_SOFT_FLOAT
+#  else
+  FFI_DEFAULT_ABI = FFI_N32
+#  endif
+# endif
+#endif
+} ffi_abi;
+
+#define FFI_EXTRA_CIF_FIELDS unsigned rstruct_flag; unsigned mips_nfixedargs
+#define FFI_TARGET_SPECIFIC_VARIADIC
+#endif /* !LIBFFI_ASM */
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#if defined(FFI_MIPS_O32) || (_MIPS_SIM ==_ABIN32)
+# define FFI_TRAMPOLINE_SIZE 20
+#else
+# define FFI_TRAMPOLINE_SIZE 56
+#endif
+
+#endif
+
Index: libffi-3.4.6/src/or1k/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/or1k/ffi.c b/libffi-3.4.6/src/or1k/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/or1k/ffi.c	
@@ -0,0 +1,341 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
+
+   OpenRISC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include "ffi_common.h"
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void* ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  char *stacktemp = stack;
+  int i, s;
+  ffi_type **arg;
+  int count = 0;
+  int nfixedargs;
+
+  nfixedargs = ecif->cif->nfixedargs;
+  arg = ecif->cif->arg_types;
+  void **argv = ecif->avalue;
+
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+      *(void **) stack = ecif->rvalue;
+      stack += 4;
+      count = 4;
+    }
+  for(i=0; i<ecif->cif->nargs; i++)
+  {
+
+    /* variadic args are saved on stack */
+    if ((nfixedargs == 0) && (count < 24))
+      {
+        count = 24;
+        stack = stacktemp + 24;
+      }
+    nfixedargs--;
+
+    s = 4;
+    switch((*arg)->type)
+      {
+      case FFI_TYPE_STRUCT:
+        *(void **)stack = *argv;
+        break;
+
+      case FFI_TYPE_SINT8:
+        *(signed int *) stack = (signed int)*(SINT8 *)(* argv);
+        break;
+
+      case FFI_TYPE_UINT8:
+        *(unsigned int *) stack = (unsigned int)*(UINT8 *)(* argv);
+        break;
+
+      case FFI_TYPE_SINT16:
+        *(signed int *) stack = (signed int)*(SINT16 *)(* argv);
+        break;
+
+      case FFI_TYPE_UINT16:
+        *(unsigned int *) stack = (unsigned int)*(UINT16 *)(* argv);
+        break;
+
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_FLOAT:
+      case FFI_TYPE_POINTER:
+        *(int *)stack = *(int*)(*argv);
+        break;
+
+      default: /* 8 byte types */
+        if (count == 20) /* never split arguments */
+          {
+            stack += 4;
+            count += 4;
+          }
+        s = (*arg)->size;
+        memcpy(stack, *argv, s);
+        break;
+      }
+
+    stack += s;
+    count += s;
+    argv++;
+    arg++;
+  }
+  return stacktemp + ((count>24)?24:0);
+}
+
+extern void ffi_call_SYSV(unsigned,
+                          extended_cif *,
+                          void *(*)(int *, extended_cif *),
+                          unsigned *,
+                          void (*fn)(void),
+                          unsigned);
+
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  int i;
+  int size;
+  ffi_type **arg;
+
+  /* Calculate size to allocate on stack */
+
+  for(i = 0, arg = cif->arg_types, size=0; i < cif->nargs; i++, arg++)
+    {
+      if ((*arg)->type == FFI_TYPE_STRUCT)
+        size += 4;
+      else
+      if ((*arg)->size <= 4)
+        size += 4;
+      else
+        size += 8;
+
+      /* If we have any large structure arguments, make a copy so we are passing
+         by value.  */
+      {
+        ffi_type *at = cif->arg_types[i];
+        int size = at->size;
+        if (at->type == FFI_TYPE_STRUCT) /* && size > 4) All struct args? */
+          {
+            char *argcopy = alloca (size);
+            memcpy (argcopy, avalue[i], size);
+            avalue[i] = argcopy;
+          }
+      }
+    }
+
+  /* for variadic functions more space is needed on the stack */
+  if (cif->nargs != cif->nfixedargs)
+    size += 24;
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    size += 4;
+
+
+  extended_cif ecif;
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+  {
+    case FFI_SYSV:
+      ffi_call_SYSV(size, &ecif, ffi_prep_args, rvalue, fn, cif->flags);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+  }
+}
+
+
+void ffi_closure_SYSV(unsigned long r3, unsigned long r4, unsigned long r5,
+                      unsigned long r6, unsigned long r7, unsigned long r8)
+{
+  register int *sp __asm__ ("r17");
+  register int *r13 __asm__ ("r13");
+
+  ffi_closure* closure = (ffi_closure*) r13;
+  char *stack_args = sp;
+
+  /* Lay the register arguments down in a continuous chunk of memory.  */
+  unsigned register_args[6] =
+    { r3, r4, r5, r6, r7, r8 };
+
+  /* Pointer to a struct return value.  */
+  void *struct_rvalue = (void *) r3;
+
+  ffi_cif *cif = closure->cif;
+  ffi_type **arg_types = cif->arg_types;
+  void **avalue = alloca (cif->nargs * sizeof(void *));
+  char *ptr = (char *) register_args;
+  int count = 0;
+  int nfixedargs = cif->nfixedargs;
+  int i;
+
+  /* preserve struct type return pointer passing */
+
+  if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
+  {
+    ptr += 4;
+    count = 4;
+  }
+
+  /* Find the address of each argument.  */
+  for (i = 0; i < cif->nargs; i++)
+    {
+
+      /* variadic args are saved on stack */
+      if ((nfixedargs == 0) && (count < 24))
+        {
+          ptr = stack_args;
+          count = 24;
+        }
+      nfixedargs--;
+
+      switch (arg_types[i]->type)
+        {
+        case FFI_TYPE_SINT8:
+        case FFI_TYPE_UINT8:
+          avalue[i] = ptr + 3;
+          break;
+
+        case FFI_TYPE_SINT16:
+        case FFI_TYPE_UINT16:
+          avalue[i] = ptr + 2;
+          break;
+
+        case FFI_TYPE_SINT32:
+        case FFI_TYPE_UINT32:
+        case FFI_TYPE_FLOAT:
+        case FFI_TYPE_POINTER:
+          avalue[i] = ptr;
+          break;
+
+        case FFI_TYPE_STRUCT:
+          avalue[i] = *(void**)ptr;
+          break;
+
+        default:
+          /* 8-byte values  */
+
+          /* arguments are never splitted */
+          if (ptr == &register_args[5])
+            ptr = stack_args;
+          avalue[i] = ptr;
+          ptr += 4;
+          count += 4;
+          break;
+        }
+      ptr += 4;
+      count += 4;
+
+      /* If we've handled more arguments than fit in registers,
+         start looking at the those passed on the stack.  */
+
+      if (count == 24)
+        ptr = stack_args;
+    }
+
+  if (cif->rtype && (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      (closure->fun) (cif, struct_rvalue, avalue, closure->user_data);
+    } else
+    {
+      long long rvalue;
+      (closure->fun) (cif, &rvalue, avalue, closure->user_data);
+      if (cif->rtype)
+        asm ("l.ori r12, %0, 0x0\n l.lwz r11, 0(r12)\n l.lwz r12, 4(r12)" : : "r" (&rvalue));
+    }
+}
+
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  unsigned short *tramp = (unsigned short *) closure->tramp;
+  unsigned long fn = (unsigned long) ffi_closure_SYSV;
+  unsigned long cls = (unsigned long) codeloc;
+
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  closure->cif = cif;
+  closure->user_data = user_data;
+  closure->fun = fun;
+
+  /* write pointers to temporary registers */
+  tramp[0] = (0x6 << 10) | (13 << 5); /* l.movhi r13, ... */
+  tramp[1] = cls >> 16;
+  tramp[2] = (0x2a << 10) | (13 << 5) | 13; /* l.ori r13, r13, ... */
+  tramp[3] = cls & 0xFFFF;
+
+  tramp[4] = (0x6 << 10) | (15 << 5); /* l.movhi r15, ... */
+  tramp[5] = fn >> 16;
+  tramp[6] = (0x2a << 10) | (15 << 5) | 15; /* l.ori r15, r15 ... */
+  tramp[7] = fn & 0xFFFF;
+
+  tramp[8] = (0x11 << 10); /* l.jr r15 */
+  tramp[9] = 15 << 11;
+
+  tramp[10] = (0x2a << 10) | (17 << 5) | 1; /* l.ori r17, r1, ... */
+  tramp[11] = 0x0;
+
+  return FFI_OK;
+}
+
+
+ffi_status ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  cif->flags = 0;
+
+  /* structures are returned as pointers */
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    cif->flags = FFI_TYPE_STRUCT;
+  else
+  if (cif->rtype->size > 4)
+    cif->flags = FFI_TYPE_UINT64;
+
+  cif->nfixedargs = cif->nargs;
+
+  return FFI_OK;
+}
+
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
+         unsigned int nfixedargs, unsigned int ntotalargs)
+{
+  ffi_status status;
+
+  status = ffi_prep_cif_machdep (cif);
+  cif->nfixedargs = nfixedargs;
+  return status;
+}
Index: libffi-3.4.6/src/or1k/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/or1k/sysv.S b/libffi-3.4.6/src/or1k/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/or1k/sysv.S	
@@ -0,0 +1,107 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
+
+   OpenRISC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+.text
+	.globl ffi_call_SYSV
+	.type ffi_call_SYSV, @function
+/*
+  r3: size to allocate on stack
+  r4: extended cif structure
+  r5: function pointer ffi_prep_args
+  r6: ret address
+  r7: function to call
+  r8: flag for return type
+*/
+
+ffi_call_SYSV:
+	/* Store registers used on stack */
+	l.sw -4(r1), r9 /* return address */
+	l.sw -8(r1), r1 /* stack address */
+	l.sw -12(r1), r14 /* callee saved registers */
+	l.sw -16(r1), r16
+	l.sw -20(r1), r18 
+	l.sw -24(r1), r20
+
+	l.ori r14, r1, 0x0 /* save stack pointer */
+	l.addi r1, r1, -24
+
+	l.ori r16, r7, 0x0 /* save function address */
+	l.ori r18, r6, 0x0 /* save ret address */
+	l.ori r20, r8, 0x0 /* save flag */
+
+	l.sub r1, r1, r3 /* reserve space on stack */
+
+	/* Call ffi_prep_args */
+	l.ori r3, r1, 0x0  /* first argument stack address, second already ecif */
+	l.jalr r5
+	l.nop
+
+	/* Load register arguments and call*/
+
+	l.lwz r3, 0(r1)
+	l.lwz r4, 4(r1)
+	l.lwz r5, 8(r1)
+	l.lwz r6, 12(r1)
+	l.lwz r7, 16(r1)
+	l.lwz r8, 20(r1)
+	l.ori r1, r11, 0x0 /* new stack pointer */
+	l.jalr r16
+	l.nop
+	
+	/* handle return values */
+
+	l.sfeqi r20, FFI_TYPE_STRUCT
+	l.bf ret  /* structs don't return an rvalue */
+	l.nop
+
+	/* copy ret address */
+
+	l.sfeqi r20, FFI_TYPE_UINT64
+	l.bnf four_byte_ret  /* 8 byte value is returned */
+	l.nop
+
+	l.sw 4(r18), r12
+
+four_byte_ret:
+	l.sw 0(r18), r11
+
+ret:
+	/* return */
+	l.ori r1, r14, 0x0 /* reset stack pointer */
+	l.lwz r9, -4(r1)
+	l.lwz r1, -8(r1)
+	l.lwz r14, -12(r1)
+	l.lwz r16, -16(r1)
+	l.lwz r18, -20(r1)
+	l.lwz r20, -24(r1)
+	l.jr r9
+	l.nop
+
+.size ffi_call_SYSV, .-ffi_call_SYSV
Index: libffi-3.4.6/src/or1k/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/or1k/ffitarget.h b/libffi-3.4.6/src/or1k/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/or1k/ffitarget.h	
@@ -0,0 +1,58 @@
+/* -----------------------------------------------------------------------
+   ffitarget.h - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
+
+   OpenRISC Target configuration macros
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source. Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+#define FFI_TRAMPOLINE_SIZE (24)
+
+#define FFI_TARGET_SPECIFIC_VARIADIC 1
+#define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs;
+
+#endif
+
Index: libffi-3.4.6/src/s390/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/s390/ffi.c b/libffi-3.4.6/src/s390/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/s390/ffi.c	
@@ -0,0 +1,756 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2000, 2007 Software AG
+           Copyright (c) 2008 Red Hat, Inc
+
+   S390 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+/*====================================================================*/
+/*                          Includes                                  */
+/*                          --------                                  */
+/*====================================================================*/
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdint.h>
+#include "internal.h"
+
+/*====================== End of Includes =============================*/
+
+/*====================================================================*/
+/*                           Defines                                  */
+/*                           -------                                  */
+/*====================================================================*/
+
+/* Maximum number of GPRs available for argument passing.  */
+#define MAX_GPRARGS 5
+
+/* Maximum number of FPRs available for argument passing.  */
+#ifdef __s390x__
+#define MAX_FPRARGS 4
+#else
+#define MAX_FPRARGS 2
+#endif
+
+/* Round to multiple of 16.  */
+#define ROUND_SIZE(size) (((size) + 15) & ~15)
+
+/*===================== End of Defines ===============================*/
+
+/*====================================================================*/
+/*                          Externals                                 */
+/*                          ---------                                 */
+/*====================================================================*/
+
+struct call_frame
+{
+  void *back_chain;
+  void *eos;
+  unsigned long gpr_args[5];
+  unsigned long gpr_save[9];
+  unsigned long long fpr_args[4];
+};
+
+extern void FFI_HIDDEN ffi_call_SYSV(struct call_frame *, unsigned, void *,
+			             void (*fn)(void), void *);
+
+extern void ffi_closure_SYSV(void);
+extern void ffi_go_closure_SYSV(void);
+
+/*====================== End of Externals ============================*/
+
+/*====================================================================*/
+/*                                                                    */
+/* Name     - ffi_check_struct_type.                                  */
+/*                                                                    */
+/* Function - Determine if a structure can be passed within a         */
+/*            general purpose or floating point register.             */
+/*                                                                    */
+/*====================================================================*/
+
+static int
+ffi_check_struct_type (ffi_type *arg)
+{
+  size_t size = arg->size;
+
+  /* If the struct has just one element, look at that element
+     to find out whether to consider the struct as floating point.  */
+  while (arg->type == FFI_TYPE_STRUCT
+         && arg->elements[0] && !arg->elements[1])
+    arg = arg->elements[0];
+
+  /* Structs of size 1, 2, 4, and 8 are passed in registers,
+     just like the corresponding int/float types.  */
+  switch (size)
+    {
+      case 1:
+        return FFI_TYPE_UINT8;
+
+      case 2:
+        return FFI_TYPE_UINT16;
+
+      case 4:
+	if (arg->type == FFI_TYPE_FLOAT)
+          return FFI_TYPE_FLOAT;
+	else
+	  return FFI_TYPE_UINT32;
+
+      case 8:
+	if (arg->type == FFI_TYPE_DOUBLE)
+          return FFI_TYPE_DOUBLE;
+	else
+	  return FFI_TYPE_UINT64;
+
+      default:
+	break;
+    }
+
+  /* Other structs are passed via a pointer to the data.  */
+  return FFI_TYPE_POINTER;
+}
+
+/*======================== End of Routine ============================*/
+
+/*====================================================================*/
+/*                                                                    */
+/* Name     - ffi_prep_cif_machdep.                                   */
+/*                                                                    */
+/* Function - Perform machine dependent CIF processing.               */
+/*                                                                    */
+/*====================================================================*/
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  size_t struct_size = 0;
+  int n_gpr = 0;
+  int n_fpr = 0;
+  int n_ov = 0;
+
+  ffi_type **ptr;
+  int i;
+
+  /* Determine return value handling.  */
+
+  switch (cif->rtype->type)
+    {
+      /* Void is easy.  */
+      case FFI_TYPE_VOID:
+	cif->flags = FFI390_RET_VOID;
+	break;
+
+      /* Structures and complex are returned via a hidden pointer.  */
+      case FFI_TYPE_STRUCT:
+      case FFI_TYPE_COMPLEX:
+	cif->flags = FFI390_RET_STRUCT;
+	n_gpr++;  /* We need one GPR to pass the pointer.  */
+	break;
+
+      /* Floating point values are returned in fpr 0.  */
+      case FFI_TYPE_FLOAT:
+	cif->flags = FFI390_RET_FLOAT;
+	break;
+
+      case FFI_TYPE_DOUBLE:
+	cif->flags = FFI390_RET_DOUBLE;
+	break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      case FFI_TYPE_LONGDOUBLE:
+	cif->flags = FFI390_RET_STRUCT;
+	n_gpr++;
+	break;
+#endif
+      /* Integer values are returned in gpr 2 (and gpr 3
+	 for 64-bit values on 31-bit machines).  */
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+	cif->flags = FFI390_RET_INT64;
+	break;
+
+      case FFI_TYPE_POINTER:
+      case FFI_TYPE_INT:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_SINT16:
+      case FFI_TYPE_UINT8:
+      case FFI_TYPE_SINT8:
+	/* These are to be extended to word size.  */
+#ifdef __s390x__
+	cif->flags = FFI390_RET_INT64;
+#else
+	cif->flags = FFI390_RET_INT32;
+#endif
+	break;
+
+      default:
+        FFI_ASSERT (0);
+        break;
+    }
+
+  /* Now for the arguments.  */
+
+  for (ptr = cif->arg_types, i = cif->nargs;
+       i > 0;
+       i--, ptr++)
+    {
+      int type = (*ptr)->type;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      /* 16-byte long double is passed like a struct.  */
+      if (type == FFI_TYPE_LONGDOUBLE)
+	type = FFI_TYPE_STRUCT;
+#endif
+
+      /* Check how a structure type is passed.  */
+      if (type == FFI_TYPE_STRUCT || type == FFI_TYPE_COMPLEX)
+	{
+	  if (type == FFI_TYPE_COMPLEX)
+	    type = FFI_TYPE_POINTER;
+	  else
+	    type = ffi_check_struct_type (*ptr);
+
+	  /* If we pass the struct via pointer, we must reserve space
+	     to copy its data for proper call-by-value semantics.  */
+	  if (type == FFI_TYPE_POINTER)
+	    struct_size += ROUND_SIZE ((*ptr)->size);
+	}
+
+      /* Now handle all primitive int/float data types.  */
+      switch (type)
+	{
+	  /* The first MAX_FPRARGS floating point arguments
+	     go in FPRs, the rest overflow to the stack.  */
+
+	  case FFI_TYPE_DOUBLE:
+	    if (n_fpr < MAX_FPRARGS)
+	      n_fpr++;
+	    else
+	      n_ov += sizeof (double) / sizeof (long);
+	    break;
+
+	  case FFI_TYPE_FLOAT:
+	    if (n_fpr < MAX_FPRARGS)
+	      n_fpr++;
+	    else
+	      n_ov++;
+	    break;
+
+	  /* On 31-bit machines, 64-bit integers are passed in GPR pairs,
+	     if one is still available, or else on the stack.  If only one
+	     register is free, skip the register (it won't be used for any
+	     subsequent argument either).  */
+
+#ifndef __s390x__
+	  case FFI_TYPE_UINT64:
+	  case FFI_TYPE_SINT64:
+	    if (n_gpr == MAX_GPRARGS-1)
+	      n_gpr = MAX_GPRARGS;
+	    if (n_gpr < MAX_GPRARGS)
+	      n_gpr += 2;
+	    else
+	      n_ov += 2;
+	    break;
+#endif
+
+	  /* Everything else is passed in GPRs (until MAX_GPRARGS
+	     have been used) or overflows to the stack.  */
+
+	  default:
+	    if (n_gpr < MAX_GPRARGS)
+	      n_gpr++;
+	    else
+	      n_ov++;
+	    break;
+        }
+    }
+
+  /* Total stack space as required for overflow arguments
+     and temporary structure copies.  */
+
+  cif->bytes = ROUND_SIZE (n_ov * sizeof (long)) + struct_size;
+
+  return FFI_OK;
+}
+
+/*======================== End of Routine ============================*/
+
+/*====================================================================*/
+/*                                                                    */
+/* Name     - ffi_call.                                               */
+/*                                                                    */
+/* Function - Call the FFI routine.                                   */
+/*                                                                    */
+/*====================================================================*/
+
+static void
+ffi_call_int(ffi_cif *cif,
+	     void (*fn)(void),
+	     void *rvalue,
+	     void **avalue,
+	     void *closure)
+{
+  int ret_type = cif->flags;
+  size_t rsize = 0, bytes = cif->bytes;
+  unsigned char *stack, *p_struct;
+  struct call_frame *frame;
+  unsigned long *p_ov, *p_gpr;
+  unsigned long long *p_fpr;
+  int n_fpr, n_gpr, n_ov, i, n;
+  ffi_type **arg_types;
+
+  FFI_ASSERT (cif->abi == FFI_SYSV);
+
+  /* If we don't have a return value, we need to fake one.  */
+  if (rvalue == NULL)
+    {
+      if (ret_type & FFI390_RET_IN_MEM)
+	rsize = cif->rtype->size;
+      else
+	ret_type = FFI390_RET_VOID;
+    }
+
+  /* The stack space will be filled with those areas:
+
+	dummy structure return		    (highest addresses)
+	  FPR argument register save area
+	  GPR argument register save area
+	stack frame for ffi_call_SYSV
+	temporary struct copies
+	overflow argument area              (lowest addresses)
+
+     We set up the following pointers:
+
+        p_fpr: bottom of the FPR area (growing upwards)
+	p_gpr: bottom of the GPR area (growing upwards)
+	p_ov: bottom of the overflow area (growing upwards)
+	p_struct: top of the struct copy area (growing downwards)
+
+     All areas are kept aligned to twice the word size.
+
+     Note that we're going to create the stack frame for both
+     ffi_call_SYSV _and_ the target function right here.  This
+     works because we don't make any function calls with more
+     than 5 arguments (indeed only memcpy and ffi_call_SYSV),
+     and thus we don't have any stacked outgoing parameters.  */
+
+  stack = alloca (bytes + sizeof(struct call_frame) + rsize);
+  frame = (struct call_frame *)(stack + bytes);
+  if (rsize)
+    rvalue = frame + 1;
+
+  /* Link the new frame back to the one from this function.  */
+  frame->back_chain = __builtin_frame_address (0);
+
+  /* Fill in all of the argument stuff.  */
+  p_ov = (unsigned long *)stack;
+  p_struct = (unsigned char *)frame;
+  p_gpr = frame->gpr_args;
+  p_fpr = frame->fpr_args;
+  n_fpr = n_gpr = n_ov = 0;
+
+  /* If we returning a structure then we set the first parameter register
+     to the address of where we are returning this structure.  */
+  if (cif->flags & FFI390_RET_IN_MEM)
+    p_gpr[n_gpr++] = (uintptr_t) rvalue;
+
+  /* Now for the arguments.  */
+  arg_types = cif->arg_types;
+  for (i = 0, n = cif->nargs; i < n; ++i)
+    {
+      ffi_type *ty = arg_types[i];
+      void *arg = avalue[i];
+      int type = ty->type;
+      ffi_arg val;
+
+    restart:
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	  val = *(SINT8 *)arg;
+	  goto do_int;
+	case FFI_TYPE_UINT8:
+	  val = *(UINT8 *)arg;
+	  goto do_int;
+	case FFI_TYPE_SINT16:
+	  val = *(SINT16 *)arg;
+	  goto do_int;
+	case FFI_TYPE_UINT16:
+	  val = *(UINT16 *)arg;
+	  goto do_int;
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	  val = *(SINT32 *)arg;
+	  goto do_int;
+	case FFI_TYPE_UINT32:
+	  val = *(UINT32 *)arg;
+	  goto do_int;
+	case FFI_TYPE_POINTER:
+	  val = *(uintptr_t *)arg;
+	do_int:
+	  *(n_gpr < MAX_GPRARGS ? p_gpr + n_gpr++ : p_ov + n_ov++) = val;
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+#ifdef __s390x__
+	  val = *(UINT64 *)arg;
+	  goto do_int;
+#else
+	  if (n_gpr == MAX_GPRARGS-1)
+	    n_gpr = MAX_GPRARGS;
+	  if (n_gpr < MAX_GPRARGS)
+	    p_gpr[n_gpr++] = ((UINT32 *) arg)[0],
+	    p_gpr[n_gpr++] = ((UINT32 *) arg)[1];
+	  else
+	    p_ov[n_ov++] = ((UINT32 *) arg)[0],
+	    p_ov[n_ov++] = ((UINT32 *) arg)[1];
+#endif
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (n_fpr < MAX_FPRARGS)
+	    p_fpr[n_fpr++] = *(UINT64 *) arg;
+	  else
+	    {
+#ifdef __s390x__
+	      p_ov[n_ov++] = *(UINT64 *) arg;
+#else
+	      p_ov[n_ov++] = ((UINT32 *) arg)[0],
+	      p_ov[n_ov++] = ((UINT32 *) arg)[1];
+#endif
+	    }
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  val = *(UINT32 *)arg;
+	  if (n_fpr < MAX_FPRARGS)
+	    p_fpr[n_fpr++] = (UINT64)val << 32;
+	  else
+	    p_ov[n_ov++] = val;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+          /* Check how a structure type is passed.  */
+	  type = ffi_check_struct_type (ty);
+	  /* Some structures are passed via a type they contain.  */
+	  if (type != FFI_TYPE_POINTER)
+	    goto restart;
+	  /* ... otherwise, passed by reference.  fallthru.  */
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  /* 16-byte long double is passed via reference.  */
+#endif
+	case FFI_TYPE_COMPLEX:
+	  /* Complex types are passed via reference.  */
+	  p_struct -= ROUND_SIZE (ty->size);
+	  memcpy (p_struct, arg, ty->size);
+	  val = (uintptr_t)p_struct;
+	  goto do_int;
+
+	default:
+	  FFI_ASSERT (0);
+	  break;
+        }
+    }
+
+  ffi_call_SYSV (frame, ret_type & FFI360_RET_MASK, rvalue, fn, closure);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+/*======================== End of Routine ============================*/
+
+/*====================================================================*/
+/*                                                                    */
+/* Name     - ffi_closure_helper_SYSV.                                */
+/*                                                                    */
+/* Function - Call a FFI closure target function.                     */
+/*                                                                    */
+/*====================================================================*/
+
+void FFI_HIDDEN
+ffi_closure_helper_SYSV (ffi_cif *cif,
+			 void (*fun)(ffi_cif*,void*,void**,void*),
+			 void *user_data,
+			 unsigned long *p_gpr,
+			 unsigned long long *p_fpr,
+			 unsigned long *p_ov)
+{
+  unsigned long long ret_buffer;
+
+  void *rvalue = &ret_buffer;
+  void **avalue;
+  void **p_arg;
+
+  int n_gpr = 0;
+  int n_fpr = 0;
+  int n_ov = 0;
+
+  ffi_type **ptr;
+  int i;
+
+  /* Allocate buffer for argument list pointers.  */
+  p_arg = avalue = alloca (cif->nargs * sizeof (void *));
+
+  /* If we returning a structure, pass the structure address
+     directly to the target function.  Otherwise, have the target
+     function store the return value to the GPR save area.  */
+  if (cif->flags & FFI390_RET_IN_MEM)
+    rvalue = (void *) p_gpr[n_gpr++];
+
+  /* Now for the arguments.  */
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, p_arg++, ptr++)
+    {
+      int deref_struct_pointer = 0;
+      int type = (*ptr)->type;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      /* 16-byte long double is passed like a struct.  */
+      if (type == FFI_TYPE_LONGDOUBLE)
+	type = FFI_TYPE_STRUCT;
+#endif
+
+      /* Check how a structure type is passed.  */
+      if (type == FFI_TYPE_STRUCT || type == FFI_TYPE_COMPLEX)
+	{
+	  if (type == FFI_TYPE_COMPLEX)
+	    type = FFI_TYPE_POINTER;
+	  else
+	    type = ffi_check_struct_type (*ptr);
+
+	  /* If we pass the struct via pointer, remember to
+	     retrieve the pointer later.  */
+	  if (type == FFI_TYPE_POINTER)
+	    deref_struct_pointer = 1;
+	}
+
+      /* Pointers are passed like UINTs of the same size.  */
+      if (type == FFI_TYPE_POINTER)
+	{
+#ifdef __s390x__
+	  type = FFI_TYPE_UINT64;
+#else
+	  type = FFI_TYPE_UINT32;
+#endif
+	}
+
+      /* Now handle all primitive int/float data types.  */
+      switch (type)
+	{
+	  case FFI_TYPE_DOUBLE:
+	    if (n_fpr < MAX_FPRARGS)
+	      *p_arg = &p_fpr[n_fpr++];
+	    else
+	      *p_arg = &p_ov[n_ov],
+	      n_ov += sizeof (double) / sizeof (long);
+	    break;
+
+	  case FFI_TYPE_FLOAT:
+	    if (n_fpr < MAX_FPRARGS)
+	      *p_arg = &p_fpr[n_fpr++];
+	    else
+	      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;
+	    break;
+
+	  case FFI_TYPE_UINT64:
+	  case FFI_TYPE_SINT64:
+#ifdef __s390x__
+	    if (n_gpr < MAX_GPRARGS)
+	      *p_arg = &p_gpr[n_gpr++];
+	    else
+	      *p_arg = &p_ov[n_ov++];
+#else
+	    if (n_gpr == MAX_GPRARGS-1)
+	      n_gpr = MAX_GPRARGS;
+	    if (n_gpr < MAX_GPRARGS)
+	      *p_arg = &p_gpr[n_gpr], n_gpr += 2;
+	    else
+	      *p_arg = &p_ov[n_ov], n_ov += 2;
+#endif
+	    break;
+
+	  case FFI_TYPE_INT:
+	  case FFI_TYPE_UINT32:
+	  case FFI_TYPE_SINT32:
+	    if (n_gpr < MAX_GPRARGS)
+	      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 4;
+	    else
+	      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;
+	    break;
+
+	  case FFI_TYPE_UINT16:
+	  case FFI_TYPE_SINT16:
+	    if (n_gpr < MAX_GPRARGS)
+	      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 2;
+	    else
+	      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 2;
+	    break;
+
+	  case FFI_TYPE_UINT8:
+	  case FFI_TYPE_SINT8:
+	    if (n_gpr < MAX_GPRARGS)
+	      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 1;
+	    else
+	      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 1;
+	    break;
+
+	  default:
+	    FFI_ASSERT (0);
+	    break;
+        }
+
+      /* If this is a struct passed via pointer, we need to
+	 actually retrieve that pointer.  */
+      if (deref_struct_pointer)
+	*p_arg = *(void **)*p_arg;
+    }
+
+
+  /* Call the target function.  */
+  (fun) (cif, rvalue, avalue, user_data);
+
+  /* Convert the return value.  */
+  switch (cif->rtype->type)
+    {
+      /* Void is easy, and so is struct.  */
+      case FFI_TYPE_VOID:
+      case FFI_TYPE_STRUCT:
+      case FFI_TYPE_COMPLEX:
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      case FFI_TYPE_LONGDOUBLE:
+#endif
+	break;
+
+      /* Floating point values are returned in fpr 0.  */
+      case FFI_TYPE_FLOAT:
+	p_fpr[0] = (long long) *(unsigned int *) rvalue << 32;
+	break;
+
+      case FFI_TYPE_DOUBLE:
+	p_fpr[0] = *(unsigned long long *) rvalue;
+	break;
+
+      /* Integer values are returned in gpr 2 (and gpr 3
+	 for 64-bit values on 31-bit machines).  */
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+#ifdef __s390x__
+	p_gpr[0] = *(unsigned long *) rvalue;
+#else
+	p_gpr[0] = ((unsigned long *) rvalue)[0],
+	p_gpr[1] = ((unsigned long *) rvalue)[1];
+#endif
+	break;
+
+      case FFI_TYPE_POINTER:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_UINT8:
+	p_gpr[0] = *(unsigned long *) rvalue;
+	break;
+
+      case FFI_TYPE_INT:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_SINT16:
+      case FFI_TYPE_SINT8:
+	p_gpr[0] = *(signed long *) rvalue;
+	break;
+
+      default:
+        FFI_ASSERT (0);
+        break;
+    }
+}
+
+/*======================== End of Routine ============================*/
+
+/*====================================================================*/
+/*                                                                    */
+/* Name     - ffi_prep_closure_loc.                                   */
+/*                                                                    */
+/* Function - Prepare a FFI closure.                                  */
+/*                                                                    */
+/*====================================================================*/
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+		      ffi_cif *cif,
+		      void (*fun) (ffi_cif *, void *, void **, void *),
+		      void *user_data,
+		      void *codeloc)
+{
+  static unsigned short const template[] = {
+    0x0d10,			/* basr %r1,0 */
+#ifndef __s390x__
+    0x9801, 0x1006,		/* lm %r0,%r1,6(%r1) */
+#else
+    0xeb01, 0x100e, 0x0004,	/* lmg %r0,%r1,14(%r1) */
+#endif
+    0x07f1			/* br %r1 */
+  };
+
+  unsigned long *tramp = (unsigned long *)&closure->tramp;
+
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  memcpy (tramp, template, sizeof(template));
+  tramp[2] = (unsigned long)codeloc;
+  tramp[3] = (unsigned long)&ffi_closure_SYSV;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+/*======================== End of Routine ============================*/
+
+/* Build a Go language closure.  */
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun)(ffi_cif*,void*,void**,void*))
+{
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  closure->tramp = ffi_go_closure_SYSV;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/s390/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/s390/sysv.S b/libffi-3.4.6/src/s390/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/s390/sysv.S	
@@ -0,0 +1,325 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2000 Software AG
+            Copyright (c) 2008 Red Hat, Inc.
+
+   S390 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.text
+
+#ifndef __s390x__
+
+	# r2:	frame
+	# r3:	ret_type
+	# r4:	ret_addr
+	# r5:	fun
+	# r6:	closure
+
+	# This assumes we are using gas.
+	.balign	8
+	.globl	ffi_call_SYSV
+	FFI_HIDDEN(ffi_call_SYSV)
+	.type	ffi_call_SYSV,%function
+ffi_call_SYSV:
+	.cfi_startproc
+	st	%r6,44(%r2)			# Save registers
+	stm	%r12,%r14,48(%r2)
+	lr	%r13,%r2			# Install frame pointer
+	.cfi_rel_offset r6, 44
+	.cfi_rel_offset r12, 48
+	.cfi_rel_offset r13, 52
+	.cfi_rel_offset r14, 56
+	.cfi_def_cfa_register r13
+	st	%r2,0(%r15)			# Set up back chain
+	sla	%r3,3				# ret_type *= 8
+	lr	%r12,%r4			# Save ret_addr
+	lr	%r1,%r5				# Save fun
+	lr	%r0,%r6				# Install static chain
+
+	# Set return address, so that there is only one indirect jump.
+#ifdef HAVE_AS_S390_ZARCH
+	larl	%r14,.Ltable
+	ar	%r14,%r3
+#else
+	basr	%r14,0
+0:	la	%r14,.Ltable-0b(%r14,%r3)
+#endif
+
+	lm	%r2,%r6,8(%r13)			# Load arguments
+	ld	%f0,64(%r13)
+	ld	%f2,72(%r13)
+	br	%r1				# ... and call function
+
+	.balign	8
+.Ltable:
+# FFI390_RET_DOUBLE
+	std	%f0,0(%r12)
+	j	.Ldone
+
+	.balign	8
+# FFI390_RET_FLOAT
+	ste	%f0,0(%r12)
+	j	.Ldone
+
+	.balign	8
+# FFI390_RET_INT64
+	st	%r3,4(%r12)
+	nop
+	# fallthru
+
+	.balign	8
+# FFI390_RET_INT32
+	st	%r2,0(%r12)
+	nop
+	# fallthru
+
+	.balign	8
+# FFI390_RET_VOID
+.Ldone:
+	l	%r14,56(%r13)
+	l	%r12,48(%r13)
+	l	%r6,44(%r13)
+	l	%r13,52(%r13)
+	.cfi_restore 14
+	.cfi_restore 13
+	.cfi_restore 12
+	.cfi_restore 6
+	.cfi_def_cfa r15, 96
+	br	%r14
+	.cfi_endproc
+	.size	 ffi_call_SYSV,.-ffi_call_SYSV
+
+
+	.balign	8
+	.globl	ffi_go_closure_SYSV
+	FFI_HIDDEN(ffi_go_closure_SYSV)
+	.type	ffi_go_closure_SYSV,%function
+ffi_go_closure_SYSV:
+	.cfi_startproc
+	stm	%r2,%r6,8(%r15)			# Save arguments
+	lr	%r4,%r0				# Load closure -> user_data
+	l	%r2,4(%r4)			#   ->cif
+	l	%r3,8(%r4)			#   ->fun
+	j	.Ldoclosure
+	.cfi_endproc
+
+	.balign	8
+	.globl	ffi_closure_SYSV
+	FFI_HIDDEN(ffi_closure_SYSV)
+	.type	ffi_closure_SYSV,%function
+ffi_closure_SYSV:
+	.cfi_startproc
+	stm	%r2,%r6,8(%r15)			# Save arguments
+	lr	%r4,%r0				# Closure
+	l	%r2,16(%r4)			#   ->cif
+	l	%r3,20(%r4)			#   ->fun
+	l	%r4,24(%r4)			#   ->user_data
+.Ldoclosure:
+	stm	%r12,%r15,48(%r15)		# Save registers
+	lr	%r12,%r15
+	.cfi_def_cfa_register r12
+	.cfi_rel_offset r6, 24
+	.cfi_rel_offset r12, 48
+	.cfi_rel_offset r13, 52
+	.cfi_rel_offset r14, 56
+	.cfi_rel_offset r15, 60
+#ifndef HAVE_AS_S390_ZARCH
+	basr	%r13,0				# Set up base register
+.Lcbase:
+	l	%r1,.Lchelper-.Lcbase(%r13)	# Get helper function
+#endif
+	ahi	%r15,-96-8			# Set up stack frame
+	st	%r12,0(%r15)			# Set up back chain
+
+	std	%f0,64(%r12)			# Save fp arguments
+	std	%f2,72(%r12)
+
+	la	%r5,96(%r12)			# Overflow
+	st	%r5,96(%r15)
+	la	%r6,64(%r12)			# FPRs
+	la	%r5,8(%r12)			# GPRs
+#ifdef HAVE_AS_S390_ZARCH
+	brasl	%r14,ffi_closure_helper_SYSV
+#else
+	bas	%r14,0(%r1,%r13)		# Call helper
+#endif
+
+	lr	%r15,%r12
+	.cfi_def_cfa_register r15
+	lm	%r12,%r14,48(%r12)		# Restore saved registers
+	l	%r6,24(%r15)
+	ld	%f0,64(%r15)			# Load return registers
+	lm	%r2,%r3,8(%r15)
+	br	%r14
+	.cfi_endproc
+
+#ifndef HAVE_AS_S390_ZARCH
+	.align 4
+.Lchelper:
+	.long	ffi_closure_helper_SYSV-.Lcbase
+#endif
+
+	.size	 ffi_closure_SYSV,.-ffi_closure_SYSV
+
+#else
+
+	# r2:	frame
+	# r3:	ret_type
+	# r4:	ret_addr
+	# r5:	fun
+	# r6:	closure
+
+	# This assumes we are using gas.
+	.balign	8
+	.globl	ffi_call_SYSV
+	FFI_HIDDEN(ffi_call_SYSV)
+	.type	ffi_call_SYSV,%function
+ffi_call_SYSV:
+	.cfi_startproc
+	stg	%r6,88(%r2)			# Save registers
+	stmg	%r12,%r14,96(%r2)
+	lgr	%r13,%r2			# Install frame pointer
+	.cfi_rel_offset r6, 88
+	.cfi_rel_offset r12, 96
+	.cfi_rel_offset r13, 104
+	.cfi_rel_offset r14, 112
+	.cfi_def_cfa_register r13
+	stg	%r2,0(%r15)			# Set up back chain
+	larl	%r14,.Ltable			# Set up return address
+	slag	%r3,%r3,3			# ret_type *= 8
+	lgr	%r12,%r4			# Save ret_addr
+	lgr	%r1,%r5				# Save fun
+	lgr	%r0,%r6				# Install static chain
+	agr	%r14,%r3
+	lmg	%r2,%r6,16(%r13)		# Load arguments
+	ld	%f0,128(%r13)
+	ld	%f2,136(%r13)
+	ld	%f4,144(%r13)
+	ld	%f6,152(%r13)
+	br	%r1				# ... and call function
+
+	.balign	8
+.Ltable:
+# FFI390_RET_DOUBLE
+	std	%f0,0(%r12)
+	j	.Ldone
+
+	.balign	8
+# FFI390_RET_DOUBLE
+	ste	%f0,0(%r12)
+	j	.Ldone
+
+	.balign	8
+# FFI390_RET_INT64
+	stg	%r2,0(%r12)
+
+	.balign	8
+# FFI390_RET_INT32
+	# Never used, as we always store type ffi_arg.
+	# But the stg above is 6 bytes and we cannot
+	# jump around this case, so fall through.
+	nop
+	nop
+
+	.balign	8
+# FFI390_RET_VOID
+.Ldone:
+	lg	%r14,112(%r13)
+	lg	%r12,96(%r13)
+	lg	%r6,88(%r13)
+	lg	%r13,104(%r13)
+	.cfi_restore r14
+	.cfi_restore r13
+	.cfi_restore r12
+	.cfi_restore r6
+	.cfi_def_cfa r15, 160
+	br	%r14
+	.cfi_endproc
+	.size	 ffi_call_SYSV,.-ffi_call_SYSV
+
+
+	.balign	8
+	.globl	ffi_go_closure_SYSV
+	FFI_HIDDEN(ffi_go_closure_SYSV)
+	.type	ffi_go_closure_SYSV,%function
+ffi_go_closure_SYSV:
+	.cfi_startproc
+	stmg	%r2,%r6,16(%r15)		# Save arguments
+	lgr	%r4,%r0				# Load closure -> user_data
+	lg	%r2,8(%r4)			#   ->cif
+	lg	%r3,16(%r4)			#   ->fun
+	j	.Ldoclosure
+	.cfi_endproc
+	.size	 ffi_go_closure_SYSV,.-ffi_go_closure_SYSV
+
+
+	.balign	8
+	.globl	ffi_closure_SYSV
+	FFI_HIDDEN(ffi_closure_SYSV)
+	.type	ffi_closure_SYSV,%function
+ffi_closure_SYSV:
+	.cfi_startproc
+	stmg	%r2,%r6,16(%r15)		# Save arguments
+	lgr	%r4,%r0				# Load closure
+	lg	%r2,32(%r4)			#   ->cif
+	lg	%r3,40(%r4)			#   ->fun
+	lg	%r4,48(%r4)			#   ->user_data
+.Ldoclosure:
+	stmg	%r13,%r15,104(%r15)		# Save registers
+	lgr	%r13,%r15
+	.cfi_def_cfa_register r13
+	.cfi_rel_offset r6, 48
+	.cfi_rel_offset r13, 104
+	.cfi_rel_offset r14, 112
+	.cfi_rel_offset r15, 120
+	aghi	%r15,-160-16			# Set up stack frame
+	stg	%r13,0(%r15)			# Set up back chain
+
+	std	%f0,128(%r13)			# Save fp arguments
+	std	%f2,136(%r13)
+	std	%f4,144(%r13)
+	std	%f6,152(%r13)
+	la	%r5,160(%r13)			# Overflow
+	stg	%r5,160(%r15)
+	la	%r6,128(%r13)			# FPRs
+	la	%r5,16(%r13)			# GPRs
+	brasl	%r14,ffi_closure_helper_SYSV	# Call helper
+
+	lgr	%r15,%r13
+	.cfi_def_cfa_register r15
+	lmg	%r13,%r14,104(%r13)		# Restore saved registers
+	lg	%r6,48(%r15)
+	ld	%f0,128(%r15)			# Load return registers
+	lg	%r2,16(%r15)
+	br	%r14
+	.cfi_endproc
+	.size	 ffi_closure_SYSV,.-ffi_closure_SYSV
+#endif /* !s390x */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/s390/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/s390/internal.h b/libffi-3.4.6/src/s390/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/s390/internal.h	
@@ -0,0 +1,11 @@
+/* If these values change, sysv.S must be adapted!  */
+#define FFI390_RET_DOUBLE	0
+#define FFI390_RET_FLOAT	1
+#define FFI390_RET_INT64	2
+#define FFI390_RET_INT32	3
+#define FFI390_RET_VOID		4
+
+#define FFI360_RET_MASK		7
+#define FFI390_RET_IN_MEM	8
+
+#define FFI390_RET_STRUCT	(FFI390_RET_VOID | FFI390_RET_IN_MEM)
Index: libffi-3.4.6/src/s390/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/s390/ffitarget.h b/libffi-3.4.6/src/s390/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/s390/ffitarget.h	
@@ -0,0 +1,70 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for S390.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#if defined (__s390x__)
+#ifndef S390X
+#define S390X
+#endif
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#ifdef S390X
+#define FFI_TRAMPOLINE_SIZE 32
+#else
+#define FFI_TRAMPOLINE_SIZE 16
+#endif
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
Index: libffi-3.4.6/src/sh64/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh64/ffi.c b/libffi-3.4.6/src/sh64/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh64/ffi.c	
@@ -0,0 +1,469 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2003, 2004, 2006, 2007, 2012 Kaz Kojima
+           Copyright (c) 2008 Anthony Green
+   
+   SuperH SHmedia Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+#define NGREGARG 8
+#define NFREGARG 12
+
+static int
+return_type (ffi_type *arg)
+{
+
+  if (arg->type != FFI_TYPE_STRUCT)
+    return arg->type;
+
+  /* gcc uses r2 if the result can be packed in on register.  */
+  if (arg->size <= sizeof (UINT8))
+    return FFI_TYPE_UINT8;
+  else if (arg->size <= sizeof (UINT16))
+    return FFI_TYPE_UINT16;
+  else if (arg->size <= sizeof (UINT32))
+    return FFI_TYPE_UINT32;
+  else if (arg->size <= sizeof (UINT64))
+    return FFI_TYPE_UINT64;
+
+  return FFI_TYPE_STRUCT;
+}
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  register unsigned int i;
+  register unsigned int avn;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+
+  argp = stack;
+
+  if (return_type (ecif->cif->rtype) == FFI_TYPE_STRUCT)
+    {
+      *(void **) argp = ecif->rvalue;
+      argp += sizeof (UINT64);
+    }
+
+  avn = ecif->cif->nargs;
+  p_argv = ecif->avalue;
+
+  for (i = 0, p_arg = ecif->cif->arg_types; i < avn; i++, p_arg++, p_argv++)
+    {
+      size_t z;
+      int align;
+
+      z = (*p_arg)->size;
+      align = (*p_arg)->alignment;
+      if (z < sizeof (UINT32))
+	{
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(SINT64 *) argp = (SINT64) *(SINT8 *)(*p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT8:
+	      *(UINT64 *) argp = (UINT64) *(UINT8 *)(*p_argv);
+	      break;
+  
+	    case FFI_TYPE_SINT16:
+	      *(SINT64 *) argp = (SINT64) *(SINT16 *)(*p_argv);
+	      break;
+  
+	    case FFI_TYPE_UINT16:
+	      *(UINT64 *) argp = (UINT64) *(UINT16 *)(*p_argv);
+	      break;
+  
+	    case FFI_TYPE_STRUCT:
+	      memcpy (argp, *p_argv, z);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	  argp += sizeof (UINT64);
+	}
+      else if (z == sizeof (UINT32) && align == sizeof (UINT32))
+	{
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_INT:
+	    case FFI_TYPE_SINT32:
+	      *(SINT64 *) argp = (SINT64) *(SINT32 *) (*p_argv);
+	      break;
+
+	    case FFI_TYPE_FLOAT:
+	    case FFI_TYPE_POINTER:
+	    case FFI_TYPE_UINT32:
+	    case FFI_TYPE_STRUCT:
+	      *(UINT64 *) argp = (UINT64) *(UINT32 *) (*p_argv);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	      break;
+	    }
+	  argp += sizeof (UINT64);
+	}
+      else if (z == sizeof (UINT64)
+	       && align == sizeof (UINT64)
+	       && ((int) *p_argv & (sizeof (UINT64) - 1)) == 0)
+	{
+	  *(UINT64 *) argp = *(UINT64 *) (*p_argv);
+	  argp += sizeof (UINT64);
+	}
+      else
+	{
+	  int n = (z + sizeof (UINT64) - 1) / sizeof (UINT64);
+
+	  memcpy (argp, *p_argv, z);
+	  argp += n * sizeof (UINT64);
+	}
+    }
+
+  return;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  int i, j;
+  int size, type;
+  int n, m;
+  int greg;
+  int freg;
+  int fpair = -1;
+
+  greg = (return_type (cif->rtype) == FFI_TYPE_STRUCT ? 1 : 0);
+  freg = 0;
+  cif->flags2 = 0;
+
+  for (i = j = 0; i < cif->nargs; i++)
+    {
+      type = (cif->arg_types)[i]->type;
+      switch (type)
+	{
+	case FFI_TYPE_FLOAT:
+	  greg++;
+	  cif->bytes += sizeof (UINT64) - sizeof (float);
+	  if (freg >= NFREGARG - 1)
+	    continue;
+	  if (fpair < 0)
+	    {
+	      fpair = freg;
+	      freg += 2;
+	    }
+	  else
+	    fpair = -1;
+	  cif->flags2 += ((cif->arg_types)[i]->type) << (2 * j++);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (greg++ >= NGREGARG && (freg + 1) >= NFREGARG)
+	    continue;
+	  if ((freg + 1) < NFREGARG)
+	    {
+	      freg += 2;
+	      cif->flags2 += ((cif->arg_types)[i]->type) << (2 * j++);
+	    }
+	  else
+	    cif->flags2 += FFI_TYPE_INT << (2 * j++);
+	  break;
+	      
+	default:
+	  size = (cif->arg_types)[i]->size;
+	  if (size < sizeof (UINT64))
+	    cif->bytes += sizeof (UINT64) - size;
+	  n = (size + sizeof (UINT64) - 1) / sizeof (UINT64);
+	  if (greg >= NGREGARG)
+	    continue;
+	  else if (greg + n - 1 >= NGREGARG)
+	    greg = NGREGARG;
+	  else
+	    greg += n;
+	  for (m = 0; m < n; m++)
+	    cif->flags2 += FFI_TYPE_INT << (2 * j++);
+	  break;
+	}
+    }
+
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_STRUCT:
+      cif->flags = return_type (cif->rtype);
+      break;
+
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      cif->flags = cif->rtype->type;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+/*@-declundef@*/
+/*@-exportheader@*/
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
+			  /*@out@*/ extended_cif *, 
+			  unsigned, unsigned, long long,
+			  /*@out@*/ unsigned *, 
+			  void (*fn)(void));
+/*@=declundef@*/
+/*@=exportheader@*/
+
+void ffi_call(/*@dependent@*/ ffi_cif *cif, 
+	      void (*fn)(void), 
+	      /*@out@*/ void *rvalue, 
+	      /*@dependent@*/ void **avalue)
+{
+  extended_cif ecif;
+  UINT64 trvalue;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)
+    ecif.rvalue = &trvalue;
+  else if ((rvalue == NULL) && 
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi) 
+    {
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, cif->flags2,
+		    ecif.rvalue, fn);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  if (rvalue
+      && cif->rtype->type == FFI_TYPE_STRUCT
+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)
+    memcpy (rvalue, &trvalue, cif->rtype->size);
+}
+
+extern void ffi_closure_SYSV (void);
+extern void __ic_invalidate (void *line);
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp;
+
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  tramp = (unsigned int *) &closure->tramp[0];
+  /* Since ffi_closure is an aligned object, the ffi trampoline is
+     called as an SHcompact code.  Sigh.
+     SHcompact part:
+     mova @(1,pc),r0; add #1,r0; jmp @r0; nop;
+     SHmedia part:
+     movi fnaddr >> 16,r1; shori fnaddr,r1; ptabs/l r1,tr0
+     movi cxt >> 16,r1; shori cxt,r1; blink tr0,r63  */
+#ifdef __LITTLE_ENDIAN__
+  tramp[0] = 0x7001c701;
+  tramp[1] = 0x0009402b;
+#else
+  tramp[0] = 0xc7017001;
+  tramp[1] = 0x402b0009;
+#endif
+  tramp[2] = 0xcc000010 | (((UINT32) ffi_closure_SYSV) >> 16) << 10;
+  tramp[3] = 0xc8000010 | (((UINT32) ffi_closure_SYSV) & 0xffff) << 10;
+  tramp[4] = 0x6bf10600;
+  tramp[5] = 0xcc000010 | (((UINT32) codeloc) >> 16) << 10;
+  tramp[6] = 0xc8000010 | (((UINT32) codeloc) & 0xffff) << 10;
+  tramp[7] = 0x4401fff0;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  /* Flush the icache.  */
+  asm volatile ("ocbwb %0,0; synco; icbi %1,0; synci" : : "r" (tramp),
+		"r"(codeloc));
+
+  return FFI_OK;
+}
+
+/* Basically the trampoline invokes ffi_closure_SYSV, and on 
+ * entry, r3 holds the address of the closure.
+ * After storing the registers that could possibly contain
+ * parameters to be passed into the stack frame and setting
+ * up space for a return value, ffi_closure_SYSV invokes the 
+ * following helper function to do most of the work.
+ */
+
+int
+ffi_closure_helper_SYSV (ffi_closure *closure, UINT64 *rvalue, 
+			 UINT64 *pgr, UINT64 *pfr, UINT64 *pst)
+{
+  void **avalue;
+  ffi_type **p_arg;
+  int i, avn;
+  int greg, freg;
+  ffi_cif *cif;
+  int fpair = -1;
+
+  cif = closure->cif;
+  avalue = alloca (cif->nargs * sizeof (void *));
+
+  /* Copy the caller's structure return value address so that the closure
+     returns the data directly to the caller.  */
+  if (return_type (cif->rtype) == FFI_TYPE_STRUCT)
+    {
+      rvalue = (UINT64 *) *pgr;
+      greg = 1;
+    }
+  else
+    greg = 0;
+
+  freg = 0;
+  cif = closure->cif;
+  avn = cif->nargs;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)
+    {
+      size_t z;
+      void *p;
+
+      z = (*p_arg)->size;
+      if (z < sizeof (UINT32))
+	{
+	  p = pgr + greg++;
+
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	    case FFI_TYPE_UINT8:
+	    case FFI_TYPE_SINT16:
+	    case FFI_TYPE_UINT16:
+	    case FFI_TYPE_STRUCT:
+#ifdef __LITTLE_ENDIAN__
+	      avalue[i] = p;
+#else
+	      avalue[i] = ((char *) p) + sizeof (UINT32) - z;
+#endif
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	}
+      else if (z == sizeof (UINT32))
+	{
+	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
+	    {
+	      if (freg < NFREGARG - 1)
+		{
+		  if (fpair >= 0)
+		    {
+		      avalue[i] = (UINT32 *) pfr + fpair;
+		      fpair = -1;
+		    }
+		  else
+		    {
+#ifdef __LITTLE_ENDIAN__
+		      fpair = freg;
+		      avalue[i] = (UINT32 *) pfr + (1 ^ freg);
+#else
+		      fpair = 1 ^ freg;
+		      avalue[i] = (UINT32 *) pfr + freg;
+#endif
+		      freg += 2;
+		    }
+		}
+	      else
+#ifdef __LITTLE_ENDIAN__
+		avalue[i] = pgr + greg;
+#else
+		avalue[i] = (UINT32 *) (pgr + greg) + 1;
+#endif
+	    }
+	  else
+#ifdef __LITTLE_ENDIAN__
+	    avalue[i] = pgr + greg;
+#else
+	    avalue[i] = (UINT32 *) (pgr + greg) + 1;
+#endif
+	  greg++;
+	}
+      else if ((*p_arg)->type == FFI_TYPE_DOUBLE)
+	{
+	  if (freg + 1 >= NFREGARG)
+	    avalue[i] = pgr + greg;
+	  else
+	    {
+	      avalue[i] = pfr + (freg >> 1);
+	      freg += 2;
+	    }
+	  greg++;
+	}
+      else
+	{
+	  int n = (z + sizeof (UINT64) - 1) / sizeof (UINT64);
+
+	  avalue[i] = pgr + greg;
+	  greg += n;
+	}
+    }
+
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  /* Tell ffi_closure_SYSV how to perform return type promotions.  */
+  return return_type (cif->rtype);
+}
+
Index: libffi-3.4.6/src/sh64/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh64/sysv.S b/libffi-3.4.6/src/sh64/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh64/sysv.S	
@@ -0,0 +1,539 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2003, 2004, 2006, 2008 Kaz Kojima
+   
+   SuperH SHmedia Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+ 
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+/* XXX these lose for some platforms, I'm sure. */
+#define CNAME(x) x
+#define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):
+#endif
+
+#ifdef __LITTLE_ENDIAN__
+#define OFS_FLT	0
+#else
+#define OFS_FLT	4
+#endif
+
+	.section	.text..SHmedia32,"ax"
+
+	# r2:	ffi_prep_args
+	# r3:	&ecif
+	# r4:	bytes
+	# r5:	flags
+	# r6:	flags2
+	# r7:	rvalue
+	# r8:	fn
+
+	# This assumes we are using gas.
+	.align	5
+ENTRY(ffi_call_SYSV)
+	# Save registers
+.LFB1:
+	addi.l	r15, -48, r15
+.LCFI0:
+	st.q	r15, 40, r32
+	st.q	r15, 32, r31
+	st.q	r15, 24, r30
+	st.q	r15, 16, r29
+	st.q	r15, 8, r28
+	st.l	r15, 4, r18
+	st.l	r15, 0, r14
+.LCFI1:
+	add.l	r15, r63, r14
+.LCFI2:
+#	add	r4, r63, r28
+	add	r5, r63, r29
+	add	r6, r63, r30
+	add	r7, r63, r31
+	add	r8, r63, r32
+
+	addi	r4, (64 + 7), r4
+	andi	r4, ~7, r4
+	sub.l	r15, r4, r15
+
+	ptabs/l	r2, tr0
+	add	r15, r63, r2
+	blink	tr0, r18
+
+	addi	r15, 64, r22
+	movi	0, r0
+	movi	0, r1
+	movi	-1, r23
+
+	pt/l	1f, tr1
+	bnei/l	r29, FFI_TYPE_STRUCT, tr1
+	ld.l	r15, 0, r19
+	addi	r15, 8, r15
+	addi	r0, 1, r0
+1:
+
+.L_pass:
+	andi	r30, 3, r20
+	shlri	r30, 2, r30
+
+	pt/l	.L_call_it, tr0
+	pt/l	.L_pass_i, tr1
+	pt/l	.L_pass_f, tr2
+
+	beqi/l	r20, FFI_TYPE_VOID, tr0
+	beqi/l	r20, FFI_TYPE_INT, tr1
+	beqi/l	r20, FFI_TYPE_FLOAT, tr2
+
+.L_pass_d:
+	addi	r0, 1, r0
+	pt/l	3f, tr0
+	movi	12, r20
+	bge/l	r1, r20, tr0
+
+	pt/l	.L_pop_d, tr1
+	pt/l	2f, tr0
+	blink	tr1, r63
+2:
+	addi.l	r15, 8, r15
+3:
+	pt/l	.L_pass, tr0
+	addi	r1, 2, r1
+	blink	tr0, r63
+
+.L_pop_d:
+	pt/l	.L_pop_d_tbl, tr1
+	gettr	tr1, r20
+	shlli	r1, 2, r21
+	add	r20, r21, r20
+	ptabs/l	r20, tr1
+	blink	tr1, r63
+
+.L_pop_d_tbl:
+	fld.d	r15, 0, dr0
+	blink	tr0, r63
+	fld.d	r15, 0, dr2
+	blink	tr0, r63
+	fld.d	r15, 0, dr4
+	blink	tr0, r63
+	fld.d	r15, 0, dr6
+	blink	tr0, r63
+	fld.d	r15, 0, dr8
+	blink	tr0, r63
+	fld.d	r15, 0, dr10
+	blink	tr0, r63
+
+.L_pass_f:
+	addi	r0, 1, r0
+	pt/l	3f, tr0
+	movi	12, r20
+	bge/l	r1, r20, tr0
+
+	pt/l	.L_pop_f, tr1
+	pt/l	2f, tr0
+	blink	tr1, r63
+2:
+	addi.l	r15, 8, r15
+3:
+	pt/l	.L_pass, tr0
+	blink	tr0, r63
+
+.L_pop_f:
+	pt/l	.L_pop_f_tbl, tr1
+	pt/l	5f, tr2
+	gettr	tr1, r20
+	bge/l	r23, r63, tr2
+	add	r1, r63, r23 
+	shlli	r1, 3, r21
+	addi	r1, 2, r1
+	add	r20, r21, r20
+	ptabs/l	r20, tr1
+	blink	tr1, r63
+5:
+	addi	r23, 1, r21
+	movi	-1, r23
+	shlli	r21, 3, r21
+	add	r20, r21, r20
+	ptabs/l	r20, tr1
+	blink	tr1, r63
+
+.L_pop_f_tbl:
+	fld.s	r15, OFS_FLT, fr0
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr1
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr2
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr3
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr4
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr5
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr6
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr7
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr8
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr9
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr10
+	blink	tr0, r63
+	fld.s	r15, OFS_FLT, fr11
+	blink	tr0, r63
+
+.L_pass_i:
+	pt/l	3f, tr0
+	movi	8, r20
+	bge/l	r0, r20, tr0
+
+	pt/l	.L_pop_i, tr1
+	pt/l	2f, tr0
+	blink	tr1, r63
+2:
+	addi.l	r15, 8, r15
+3:
+	pt/l	.L_pass, tr0
+	addi	r0, 1, r0
+	blink	tr0, r63
+
+.L_pop_i:
+	pt/l	.L_pop_i_tbl, tr1
+	gettr	tr1, r20
+	shlli	r0, 3, r21
+	add	r20, r21, r20
+	ptabs/l	r20, tr1
+	blink	tr1, r63
+
+.L_pop_i_tbl:
+	ld.q	r15, 0, r2
+	blink	tr0, r63
+	ld.q	r15, 0, r3
+	blink	tr0, r63
+	ld.q	r15, 0, r4
+	blink	tr0, r63
+	ld.q	r15, 0, r5
+	blink	tr0, r63
+	ld.q	r15, 0, r6
+	blink	tr0, r63
+	ld.q	r15, 0, r7
+	blink	tr0, r63
+	ld.q	r15, 0, r8
+	blink	tr0, r63
+	ld.q	r15, 0, r9
+	blink	tr0, r63
+
+.L_call_it:
+	# call function
+	pt/l	1f, tr1
+	bnei/l	r29, FFI_TYPE_STRUCT, tr1
+	add	r19, r63, r2
+1:
+	add	r22, r63, r15
+	ptabs/l	r32, tr0
+	blink	tr0, r18
+
+	pt/l	.L_ret_i, tr0
+	pt/l	.L_ret_ll, tr1
+	pt/l	.L_ret_d, tr2
+	pt/l	.L_ret_f, tr3
+	pt/l	.L_epilogue, tr4
+
+	beqi/l	r29, FFI_TYPE_INT, tr0
+	beqi/l	r29, FFI_TYPE_UINT32, tr0
+	beqi/l	r29, FFI_TYPE_SINT64, tr1
+	beqi/l	r29, FFI_TYPE_UINT64, tr1
+	beqi/l	r29, FFI_TYPE_DOUBLE, tr2
+	beqi/l	r29, FFI_TYPE_FLOAT, tr3
+
+	pt/l	.L_ret_q, tr0
+	pt/l	.L_ret_h, tr1
+
+	beqi/l	r29, FFI_TYPE_UINT8, tr0
+	beqi/l	r29, FFI_TYPE_UINT16, tr1
+	blink	tr4, r63
+
+.L_ret_d:
+	fst.d	r31, 0, dr0
+	blink	tr4, r63
+
+.L_ret_ll:
+	st.q	r31, 0, r2
+	blink	tr4, r63
+
+.L_ret_f:
+	fst.s	r31, OFS_FLT, fr0
+	blink	tr4, r63
+
+.L_ret_q:
+	st.b	r31, 0, r2
+	blink	tr4, r63
+
+.L_ret_h:
+	st.w	r31, 0, r2
+	blink	tr4, r63
+
+.L_ret_i:
+	st.l	r31, 0, r2
+	# Fall
+
+.L_epilogue:
+	# Remove the space we pushed for the args
+	add	r14, r63, r15
+
+	ld.l	r15, 0, r14
+	ld.l	r15, 4, r18
+	ld.q	r15, 8, r28
+	ld.q	r15, 16, r29
+	ld.q	r15, 24, r30
+	ld.q	r15, 32, r31
+	ld.q	r15, 40, r32
+	addi.l	r15, 48, r15
+	ptabs	r18, tr0
+	blink	tr0, r63
+
+.LFE1:
+.ffi_call_SYSV_end:
+	.size	 CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
+
+	.align	5
+ENTRY(ffi_closure_SYSV)
+.LFB2:
+	addi.l	r15, -136, r15
+.LCFI3:
+	st.l	r15, 12, r18
+	st.l	r15, 8, r14
+	st.l	r15, 4, r12
+.LCFI4:
+	add	r15, r63, r14
+.LCFI5:
+	/* Stack layout:	
+	   ...
+	   64 bytes (register parameters)
+	   48 bytes (floating register parameters)
+	    8 bytes (result)
+	    4 bytes (r18)
+	    4 bytes (r14)
+	    4 bytes (r12)
+	    4 bytes (for align)
+	   <- new stack pointer
+	*/
+	fst.d	r14, 24, dr0
+	fst.d	r14, 32, dr2
+	fst.d	r14, 40, dr4
+	fst.d	r14, 48, dr6
+	fst.d	r14, 56, dr8
+	fst.d	r14, 64, dr10
+	st.q	r14, 72, r2
+	st.q	r14, 80, r3
+	st.q	r14, 88, r4
+	st.q	r14, 96, r5
+	st.q	r14, 104, r6
+	st.q	r14, 112, r7
+	st.q	r14, 120, r8
+	st.q	r14, 128, r9
+
+	add	r1, r63, r2
+	addi	r14, 16, r3
+	addi	r14, 72, r4
+	addi	r14, 24, r5
+	addi	r14, 136, r6
+#ifdef PIC
+	movi	(((datalabel _GLOBAL_OFFSET_TABLE_-(.LPCS0-.)) >> 16) & 65535), r12
+        shori	((datalabel _GLOBAL_OFFSET_TABLE_-(.LPCS0-.)) & 65535), r12
+.LPCS0:	ptrel/u r12, tr0
+	movi	((ffi_closure_helper_SYSV@GOTPLT) & 65535), r1
+	gettr	tr0, r12
+	ldx.l	r1, r12, r1
+	ptabs	r1, tr0
+#else
+	pt/l	ffi_closure_helper_SYSV, tr0
+#endif
+	blink	tr0, r18
+
+	shlli	r2, 1, r1
+        movi    (((datalabel .L_table) >> 16) & 65535), r2
+        shori   ((datalabel .L_table) & 65535), r2
+        ldx.w   r2, r1, r1
+        add     r1, r2, r1
+	pt/l	.L_case_v, tr1
+        ptabs   r1, tr0
+        blink   tr0, r63
+
+        .align 2
+.L_table:
+	.word	.L_case_v - datalabel .L_table	/* FFI_TYPE_VOID */
+	.word	.L_case_i - datalabel .L_table	/* FFI_TYPE_INT */
+	.word	.L_case_f - datalabel .L_table	/* FFI_TYPE_FLOAT */
+	.word	.L_case_d - datalabel .L_table	/* FFI_TYPE_DOUBLE */
+	.word	.L_case_d - datalabel .L_table	/* FFI_TYPE_LONGDOUBLE */
+	.word	.L_case_uq - datalabel .L_table	/* FFI_TYPE_UINT8 */
+	.word	.L_case_q - datalabel .L_table	/* FFI_TYPE_SINT8 */
+	.word	.L_case_uh - datalabel .L_table	/* FFI_TYPE_UINT16 */
+	.word	.L_case_h - datalabel .L_table	/* FFI_TYPE_SINT16 */
+	.word	.L_case_i - datalabel .L_table	/* FFI_TYPE_UINT32 */
+	.word	.L_case_i - datalabel .L_table	/* FFI_TYPE_SINT32 */
+	.word	.L_case_ll - datalabel .L_table	/* FFI_TYPE_UINT64 */
+	.word	.L_case_ll - datalabel .L_table	/* FFI_TYPE_SINT64 */
+	.word	.L_case_v - datalabel .L_table	/* FFI_TYPE_STRUCT */
+	.word	.L_case_i - datalabel .L_table	/* FFI_TYPE_POINTER */
+
+        .align 2
+.L_case_d:
+	fld.d	r14, 16, dr0
+	blink	tr1, r63
+.L_case_f:
+	fld.s	r14, 16, fr0
+	blink	tr1, r63
+.L_case_ll:
+	ld.q	r14, 16, r2
+	blink	tr1, r63
+.L_case_i:
+	ld.l	r14, 16, r2
+	blink	tr1, r63
+.L_case_q:
+	ld.b	r14, 16, r2
+	blink	tr1, r63
+.L_case_uq:
+	ld.ub	r14, 16, r2
+	blink	tr1, r63
+.L_case_h:
+	ld.w	r14, 16, r2
+	blink	tr1, r63
+.L_case_uh:
+	ld.uw	r14, 16, r2
+	blink	tr1, r63
+.L_case_v:
+	add.l	r14, r63, r15
+	ld.l	r15, 4, r12
+	ld.l	r15, 8, r14
+	ld.l	r15, 12, r18
+	addi.l	r15, 136, r15
+	ptabs	r18, tr0
+	blink	tr0, r63
+
+.LFE2:
+.ffi_closure_SYSV_end:
+	.size	 CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+
+	.section	".eh_frame","aw",@progbits
+__FRAME_BEGIN__:
+	.4byte	.LECIE1-.LSCIE1	/* Length of Common Information Entry */
+.LSCIE1:
+	.4byte	0x0	/* CIE Identifier Tag */
+	.byte	0x1	/* CIE Version */
+#ifdef PIC
+	.ascii "zR\0"	/* CIE Augmentation */
+#else
+	.byte	0x0	/* CIE Augmentation */
+#endif
+	.uleb128 0x1	/* CIE Code Alignment Factor */
+	.sleb128 -4	/* CIE Data Alignment Factor */
+	.byte	0x12	/* CIE RA Column */
+#ifdef PIC
+	.uleb128 0x1	/* Augmentation size */
+	.byte	0x10	/* FDE Encoding (pcrel) */
+#endif
+	.byte	0xc	/* DW_CFA_def_cfa */
+	.uleb128 0xf
+	.uleb128 0x0
+	.align	2
+.LECIE1:
+.LSFDE1:
+	.4byte	datalabel .LEFDE1-datalabel .LASFDE1	/* FDE Length */
+.LASFDE1:
+	.4byte	datalabel .LASFDE1-datalabel __FRAME_BEGIN__
+#ifdef PIC
+	.4byte	.LFB1-.	/* FDE initial location */
+#else
+	.4byte	.LFB1	/* FDE initial location */
+#endif
+	.4byte	datalabel .LFE1-datalabel .LFB1	/* FDE address range */
+#ifdef PIC
+	.uleb128 0x0	/* Augmentation size */
+#endif
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI0-datalabel .LFB1
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.uleb128 0x30
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI1-datalabel .LCFI0
+	.byte   0x8e	/* DW_CFA_offset, column 0xe */
+	.uleb128 0xc
+	.byte   0x92	/* DW_CFA_offset, column 0x12 */
+	.uleb128 0xb
+	.byte   0x9c	/* DW_CFA_offset, column 0x1c */
+	.uleb128 0xa
+	.byte   0x9d	/* DW_CFA_offset, column 0x1d */
+	.uleb128 0x8
+	.byte   0x9e	/* DW_CFA_offset, column 0x1e */
+	.uleb128 0x6
+	.byte   0x9f	/* DW_CFA_offset, column 0x1f */
+	.uleb128 0x4
+	.byte   0xa0	/* DW_CFA_offset, column 0x20 */
+	.uleb128 0x2
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI2-datalabel .LCFI1
+	.byte	0xd	/* DW_CFA_def_cfa_register */
+	.uleb128 0xe
+	.align	2
+.LEFDE1:
+
+.LSFDE3:
+	.4byte	datalabel .LEFDE3-datalabel .LASFDE3	/* FDE Length */
+.LASFDE3:
+	.4byte	datalabel .LASFDE3-datalabel __FRAME_BEGIN__
+#ifdef PIC
+	.4byte	.LFB2-.	/* FDE initial location */
+#else
+	.4byte	.LFB2	/* FDE initial location */
+#endif
+	.4byte	datalabel .LFE2-datalabel .LFB2	/* FDE address range */
+#ifdef PIC
+	.uleb128 0x0	/* Augmentation size */
+#endif
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI3-datalabel .LFB2
+	.byte	0xe	/* DW_CFA_def_cfa_offset */
+	.uleb128 0x88
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI4-datalabel .LCFI3
+	.byte   0x8c	/* DW_CFA_offset, column 0xc */
+	.uleb128 0x21
+	.byte   0x8e	/* DW_CFA_offset, column 0xe */
+	.uleb128 0x20
+	.byte   0x92	/* DW_CFA_offset, column 0x12 */
+	.uleb128 0x1f
+	.byte	0x4	/* DW_CFA_advance_loc4 */
+	.4byte	datalabel .LCFI5-datalabel .LCFI4
+	.byte	0xd	/* DW_CFA_def_cfa_register */
+	.uleb128 0xe
+	.align	2
+.LEFDE3:
Index: libffi-3.4.6/src/sh64/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sh64/ffitarget.h b/libffi-3.4.6/src/sh64/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sh64/ffitarget.h	
@@ -0,0 +1,58 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for SuperH - SHmedia.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+
+#define FFI_EXTRA_CIF_FIELDS long long flags2
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 32
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
Index: libffi-3.4.6/src/tile/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/tile/ffi.c b/libffi-3.4.6/src/tile/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/tile/ffi.c	
@@ -0,0 +1,355 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2012 Tilera Corp.
+
+   TILE Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <arch/abi.h>
+#include <arch/icache.h>
+#include <arch/opcode.h>
+
+
+/* The first 10 registers are used to pass arguments and return values. */
+#define NUM_ARG_REGS 10
+
+/* Performs a raw function call with the given NUM_ARG_REGS register arguments
+   and the specified additional stack arguments (if any). */
+extern void ffi_call_tile(ffi_sarg reg_args[NUM_ARG_REGS],
+                          const ffi_sarg *stack_args,
+                          size_t stack_args_bytes,
+                          void (*fnaddr)(void))
+  FFI_HIDDEN;
+
+/* This handles the raw call from the closure stub, cleaning up the
+   parameters and delegating to ffi_closure_tile_inner. */
+extern void ffi_closure_tile(void) FFI_HIDDEN;
+
+
+ffi_status
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* We always allocate room for all registers. Even if we don't
+     use them as parameters, they get returned in the same array
+     as struct return values so we need to make room. */
+  if (cif->bytes < NUM_ARG_REGS * FFI_SIZEOF_ARG)
+    cif->bytes = NUM_ARG_REGS * FFI_SIZEOF_ARG;
+
+  if (cif->rtype->size > NUM_ARG_REGS * FFI_SIZEOF_ARG)
+    cif->flags = FFI_TYPE_STRUCT;
+  else
+    cif->flags = FFI_TYPE_INT;
+
+  /* Nothing to do. */
+  return FFI_OK;
+}
+
+
+static long
+assign_to_ffi_arg(ffi_sarg *out, void *in, const ffi_type *type,
+                  int write_to_reg)
+{
+  switch (type->type)
+    {
+    case FFI_TYPE_SINT8:
+      *out = *(SINT8 *)in;
+      return 1;
+
+    case FFI_TYPE_UINT8:
+      *out = *(UINT8 *)in;
+      return 1;
+
+    case FFI_TYPE_SINT16:
+      *out = *(SINT16 *)in;
+      return 1;
+
+    case FFI_TYPE_UINT16:
+      *out = *(UINT16 *)in;
+      return 1;
+
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+#ifndef __LP64__
+    case FFI_TYPE_POINTER:
+#endif
+      /* Note that even unsigned 32-bit quantities are sign extended
+         on tilegx when stored in a register.  */
+      *out = *(SINT32 *)in;
+      return 1;
+
+    case FFI_TYPE_FLOAT:
+#ifdef __tilegx__
+      if (write_to_reg)
+        {
+          /* Properly sign extend the value.  */
+          union { float f; SINT32 s32; } val;
+          val.f = *(float *)in;
+          *out = val.s32;
+        }
+      else
+#endif
+        {
+          *(float *)out = *(float *)in;
+        }
+      return 1;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_DOUBLE:
+#ifdef __LP64__
+    case FFI_TYPE_POINTER:
+#endif
+      *(UINT64 *)out = *(UINT64 *)in;
+      return sizeof(UINT64) / FFI_SIZEOF_ARG;
+
+    case FFI_TYPE_STRUCT:
+      memcpy(out, in, type->size);
+      return (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;
+
+    case FFI_TYPE_VOID:
+      /* Must be a return type. Nothing to do. */
+      return 0;
+
+    default:
+      FFI_ASSERT(0);
+      return -1;
+    }
+}
+
+
+void
+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_sarg * const arg_mem = alloca(cif->bytes);
+  ffi_sarg * const reg_args = arg_mem;
+  ffi_sarg * const stack_args = &reg_args[NUM_ARG_REGS];
+  ffi_sarg *argp = arg_mem;
+  ffi_type ** const arg_types = cif->arg_types;
+  const long num_args = cif->nargs;
+  long i;
+
+  if (cif->flags == FFI_TYPE_STRUCT)
+    {
+      /* Pass a hidden pointer to the return value. We make sure there
+         is scratch space for the callee to store the return value even if
+         our caller doesn't care about it. */
+      *argp++ = (intptr_t)(rvalue ? rvalue : alloca(cif->rtype->size));
+
+      /* No more work needed to return anything. */
+      rvalue = NULL;
+    }
+
+  for (i = 0; i < num_args; i++)
+    {
+      ffi_type *type = arg_types[i];
+      void * const arg_in = avalue[i];
+      ptrdiff_t arg_word = argp - arg_mem;
+
+#ifndef __tilegx__
+      /* Doubleword-aligned values are always in an even-number register
+         pair, or doubleword-aligned stack slot if out of registers. */
+      long align = arg_word & (type->alignment > FFI_SIZEOF_ARG);
+      argp += align;
+      arg_word += align;
+#endif
+
+      if (type->type == FFI_TYPE_STRUCT)
+        {
+          const size_t arg_size_in_words =
+            (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;
+
+          if (arg_word < NUM_ARG_REGS &&
+              arg_word + arg_size_in_words > NUM_ARG_REGS)
+            {
+              /* Args are not allowed to span registers and the stack. */
+              argp = stack_args;
+            }
+
+          memcpy(argp, arg_in, type->size);
+          argp += arg_size_in_words;
+        }
+      else
+        {
+          argp += assign_to_ffi_arg(argp, arg_in, arg_types[i], 1);
+        }
+    }
+
+  /* Actually do the call. */
+  ffi_call_tile(reg_args, stack_args,
+                cif->bytes - (NUM_ARG_REGS * FFI_SIZEOF_ARG), fn);
+
+  if (rvalue != NULL)
+    assign_to_ffi_arg(rvalue, reg_args, cif->rtype, 0);
+}
+
+
+/* Template code for closure. */
+extern const UINT64 ffi_template_tramp_tile[] FFI_HIDDEN;
+
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+                      ffi_cif *cif,
+                      void (*fun)(ffi_cif*, void*, void**, void*),
+                      void *user_data,
+                      void *codeloc)
+{
+#ifdef __tilegx__
+  /* TILE-Gx */
+  SINT64 c;
+  SINT64 h;
+  int s;
+  UINT64 *out;
+
+  if (cif->abi != FFI_UNIX)
+    return FFI_BAD_ABI;
+
+  out = (UINT64 *)closure->tramp;
+
+  c = (intptr_t)closure;
+  h = (intptr_t)ffi_closure_tile;
+  s = 0;
+
+  /* Find the smallest shift count that doesn't lose information
+     (i.e. no need to explicitly insert high bits of the address that
+     are just the sign extension of the low bits). */
+  while ((c >> s) != (SINT16)(c >> s) || (h >> s) != (SINT16)(h >> s))
+    s += 16;
+
+#define OPS(a, b, shift) \
+  (create_Imm16_X0((a) >> (shift)) | create_Imm16_X1((b) >> (shift)))
+
+  /* Emit the moveli. */
+  *out++ = ffi_template_tramp_tile[0] | OPS(c, h, s);
+  for (s -= 16; s >= 0; s -= 16)
+    *out++ = ffi_template_tramp_tile[1] | OPS(c, h, s);
+
+#undef OPS
+
+  *out++ = ffi_template_tramp_tile[2];
+
+#else
+  /* TILEPro */
+  UINT64 *out;
+  intptr_t delta;
+
+  if (cif->abi != FFI_UNIX)
+    return FFI_BAD_ABI;
+
+  out = (UINT64 *)closure->tramp;
+  delta = (intptr_t)ffi_closure_tile - (intptr_t)codeloc;
+
+  *out++ = ffi_template_tramp_tile[0] | create_JOffLong_X1(delta >> 3);
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  invalidate_icache(closure->tramp, (char *)out - closure->tramp,
+                    getpagesize());
+
+  return FFI_OK;
+}
+
+
+/* This is called by the assembly wrapper for closures. This does
+   all of the work. On entry reg_args[0] holds the values the registers
+   had when the closure was invoked. On return reg_args[1] holds the register
+   values to be returned to the caller (many of which may be garbage). */
+void FFI_HIDDEN
+ffi_closure_tile_inner(ffi_closure *closure,
+                       ffi_sarg reg_args[2][NUM_ARG_REGS],
+                       ffi_sarg *stack_args)
+{
+  ffi_cif * const cif = closure->cif;
+  void ** const avalue = alloca(cif->nargs * sizeof(void *));
+  void *rvalue;
+  ffi_type ** const arg_types = cif->arg_types;
+  ffi_sarg * const reg_args_in = reg_args[0];
+  ffi_sarg * const reg_args_out = reg_args[1];
+  ffi_sarg * argp;
+  long i, arg_word, nargs = cif->nargs;
+  /* Use a union to guarantee proper alignment for double. */
+  union { ffi_sarg arg[NUM_ARG_REGS]; double d; UINT64 u64; } closure_ret;
+
+  /* Start out reading register arguments. */
+  argp = reg_args_in;
+
+  /* Copy the caller's structure return address to that the closure
+     returns the data directly to the caller.  */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    {
+      /* Return by reference via hidden pointer. */
+      rvalue = (void *)(intptr_t)*argp++;
+      arg_word = 1;
+    }
+  else
+    {
+      /* Return the value in registers. */
+      rvalue = &closure_ret;
+      arg_word = 0;
+    }
+
+  /* Grab the addresses of the arguments. */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type * const type = arg_types[i];
+      const size_t arg_size_in_words =
+        (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;
+
+#ifndef __tilegx__
+      /* Doubleword-aligned values are always in an even-number register
+         pair, or doubleword-aligned stack slot if out of registers. */
+      long align = arg_word & (type->alignment > FFI_SIZEOF_ARG);
+      argp += align;
+      arg_word += align;
+#endif
+
+      if (arg_word == NUM_ARG_REGS ||
+          (arg_word < NUM_ARG_REGS &&
+           arg_word + arg_size_in_words > NUM_ARG_REGS))
+        {
+          /* Switch to reading arguments from the stack. */
+          argp = stack_args;
+          arg_word = NUM_ARG_REGS;
+        }
+
+      avalue[i] = argp;
+      argp += arg_size_in_words;
+      arg_word += arg_size_in_words;
+    }
+
+  /* Invoke the closure.  */
+  closure->fun(cif, rvalue, avalue, closure->user_data);
+
+  if (cif->flags != FFI_TYPE_STRUCT)
+    {
+      /* Canonicalize for register representation. */
+      assign_to_ffi_arg(reg_args_out, &closure_ret, cif->rtype, 1);
+    }
+}
Index: libffi-3.4.6/src/tile/tile.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/tile/tile.S b/libffi-3.4.6/src/tile/tile.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/tile/tile.S	
@@ -0,0 +1,360 @@
+/* -----------------------------------------------------------------------
+   tile.S - Copyright (c) 2011 Tilera Corp.
+
+   Tilera TILEPro and TILE-Gx Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Number of bytes in a register. */
+#define REG_SIZE FFI_SIZEOF_ARG
+
+/* Number of bytes in stack linkage area for backtracing.
+
+   A note about the ABI: on entry to a procedure, sp points to a stack
+   slot where it must spill the return address if it's not a leaf.
+   REG_SIZE bytes beyond that is a slot owned by the caller which
+   contains the sp value that the caller had when it was originally
+   entered (i.e. the caller's frame pointer). */
+#define LINKAGE_SIZE (2 * REG_SIZE)
+
+/* The first 10 registers are used to pass arguments and return values. */
+#define NUM_ARG_REGS 10
+
+#ifdef __tilegx__
+#define SW st
+#define LW ld
+#define BGZT bgtzt
+#else
+#define SW sw
+#define LW lw
+#define BGZT bgzt
+#endif
+
+
+/* void ffi_call_tile (int_reg_t reg_args[NUM_ARG_REGS],
+                       const int_reg_t *stack_args,
+                       unsigned long stack_args_bytes,
+                       void (*fnaddr)(void));
+
+        On entry, REG_ARGS contain the outgoing register values,
+        and STACK_ARGS contains STACK_ARG_BYTES of additional values
+        to be passed on the stack. If STACK_ARG_BYTES is zero, then
+        STACK_ARGS is ignored.
+
+        When the invoked function returns, the values of r0-r9 are
+        blindly stored back into REG_ARGS for the caller to examine. */
+
+        .section .text.ffi_call_tile, "ax", @progbits
+        .align  8
+        .globl  ffi_call_tile
+        FFI_HIDDEN(ffi_call_tile)
+ffi_call_tile:
+
+/* Incoming arguments. */
+#define REG_ARGS                r0
+#define INCOMING_STACK_ARGS     r1
+#define STACK_ARG_BYTES         r2
+#define ORIG_FNADDR             r3
+
+/* Temporary values. */
+#define FRAME_SIZE              r10
+#define TMP                     r11
+#define TMP2                    r12
+#define OUTGOING_STACK_ARGS     r13
+#define REG_ADDR_PTR            r14
+#define RETURN_REG_ADDR         r15
+#define FNADDR                  r16
+
+        .cfi_startproc
+        {
+         /* Save return address. */
+         SW     sp, lr
+         .cfi_offset lr, 0
+         /* Prepare to spill incoming r52. */
+         addi   TMP, sp, -REG_SIZE
+         /* Increase frame size to have room to spill r52 and REG_ARGS.
+            The +7 is to round up mod 8. */
+         addi   FRAME_SIZE, STACK_ARG_BYTES, \
+                REG_SIZE + REG_SIZE + LINKAGE_SIZE + 7
+        }
+        {
+         /* Round stack frame size to a multiple of 8 to satisfy ABI. */
+         andi   FRAME_SIZE, FRAME_SIZE, -8
+         /* Compute where to spill REG_ARGS value. */
+         addi   TMP2, sp, -(REG_SIZE * 2)
+        }
+        {
+         /* Spill incoming r52. */
+         SW     TMP, r52
+         .cfi_offset r52, -REG_SIZE
+         /* Set up our frame pointer. */
+         move   r52, sp
+         .cfi_def_cfa_register r52
+         /* Push stack frame. */
+         sub    sp, sp, FRAME_SIZE
+        }
+        {
+         /* Prepare to set up stack linkage. */
+         addi   TMP, sp, REG_SIZE
+         /* Prepare to memcpy stack args. */
+         addi   OUTGOING_STACK_ARGS, sp, LINKAGE_SIZE
+         /* Save REG_ARGS which we will need after we call the subroutine. */
+         SW     TMP2, REG_ARGS
+        }
+        {
+         /* Set up linkage info to hold incoming stack pointer. */
+         SW     TMP, r52
+        }
+        {
+         /* Skip stack args memcpy if we don't have any stack args (common). */
+         blezt  STACK_ARG_BYTES, .Ldone_stack_args_memcpy
+        }
+
+.Lmemcpy_stack_args:
+        {
+         /* Load incoming argument from stack_args. */
+         LW     TMP, INCOMING_STACK_ARGS
+         addi   INCOMING_STACK_ARGS, INCOMING_STACK_ARGS, REG_SIZE
+        }
+        {
+         /* Store stack argument into outgoing stack argument area. */
+         SW     OUTGOING_STACK_ARGS, TMP
+         addi   OUTGOING_STACK_ARGS, OUTGOING_STACK_ARGS, REG_SIZE
+         addi   STACK_ARG_BYTES, STACK_ARG_BYTES, -REG_SIZE
+        }
+        {
+         BGZT   STACK_ARG_BYTES, .Lmemcpy_stack_args
+        }
+.Ldone_stack_args_memcpy:
+
+        {
+         /* Copy aside ORIG_FNADDR so we can overwrite its register. */
+         move   FNADDR, ORIG_FNADDR
+         /* Prepare to load argument registers. */
+         addi   REG_ADDR_PTR, r0, REG_SIZE
+         /* Load outgoing r0. */
+         LW     r0, r0
+        }
+
+        /* Load up argument registers from the REG_ARGS array. */
+#define LOAD_REG(REG, PTR) \
+        { \
+         LW     REG, PTR ; \
+         addi   PTR, PTR, REG_SIZE \
+        }
+
+        LOAD_REG(r1, REG_ADDR_PTR)
+        LOAD_REG(r2, REG_ADDR_PTR)
+        LOAD_REG(r3, REG_ADDR_PTR)
+        LOAD_REG(r4, REG_ADDR_PTR)
+        LOAD_REG(r5, REG_ADDR_PTR)
+        LOAD_REG(r6, REG_ADDR_PTR)
+        LOAD_REG(r7, REG_ADDR_PTR)
+        LOAD_REG(r8, REG_ADDR_PTR)
+        LOAD_REG(r9, REG_ADDR_PTR)
+
+        {
+         /* Call the subroutine. */
+         jalr   FNADDR
+        }
+
+        {
+         /* Restore original lr. */
+         LW     lr, r52
+         /* Prepare to recover ARGS, which we spilled earlier. */
+         addi   TMP, r52, -(2 * REG_SIZE)
+        }
+        {
+         /* Restore ARGS, so we can fill it in with the return regs r0-r9. */
+         LW     RETURN_REG_ADDR, TMP
+         /* Prepare to restore original r52. */
+         addi   TMP, r52, -REG_SIZE
+        }
+
+        {
+         /* Pop stack frame. */
+         move   sp, r52
+         /* Restore original r52. */
+         LW     r52, TMP
+        }
+
+#define STORE_REG(REG, PTR) \
+        { \
+         SW     PTR, REG ; \
+         addi   PTR, PTR, REG_SIZE \
+        }
+
+        /* Return all register values by reference. */
+        STORE_REG(r0, RETURN_REG_ADDR)
+        STORE_REG(r1, RETURN_REG_ADDR)
+        STORE_REG(r2, RETURN_REG_ADDR)
+        STORE_REG(r3, RETURN_REG_ADDR)
+        STORE_REG(r4, RETURN_REG_ADDR)
+        STORE_REG(r5, RETURN_REG_ADDR)
+        STORE_REG(r6, RETURN_REG_ADDR)
+        STORE_REG(r7, RETURN_REG_ADDR)
+        STORE_REG(r8, RETURN_REG_ADDR)
+        STORE_REG(r9, RETURN_REG_ADDR)
+
+        {
+         jrp    lr
+        }
+
+        .cfi_endproc
+        .size ffi_call_tile, .-ffi_call_tile
+
+/* ffi_closure_tile(...)
+
+   On entry, lr points to the closure plus 8 bytes, and r10
+   contains the actual return address.
+
+   This function simply dumps all register parameters into a stack array
+   and passes the closure, the registers array, and the stack arguments
+   to C code that does all of the actual closure processing. */
+
+        .section .text.ffi_closure_tile, "ax", @progbits
+        .align  8
+        .globl  ffi_closure_tile
+        FFI_HIDDEN(ffi_closure_tile)
+
+        .cfi_startproc
+/* Room to spill all NUM_ARG_REGS incoming registers, plus frame linkage. */
+#define CLOSURE_FRAME_SIZE (((NUM_ARG_REGS * REG_SIZE * 2 + LINKAGE_SIZE) + 7) & -8)
+ffi_closure_tile:
+        {
+#ifdef __tilegx__
+         st     sp, lr
+         .cfi_offset lr, 0
+#else
+         /* Save return address (in r10 due to closure stub wrapper). */
+         SW     sp, r10
+         .cfi_return_column r10
+         .cfi_offset r10, 0
+#endif
+         /* Compute address for stack frame linkage. */
+         addli   r10, sp, -(CLOSURE_FRAME_SIZE - REG_SIZE)
+        }
+        {
+         /* Save incoming stack pointer in linkage area. */
+         SW     r10, sp
+         .cfi_offset sp, -(CLOSURE_FRAME_SIZE - REG_SIZE)
+         /* Push a new stack frame. */
+         addli   sp, sp, -CLOSURE_FRAME_SIZE
+         .cfi_adjust_cfa_offset CLOSURE_FRAME_SIZE
+        }
+
+        {
+         /* Create pointer to where to start spilling registers. */
+         addi   r10, sp, LINKAGE_SIZE
+        }
+
+        /* Spill all the incoming registers. */
+        STORE_REG(r0, r10)
+        STORE_REG(r1, r10)
+        STORE_REG(r2, r10)
+        STORE_REG(r3, r10)
+        STORE_REG(r4, r10)
+        STORE_REG(r5, r10)
+        STORE_REG(r6, r10)
+        STORE_REG(r7, r10)
+        STORE_REG(r8, r10)
+        {
+         /* Save r9. */
+         SW     r10, r9
+#ifdef __tilegx__
+         /* Pointer to closure is passed in r11. */
+         move  r0, r11
+#else
+         /* Compute pointer to the closure object. Because the closure
+            starts with a "jal ffi_closure_tile", we can just take the
+            value of lr (a phony return address pointing into the closure)
+            and subtract 8. */
+         addi   r0, lr, -8
+#endif
+         /* Compute a pointer to the register arguments we just spilled. */
+         addi   r1, sp, LINKAGE_SIZE
+        }
+        {
+         /* Compute a pointer to the extra stack arguments (if any). */
+         addli   r2, sp, CLOSURE_FRAME_SIZE + LINKAGE_SIZE
+         /* Call C code to deal with all of the grotty details. */
+         jal    ffi_closure_tile_inner
+        }
+        {
+         addli   r10, sp, CLOSURE_FRAME_SIZE
+        }
+        {
+         /* Restore the return address. */
+         LW     lr, r10
+         /* Compute pointer to registers array. */
+         addli   r10, sp, LINKAGE_SIZE + (NUM_ARG_REGS * REG_SIZE)
+        }
+        /* Return all the register values, which C code may have set. */
+        LOAD_REG(r0, r10)
+        LOAD_REG(r1, r10)
+        LOAD_REG(r2, r10)
+        LOAD_REG(r3, r10)
+        LOAD_REG(r4, r10)
+        LOAD_REG(r5, r10)
+        LOAD_REG(r6, r10)
+        LOAD_REG(r7, r10)
+        LOAD_REG(r8, r10)
+        LOAD_REG(r9, r10)
+        {
+         /* Pop the frame. */
+         addli   sp, sp, CLOSURE_FRAME_SIZE
+         jrp    lr
+        }
+
+        .cfi_endproc
+        .size   ffi_closure_tile, . - ffi_closure_tile
+
+
+/* What follows are code template instructions that get copied to the
+   closure trampoline by ffi_prep_closure_loc.  The zeroed operands
+   get replaced by their proper values at runtime. */
+
+        .section .text.ffi_template_tramp_tile, "ax", @progbits
+        .align  8
+        .globl  ffi_template_tramp_tile
+        FFI_HIDDEN(ffi_template_tramp_tile)
+ffi_template_tramp_tile:
+#ifdef __tilegx__
+        {
+          moveli r11, 0 /* backpatched to address of containing closure. */
+          moveli r10, 0 /* backpatched to ffi_closure_tile. */
+        }
+        /* Note: the following bundle gets generated multiple times
+           depending on the pointer value (esp. useful for -m32 mode). */
+        { shl16insli r11, r11, 0 ; shl16insli r10, r10, 0 }
+        { info 2+8 /* for backtracer: -> pc in lr, frame size 0 */ ; jr r10 }
+#else
+        /* 'jal .' yields a PC-relative offset of zero so we can OR in the
+           right offset at runtime. */
+        { move r10, lr ; jal . /* ffi_closure_tile */ }
+#endif
+
+        .size   ffi_template_tramp_tile, . - ffi_template_tramp_tile
Index: libffi-3.4.6/src/tile/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/tile/ffitarget.h b/libffi-3.4.6/src/tile/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/tile/ffitarget.h	
@@ -0,0 +1,65 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012 Tilera Corp.
+   Target configuration macros for TILE.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+
+#include <arch/abi.h>
+
+typedef uint_reg_t ffi_arg;
+typedef int_reg_t  ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_UNIX,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_UNIX
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+#define FFI_CLOSURES 1
+
+#ifdef __tilegx__
+/* We always pass 8-byte values, even in -m32 mode. */
+# define FFI_SIZEOF_ARG 8
+# ifdef __LP64__
+#  define FFI_TRAMPOLINE_SIZE (8 * 5)  /* 5 bundles */
+# else
+#  define FFI_TRAMPOLINE_SIZE (8 * 3)  /* 3 bundles */
+# endif
+#else
+# define FFI_SIZEOF_ARG 4
+# define FFI_TRAMPOLINE_SIZE 8 /* 1 bundle */
+#endif
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/alpha/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/alpha/ffi.c b/libffi-3.4.6/src/alpha/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/alpha/ffi.c	
@@ -0,0 +1,521 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2012  Anthony Green
+	   Copyright (c) 1998, 2001, 2007, 2008  Red Hat, Inc.
+
+   Alpha Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include "internal.h"
+
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 128-bit type.  */
+#if defined(__LONG_DOUBLE_128__)
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+extern void ffi_call_osf(void *stack, void *frame, unsigned flags,
+			 void *raddr, void (*fn)(void), void *closure)
+	FFI_HIDDEN;
+extern void ffi_closure_osf(void) FFI_HIDDEN;
+extern void ffi_go_closure_osf(void) FFI_HIDDEN;
+
+/* Promote a float value to its in-register double representation.
+   Unlike actually casting to double, this does not trap on NaN.  */
+static inline UINT64 lds(void *ptr)
+{
+  UINT64 ret;
+  asm("lds %0,%1" : "=f"(ret) : "m"(*(UINT32 *)ptr));
+  return ret;
+}
+
+/* And the reverse.  */
+static inline void sts(void *ptr, UINT64 val)
+{
+  asm("sts %1,%0" : "=m"(*(UINT32 *)ptr) : "f"(val));
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  size_t bytes = 0;
+  int flags, i, avn;
+  ffi_type *rtype, *itype;
+
+  if (cif->abi != FFI_OSF)
+    return FFI_BAD_ABI;
+
+  /* Compute the size of the argument area.  */
+  for (i = 0, avn = cif->nargs; i < avn; i++)
+    {
+      itype = cif->arg_types[i];
+      switch (itype->type)
+	{
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	  /* All take one 8 byte slot.  */
+	  bytes += 8;
+	  break;
+
+	case FFI_TYPE_VOID:
+	case FFI_TYPE_STRUCT:
+	  /* Passed by value in N slots.  */
+	  bytes += FFI_ALIGN(itype->size, FFI_SIZEOF_ARG);
+	  break;
+
+	case FFI_TYPE_COMPLEX:
+	  /* _Complex long double passed by reference; others in 2 slots.  */
+	  if (itype->elements[0]->type == FFI_TYPE_LONGDOUBLE)
+	    bytes += 8;
+	  else
+	    bytes += 16;
+	  break;
+
+	default:
+	  abort();
+	}
+    }
+
+  /* Set the return type flag */
+  rtype = cif->rtype;
+  switch (rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      flags = ALPHA_FLAGS(ALPHA_ST_VOID, ALPHA_LD_VOID);
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT32);
+      break;
+    case FFI_TYPE_FLOAT:
+      flags = ALPHA_FLAGS(ALPHA_ST_FLOAT, ALPHA_LD_FLOAT);
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = ALPHA_FLAGS(ALPHA_ST_DOUBLE, ALPHA_LD_DOUBLE);
+      break;
+    case FFI_TYPE_UINT8:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_UINT8);
+      break;
+    case FFI_TYPE_SINT8:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_SINT8);
+      break;
+    case FFI_TYPE_UINT16:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_UINT16);
+      break;
+    case FFI_TYPE_SINT16:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_SINT16);
+      break;
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_POINTER:
+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT64);
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+    case FFI_TYPE_STRUCT:
+      /* Passed in memory, with a hidden pointer.  */
+      flags = ALPHA_RET_IN_MEM;
+      break;
+    case FFI_TYPE_COMPLEX:
+      itype = rtype->elements[0];
+      switch (itype->type)
+	{
+	case FFI_TYPE_FLOAT:
+	  flags = ALPHA_FLAGS(ALPHA_ST_CPLXF, ALPHA_LD_CPLXF);
+	  break;
+	case FFI_TYPE_DOUBLE:
+	  flags = ALPHA_FLAGS(ALPHA_ST_CPLXD, ALPHA_LD_CPLXD);
+	  break;
+	default:
+	  if (rtype->size <= 8)
+	    flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT64);
+	  else
+	    flags = ALPHA_RET_IN_MEM;
+	  break;
+	}
+      break;
+    default:
+      abort();
+    }
+  cif->flags = flags;
+
+  /* Include the hidden structure pointer in args requirement.  */
+  if (flags == ALPHA_RET_IN_MEM)
+    bytes += 8;
+  /* Minimum size is 6 slots, so that ffi_call_osf can pop them.  */
+  if (bytes < 6*8)
+    bytes = 6*8;
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+static unsigned long
+extend_basic_type(void *valp, int type, int argn)
+{
+  switch (type)
+    {
+    case FFI_TYPE_SINT8:
+      return *(SINT8 *)valp;
+    case FFI_TYPE_UINT8:
+      return *(UINT8 *)valp;
+    case FFI_TYPE_SINT16:
+      return *(SINT16 *)valp;
+    case FFI_TYPE_UINT16:
+      return *(UINT16 *)valp;
+
+    case FFI_TYPE_FLOAT:
+      if (argn < 6)
+	return lds(valp);
+      /* FALLTHRU */
+
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+      /* Note that unsigned 32-bit quantities are sign extended.  */
+      return *(SINT32 *)valp;
+
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_DOUBLE:
+      return *(UINT64 *)valp;
+
+    default:
+      abort();
+    }
+}
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  unsigned long *argp;
+  long i, avn, argn, flags = cif->flags;
+  ffi_type **arg_types;
+  void *frame;
+
+  /* If the return value is a struct and we don't have a return
+     value address then we need to make one.  */
+  if (rvalue == NULL && flags == ALPHA_RET_IN_MEM)
+    rvalue = alloca(cif->rtype->size);
+
+  /* Allocate the space for the arguments, plus 4 words of temp
+     space for ffi_call_osf.  */
+  argp = frame = alloca(cif->bytes + 4*FFI_SIZEOF_ARG);
+  frame += cif->bytes;
+
+  argn = 0;
+  if (flags == ALPHA_RET_IN_MEM)
+    argp[argn++] = (unsigned long)rvalue;
+
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+
+  for (i = 0, avn = cif->nargs; i < avn; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      void *valp = avalue[i];
+      int type = ty->type;
+      size_t size;
+
+      switch (type)
+	{
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	  argp[argn] = extend_basic_type(valp, type, argn);
+	  argn++;
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	by_reference:
+	  /* Note that 128-bit long double is passed by reference.  */
+	  argp[argn++] = (unsigned long)valp;
+	  break;
+
+	case FFI_TYPE_VOID:
+	case FFI_TYPE_STRUCT:
+	  size = ty->size;
+	  memcpy(argp + argn, valp, size);
+	  argn += FFI_ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+	  break;
+
+	case FFI_TYPE_COMPLEX:
+	  type = ty->elements[0]->type;
+	  if (type == FFI_TYPE_LONGDOUBLE)
+	    goto by_reference;
+
+	  /* Most complex types passed as two separate arguments.  */
+	  size = ty->elements[0]->size;
+	  argp[argn] = extend_basic_type(valp, type, argn);
+	  argp[argn + 1] = extend_basic_type(valp + size, type, argn + 1);
+	  argn += 2;
+	  break;
+
+	default:
+	  abort();
+	}
+    }
+
+  flags = (flags >> ALPHA_ST_SHIFT) & 0xff;
+  ffi_call_osf(argp, frame, flags, rvalue, fn, closure);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp;
+
+  if (cif->abi != FFI_OSF)
+    return FFI_BAD_ABI;
+
+  tramp = (unsigned int *) &closure->tramp[0];
+  tramp[0] = 0x47fb0401;	/* mov $27,$1		*/
+  tramp[1] = 0xa77b0010;	/* ldq $27,16($27)	*/
+  tramp[2] = 0x6bfb0000;	/* jmp $31,($27),0	*/
+  tramp[3] = 0x47ff041f;	/* nop			*/
+  *(void **) &tramp[4] = ffi_closure_osf;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  /* Flush the Icache.
+
+     Tru64 UNIX as doesn't understand the imb mnemonic, so use call_pal
+     instead, since both Compaq as and gas can handle it.
+
+     0x86 is PAL_imb in Tru64 UNIX <alpha/pal.h>.  */
+  asm volatile ("call_pal 0x86" : : : "memory");
+
+  return FFI_OK;
+}
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure,
+		     ffi_cif* cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+  if (cif->abi != FFI_OSF)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (void *)ffi_go_closure_osf;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+long FFI_HIDDEN
+ffi_closure_osf_inner (ffi_cif *cif,
+		       void (*fun)(ffi_cif*, void*, void**, void*),
+		       void *user_data,
+		       void *rvalue, unsigned long *argp)
+{
+  void **avalue;
+  ffi_type **arg_types;
+  long i, avn, argn, flags;
+
+  avalue = alloca(cif->nargs * sizeof(void *));
+  flags = cif->flags;
+  argn = 0;
+
+  /* Copy the caller's structure return address to that the closure
+     returns the data directly to the caller.  */
+  if (flags == ALPHA_RET_IN_MEM)
+    {
+      rvalue = (void *) argp[0];
+      argn = 1;
+    }
+
+  arg_types = cif->arg_types;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  for (i = 0, avn = cif->nargs; i < avn; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      int type = ty->type;
+      void *valp = &argp[argn];
+      size_t size;
+
+      switch (type)
+	{
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  argn += 1;
+	  break;
+
+	case FFI_TYPE_VOID:
+	case FFI_TYPE_STRUCT:
+	  size = ty->size;
+	  argn += FFI_ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* Floats coming from registers need conversion from double
+	     back to float format.  */
+	  if (argn < 6)
+	    {
+	      valp = &argp[argn - 6];
+	      sts(valp, argp[argn - 6]);
+	    }
+	  argn += 1;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (argn < 6)
+	    valp = &argp[argn - 6];
+	  argn += 1;
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	by_reference:
+	  /* 128-bit long double is passed by reference.  */
+	  valp = (void *)argp[argn];
+	  argn += 1;
+	  break;
+
+	case FFI_TYPE_COMPLEX:
+	  type = ty->elements[0]->type;
+	  switch (type)
+	    {
+	    case FFI_TYPE_SINT64:
+	    case FFI_TYPE_UINT64:
+	      /* Passed as separate arguments, but they wind up sequential.  */
+	      break;
+
+	    case FFI_TYPE_INT:
+	    case FFI_TYPE_SINT8:
+	    case FFI_TYPE_UINT8:
+	    case FFI_TYPE_SINT16:
+	    case FFI_TYPE_UINT16:
+	    case FFI_TYPE_SINT32:
+	    case FFI_TYPE_UINT32:
+	      /* Passed as separate arguments.  Disjoint, but there's room
+		 enough in one slot to hold the pair.  */
+	      size = ty->elements[0]->size;
+	      memcpy(valp + size, valp + 8, size);
+	      break;
+
+	    case FFI_TYPE_FLOAT:
+	      /* Passed as separate arguments.  Disjoint, and each piece
+		 may need conversion back to float.  */
+	      if (argn < 6)
+		{
+		  valp = &argp[argn - 6];
+		  sts(valp, argp[argn - 6]);
+		}
+	      if (argn + 1 < 6)
+		sts(valp + 4, argp[argn + 1 - 6]);
+	      else
+		*(UINT32 *)(valp + 4) = argp[argn + 1];
+	      break;
+
+	    case FFI_TYPE_DOUBLE:
+	      /* Passed as separate arguments.  Only disjoint if one part
+		 is in fp regs and the other is on the stack.  */
+	      if (argn < 5)
+		valp = &argp[argn - 6];
+	      else if (argn == 5)
+		{
+		  valp = alloca(16);
+		  ((UINT64 *)valp)[0] = argp[5 - 6];
+		  ((UINT64 *)valp)[1] = argp[6];
+		}
+	      break;
+
+	    case FFI_TYPE_LONGDOUBLE:
+	      goto by_reference;
+
+	    default:
+	      abort();
+	    }
+	  argn += 2;
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      avalue[i] = valp;
+    }
+
+  /* Invoke the closure.  */
+  fun (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_osf how to perform return type promotions.  */
+  return (flags >> ALPHA_LD_SHIFT) & 0xff;
+}
Index: libffi-3.4.6/src/alpha/osf.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/alpha/osf.S b/libffi-3.4.6/src/alpha/osf.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/alpha/osf.S	
@@ -0,0 +1,282 @@
+/* -----------------------------------------------------------------------
+   osf.S - Copyright (c) 1998, 2001, 2007, 2008, 2011, 2014 Red Hat
+
+   Alpha/OSF Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+
+	.arch ev6
+	.text
+
+/* Aid in building a direct addressed jump table, 4 insns per entry.  */
+.macro E index
+	.align	4
+	.org	99b + \index * 16
+.endm
+
+/* ffi_call_osf (void *stack, void *frame, unsigned flags,
+		 void *raddr, void (*fnaddr)(void), void *closure)
+
+   Bit o trickiness here -- FRAME is the base of the stack frame
+   for this function.  This has been allocated by ffi_call.  We also
+   deallocate some of the stack that has been alloca'd.  */
+
+	.align	4
+	.globl	ffi_call_osf
+	.ent	ffi_call_osf
+	FFI_HIDDEN(ffi_call_osf)
+
+ffi_call_osf:
+	cfi_startproc
+	cfi_def_cfa($17, 32)
+	mov	$16, $30
+	stq	$26, 0($17)
+	stq	$15, 8($17)
+	mov	$17, $15
+	.prologue 0
+	cfi_def_cfa_register($15)
+	cfi_rel_offset($26, 0)
+	cfi_rel_offset($15, 8)
+
+	stq	$18, 16($17)		# save flags into frame
+	stq	$19, 24($17)		# save rvalue into frame
+	mov	$20, $27		# fn into place for call
+	mov	$21, $1			# closure into static chain
+
+	# Load up all of the (potential) argument registers.
+	ldq	$16, 0($30)
+	ldt	$f16, 0($30)
+	ldt	$f17, 8($30)
+	ldq	$17, 8($30)
+	ldt	$f18, 16($30)
+	ldq	$18, 16($30)
+	ldt	$f19, 24($30)
+	ldq	$19, 24($30)
+	ldt	$f20, 32($30)
+	ldq	$20, 32($30)
+	ldt	$f21, 40($30)
+	ldq	$21, 40($30)
+
+	# Deallocate the register argument area.
+	lda	$30, 48($30)
+
+	jsr	$26, ($27), 0
+0:
+	ldah	$29, 0($26)		!gpdisp!1
+	ldq	$2, 24($15)		# reload rvalue
+	lda	$29, 0($29)		!gpdisp!1
+	ldq	$3, 16($15)		# reload flags
+	lda	$1, 99f-0b($26)
+	ldq	$26, 0($15)
+	ldq	$15, 8($15)
+	cfi_restore($26)
+	cfi_restore($15)
+	cfi_def_cfa($sp, 0)
+	cmoveq	$2, ALPHA_ST_VOID, $3	# mash null rvalue to void
+	addq	$3, $3, $3
+	s8addq	$3, $1, $1		# 99f + stcode * 16
+	jmp	$31, ($1), $st_int
+
+	.align	4
+99:
+E ALPHA_ST_VOID
+	ret
+E ALPHA_ST_INT
+$st_int:
+	stq	$0, 0($2)
+	ret
+E ALPHA_ST_FLOAT
+	sts	$f0, 0($2)
+	ret
+E ALPHA_ST_DOUBLE
+	stt	$f0, 0($2)
+	ret
+E ALPHA_ST_CPLXF
+	sts	$f0, 0($2)
+	sts	$f1, 4($2)
+	ret
+E ALPHA_ST_CPLXD
+	stt	$f0, 0($2)
+	stt	$f1, 8($2)
+	ret
+
+	cfi_endproc
+	.end	ffi_call_osf
+
+/* ffi_closure_osf(...)
+
+   Receives the closure argument in $1.   */
+
+#define CLOSURE_FS	(16*8)
+
+	.align	4
+	.globl	ffi_go_closure_osf
+	.ent	ffi_go_closure_osf
+	FFI_HIDDEN(ffi_go_closure_osf)
+
+ffi_go_closure_osf:
+	cfi_startproc
+	ldgp	$29, 0($27)
+	subq	$30, CLOSURE_FS, $30
+	cfi_adjust_cfa_offset(CLOSURE_FS)
+	stq	$26, 0($30)
+	.prologue 1
+	cfi_rel_offset($26, 0)
+
+	stq	$16, 10*8($30)
+	stq	$17, 11*8($30)
+	stq	$18, 12*8($30)
+
+	ldq	$16, 8($1)			# load cif
+	ldq	$17, 16($1)			# load fun
+	mov	$1, $18				# closure is user_data
+	br	$do_closure
+
+	cfi_endproc
+	.end	ffi_go_closure_osf
+
+	.align	4
+	.globl	ffi_closure_osf
+	.ent	ffi_closure_osf
+	FFI_HIDDEN(ffi_closure_osf)
+
+ffi_closure_osf:
+	cfi_startproc
+	ldgp	$29, 0($27)
+	subq	$30, CLOSURE_FS, $30
+	cfi_adjust_cfa_offset(CLOSURE_FS)
+	stq	$26, 0($30)
+	.prologue 1
+	cfi_rel_offset($26, 0)
+
+	# Store all of the potential argument registers in va_list format.
+	stq	$16, 10*8($30)
+	stq	$17, 11*8($30)
+	stq	$18, 12*8($30)
+
+	ldq	$16, 24($1)			# load cif
+	ldq	$17, 32($1)			# load fun
+	ldq	$18, 40($1)			# load user_data
+
+$do_closure:
+	stq	$19, 13*8($30)
+	stq	$20, 14*8($30)
+	stq	$21, 15*8($30)
+	stt	$f16, 4*8($30)
+	stt	$f17, 5*8($30)
+	stt	$f18, 6*8($30)
+	stt	$f19, 7*8($30)
+	stt	$f20, 8*8($30)
+	stt	$f21, 9*8($30)
+
+	# Call ffi_closure_osf_inner to do the bulk of the work.
+	lda	$19, 2*8($30)
+	lda	$20, 10*8($30)
+	jsr	$26, ffi_closure_osf_inner
+0:
+	ldah	$29, 0($26)			!gpdisp!2
+	lda	$2, 99f-0b($26)
+	s4addq	$0, 0, $1			# ldcode * 4
+	ldq	$0, 16($30)			# preload return value
+	s4addq	$1, $2, $1			# 99f + ldcode * 16
+	lda	$29, 0($29)			!gpdisp!2
+	ldq	$26, 0($30)
+	cfi_restore($26)
+	jmp	$31, ($1), $load_32
+
+.macro epilogue
+	addq	$30, CLOSURE_FS, $30
+	cfi_adjust_cfa_offset(-CLOSURE_FS)
+	ret
+	.align	4
+	cfi_adjust_cfa_offset(CLOSURE_FS)
+.endm
+
+	.align 4
+99:
+E ALPHA_LD_VOID
+	epilogue
+
+E ALPHA_LD_INT64
+	epilogue
+
+E ALPHA_LD_INT32
+$load_32:
+	sextl	$0, $0
+	epilogue
+
+E ALPHA_LD_UINT16
+	zapnot	$0, 3, $0
+	epilogue
+
+E ALPHA_LD_SINT16
+#ifdef __alpha_bwx__
+	sextw	$0, $0
+#else
+	sll	$0, 48, $0
+	sra	$0, 48, $0
+#endif
+	epilogue
+
+E ALPHA_LD_UINT8
+	and	$0, 0xff, $0
+	epilogue
+
+E ALPHA_LD_SINT8
+#ifdef __alpha_bwx__
+	sextb	$0, $0
+#else
+	sll	$0, 56, $0
+	sra	$0, 56, $0
+#endif
+	epilogue
+
+E ALPHA_LD_FLOAT
+	lds	$f0, 16($sp)
+	epilogue
+
+E ALPHA_LD_DOUBLE
+	ldt	$f0, 16($sp)
+	epilogue
+
+E ALPHA_LD_CPLXF
+	lds	$f0, 16($sp)
+	lds	$f1, 20($sp)
+	epilogue
+
+E ALPHA_LD_CPLXD
+	ldt	$f0, 16($sp)
+	ldt	$f1, 24($sp)
+	epilogue
+
+	cfi_endproc
+	.end	ffi_closure_osf
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/alpha/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/alpha/internal.h b/libffi-3.4.6/src/alpha/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/alpha/internal.h	
@@ -0,0 +1,23 @@
+#define ALPHA_ST_VOID	0
+#define ALPHA_ST_INT	1
+#define ALPHA_ST_FLOAT	2
+#define ALPHA_ST_DOUBLE	3
+#define ALPHA_ST_CPLXF	4
+#define ALPHA_ST_CPLXD	5
+
+#define ALPHA_LD_VOID	0
+#define ALPHA_LD_INT64	1
+#define ALPHA_LD_INT32	2
+#define ALPHA_LD_UINT16	3
+#define ALPHA_LD_SINT16	4
+#define ALPHA_LD_UINT8	5
+#define ALPHA_LD_SINT8	6
+#define ALPHA_LD_FLOAT	7
+#define ALPHA_LD_DOUBLE	8
+#define ALPHA_LD_CPLXF	9
+#define ALPHA_LD_CPLXD	10
+
+#define ALPHA_ST_SHIFT		0
+#define ALPHA_LD_SHIFT		8
+#define ALPHA_RET_IN_MEM	0x10000
+#define ALPHA_FLAGS(S, L)	(((L) << ALPHA_LD_SHIFT) | (S))
Index: libffi-3.4.6/src/alpha/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/alpha/ffitarget.h b/libffi-3.4.6/src/alpha/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/alpha/ffitarget.h	
@@ -0,0 +1,57 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for Alpha.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_OSF,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_OSF
+} ffi_abi;
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/avr32/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/avr32/ffi.c b/libffi-3.4.6/src/avr32/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/avr32/ffi.c	
@@ -0,0 +1,423 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2011  Anthony Green
+           Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>
+
+   AVR32 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <asm/unistd.h>
+
+/* #define DEBUG */
+
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+    unsigned int, unsigned int, unsigned int*, unsigned int,
+    void (*fn)(void));
+extern void ffi_closure_SYSV (ffi_closure *);
+
+unsigned int pass_struct_on_stack(ffi_type *type)
+{
+    if(type->type != FFI_TYPE_STRUCT)
+        return 0;
+
+    if(type->alignment < type->size &&
+        !(type->size == 4 || type->size == 8) &&
+        !(type->size == 8 && type->alignment >= 4))
+        return 1;
+
+    if(type->size == 3 || type->size == 5 || type->size == 6 ||
+        type->size == 7)
+        return 1;
+
+    return 0;
+}
+
+/* ffi_prep_args is called by the assembly routine once stack space
+ * has been allocated for the function's arguments
+ *
+ * This is annoyingly complex since we need to keep track of used
+ * registers.
+ */
+
+void ffi_prep_args(char *stack, extended_cif *ecif)
+{
+    unsigned int i;
+    void **p_argv;
+    ffi_type **p_arg;
+    char *reg_base = stack;
+    char *stack_base = stack + 20;
+    unsigned int stack_offset = 0;
+    unsigned int reg_mask = 0;
+
+    p_argv = ecif->avalue;
+
+    /* If cif->flags is struct then we know it's not passed in registers */
+    if(ecif->cif->flags == FFI_TYPE_STRUCT)
+    {
+        *(void**)reg_base = ecif->rvalue;
+        reg_mask |= 1;
+    }
+
+    for(i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;
+        i++, p_arg++)
+    {
+        size_t z = (*p_arg)->size;
+        int alignment = (*p_arg)->alignment;
+        int type = (*p_arg)->type;
+        char *addr = 0;
+
+        if(z % 4 != 0)
+            z += (4 - z % 4);
+
+        if(reg_mask != 0x1f)
+        {
+            if(pass_struct_on_stack(*p_arg))
+            {
+                addr = stack_base + stack_offset;
+                stack_offset += z;
+            }
+            else if(z == sizeof(int))
+            {
+                char index = 0;
+
+                while((reg_mask >> index) & 1)
+                    index++;
+
+                addr = reg_base + (index * 4);
+                reg_mask |= (1 << index);
+            }
+            else if(z == 2 * sizeof(int))
+            {
+                if(!((reg_mask >> 1) & 1))
+                {
+                    addr = reg_base + 4;
+                    reg_mask |= (3 << 1);
+                }
+                else if(!((reg_mask >> 3) & 1))
+                {
+                    addr = reg_base + 12;
+                    reg_mask |= (3 << 3);
+                }
+            }
+        }
+
+        if(!addr)
+        {
+            addr = stack_base + stack_offset;
+            stack_offset += z;
+        }
+
+        if(type == FFI_TYPE_STRUCT && (*p_arg)->elements[1] == NULL)
+            type = (*p_arg)->elements[0]->type;
+
+        switch(type)
+        {
+        case FFI_TYPE_UINT8:
+            *(unsigned int *)addr = (unsigned int)*(UINT8 *)(*p_argv);
+            break;
+        case FFI_TYPE_SINT8:
+            *(signed int *)addr = (signed int)*(SINT8 *)(*p_argv);
+            break;
+        case FFI_TYPE_UINT16:
+            *(unsigned int *)addr = (unsigned int)*(UINT16 *)(*p_argv);
+            break;
+        case FFI_TYPE_SINT16:
+            *(signed int *)addr = (signed int)*(SINT16 *)(*p_argv);
+            break;
+        default:
+            memcpy(addr, *p_argv, z);
+        }
+
+        p_argv++;
+    }
+
+#ifdef DEBUG
+    /* Debugging */
+    for(i = 0; i < 5; i++)
+    {
+        if((reg_mask & (1 << i)) == 0)
+            printf("r%d: (unused)\n", 12 - i);
+        else
+            printf("r%d: 0x%08x\n", 12 - i, ((unsigned int*)reg_base)[i]);
+    }
+
+    for(i = 0; i < stack_offset / 4; i++)
+    {
+        printf("sp+%d: 0x%08x\n", i*4, ((unsigned int*)stack_base)[i]);
+    }
+#endif
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+    /* Round the stack up to a multiple of 8 bytes.  This isn't needed
+     * everywhere, but it is on some platforms, and it doesn't harm
+     * anything when it isn't needed. */
+    cif->bytes = (cif->bytes + 7) & ~7;
+
+    /* Flag to indicate that he return value is in fact a struct */
+    cif->rstruct_flag = 0;
+
+    /* Set the return type flag */
+    switch(cif->rtype->type)
+    {
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT8:
+        cif->flags = (unsigned)FFI_TYPE_UINT8;
+        break;
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT16:
+        cif->flags = (unsigned)FFI_TYPE_UINT16;
+        break;
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+        cif->flags = (unsigned)FFI_TYPE_UINT32;
+        break;
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+        cif->flags = (unsigned)FFI_TYPE_UINT64;
+        break;
+    case FFI_TYPE_STRUCT:
+        cif->rstruct_flag = 1;
+        if(!pass_struct_on_stack(cif->rtype))
+        {
+            if(cif->rtype->size <= 1)
+                cif->flags = (unsigned)FFI_TYPE_UINT8;
+            else if(cif->rtype->size <= 2)
+                cif->flags = (unsigned)FFI_TYPE_UINT16;
+            else if(cif->rtype->size <= 4)
+                cif->flags = (unsigned)FFI_TYPE_UINT32;
+            else if(cif->rtype->size <= 8)
+                cif->flags = (unsigned)FFI_TYPE_UINT64;
+            else
+                cif->flags = (unsigned)cif->rtype->type;
+        }
+        else
+            cif->flags = (unsigned)cif->rtype->type;
+        break;
+    default:
+        cif->flags = (unsigned)cif->rtype->type;
+        break;
+    }
+
+    return FFI_OK;
+}
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+    extended_cif ecif;
+
+    unsigned int size = 0, i = 0;
+    ffi_type **p_arg;
+
+    ecif.cif = cif;
+    ecif.avalue = avalue;
+
+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)
+        size += (*p_arg)->size + (4 - (*p_arg)->size % 4);
+
+    /* If the return value is a struct and we don't have a return value
+     * address then we need to make one */
+
+    /* If cif->flags is struct then it's not suitable for registers */
+    if((rvalue == NULL) && (cif->flags == FFI_TYPE_STRUCT))
+        ecif.rvalue = alloca(cif->rtype->size);
+    else
+        ecif.rvalue = rvalue;
+
+    switch(cif->abi)
+    {
+    case FFI_SYSV:
+        ffi_call_SYSV(ffi_prep_args, &ecif, size, cif->flags,
+            ecif.rvalue, cif->rstruct_flag, fn);
+        break;
+    default:
+        FFI_ASSERT(0);
+        break;
+    }
+}
+
+static void ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,
+    void **avalue, ffi_cif *cif)
+{
+    register unsigned int i, reg_mask = 0;
+    register void **p_argv;
+    register ffi_type **p_arg;
+    register char *reg_base = stack;
+    register char *stack_base = stack + 20;
+    register unsigned int stack_offset = 0;
+
+#ifdef DEBUG
+    /* Debugging */
+    for(i = 0; i < cif->nargs + 7; i++)
+    {
+        printf("sp+%d: 0x%08x\n", i*4, ((unsigned int*)stack)[i]);
+    }
+#endif
+
+    /* If cif->flags is struct then we know it's not passed in registers */
+    if(cif->flags == FFI_TYPE_STRUCT)
+    {
+        *rvalue = *(void **)reg_base;
+        reg_mask |= 1;
+    }
+
+    p_argv = avalue;
+
+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)
+    {
+        size_t z = (*p_arg)->size;
+        int alignment = (*p_arg)->alignment;
+
+        *p_argv = 0;
+
+        if(z % 4 != 0)
+            z += (4 - z % 4);
+
+        if(reg_mask != 0x1f)
+        {
+            if(pass_struct_on_stack(*p_arg))
+            {
+                *p_argv = (void*)stack_base + stack_offset;
+                stack_offset += z;
+            }
+            else if(z <= sizeof(int))
+            {
+                char index = 0;
+
+                while((reg_mask >> index) & 1)
+                    index++;
+
+                *p_argv = (void*)reg_base + (index * 4);
+                reg_mask |= (1 << index);
+            }
+            else if(z == 2 * sizeof(int))
+            {
+                if(!((reg_mask >> 1) & 1))
+                {
+                    *p_argv = (void*)reg_base + 4;
+                    reg_mask |= (3 << 1);
+                }
+                else if(!((reg_mask >> 3) & 1))
+                {
+                    *p_argv = (void*)reg_base + 12;
+                    reg_mask |= (3 << 3);
+                }
+            }
+        }
+
+        if(!*p_argv)
+        {
+            *p_argv = (void*)stack_base + stack_offset;
+            stack_offset += z;
+        }
+
+        if((*p_arg)->type != FFI_TYPE_STRUCT ||
+            (*p_arg)->elements[1] == NULL)
+        {
+            if(alignment == 1)
+                **(unsigned int**)p_argv <<= 24;
+            else if(alignment == 2)
+                **(unsigned int**)p_argv <<= 16;
+        }
+
+        p_argv++;
+    }
+
+#ifdef DEBUG
+    /* Debugging */
+    for(i = 0; i < cif->nargs; i++)
+    {
+        printf("sp+%d: 0x%08x\n", i*4, *(((unsigned int**)avalue)[i]));
+    }
+#endif
+}
+
+/* This function is jumped to by the trampoline */
+
+unsigned int ffi_closure_SYSV_inner(ffi_closure *closure, void **respp,
+    void *args)
+{
+    ffi_cif *cif;
+    void **arg_area;
+    unsigned int i, size = 0;
+    ffi_type **p_arg;
+
+    cif = closure->cif;
+
+    for(i = 0, p_arg = cif->arg_types; i < cif->nargs; i++, p_arg++)
+        size += (*p_arg)->size + (4 - (*p_arg)->size % 4);
+
+    arg_area = (void **)alloca(size);
+
+    /* this call will initialize ARG_AREA, such that each element in that
+     * array points to the corresponding value on the stack; and if the
+     * function returns a structure, it will re-set RESP to point to the
+     * structure return address. */
+
+    ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);
+
+    (closure->fun)(cif, *respp, arg_area, closure->user_data);
+
+    return cif->flags;
+}
+
+ffi_status ffi_prep_closure_loc(ffi_closure* closure, ffi_cif* cif,
+    void (*fun)(ffi_cif*, void*, void**, void*), void *user_data,
+    void *codeloc)
+{
+    if (cif->abi != FFI_SYSV)
+      return FFI_BAD_ABI;
+
+    unsigned char *__tramp = (unsigned char*)(&closure->tramp[0]);
+    unsigned int  __fun = (unsigned int)(&ffi_closure_SYSV);
+    unsigned int  __ctx = (unsigned int)(codeloc);
+    unsigned int  __rstruct_flag = (unsigned int)(cif->rstruct_flag);
+    unsigned int  __inner = (unsigned int)(&ffi_closure_SYSV_inner);
+    *(unsigned int*) &__tramp[0] = 0xebcd1f00;    /* pushm  r8-r12 */
+    *(unsigned int*) &__tramp[4] = 0xfefc0010;    /* ld.w   r12, pc[16] */
+    *(unsigned int*) &__tramp[8] = 0xfefb0010;    /* ld.w   r11, pc[16] */
+    *(unsigned int*) &__tramp[12] = 0xfefa0010;   /* ld.w   r10, pc[16] */
+    *(unsigned int*) &__tramp[16] = 0xfeff0010;   /* ld.w   pc, pc[16] */
+    *(unsigned int*) &__tramp[20] = __ctx;
+    *(unsigned int*) &__tramp[24] = __rstruct_flag;
+    *(unsigned int*) &__tramp[28] = __inner;
+    *(unsigned int*) &__tramp[32] = __fun;
+    syscall(__NR_cacheflush, 0, (&__tramp[0]), 36);
+
+    closure->cif = cif;
+    closure->user_data = user_data;
+    closure->fun  = fun;
+
+    return FFI_OK;
+}
+
Index: libffi-3.4.6/src/avr32/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/avr32/sysv.S b/libffi-3.4.6/src/avr32/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/avr32/sysv.S	
@@ -0,0 +1,208 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>
+
+   AVR32 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+   --------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+    /* r12:  ffi_prep_args
+     * r11:  &ecif
+     * r10:  size
+     * r9:   cif->flags
+     * r8:   ecif.rvalue
+     * sp+0: cif->rstruct_flag
+     * sp+4: fn */
+
+    .text
+    .align  1
+    .globl  ffi_call_SYSV
+    .type   ffi_call_SYSV, @function
+ffi_call_SYSV:
+    stm     --sp, r0,r1,lr
+    stm     --sp, r8-r12
+    mov     r0, sp
+
+    /* Make room for all of the new args. */
+    sub     sp, r10
+    /* Pad to make way for potential skipped registers */
+    sub     sp, 20
+
+    /* Call ffi_prep_args(stack, &ecif). */
+    /* r11 already set */
+    mov     r1, r12
+    mov     r12, sp
+    icall   r1
+
+    /* Save new argument size */
+    mov     r1, r12
+
+    /* Move first 5 parameters in registers. */
+    ldm     sp++, r8-r12
+
+    /* call (fn) (...). */
+    ld.w    r1, r0[36]
+    icall   r1
+
+    /* Remove the space we pushed for the args. */
+    mov     sp, r0
+
+    /* Load r1 with the rstruct flag. */
+    ld.w    r1, sp[32]
+
+    /* Load r9 with the return type code. */
+    ld.w    r9, sp[12]
+
+    /* Load r8 with the return value pointer. */
+    ld.w    r8, sp[16]
+
+    /* If the return value pointer is NULL, assume no return value. */
+    cp.w    r8, 0
+    breq    .Lend
+
+    /* Check if return type is actually a struct */
+    cp.w    r1, 0
+    breq    1f
+
+    /* Return 8bit */
+    cp.w    r9, FFI_TYPE_UINT8
+    breq    .Lstore8
+
+    /* Return 16bit */
+    cp.w    r9, FFI_TYPE_UINT16
+    breq    .Lstore16
+
+1:
+    /* Return 32bit */
+    cp.w    r9, FFI_TYPE_UINT32
+    breq    .Lstore32
+    cp.w    r9, FFI_TYPE_UINT16
+    breq    .Lstore32
+    cp.w    r9, FFI_TYPE_UINT8
+    breq    .Lstore32
+
+    /* Return 64bit */
+    cp.w    r9, FFI_TYPE_UINT64
+    breq    .Lstore64
+
+    /* Didn't match anything */
+    bral    .Lend
+
+.Lstore64:
+    st.w    r8[0], r11
+    st.w    r8[4], r10
+    bral    .Lend
+
+.Lstore32:
+    st.w    r8[0], r12
+    bral    .Lend
+
+.Lstore16:
+    st.h    r8[0], r12
+    bral    .Lend
+
+.Lstore8:
+    st.b    r8[0], r12
+    bral    .Lend
+
+.Lend:
+    sub     sp, -20
+    ldm     sp++, r0,r1,pc
+
+    .size   ffi_call_SYSV, . - ffi_call_SYSV
+
+
+    /* r12:  __ctx
+     * r11:  __rstruct_flag
+     * r10:  __inner */
+
+    .align  1
+    .globl  ffi_closure_SYSV
+    .type   ffi_closure_SYSV, @function
+ffi_closure_SYSV:
+    stm     --sp, r0,lr
+    mov     r0, r11
+    mov     r8, r10
+    sub     r10, sp, -8
+    sub     sp, 12
+    st.w    sp[8], sp
+    sub     r11, sp, -8
+    icall   r8
+
+    /* Check if return type is actually a struct */
+    cp.w    r0, 0
+    breq    1f
+
+    /* Return 8bit */
+    cp.w    r12, FFI_TYPE_UINT8
+    breq    .Lget8
+
+    /* Return 16bit */
+    cp.w    r12, FFI_TYPE_UINT16
+    breq    .Lget16
+
+1:
+    /* Return 32bit */
+    cp.w    r12, FFI_TYPE_UINT32
+    breq    .Lget32
+    cp.w    r12, FFI_TYPE_UINT16
+    breq    .Lget32
+    cp.w    r12, FFI_TYPE_UINT8
+    breq    .Lget32
+
+    /* Return 64bit */
+    cp.w    r12, FFI_TYPE_UINT64
+    breq    .Lget64
+
+    /* Didn't match anything */
+    bral    .Lclend
+
+.Lget64:
+    ld.w    r11, sp[0]
+    ld.w    r10, sp[4]
+    bral    .Lclend
+
+.Lget32:
+    ld.w    r12, sp[0]
+    bral    .Lclend
+
+.Lget16:
+    ld.uh   r12, sp[0]
+    bral    .Lclend
+
+.Lget8:
+    ld.ub   r12, sp[0]
+    bral    .Lclend
+
+.Lclend:
+    sub     sp, -12
+    ldm     sp++, r0,lr
+    sub     sp, -20
+    mov     pc, lr
+
+    .size   ffi_closure_SYSV, . - ffi_closure_SYSV
+
+#if defined __ELF__ && defined __linux__
+    .section    .note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/avr32/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/avr32/ffitarget.h b/libffi-3.4.6/src/avr32/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/avr32/ffitarget.h	
@@ -0,0 +1,55 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 2009  Bradley Smith <brad@brad-smith.co.uk>
+   Target configuration macros for AVR32.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+#define FFI_EXTRA_CIF_FIELDS unsigned int rstruct_flag
+
+/* Definitions for closures */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 36
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/metag/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/metag/ffi.c b/libffi-3.4.6/src/metag/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/metag/ffi.c	
@@ -0,0 +1,330 @@
+/* ----------------------------------------------------------------------
+  ffi.c - Copyright (c) 2013 Imagination Technologies
+
+  Meta Foreign Function Interface
+  Permission is hereby granted, free of charge, to any person obtaining
+  a copy of this software and associated documentation files (the
+  `Software''), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, sublicense, and/or sell copies of the Software, and to
+  permit persons to whom the Software is furnished to do so, subject to
+  the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED `AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL SIMON POSNJAK BE LIABLE FOR ANY CLAIM, DAMAGES OR
+  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+#define MIN(a,b) (((a) < (b)) ? (a) : (b))
+
+/*
+ * ffi_prep_args is called by the assembly routine once stack space has been
+ * allocated for the function's arguments
+ */
+
+unsigned int ffi_prep_args(char *stack, extended_cif *ecif)
+{
+	register unsigned int i;
+	register void **p_argv;
+	register char *argp;
+	register ffi_type **p_arg;
+
+	argp = stack;
+
+	/* Store return value */
+	if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {
+		argp -= 4;
+		*(void **) argp = ecif->rvalue;
+	}
+
+	p_argv = ecif->avalue;
+
+	/* point to next location */
+	for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; (i != 0); i--, p_arg++, p_argv++)
+	{
+		size_t z;
+
+		/* Move argp to address of argument */
+		z = (*p_arg)->size;
+		argp -= z;
+
+		/* Align if necessary */
+		argp = (char *) FFI_ALIGN_DOWN(FFI_ALIGN_DOWN(argp, (*p_arg)->alignment), 4);
+
+		if (z < sizeof(int)) {
+			z = sizeof(int);
+			switch ((*p_arg)->type)
+			{
+			case FFI_TYPE_SINT8:
+				*(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+				break;
+			case FFI_TYPE_UINT8:
+				*(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+				break;
+			case FFI_TYPE_SINT16:
+				*(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+				break;
+			case FFI_TYPE_UINT16:
+				*(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+			case FFI_TYPE_STRUCT:
+				memcpy(argp, *p_argv, (*p_arg)->size);
+				break;
+			default:
+				FFI_ASSERT(0);
+			}
+		} else if ( z == sizeof(int)) {
+			*(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+		} else {
+			memcpy(argp, *p_argv, z);
+		}
+	}
+
+	/* return the size of the arguments to be passed in registers,
+	   padded to an 8 byte boundary to preserve stack alignment */
+	return FFI_ALIGN(MIN(stack - argp, 6*4), 8);
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+	ffi_type **ptr;
+	unsigned i, bytes = 0;
+
+	for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++) {
+		if ((*ptr)->size == 0)
+			return FFI_BAD_TYPEDEF;
+
+		/* Perform a sanity check on the argument type, do this
+		   check after the initialization.  */
+		FFI_ASSERT_VALID_TYPE(*ptr);
+
+		/* Add any padding if necessary */
+		if (((*ptr)->alignment - 1) & bytes)
+			bytes = FFI_ALIGN(bytes, (*ptr)->alignment);
+
+		bytes += FFI_ALIGN((*ptr)->size, 4);
+	}
+
+	/* Ensure arg space is aligned to an 8-byte boundary */
+	bytes = FFI_ALIGN(bytes, 8);
+
+	/* Make space for the return structure pointer */
+	if (cif->rtype->type == FFI_TYPE_STRUCT) {
+		bytes += sizeof(void*);
+
+		/* Ensure stack is aligned to an 8-byte boundary */
+		bytes = FFI_ALIGN(bytes, 8);
+	}
+
+	cif->bytes = bytes;
+
+	/* Set the return type flag */
+	switch (cif->rtype->type) {
+	case FFI_TYPE_VOID:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+		cif->flags = (unsigned) cif->rtype->type;
+		break;
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+		cif->flags = (unsigned) FFI_TYPE_SINT64;
+		break;
+	case FFI_TYPE_STRUCT:
+		/* Meta can store return values which are <= 64 bits */
+		if (cif->rtype->size <= 4)
+			/* Returned to D0Re0 as 32-bit value */
+			cif->flags = (unsigned)FFI_TYPE_INT;
+		else if ((cif->rtype->size > 4) && (cif->rtype->size <= 8))
+			/* Returned valued is stored to D1Re0|R0Re0 */
+			cif->flags = (unsigned)FFI_TYPE_DOUBLE;
+		else
+			/* value stored in memory */
+			cif->flags = (unsigned)FFI_TYPE_STRUCT;
+		break;
+	default:
+		cif->flags = (unsigned)FFI_TYPE_INT;
+		break;
+	}
+	return FFI_OK;
+}
+
+extern void ffi_call_SYSV(void (*fn)(void), extended_cif *, unsigned, unsigned, double *);
+
+/*
+ * Exported in API. Entry point
+ * cif -> ffi_cif object
+ * fn -> function pointer
+ * rvalue -> pointer to return value
+ * avalue -> vector of void * pointers pointing to memory locations holding the
+ * arguments
+ */
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+	extended_cif ecif;
+
+	int small_struct = (((cif->flags == FFI_TYPE_INT) || (cif->flags == FFI_TYPE_DOUBLE)) && (cif->rtype->type == FFI_TYPE_STRUCT));
+	ecif.cif = cif;
+	ecif.avalue = avalue;
+
+	double temp;
+
+	/*
+	 * If the return value is a struct and we don't have a return value address
+	 * then we need to make one
+	 */
+
+	if ((rvalue == NULL ) && (cif->flags == FFI_TYPE_STRUCT))
+		ecif.rvalue = alloca(cif->rtype->size);
+	else if (small_struct)
+		ecif.rvalue = &temp;
+	else
+		ecif.rvalue = rvalue;
+
+	switch (cif->abi) {
+	case FFI_SYSV:
+		ffi_call_SYSV(fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);
+		break;
+	default:
+		FFI_ASSERT(0);
+		break;
+	}
+
+	if (small_struct)
+		memcpy (rvalue, &temp, cif->rtype->size);
+}
+
+/* private members */
+
+static void ffi_prep_incoming_args_SYSV (char *, void **, void **,
+	ffi_cif*, float *);
+
+void ffi_closure_SYSV (ffi_closure *);
+
+/* Do NOT change that without changing the FFI_TRAMPOLINE_SIZE */
+extern unsigned int ffi_metag_trampoline[10]; /* 10 instructions */
+
+/* end of private members */
+
+/*
+ * __tramp: trampoline memory location
+ * __fun: assembly routine
+ * __ctx: memory location for wrapper
+ *
+ * At this point, tramp[0] == __ctx !
+ */
+void ffi_init_trampoline(unsigned char *__tramp, unsigned int __fun, unsigned int __ctx) {
+	memcpy (__tramp, ffi_metag_trampoline, sizeof(ffi_metag_trampoline));
+	*(unsigned int*) &__tramp[40] = __ctx;
+	*(unsigned int*) &__tramp[44] = __fun;
+	/* This will flush the instruction cache */
+	__builtin_meta2_cachewd(&__tramp[0], 1);
+	__builtin_meta2_cachewd(&__tramp[47], 1);
+}
+
+
+
+/* the cif must already be prepared */
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+	ffi_cif* cif,
+	void (*fun)(ffi_cif*,void*,void**,void*),
+	void *user_data,
+	void *codeloc)
+{
+	void (*closure_func)(ffi_closure*) = NULL;
+
+	if (cif->abi == FFI_SYSV)
+		closure_func = &ffi_closure_SYSV;
+	else
+		return FFI_BAD_ABI;
+
+	ffi_init_trampoline(
+		(unsigned char*)&closure->tramp[0],
+		(unsigned int)closure_func,
+		(unsigned int)codeloc);
+
+	closure->cif = cif;
+	closure->user_data = user_data;
+	closure->fun = fun;
+
+	return FFI_OK;
+}
+
+
+/* This function is jumped to by the trampoline */
+unsigned int ffi_closure_SYSV_inner (closure, respp, args, vfp_args)
+	ffi_closure *closure;
+	void **respp;
+	void *args;
+	void *vfp_args;
+{
+	ffi_cif *cif;
+	void **arg_area;
+
+	cif = closure->cif;
+	arg_area = (void**) alloca (cif->nargs * sizeof (void*));
+
+	/*
+	 * This call will initialize ARG_AREA, such that each
+	 * element in that array points to the corresponding
+	 * value on the stack; and if the function returns
+	 * a structure, it will re-set RESP to point to the
+	 * structure return address.
+	 */
+	ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif, vfp_args);
+
+	(closure->fun) ( cif, *respp, arg_area, closure->user_data);
+
+	return cif->flags;
+}
+
+static void ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,
+	void **avalue, ffi_cif *cif,
+	float *vfp_stack)
+{
+	register unsigned int i;
+	register void **p_argv;
+	register char *argp;
+	register ffi_type **p_arg;
+
+	/* stack points to original arguments */
+	argp = stack;
+
+	/* Store return value */
+	if ( cif->flags == FFI_TYPE_STRUCT ) {
+		argp -= 4;
+		*rvalue = *(void **) argp;
+	}
+
+	p_argv = avalue;
+
+	for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++) {
+		size_t z;
+		size_t alignment;
+
+		alignment = (*p_arg)->alignment;
+		if (alignment < 4)
+			alignment = 4;
+		if ((alignment - 1) & (unsigned)argp)
+			argp = (char *) FFI_ALIGN(argp, alignment);
+
+		z = (*p_arg)->size;
+		*p_argv = (void*) argp;
+		p_argv++;
+		argp -= z;
+	}
+	return;
+}
Index: libffi-3.4.6/src/metag/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/metag/sysv.S b/libffi-3.4.6/src/metag/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/metag/sysv.S	
@@ -0,0 +1,311 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2013 Imagination Technologies Ltd.
+
+   Meta Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+#ifdef __USER_LABEL_PREFIX__
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+/* Use the right prefix for global labels. */
+#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
+#else
+#define CNAME(x) x
+#endif
+#define ENTRY(x) .globl CNAME(x); .type CNAME(x), %function; CNAME(x):
+#endif
+
+#ifdef __ELF__
+#define LSYM(x) .x
+#else
+#define LSYM(x) x
+#endif
+
+.macro call_reg x=
+	.text
+	.balign 4
+	mov D1RtP, \x
+	swap D1RtP, PC
+.endm
+
+! Save register arguments
+.macro SAVE_ARGS
+	.text
+	.balign 4
+	setl	[A0StP++], D0Ar6, D1Ar5
+	setl	[A0StP++], D0Ar4, D1Ar3
+	setl	[A0StP++], D0Ar2, D1Ar1
+.endm
+
+! Save retrun, frame pointer and other regs
+.macro SAVE_REGS regs=
+	.text
+	.balign 4
+	setl	[A0StP++], D0FrT, D1RtP
+	! Needs to be a pair of regs
+	.ifnc "\regs",""
+	setl	[A0StP++], \regs
+	.endif
+.endm
+
+! Declare a global function
+.macro METAG_FUNC_START name
+	.text
+	.balign 4
+	ENTRY(\name)
+.endm
+
+! Return registers from the stack. Reverse SAVE_REGS operation
+.macro RET_REGS regs=, cond=
+	.ifnc "\regs", ""
+	getl	\regs, [--A0StP]
+	.endif
+	getl	D0FrT, D1RtP, [--A0StP]
+.endm
+
+! Return arguments
+.macro RET_ARGS
+	getl	D0Ar2, D1Ar1, [--A0StP]
+	getl	D0Ar4, D1Ar3, [--A0StP]
+	getl	D0Ar6, D1Ar5, [--A0StP]
+.endm
+
+
+	! D1Ar1:	fn
+	! D0Ar2:	&ecif
+	! D1Ar3:	cif->bytes
+	! D0Ar4:	fig->flags
+	! D1Ar5:	ecif.rvalue
+
+	! This assumes we are using GNU as
+METAG_FUNC_START ffi_call_SYSV
+	! Save argument registers
+
+	SAVE_ARGS
+
+	! new frame
+	mov	D0FrT, A0FrP
+	add     A0FrP, A0StP, #0
+
+	! Preserve the old frame pointer
+	SAVE_REGS "D1.5, D0.5"
+
+	! Make room for new args. cifs->bytes is the total space for input
+	! and return arguments
+
+	add	A0StP, A0StP, D1Ar3
+
+	! Preserve cifs->bytes & fn
+	mov	D0.5, D1Ar3
+	mov	D1.5, D1Ar1
+
+	! Place all of the ffi_prep_args in position
+	mov	D1Ar1, A0StP
+
+	! Call ffi_prep_args(stack, &ecif)
+#ifdef __PIC__
+	callr  D1RtP, CNAME(ffi_prep_args@PLT)
+#else
+	callr  D1RtP, CNAME(ffi_prep_args)
+#endif
+
+	! Restore fn pointer
+
+	! The foreign stack should look like this
+	! XXXXX XXXXXX <--- stack pointer
+	! FnArgN rvalue
+	! FnArgN+2 FnArgN+1
+	! FnArgN+4 FnArgN+3
+	! ....
+	!
+
+	! A0StP now points to the first (or return) argument + 4
+
+	! Preserve cif->bytes
+	getl	D0Ar2, D1Ar1, [--A0StP]
+	getl	D0Ar4, D1Ar3, [--A0StP]
+	getl	D0Ar6, D1Ar5, [--A0StP]
+
+	! Place A0StP to the first argument again
+	add	A0StP, A0StP, #24 ! That's because we loaded 6 regs x 4 byte each
+
+	! A0FrP points to the initial stack without the reserved space for the
+	! cifs->bytes, whilst A0StP points to the stack after the space allocation
+
+	! fn was the first argument of ffi_call_SYSV.
+	! The stack at this point looks like this:
+	!
+	! A0StP(on entry to _SYSV) ->	Arg6	Arg5     | low
+	!				Arg4	Arg3     |
+	! 				Arg2	Arg1     |
+	! A0FrP ---->			D0FrtP	D1RtP    |
+	!				D1.5	D0.5	 |
+	! A0StP(bf prep_args) ->	FnArgn	FnArgn-1 |
+	!				FnArgn-2FnArgn-3 |
+	!				................ | <= cifs->bytes
+	!				FnArg4  FnArg3	 |
+	! A0StP (prv_A0StP+cifs->bytes) FnArg2  FnArg1   | high
+	!
+	! fn was in Arg1 so it's located in in A0FrP+#-0xC
+	!
+
+	! D0Re0 contains the size of arguments stored in registers
+	sub	A0StP, A0StP, D0Re0
+
+	! Arg1 is the function pointer for the foreign call. This has been
+	! preserved in D1.5
+
+	! Time to call (fn). Arguments should be like this:
+	! Arg1-Arg6 are loaded to regs
+	! The rest of the arguments are stored in stack pointed by A0StP
+
+	call_reg D1.5
+
+	! Reset stack.
+
+	mov	A0StP, A0FrP
+
+	! Load Arg1 with the pointer to storage for the return type
+	! This was stored in Arg5
+
+	getd	D1Ar1, [A0FrP+#-20]
+
+	! Load D0Ar2 with the return type code. This was stored in Arg4 (flags)
+
+	getd	D0Ar2, [A0FrP+#-16]
+
+	! We are ready to start processing the return value
+	! D0Re0 (and D1Re0) hold the return value
+
+	! If the return value is NULL, assume no return value
+	cmp	D1Ar1, #0
+	beq	LSYM(Lepilogue)
+
+	! return INT
+	cmp		D0Ar2, #FFI_TYPE_INT
+	! Sadly, there is no setd{cc} instruction so we need to workaround that
+	bne	.INT64
+	setd	[D1Ar1], D0Re0
+	b	LSYM(Lepilogue)
+
+	! return INT64
+.INT64:
+	cmp	D0Ar2, #FFI_TYPE_SINT64
+	setleq	[D1Ar1], D0Re0, D1Re0
+
+	! return DOUBLE
+	cmp	D0Ar2, #FFI_TYPE_DOUBLE
+	setl	[D1AR1++], D0Re0, D1Re0
+
+LSYM(Lepilogue):
+	! At this point, the stack pointer points right after the argument
+	! saved area. We need to restore 4 regs, therefore we need to move
+	! 16 bytes ahead.
+	add     A0StP, A0StP, #16
+	RET_REGS "D1.5, D0.5"
+	RET_ARGS
+	getd	D0Re0, [A0StP]
+	mov     A0FrP, D0FrT
+	swap	D1RtP, PC
+
+.ffi_call_SYSV_end:
+       .size   CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
+
+
+/*
+	(called by ffi_metag_trampoline)
+	void ffi_closure_SYSV (ffi_closure*)
+
+	(called by ffi_closure_SYSV)
+	unsigned int FFI_HIDDEN
+	ffi_closure_SYSV_inner (closure,respp, args)
+		ffi_closure *closure;
+		void **respp;
+		void *args;
+*/
+
+METAG_FUNC_START ffi_closure_SYSV
+	! We assume that D1Ar1 holds the address of the
+	! ffi_closure struct. We will use that to fetch the
+	! arguments. The stack pointer points to an empty space
+	! and it is ready to store more data.
+
+	! D1Ar1 is ready
+	! Allocate stack space for return value
+	add A0StP, A0StP, #8
+	! Store it to D0Ar2
+	sub D0Ar2, A0StP, #8
+
+	sub D1Ar3, A0FrP, #4
+
+	! D1Ar3 contains the address of the original D1Ar1 argument
+	! We need to subtract #4 later on
+
+	! Preverve D0Ar2
+	mov D0.5, D0Ar2
+
+#ifdef __PIC__
+	callr D1RtP, CNAME(ffi_closure_SYSV_inner@PLT)
+#else
+	callr D1RtP, CNAME(ffi_closure_SYSV_inner)
+#endif
+
+	! Check the return value and store it to D0.5
+	cmp D0Re0, #FFI_TYPE_INT
+	beq .Lretint
+	cmp D0Re0, #FFI_TYPE_DOUBLE
+	beq .Lretdouble
+.Lclosure_epilogue:
+	sub A0StP, A0StP, #8
+	RET_REGS "D1.5, D0.5"
+	RET_ARGS
+	swap	D1RtP, PC
+
+.Lretint:
+	setd [D0.5], D0Re0
+	b .Lclosure_epilogue
+.Lretdouble:
+	setl [D0.5++], D0Re0, D1Re0
+	b .Lclosure_epilogue
+.ffi_closure_SYSV_end:
+.size CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)
+
+
+ENTRY(ffi_metag_trampoline)
+	SAVE_ARGS
+	! New frame
+	mov A0FrP, A0StP
+	SAVE_REGS "D1.5, D0.5"
+	mov D0.5, PC
+	! Load D1Ar1 the value of ffi_metag_trampoline
+	getd D1Ar1, [D0.5 + #8]
+	! Jump to ffi_closure_SYSV
+	getd PC, [D0.5 + #12]
Index: libffi-3.4.6/src/metag/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/metag/ffitarget.h b/libffi-3.4.6/src/metag/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/metag/ffitarget.h	
@@ -0,0 +1,53 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2013 Imagination Technologies Ltd.
+   Target configuration macros for Meta
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_DEFAULT_ABI = FFI_SYSV,
+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1,
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 48
+#define FFI_NATIVE_RAW_API 0
+
+#endif
+
Index: libffi-3.4.6/src/moxie/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/moxie/ffi.c b/libffi-3.4.6/src/moxie/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/moxie/ffi.c	
@@ -0,0 +1,310 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (C) 2012, 2013, 2018, 2021, 2022  Anthony Green
+
+   Moxie Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+void *ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  register unsigned int i;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+  register int count = 0;
+
+  p_argv = ecif->avalue;
+  argp = stack;
+
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+      *(void **) argp = ecif->rvalue;
+      argp += 4;
+    }
+
+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;
+       (i != 0);
+       i--, p_arg++)
+    {
+      size_t z;
+
+      z = (*p_arg)->size;
+
+      if ((*p_arg)->type == FFI_TYPE_STRUCT)
+	{
+	  z = sizeof(void*);
+	  *(void **) argp = *p_argv;
+	}
+      else if (z < sizeof(int))
+	{
+	  z = sizeof(int);
+	  switch ((*p_arg)->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);
+	      break;
+
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);
+	      break;
+
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);
+	      break;
+
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	}
+      else if (z == sizeof(int))
+	{
+	  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);
+	}
+      else
+	{
+	  memcpy(argp, *p_argv, z);
+	}
+      p_argv++;
+      argp += z;
+      count += z;
+    }
+
+  return (stack + ((count > 24) ? 24 : FFI_ALIGN_DOWN(count, 8)));
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    cif->flags = -1;
+  else
+    cif->flags = cif->rtype->size;
+
+  cif->bytes = FFI_ALIGN (cif->bytes, 8);
+
+  return FFI_OK;
+}
+
+extern void ffi_call_EABI(void *(*)(char *, extended_cif *),
+			  extended_cif *,
+			  unsigned, unsigned,
+			  unsigned *,
+			  void (*fn)(void));
+
+void ffi_call(ffi_cif *cif,
+	      void (*fn)(void),
+	      void *rvalue,
+	      void **avalue)
+{
+  extended_cif ecif;
+  ffi_type **arg_types = cif->arg_types;
+  int i, nargs = cif->nargs;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT) /*  && size > 4) All struct args?? */
+        {
+          char *argcopy = alloca (size);
+          memcpy (argcopy, avalue[i], size);
+          avalue[i] = argcopy;
+        }
+    }
+
+  switch (cif->abi)
+    {
+    case FFI_EABI:
+      ffi_call_EABI(ffi_prep_args, &ecif, cif->bytes,
+		    cif->flags, ecif.rvalue, fn);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,
+		       unsigned arg4, unsigned arg5, unsigned arg6)
+{
+  /* This function is called by a trampoline.  The trampoline stows a
+     pointer to the ffi_closure object in $r12.  We must save this
+     pointer in a place that will persist while we do our work.  */
+  register ffi_closure *creg __asm__ ("$r12");
+  ffi_closure *closure = creg;
+
+  /* Arguments that don't fit in registers are found on the stack
+     at a fixed offset above the current frame pointer.  */
+  register char *frame_pointer __asm__ ("$fp");
+
+  /* Pointer to a struct return value.  */
+  void *struct_rvalue = (void *) arg1;
+
+  /* 6 words reserved for register args + 3 words from jsr */
+  char *stack_args = frame_pointer + 9*4;
+
+  /* Lay the register arguments down in a continuous chunk of memory.  */
+  unsigned register_args[6] =
+    { arg1, arg2, arg3, arg4, arg5, arg6 };
+  char *register_args_ptr = (char *) register_args;
+
+  ffi_cif *cif = closure->cif;
+  ffi_type **arg_types = cif->arg_types;
+  void **avalue = alloca (cif->nargs * sizeof(void *));
+  char *ptr = (char *) register_args;
+  int i;
+
+  /* preserve struct type return pointer passing */
+  if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {
+    ptr += 4;
+    register_args_ptr = (char *)&register_args[1];
+  }
+
+  /* Find the address of each argument.  */
+  for (i = 0; i < cif->nargs; i++)
+    {
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  avalue[i] = ptr + 3;
+	  break;
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  avalue[i] = ptr + 2;
+	  break;
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_POINTER:
+	  avalue[i] = ptr;
+	  break;
+	case FFI_TYPE_STRUCT:
+          {
+            if (arg_types[i]->size > 4)
+              {
+                void *copy = alloca(arg_types[i]->size);
+                memcpy(copy, *(void**)ptr, arg_types[i]->size);
+                avalue[i] = copy;
+              }
+            else
+              avalue[i] = *(void**)ptr;
+          }
+	  break;
+	default:
+	  /* This is an 8-byte value.  */
+	  if (ptr == (char *) &register_args[5])
+	    {
+	      /* The value is split across two locations */
+	      unsigned *ip = alloca(8);
+	      avalue[i] = ip;
+	      ip[0] = *(unsigned *) ptr;
+	      ip[1] = *(unsigned *) stack_args;
+	    }
+	  else
+	    {
+	      avalue[i] = ptr;
+	    }
+	  ptr += 4;
+	  break;
+	}
+      ptr += 4;
+
+      /* If we've handled more arguments than fit in registers,
+	 start looking at the those passed on the stack.  */
+      if (ptr == (char *) &register_args[6])
+	ptr = stack_args;
+      else if (ptr == (char *) &register_args[7])
+	ptr = stack_args + 4;
+    }
+
+  /* Invoke the closure.  */
+  if (cif->rtype && (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      (closure->fun) (cif, struct_rvalue, avalue, closure->user_data);
+    }
+  else
+    {
+      /* Allocate space for the return value and call the function.  */
+      long long rvalue;
+      (closure->fun) (cif, &rvalue, avalue, closure->user_data);
+      asm ("mov $r12, %0\n ld.l $r0, ($r12)\n ldo.l $r1, 4($r12)" : : "r" (&rvalue));
+    }
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned short *tramp = (unsigned short *) &closure->tramp[0];
+  unsigned long fn = (long) ffi_closure_eabi;
+  unsigned long cls = (long) codeloc;
+
+  if (cif->abi != FFI_EABI)
+    return FFI_BAD_ABI;
+
+  fn = (unsigned long) ffi_closure_eabi;
+
+  tramp[0] = 0x01e0; /* ldi.l $r12, .... */
+  tramp[1] = cls >> 16;
+  tramp[2] = cls & 0xffff;
+  tramp[3] = 0x1a00; /* jmpa .... */
+  tramp[4] = fn >> 16;
+  tramp[5] = fn & 0xffff;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/moxie/eabi.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/moxie/eabi.S b/libffi-3.4.6/src/moxie/eabi.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/moxie/eabi.S	
@@ -0,0 +1,101 @@
+/* -----------------------------------------------------------------------
+   eabi.S - Copyright (c) 2012, 2013  Anthony Green
+   
+   Moxie Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.globl ffi_prep_args_EABI
+
+	.text
+	.p2align 4
+	.globl ffi_call_EABI
+	.type ffi_call_EABI, @function
+
+	# $r0 :   ffi_prep_args
+	# $r1 :   &ecif
+	# $r2 :   cif->bytes
+	# $r3 :   fig->flags
+	# $r4 :   ecif.rvalue
+	# $r5 :   fn
+	
+ffi_call_EABI:
+	push	$sp, $r6
+	push	$sp, $r7
+	push	$sp, $r8
+	dec	$sp, 24
+
+	/* Store incoming args on stack.  */
+	sto.l	0($sp), $r0 /* ffi_prep_args */
+	sto.l	4($sp), $r1 /* ecif */
+	sto.l	8($sp), $r2 /* bytes */
+	sto.l	12($sp), $r3 /* flags */
+	sto.l	16($sp), $r4 /* &rvalue */
+	sto.l	20($sp), $r5 /* fn */
+	
+	/* Call ffi_prep_args.  */
+	mov 	$r6, $r4 /* Save result buffer */
+	mov	$r7, $r5 /* Save the target fn */
+	mov	$r8, $r3 /* Save the flags */
+	sub	$sp, $r2 /* Allocate stack space */
+	mov	$r0, $sp /* We can stomp over $r0 */
+	/* $r1 is already set up */
+	jsra 	ffi_prep_args
+
+	/* Load register arguments.  */
+	ldo.l	$r0, 0($sp)
+	ldo.l	$r1, 4($sp)
+	ldo.l	$r2, 8($sp)
+	ldo.l	$r3, 12($sp)
+	ldo.l	$r4, 16($sp)
+	ldo.l	$r5, 20($sp)
+	
+	/* Call the target function.  */
+	jsr	$r7
+
+	ldi.l	$r7, 0xffffffff
+	cmp	$r8, $r7
+	beq	retstruct
+
+	ldi.l	$r7, 4
+	cmp	$r8, $r7
+	bgt	ret2reg
+
+	st.l	($r6), $r0
+	jmpa	retdone
+
+ret2reg:	
+	st.l	($r6), $r0
+	sto.l	4($r6), $r1
+
+retstruct:
+retdone:	
+	/* Return.  */
+	ldo.l	$r6, -4($fp)
+	ldo.l	$r7, -8($fp)
+	ldo.l	$r8, -12($fp)
+	ret
+	.size ffi_call_EABI, .-ffi_call_EABI
+	
Index: libffi-3.4.6/src/moxie/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/moxie/ffitarget.h b/libffi-3.4.6/src/moxie/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/moxie/ffitarget.h	
@@ -0,0 +1,52 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012, 2013  Anthony Green
+   Target configuration macros for Moxie
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+/* ---- System specific configurations ----------------------------------- */
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_EABI,
+  FFI_DEFAULT_ABI = FFI_EABI,
+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+/* Trampolines are 12-bytes long.  See ffi_prep_closure_loc.  */
+#define FFI_TRAMPOLINE_SIZE (12)
+
+#endif
Index: libffi-3.4.6/src/nios2/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/nios2/ffi.c b/libffi-3.4.6/src/nios2/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/nios2/ffi.c	
@@ -0,0 +1,304 @@
+/* libffi support for Altera Nios II.
+
+   Copyright (c) 2013 Mentor Graphics.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+   
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+   
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* The Nios II Processor Reference Handbook defines the procedure call
+   ABI as follows.
+
+   Arguments are passed as if a structure containing the types of
+   the arguments were constructed.  The first 16 bytes are passed in r4
+   through r7, the remainder on the stack.  The first 16 bytes of a function
+   taking variable arguments are passed in r4-r7 in the same way.
+
+   Return values of types up to 8 bytes are returned in r2 and r3.  For
+   return values greater than 8 bytes, the caller must allocate memory for
+   the result and pass the address as if it were argument 0.  
+
+   While this isn't specified explicitly in the ABI documentation, GCC
+   promotes integral arguments smaller than int size to 32 bits.
+
+   Also of note, the ABI specifies that all structure objects are
+   aligned to 32 bits even if all their fields have a smaller natural
+   alignment.  See FFI_AGGREGATE_ALIGNMENT.  */
+
+
+/* Declare the assembly language hooks.  */
+
+extern UINT64 ffi_call_sysv (void (*) (char *, extended_cif *),
+			     extended_cif *,
+			     unsigned, 
+			     void (*fn) (void));
+extern void ffi_closure_sysv (void);
+
+/* Perform machine-dependent cif processing.  */
+
+ffi_status ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* We always want at least 16 bytes in the parameter block since it
+     simplifies the low-level call function.  Also round the parameter
+     block size up to a multiple of 4 bytes to preserve
+     32-bit alignment of the stack pointer.  */
+  if (cif->bytes < 16)
+    cif->bytes = 16;
+  else
+    cif->bytes = (cif->bytes + 3) & ~3;
+
+  return FFI_OK;
+}
+
+
+/* ffi_prep_args is called by the assembly routine to transfer arguments
+   to the stack using the pointers in the ecif array.
+   Note that the stack buffer is big enough to fit all the arguments,
+   but the first 16 bytes will be copied to registers for the actual
+   call.  */
+
+void ffi_prep_args (char *stack, extended_cif *ecif)
+{
+  char *argp = stack;
+  unsigned int i;
+
+  /* The implicit return value pointer is passed as if it were a hidden
+     first argument.  */
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT
+      && ecif->cif->rtype->size > 8)
+    {
+      (*(void **) argp) = ecif->rvalue;
+      argp += 4;
+    }
+
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      void *avalue = ecif->avalue[i];
+      ffi_type *atype = ecif->cif->arg_types[i];
+      size_t size = atype->size;
+      size_t alignment = atype->alignment;
+
+      /* Align argp as appropriate for the argument type.  */
+      if ((alignment - 1) & (unsigned) argp)
+	argp = (char *) FFI_ALIGN (argp, alignment);
+
+      /* Copy the argument, promoting integral types smaller than a
+	 word to word size.  */
+      if (size < sizeof (int))
+	{
+	  size = sizeof (int);
+	  switch (atype->type)
+	    {
+	    case FFI_TYPE_SINT8:
+	      *(signed int *) argp = (signed int) *(SINT8 *) avalue;
+	      break;
+		  
+	    case FFI_TYPE_UINT8:
+	      *(unsigned int *) argp = (unsigned int) *(UINT8 *) avalue;
+	      break;
+		  
+	    case FFI_TYPE_SINT16:
+	      *(signed int *) argp = (signed int) *(SINT16 *) avalue;
+	      break;
+		  
+	    case FFI_TYPE_UINT16:
+	      *(unsigned int *) argp = (unsigned int) *(UINT16 *) avalue;
+	      break;
+
+	    case FFI_TYPE_STRUCT:
+	      memcpy (argp, avalue, atype->size);
+	      break;
+
+	    default:
+	      FFI_ASSERT(0);
+	    }
+	}
+      else if (size == sizeof (int))
+	*(unsigned int *) argp = (unsigned int) *(UINT32 *) avalue;
+      else
+	memcpy (argp, avalue, size);
+      argp += size;
+    }
+}
+
+
+/* Call FN using the prepared CIF.  RVALUE points to space allocated by
+   the caller for the return value, and AVALUE is an array of argument
+   pointers.  */
+
+void ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+
+  extended_cif ecif;
+  UINT64 result;
+
+  /* If bigret is true, this is the case where a return value of larger
+     than 8 bytes is handled by being passed by reference as an implicit
+     argument.  */
+  int bigret = (cif->rtype->type == FFI_TYPE_STRUCT
+		&& cif->rtype->size > 8);
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* Allocate space for return value if this is the pass-by-reference case
+     and the caller did not provide a buffer.  */
+  if (rvalue == NULL && bigret)
+    ecif.rvalue = alloca (cif->rtype->size);
+  else
+    ecif.rvalue = rvalue;
+
+  result = ffi_call_sysv (ffi_prep_args, &ecif, cif->bytes, fn);
+
+  /* Now result contains the 64 bit contents returned from fn in
+     r2 and r3.  Copy the value of the appropriate size to the user-provided
+     rvalue buffer.  */
+  if (rvalue && !bigret)
+    switch (cif->rtype->size)
+      {
+      case 1:
+	*(UINT8 *)rvalue = (UINT8) result;
+	break;
+      case 2:
+	*(UINT16 *)rvalue = (UINT16) result;
+	break;
+      case 4:
+	*(UINT32 *)rvalue = (UINT32) result;
+	break;
+      case 8:
+	*(UINT64 *)rvalue = (UINT64) result;
+	break;
+      default:
+	memcpy (rvalue, (void *)&result, cif->rtype->size);
+	break;
+      }
+}
+
+/* This function is invoked from the closure trampoline to invoke
+   CLOSURE with argument block ARGS.  Parse ARGS according to
+   CLOSURE->cfi and invoke CLOSURE->fun.  */
+
+static UINT64
+ffi_closure_helper (unsigned char *args,
+		    ffi_closure *closure)
+{
+  ffi_cif *cif = closure->cif;
+  unsigned char *argp = args;
+  void **parsed_args = alloca (cif->nargs * sizeof (void *));
+  UINT64 result;
+  void *retptr;
+  unsigned int i;
+
+  /* First figure out what to do about the return type.  If this is the
+     big-structure-return case, the first arg is the hidden return buffer
+     allocated by the caller.  */
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+      && cif->rtype->size > 8)
+    {
+      retptr = *((void **) argp);
+      argp += 4;
+    }
+  else
+    retptr = (void *) &result;
+
+  /* Fill in the array of argument pointers.  */
+  for (i = 0; i < cif->nargs; i++)
+    {
+      size_t size = cif->arg_types[i]->size;
+      size_t alignment = cif->arg_types[i]->alignment;
+
+      /* Align argp as appropriate for the argument type.  */
+      if ((alignment - 1) & (unsigned) argp)
+	argp = (char *) FFI_ALIGN (argp, alignment);
+
+      /* Arguments smaller than an int are promoted to int.  */
+      if (size < sizeof (int))
+	size = sizeof (int);
+
+      /* Store the pointer.  */
+      parsed_args[i] = argp;
+      argp += size;
+    }
+
+  /* Call the user-supplied function.  */
+  (closure->fun) (cif, retptr, parsed_args, closure->user_data);
+  return result;
+}
+
+
+/* Initialize CLOSURE with a trampoline to call FUN with
+   CIF and USER_DATA.  */
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun) (ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+  int i;
+
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  /* The trampoline looks like:
+       movhi r8, %hi(ffi_closure_sysv)
+       ori r8, r8, %lo(ffi_closure_sysv)
+       movhi r9, %hi(ffi_closure_helper)
+       ori r0, r9, %lo(ffi_closure_helper)
+       movhi r10, %hi(closure)
+       ori r10, r10, %lo(closure)
+       jmp r8
+     and then ffi_closure_sysv retrieves the closure pointer out of r10
+     in addition to the arguments passed in the normal way for the call,
+     and invokes ffi_closure_helper.  We encode the pointer to
+     ffi_closure_helper in the trampoline because making a PIC call
+     to it in ffi_closure_sysv would be messy (it would have to indirect
+     through the GOT).  */
+
+#define HI(x) ((((unsigned int) (x)) >> 16) & 0xffff)
+#define LO(x) (((unsigned int) (x)) & 0xffff)
+  tramp[0] = (0 << 27) | (8 << 22) | (HI (ffi_closure_sysv) << 6) | 0x34;
+  tramp[1] = (8 << 27) | (8 << 22) | (LO (ffi_closure_sysv) << 6) | 0x14;
+  tramp[2] = (0 << 27) | (9 << 22) | (HI (ffi_closure_helper) << 6) | 0x34;
+  tramp[3] = (9 << 27) | (9 << 22) | (LO (ffi_closure_helper) << 6) | 0x14;
+  tramp[4] = (0 << 27) | (10 << 22) | (HI (closure) << 6) | 0x34;
+  tramp[5] = (10 << 27) | (10 << 22) | (LO (closure) << 6) | 0x14;
+  tramp[6] = (8 << 27) | (0x0d << 11) | 0x3a;
+#undef HI
+#undef LO
+
+  /* Flush the caches.
+     See Example 9-4 in the Nios II Software Developer's Handbook.  */
+  for (i = 0; i < 7; i++)
+    asm volatile ("flushd 0(%0); flushi %0" :: "r"(tramp + i) : "memory");
+  asm volatile ("flushp" ::: "memory");
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
Index: libffi-3.4.6/src/nios2/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/nios2/sysv.S b/libffi-3.4.6/src/nios2/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/nios2/sysv.S	
@@ -0,0 +1,136 @@
+/* Low-level libffi support for Altera Nios II.
+
+   Copyright (c) 2013 Mentor Graphics.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+   
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+   
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+/* This function is declared on the C side as 
+
+   extern UINT64 ffi_call_sysv (void (*arghook) (char *, extended_cif *),
+	  		        extended_cif *ecif,
+				unsigned nbytes, 
+				void (*fn) (void));
+	
+   On input, the arguments appear as
+	r4 = arghook
+	r5 = ecif
+	r6 = nbytes
+	r7 = fn
+*/
+
+	.section	.text
+	.align	2
+	.global	ffi_call_sysv
+	.type	ffi_call_sysv, @function
+
+ffi_call_sysv:
+	.cfi_startproc
+
+	/* Create the stack frame, saving r16 so we can use it locally.  */
+	addi	sp, sp, -12
+	.cfi_def_cfa_offset 12
+	stw	ra, 8(sp)
+	stw	fp, 4(sp)
+	stw	r16, 0(sp)
+	.cfi_offset 31, -4
+	.cfi_offset 28, -8
+	.cfi_offset 16, -12
+	mov	fp, sp
+	.cfi_def_cfa_register 28
+	mov	r16, r7
+
+	/* Adjust the stack pointer to create the argument buffer
+	   nbytes long.  */
+	sub	sp, sp, r6
+
+	/* Call the arghook function.  */
+	mov	r2, r4		/* fn */
+	mov	r4, sp		/* argbuffer */
+	callr	r2		/* r5 already contains ecif */
+
+	/* Pop off the first 16 bytes of the argument buffer on the stack,
+	   transferring the contents to the argument registers.  */
+	ldw	r4, 0(sp)
+	ldw	r5, 4(sp)
+	ldw	r6, 8(sp)
+	ldw	r7, 12(sp)
+	addi	sp, sp, 16
+
+	/* Call the user function, which leaves its result in r2 and r3.  */
+	callr	r16
+
+	/* Pop off the stack frame.  */
+	mov	sp, fp
+	ldw	ra, 8(sp)
+	ldw	fp, 4(sp)
+	ldw	r16, 0(sp)
+	addi	sp, sp, 12
+	ret
+	.cfi_endproc
+	.size	ffi_call_sysv, .-ffi_call_sysv
+
+
+/* Closure trampolines jump here after putting the C helper address
+   in r9 and the closure pointer in r10.  The user-supplied arguments
+   to the closure are in the normal places, in r4-r7 and on the
+   stack.  Push the register arguments on the stack too and then call the
+   C helper function to deal with them.  */
+   
+	.section	.text
+	.align	2
+	.global	ffi_closure_sysv
+	.type	ffi_closure_sysv, @function
+
+ffi_closure_sysv:
+	.cfi_startproc
+
+	/* Create the stack frame, pushing the register args on the stack
+	   just below the stack args.  This is the same trick illustrated
+	   in Figure 7-3 in the Nios II Processor Reference Handbook, used
+	   for variable arguments and structures passed by value.  */
+	addi	sp, sp, -20
+	.cfi_def_cfa_offset 20
+	stw	ra, 0(sp)
+	.cfi_offset 31, -20
+	stw	r4, 4(sp)
+	.cfi_offset 4, -16
+	stw	r5, 8(sp)
+	.cfi_offset 5, -12
+	stw	r6, 12(sp)
+	.cfi_offset 6, -8
+	stw	r7, 16(sp)
+	.cfi_offset 7, -4
+
+	/* Call the helper.
+	   r4 = pointer to arguments on stack
+	   r5 = closure pointer (loaded in r10 by the trampoline)
+	   r9 = address of helper function (loaded by trampoline) */
+	addi	r4, sp, 4
+	mov	r5, r10
+	callr	r9
+	
+	/* Pop the stack and return.  */
+	ldw	ra, 0(sp)
+	addi	sp, sp, 20
+	.cfi_def_cfa_offset -20
+	ret
+	.cfi_endproc
+	.size	ffi_closure_sysv, .-ffi_closure_sysv
+
Index: libffi-3.4.6/src/nios2/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/nios2/ffitarget.h b/libffi-3.4.6/src/nios2/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/nios2/ffitarget.h	
@@ -0,0 +1,52 @@
+/* libffi target includes for Altera Nios II.
+
+   Copyright (c) 2013 Mentor Graphics.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+   
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+   
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+/* Structures have a 4-byte alignment even if all the fields have lesser
+   alignment requirements.  */
+#define FFI_AGGREGATE_ALIGNMENT 4
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 28   /* 7 instructions */
+#define FFI_NATIVE_RAW_API 0
+
+#endif
Index: libffi-3.4.6/src/riscv/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/riscv/ffi.c b/libffi-3.4.6/src/riscv/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/riscv/ffi.c	
@@ -0,0 +1,514 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+                         2018 Stef O'Rear <sorear2@gmail.com>
+   Based on MIPS N32/64 port
+
+   RISC-V Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#if __riscv_float_abi_double
+#define ABI_FLEN 64
+#define ABI_FLOAT double
+#elif __riscv_float_abi_single
+#define ABI_FLEN 32
+#define ABI_FLOAT float
+#endif
+
+#define NARGREG 8
+#define STKALIGN 16
+#define MAXCOPYARG (2 * sizeof(double))
+
+typedef struct call_context
+{
+#if ABI_FLEN
+    ABI_FLOAT fa[8];
+#endif
+    size_t a[8];
+    /* used by the assembly code to in-place construct its own stack frame */
+    char frame[16];
+} call_context;
+
+typedef struct call_builder
+{
+    call_context *aregs;
+    int used_integer;
+    int used_float;
+    size_t *used_stack;
+    void *struct_stack;
+} call_builder;
+
+/* integer (not pointer) less than ABI XLEN */
+/* FFI_TYPE_INT does not appear to be used */
+#if __SIZEOF_POINTER__ == 8
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT64)
+#else
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT32)
+#endif
+
+#if ABI_FLEN
+typedef struct {
+    char as_elements, type1, offset2, type2;
+} float_struct_info;
+
+#if ABI_FLEN >= 64
+#define IS_FLOAT(type) ((type) >= FFI_TYPE_FLOAT && (type) <= FFI_TYPE_DOUBLE)
+#else
+#define IS_FLOAT(type) ((type) == FFI_TYPE_FLOAT)
+#endif
+
+static ffi_type **flatten_struct(ffi_type *in, ffi_type **out, ffi_type **out_end) {
+    int i;
+    if (out == out_end) return out;
+    if (in->type != FFI_TYPE_STRUCT) {
+        *(out++) = in;
+    } else {
+        for (i = 0; in->elements[i]; i++)
+            out = flatten_struct(in->elements[i], out, out_end);
+    }
+    return out;
+}
+
+/* Structs with at most two fields after flattening, one of which is of
+   floating point type, are passed in multiple registers if sufficient
+   registers are available. */
+static float_struct_info struct_passed_as_elements(call_builder *cb, ffi_type *top) {
+    float_struct_info ret = {0, 0, 0, 0};
+    ffi_type *fields[3];
+    int num_floats, num_ints;
+    int num_fields = flatten_struct(top, fields, fields + 3) - fields;
+
+    if (num_fields == 1) {
+        if (IS_FLOAT(fields[0]->type)) {
+            ret.as_elements = 1;
+            ret.type1 = fields[0]->type;
+        }
+    } else if (num_fields == 2) {
+        num_floats = IS_FLOAT(fields[0]->type) + IS_FLOAT(fields[1]->type);
+        num_ints = IS_INT(fields[0]->type) + IS_INT(fields[1]->type);
+        if (num_floats == 0 || num_floats + num_ints != 2)
+            return ret;
+        if (cb->used_float + num_floats > NARGREG || cb->used_integer + (2 - num_floats) > NARGREG)
+            return ret;
+        if (!IS_FLOAT(fields[0]->type) && !IS_FLOAT(fields[1]->type))
+            return ret;
+
+        ret.type1 = fields[0]->type;
+        ret.type2 = fields[1]->type;
+        ret.offset2 = FFI_ALIGN(fields[0]->size, fields[1]->alignment);
+        ret.as_elements = 1;
+    }
+
+    return ret;
+}
+#endif
+
+/* allocates a single register, float register, or XLEN-sized stack slot to a datum */
+static void marshal_atom(call_builder *cb, int type, void *data) {
+    size_t value = 0;
+    switch (type) {
+        case FFI_TYPE_UINT8: value = *(uint8_t *)data; break;
+        case FFI_TYPE_SINT8: value = *(int8_t *)data; break;
+        case FFI_TYPE_UINT16: value = *(uint16_t *)data; break;
+        case FFI_TYPE_SINT16: value = *(int16_t *)data; break;
+        /* 32-bit quantities are always sign-extended in the ABI */
+        case FFI_TYPE_UINT32: value = *(int32_t *)data; break;
+        case FFI_TYPE_SINT32: value = *(int32_t *)data; break;
+#if __SIZEOF_POINTER__ == 8
+        case FFI_TYPE_UINT64: value = *(uint64_t *)data; break;
+        case FFI_TYPE_SINT64: value = *(int64_t *)data; break;
+#endif
+        case FFI_TYPE_POINTER: value = *(size_t *)data; break;
+
+        /* float values may be recoded in an implementation-defined way
+           by hardware conforming to 2.1 or earlier, so use asm to
+           reinterpret floats as doubles */
+#if ABI_FLEN >= 32
+        case FFI_TYPE_FLOAT:
+            asm("" : "=f"(cb->aregs->fa[cb->used_float++]) : "0"(*(float *)data));
+            return;
+#endif
+#if ABI_FLEN >= 64
+        case FFI_TYPE_DOUBLE:
+            asm("" : "=f"(cb->aregs->fa[cb->used_float++]) : "0"(*(double *)data));
+            return;
+#endif
+        default: FFI_ASSERT(0); break;
+    }
+
+    if (cb->used_integer == NARGREG) {
+        *cb->used_stack++ = value;
+    } else {
+        cb->aregs->a[cb->used_integer++] = value;
+    }
+}
+
+static void unmarshal_atom(call_builder *cb, int type, void *data) {
+    size_t value;
+    switch (type) {
+#if ABI_FLEN >= 32
+        case FFI_TYPE_FLOAT:
+            asm("" : "=f"(*(float *)data) : "0"(cb->aregs->fa[cb->used_float++]));
+            return;
+#endif
+#if ABI_FLEN >= 64
+        case FFI_TYPE_DOUBLE:
+            asm("" : "=f"(*(double *)data) : "0"(cb->aregs->fa[cb->used_float++]));
+            return;
+#endif
+    }
+
+    if (cb->used_integer == NARGREG) {
+        value = *cb->used_stack++;
+    } else {
+        value = cb->aregs->a[cb->used_integer++];
+    }
+
+    switch (type) {
+        case FFI_TYPE_UINT8: *(uint8_t *)data = value; break;
+        case FFI_TYPE_SINT8: *(uint8_t *)data = value; break;
+        case FFI_TYPE_UINT16: *(uint16_t *)data = value; break;
+        case FFI_TYPE_SINT16: *(uint16_t *)data = value; break;
+        case FFI_TYPE_UINT32: *(uint32_t *)data = value; break;
+        case FFI_TYPE_SINT32: *(uint32_t *)data = value; break;
+#if __SIZEOF_POINTER__ == 8
+        case FFI_TYPE_UINT64: *(uint64_t *)data = value; break;
+        case FFI_TYPE_SINT64: *(uint64_t *)data = value; break;
+#endif
+        case FFI_TYPE_POINTER: *(size_t *)data = value; break;
+        default: FFI_ASSERT(0); break;
+    }
+}
+
+/* adds an argument to a call, or a not by reference return value */
+static void marshal(call_builder *cb, ffi_type *type, int var, void *data) {
+    size_t realign[2];
+
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) {
+            marshal_atom(cb, fsi.type1, data);
+            if (fsi.offset2)
+                marshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);
+            return;
+        }
+    }
+
+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {
+        marshal_atom(cb, type->type, data);
+        return;
+    }
+#endif
+
+    if (type->size > 2 * __SIZEOF_POINTER__) {
+        /* copy to stack and pass by reference */
+        data = memcpy (cb->struct_stack, data, type->size);
+        cb->struct_stack = (size_t *) FFI_ALIGN ((char *) cb->struct_stack + type->size, __SIZEOF_POINTER__);
+        marshal_atom(cb, FFI_TYPE_POINTER, &data);
+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+        marshal_atom(cb, type->type, data);
+    } else {
+        /* overlong integers, soft-float floats, and structs without special
+           float handling are treated identically from this point on */
+
+        /* variadics are aligned even in registers */
+        if (type->alignment > __SIZEOF_POINTER__) {
+            if (var)
+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);
+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);
+        }
+
+        memcpy(realign, data, type->size);
+        if (type->size > 0)
+            marshal_atom(cb, FFI_TYPE_POINTER, realign);
+        if (type->size > __SIZEOF_POINTER__)
+            marshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+    }
+}
+
+/* for arguments passed by reference returns the pointer, otherwise the arg is copied (up to MAXCOPYARG bytes) */
+static void *unmarshal(call_builder *cb, ffi_type *type, int var, void *data) {
+    size_t realign[2];
+    void *pointer;
+
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) {
+            unmarshal_atom(cb, fsi.type1, data);
+            if (fsi.offset2)
+                unmarshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);
+            return data;
+        }
+    }
+
+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {
+        unmarshal_atom(cb, type->type, data);
+        return data;
+    }
+#endif
+
+    if (type->size > 2 * __SIZEOF_POINTER__) {
+        /* pass by reference */
+        unmarshal_atom(cb, FFI_TYPE_POINTER, (char*)&pointer);
+        return pointer;
+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+        unmarshal_atom(cb, type->type, data);
+        return data;
+    } else {
+        /* overlong integers, soft-float floats, and structs without special
+           float handling are treated identically from this point on */
+
+        /* variadics are aligned even in registers */
+        if (type->alignment > __SIZEOF_POINTER__) {
+            if (var)
+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);
+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);
+        }
+
+        if (type->size > 0)
+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign);
+        if (type->size > __SIZEOF_POINTER__)
+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+        memcpy(data, realign, type->size);
+        return data;
+    }
+}
+
+static int passed_by_ref(call_builder *cb, ffi_type *type, int var) {
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) return 0;
+    }
+#endif
+
+    return type->size > 2 * __SIZEOF_POINTER__;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif) {
+    cif->riscv_nfixedargs = cif->nargs;
+    return FFI_OK;
+}
+
+/* Perform machine dependent cif processing when we have a variadic function */
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs) {
+    cif->riscv_nfixedargs = nfixedargs;
+    return FFI_OK;
+}
+
+/* Low level routine for calling functions */
+extern void ffi_call_asm (void *stack, struct call_context *regs,
+			  void (*fn) (void), void *closure) FFI_HIDDEN;
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	      void *closure)
+{
+    /* this is a conservative estimate, assuming a complex return value and
+       that all remaining arguments are long long / __int128 */
+    size_t arg_bytes = cif->nargs <= 3 ? 0 :
+        FFI_ALIGN(2 * sizeof(size_t) * (cif->nargs - 3), STKALIGN);
+    /* Allocate space for copies of big structures.  */
+    size_t struct_bytes = FFI_ALIGN (cif->bytes, STKALIGN);
+    size_t rval_bytes = 0;
+    if (rvalue == NULL && cif->rtype->size > 2*__SIZEOF_POINTER__)
+        rval_bytes = FFI_ALIGN(cif->rtype->size, STKALIGN);
+    size_t alloc_size = arg_bytes + rval_bytes + struct_bytes + sizeof(call_context);
+
+    /* the assembly code will deallocate all stack data at lower addresses
+       than the argument region, so we need to allocate the frame and the
+       return value after the arguments in a single allocation */
+    size_t alloc_base;
+    /* Argument region must be 16-byte aligned */
+    if (_Alignof(max_align_t) >= STKALIGN) {
+        /* since sizeof long double is normally 16, the compiler will
+           guarantee alloca alignment to at least that much */
+        alloc_base = (size_t)alloca(alloc_size);
+    } else {
+        alloc_base = FFI_ALIGN(alloca(alloc_size + STKALIGN - 1), STKALIGN);
+    }
+
+    if (rval_bytes)
+        rvalue = (void*)(alloc_base + arg_bytes);
+
+    call_builder cb;
+    cb.used_float = cb.used_integer = 0;
+    cb.aregs = (call_context*)(alloc_base + arg_bytes + rval_bytes + struct_bytes);
+    cb.used_stack = (void*)alloc_base;
+    cb.struct_stack = (void *) (alloc_base + arg_bytes + rval_bytes);
+
+    int return_by_ref = passed_by_ref(&cb, cif->rtype, 0);
+    if (return_by_ref)
+        marshal(&cb, &ffi_type_pointer, 0, &rvalue);
+
+    int i;
+    for (i = 0; i < cif->nargs; i++)
+        marshal(&cb, cif->arg_types[i], i >= cif->riscv_nfixedargs, avalue[i]);
+
+    ffi_call_asm ((void *) alloc_base, cb.aregs, fn, closure);
+
+    cb.used_float = cb.used_integer = 0;
+    if (!return_by_ref && rvalue)
+      {
+	if (IS_INT(cif->rtype->type)
+	    && cif->rtype->size < sizeof (ffi_arg))
+	  {
+	    /* Integer types smaller than ffi_arg need to be extended.  */
+	    switch (cif->rtype->type)
+	      {
+	      case FFI_TYPE_SINT8:
+	      case FFI_TYPE_SINT16:
+	      case FFI_TYPE_SINT32:
+		unmarshal_atom (&cb, (sizeof (ffi_arg) > 4
+				      ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32),
+				rvalue);
+		break;
+	      case FFI_TYPE_UINT8:
+	      case FFI_TYPE_UINT16:
+	      case FFI_TYPE_UINT32:
+		unmarshal_atom (&cb, (sizeof (ffi_arg) > 4
+				      ? FFI_TYPE_UINT64 : FFI_TYPE_UINT32),
+				rvalue);
+		break;
+	      }
+	  }
+	else
+	  unmarshal(&cb, cif->rtype, 0, rvalue);
+      }
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+extern void ffi_closure_asm(void) FFI_HIDDEN;
+
+ffi_status ffi_prep_closure_loc(ffi_closure *closure, ffi_cif *cif, void (*fun)(ffi_cif*,void*,void**,void*), void *user_data, void *codeloc)
+{
+    uint32_t *tramp = (uint32_t *) &closure->tramp[0];
+    uint64_t fn = (uint64_t) (uintptr_t) ffi_closure_asm;
+
+    if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+        return FFI_BAD_ABI;
+
+    /* we will call ffi_closure_inner with codeloc, not closure, but as long
+       as the memory is readable it should work */
+
+    tramp[0] = 0x00000317; /* auipc t1, 0 (i.e. t0 <- codeloc) */
+#if __SIZEOF_POINTER__ == 8
+    tramp[1] = 0x01033383; /* ld t2, 16(t1) */
+#else
+    tramp[1] = 0x01032383; /* lw t2, 16(t1) */
+#endif
+    tramp[2] = 0x00038067; /* jr t2 */
+    tramp[3] = 0x00000013; /* nop */
+    tramp[4] = fn;
+    tramp[5] = fn >> 32;
+
+    closure->cif = cif;
+    closure->fun = fun;
+    closure->user_data = user_data;
+
+#if !defined(__FreeBSD__)
+    __builtin___clear_cache(codeloc, codeloc + FFI_TRAMPOLINE_SIZE);
+#endif
+
+    return FFI_OK;
+}
+
+extern void ffi_go_closure_asm (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+  if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (void *) ffi_go_closure_asm;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+/* Called by the assembly code with aregs pointing to saved argument registers
+   and stack pointing to the stacked arguments.  Return values passed in
+   registers will be reloaded from aregs. */
+void FFI_HIDDEN
+ffi_closure_inner (ffi_cif *cif,
+		   void (*fun) (ffi_cif *, void *, void **, void *),
+		   void *user_data,
+		   size_t *stack, call_context *aregs)
+{
+    void **avalue = alloca(cif->nargs * sizeof(void*));
+    /* storage for arguments which will be copied by unmarshal().  We could
+       theoretically avoid the copies in many cases and use at most 128 bytes
+       of memory, but allocating disjoint storage for each argument is
+       simpler. */
+    char *astorage = alloca(cif->nargs * MAXCOPYARG);
+    void *rvalue;
+    call_builder cb;
+    int return_by_ref;
+    int i;
+
+    cb.aregs = aregs;
+    cb.used_integer = cb.used_float = 0;
+    cb.used_stack = stack;
+
+    return_by_ref = passed_by_ref(&cb, cif->rtype, 0);
+    if (return_by_ref)
+        unmarshal(&cb, &ffi_type_pointer, 0, &rvalue);
+    else
+        rvalue = alloca(cif->rtype->size);
+
+    for (i = 0; i < cif->nargs; i++)
+        avalue[i] = unmarshal(&cb, cif->arg_types[i],
+            i >= cif->riscv_nfixedargs, astorage + i*MAXCOPYARG);
+
+    fun (cif, rvalue, avalue, user_data);
+
+    if (!return_by_ref && cif->rtype->type != FFI_TYPE_VOID) {
+        cb.used_integer = cb.used_float = 0;
+        marshal(&cb, cif->rtype, 0, rvalue);
+    }
+}
Index: libffi-3.4.6/src/riscv/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/riscv/sysv.S b/libffi-3.4.6/src/riscv/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/riscv/sysv.S	
@@ -0,0 +1,293 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+                         2018 Stef O'Rear <sorear2@gmail.com>
+
+   RISC-V Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Define aliases so that we can handle all ABIs uniformly */
+
+#if __SIZEOF_POINTER__ == 8
+#define PTRS 8
+#define LARG ld
+#define SARG sd
+#else
+#define PTRS 4
+#define LARG lw
+#define SARG sw
+#endif
+
+#if __riscv_float_abi_double
+#define FLTS 8
+#define FLARG fld
+#define FSARG fsd
+#elif __riscv_float_abi_single
+#define FLTS 4
+#define FLARG flw
+#define FSARG fsw
+#else
+#define FLTS 0
+#endif
+
+#define fp s0
+
+    .text
+    .globl  ffi_call_asm
+    .type   ffi_call_asm, @function
+    .hidden ffi_call_asm
+/*
+  struct call_context {
+      floatreg fa[8];
+      intreg a[8];
+      intreg pad[rv32 ? 2 : 0];
+      intreg save_fp, save_ra;
+  }
+  void ffi_call_asm (size_t *stackargs, struct call_context *regargs,
+                     void (*fn) (void), void *closure);
+*/
+
+#define FRAME_LEN (8 * FLTS + 8 * PTRS + 16)
+
+ffi_call_asm:
+    .cfi_startproc
+
+    /*
+      We are NOT going to set up an ordinary stack frame.  In order to pass
+      the stacked args to the called function, we adjust our stack pointer to
+      a0, which is in the _caller's_ alloca area.  We establish our own stack
+      frame at the end of the call_context.
+
+      Anything below the arguments will be freed at this point, although we
+      preserve the call_context so that it can be read back in the caller.
+    */
+
+    .cfi_def_cfa 11, FRAME_LEN # interim CFA based on a1
+    SARG    fp, FRAME_LEN - 2*PTRS(a1)
+    .cfi_offset 8, -2*PTRS
+    SARG    ra, FRAME_LEN - 1*PTRS(a1)
+    .cfi_offset 1, -1*PTRS
+
+    addi    fp, a1, FRAME_LEN
+    mv      sp, a0
+    .cfi_def_cfa 8, 0 # our frame is fully set up
+
+    # Load arguments
+    mv      t1, a2
+    mv      t2, a3
+
+#if FLTS
+    FLARG   fa0, -FRAME_LEN+0*FLTS(fp)
+    FLARG   fa1, -FRAME_LEN+1*FLTS(fp)
+    FLARG   fa2, -FRAME_LEN+2*FLTS(fp)
+    FLARG   fa3, -FRAME_LEN+3*FLTS(fp)
+    FLARG   fa4, -FRAME_LEN+4*FLTS(fp)
+    FLARG   fa5, -FRAME_LEN+5*FLTS(fp)
+    FLARG   fa6, -FRAME_LEN+6*FLTS(fp)
+    FLARG   fa7, -FRAME_LEN+7*FLTS(fp)
+#endif
+
+    LARG    a0, -FRAME_LEN+8*FLTS+0*PTRS(fp)
+    LARG    a1, -FRAME_LEN+8*FLTS+1*PTRS(fp)
+    LARG    a2, -FRAME_LEN+8*FLTS+2*PTRS(fp)
+    LARG    a3, -FRAME_LEN+8*FLTS+3*PTRS(fp)
+    LARG    a4, -FRAME_LEN+8*FLTS+4*PTRS(fp)
+    LARG    a5, -FRAME_LEN+8*FLTS+5*PTRS(fp)
+    LARG    a6, -FRAME_LEN+8*FLTS+6*PTRS(fp)
+    LARG    a7, -FRAME_LEN+8*FLTS+7*PTRS(fp)
+
+    /* Call */
+    jalr    t1
+
+    /* Save return values - only a0/a1 (fa0/fa1) are used */
+#if FLTS
+    FSARG   fa0, -FRAME_LEN+0*FLTS(fp)
+    FSARG   fa1, -FRAME_LEN+1*FLTS(fp)
+#endif
+
+    SARG    a0, -FRAME_LEN+8*FLTS+0*PTRS(fp)
+    SARG    a1, -FRAME_LEN+8*FLTS+1*PTRS(fp)
+
+    /* Restore and return */
+    addi    sp, fp, -FRAME_LEN
+    .cfi_def_cfa 2, FRAME_LEN
+    LARG    ra, -1*PTRS(fp)
+    .cfi_restore 1
+    LARG    fp, -2*PTRS(fp)
+    .cfi_restore 8
+    ret
+    .cfi_endproc
+    .size   ffi_call_asm, .-ffi_call_asm
+
+
+/*
+  ffi_closure_asm. Expects address of the passed-in ffi_closure in t1.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+    .globl ffi_closure_asm
+    .hidden ffi_closure_asm
+    .type ffi_closure_asm, @function
+ffi_closure_asm:
+    .cfi_startproc
+
+    addi    sp,  sp, -FRAME_LEN
+    .cfi_def_cfa_offset FRAME_LEN
+
+    /* make a frame */
+    SARG    fp, FRAME_LEN - 2*PTRS(sp)
+    .cfi_offset 8, -2*PTRS
+    SARG    ra, FRAME_LEN - 1*PTRS(sp)
+    .cfi_offset 1, -1*PTRS
+    addi    fp, sp, FRAME_LEN
+
+    /* save arguments */
+#if FLTS
+    FSARG   fa0, 0*FLTS(sp)
+    FSARG   fa1, 1*FLTS(sp)
+    FSARG   fa2, 2*FLTS(sp)
+    FSARG   fa3, 3*FLTS(sp)
+    FSARG   fa4, 4*FLTS(sp)
+    FSARG   fa5, 5*FLTS(sp)
+    FSARG   fa6, 6*FLTS(sp)
+    FSARG   fa7, 7*FLTS(sp)
+#endif
+
+    SARG    a0, 8*FLTS+0*PTRS(sp)
+    SARG    a1, 8*FLTS+1*PTRS(sp)
+    SARG    a2, 8*FLTS+2*PTRS(sp)
+    SARG    a3, 8*FLTS+3*PTRS(sp)
+    SARG    a4, 8*FLTS+4*PTRS(sp)
+    SARG    a5, 8*FLTS+5*PTRS(sp)
+    SARG    a6, 8*FLTS+6*PTRS(sp)
+    SARG    a7, 8*FLTS+7*PTRS(sp)
+
+    /* enter C */
+    LARG    a0, FFI_TRAMPOLINE_SIZE+0*PTRS(t1)
+    LARG    a1, FFI_TRAMPOLINE_SIZE+1*PTRS(t1)
+    LARG    a2, FFI_TRAMPOLINE_SIZE+2*PTRS(t1)
+    addi    a3, sp, FRAME_LEN
+    mv      a4, sp
+
+    call    ffi_closure_inner
+
+    /* return values */
+#if FLTS
+    FLARG   fa0, 0*FLTS(sp)
+    FLARG   fa1, 1*FLTS(sp)
+#endif
+
+    LARG    a0, 8*FLTS+0*PTRS(sp)
+    LARG    a1, 8*FLTS+1*PTRS(sp)
+
+    /* restore and return */
+    LARG    ra, FRAME_LEN-1*PTRS(sp)
+    .cfi_restore 1
+    LARG    fp, FRAME_LEN-2*PTRS(sp)
+    .cfi_restore 8
+    addi    sp, sp, FRAME_LEN
+    .cfi_def_cfa_offset 0
+    ret
+    .cfi_endproc
+    .size ffi_closure_asm, .-ffi_closure_asm
+
+/*
+  ffi_go_closure_asm.  Expects address of the passed-in ffi_go_closure in t2.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+    .globl ffi_go_closure_asm
+    .hidden ffi_go_closure_asm
+    .type ffi_go_closure_asm, @function
+ffi_go_closure_asm:
+    .cfi_startproc
+
+    addi    sp,  sp, -FRAME_LEN
+    .cfi_def_cfa_offset FRAME_LEN
+
+    /* make a frame */
+    SARG    fp, FRAME_LEN - 2*PTRS(sp)
+    .cfi_offset 8, -2*PTRS
+    SARG    ra, FRAME_LEN - 1*PTRS(sp)
+    .cfi_offset 1, -1*PTRS
+    addi    fp, sp, FRAME_LEN
+
+    /* save arguments */
+#if FLTS
+    FSARG   fa0, 0*FLTS(sp)
+    FSARG   fa1, 1*FLTS(sp)
+    FSARG   fa2, 2*FLTS(sp)
+    FSARG   fa3, 3*FLTS(sp)
+    FSARG   fa4, 4*FLTS(sp)
+    FSARG   fa5, 5*FLTS(sp)
+    FSARG   fa6, 6*FLTS(sp)
+    FSARG   fa7, 7*FLTS(sp)
+#endif
+
+    SARG    a0, 8*FLTS+0*PTRS(sp)
+    SARG    a1, 8*FLTS+1*PTRS(sp)
+    SARG    a2, 8*FLTS+2*PTRS(sp)
+    SARG    a3, 8*FLTS+3*PTRS(sp)
+    SARG    a4, 8*FLTS+4*PTRS(sp)
+    SARG    a5, 8*FLTS+5*PTRS(sp)
+    SARG    a6, 8*FLTS+6*PTRS(sp)
+    SARG    a7, 8*FLTS+7*PTRS(sp)
+
+    /* enter C */
+    LARG    a0, 1*PTRS(t2)
+    LARG    a1, 2*PTRS(t2)
+    mv      a2, t2
+    addi    a3, sp, FRAME_LEN
+    mv      a4, sp
+
+    call    ffi_closure_inner
+
+    /* return values */
+#if FLTS
+    FLARG   fa0, 0*FLTS(sp)
+    FLARG   fa1, 1*FLTS(sp)
+#endif
+
+    LARG    a0, 8*FLTS+0*PTRS(sp)
+    LARG    a1, 8*FLTS+1*PTRS(sp)
+
+    /* restore and return */
+    LARG    ra, FRAME_LEN-1*PTRS(sp)
+    .cfi_restore 1
+    LARG    fp, FRAME_LEN-2*PTRS(sp)
+    .cfi_restore 8
+    addi    sp, sp, FRAME_LEN
+    .cfi_def_cfa_offset 0
+    ret
+    .cfi_endproc
+    .size ffi_go_closure_asm, .-ffi_go_closure_asm
Index: libffi-3.4.6/src/riscv/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/riscv/ffitarget.h b/libffi-3.4.6/src/riscv/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/riscv/ffitarget.h	
@@ -0,0 +1,69 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - 2014 Michael Knyszek
+
+   Target configuration macros for RISC-V.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef __riscv
+#error "libffi was configured for a RISC-V target but this does not appear to be a RISC-V compiler."
+#endif
+
+#ifndef LIBFFI_ASM
+
+typedef unsigned long ffi_arg;
+typedef   signed long ffi_sarg;
+
+/* FFI_UNUSED_NN and riscv_unused are to maintain ABI compatibility with a
+   distributed Berkeley patch from 2014, and can be removed at SONAME bump */
+typedef enum ffi_abi {
+    FFI_FIRST_ABI = 0,
+    FFI_SYSV,
+    FFI_UNUSED_1,
+    FFI_UNUSED_2,
+    FFI_UNUSED_3,
+    FFI_LAST_ABI,
+
+    FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+
+#endif /* LIBFFI_ASM */
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_NATIVE_RAW_API 0
+#define FFI_EXTRA_CIF_FIELDS unsigned riscv_nfixedargs; unsigned riscv_unused;
+#define FFI_TARGET_SPECIFIC_VARIADIC
+
+#endif
+
Index: libffi-3.4.6/src/sparc/v8.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/v8.S b/libffi-3.4.6/src/sparc/v8.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/v8.S	
@@ -0,0 +1,443 @@
+/* -----------------------------------------------------------------------
+   v8.S - Copyright (c) 2013  The Written Word, Inc.
+	  Copyright (c) 1996, 1997, 2003, 2004, 2008  Red Hat, Inc.
+
+   SPARC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include "internal.h"
+
+#ifndef SPARC64
+
+#define C2(X, Y)  X ## Y
+#define C1(X, Y)  C2(X, Y)
+
+#ifdef __USER_LABEL_PREFIX__
+# define C(Y)	C1(__USER_LABEL_PREFIX__, Y)
+#else
+# define C(Y)	Y
+#endif
+#define L(Y)	C1(.L, Y)
+
+	.text
+
+#ifndef __GNUC__
+        .align 8
+	.globl	C(ffi_flush_icache)
+	.type	C(ffi_flush_icache),#function
+	FFI_HIDDEN(C(ffi_flush_icache))
+
+C(ffi_flush_icache):
+1:	iflush %o0
+	iflush %o+8
+	nop
+	nop
+	nop
+	nop
+	nop
+	retl
+	 nop
+	.size	C(ffi_flush_icache), . - C(ffi_flush_icache)
+#endif
+
+#if defined(__sun__) && defined(__svr4__)
+# define E(INDEX)	.align 16
+#else
+# define E(INDEX)	.align 16; .org 2b + INDEX * 16
+#endif
+
+        .align 8
+	.globl	C(ffi_call_v8)
+	.type	C(ffi_call_v8),#function
+	FFI_HIDDEN(C(ffi_call_v8))
+
+C(ffi_call_v8):
+.LUW0:
+	! Allocate a stack frame sized by ffi_call.
+	save	%sp, %o4, %sp
+.LUW1:
+	mov	%i0, %o0		! copy cif
+	add	%sp, 64+32, %o1		! load args area
+	mov	%i2, %o2		! copy rvalue
+	call	C(ffi_prep_args_v8)
+	 mov	%i3, %o3		! copy avalue
+
+	add	%sp, 32, %sp		! deallocate prep frame
+	and	%o0, SPARC_FLAG_RET_MASK, %l0	! save return type
+	srl	%o0, SPARC_SIZEMASK_SHIFT, %l1	! save return size
+	ld	[%sp+64+4], %o0		! load all argument registers
+	ld	[%sp+64+8], %o1
+	ld	[%sp+64+12], %o2
+	ld	[%sp+64+16], %o3
+	cmp	%l0, SPARC_RET_STRUCT	! struct return needs an unimp 4
+	ld	[%sp+64+20], %o4
+	be	8f
+	 ld	[%sp+64+24], %o5
+
+	! Call foreign function
+	call	%i1
+	 mov	%i5, %g2		! load static chain
+
+0:	call	1f		! load pc in %o7
+	 sll	%l0, 4, %l0
+1:	add	%o7, %l0, %o7	! o7 = 0b + ret_type*16
+	jmp	%o7+(2f-0b)
+	 nop
+
+	! Note that each entry is 4 insns, enforced by the E macro.
+	.align	16
+2:
+E(SPARC_RET_VOID)
+	ret
+	 restore
+E(SPARC_RET_STRUCT)
+	unimp
+E(SPARC_RET_UINT8)
+	and	%o0, 0xff, %o0
+	st	%o0, [%i2]
+	ret
+	 restore
+E(SPARC_RET_SINT8)
+	sll	%o0, 24, %o0
+	b	7f
+	 sra	%o0, 24, %o0
+E(SPARC_RET_UINT16)
+	sll	%o0, 16, %o0
+	b	7f
+	 srl	%o0, 16, %o0
+E(SPARC_RET_SINT16)
+	sll	%o0, 16, %o0
+	b	7f
+	 sra	%o0, 16, %o0
+E(SPARC_RET_UINT32)
+7:	st	%o0, [%i2]
+	ret
+	 restore
+E(SP_V8_RET_CPLX16)
+	sth	%o0, [%i2+2]
+	b	9f
+	 srl	%o0, 16, %o0
+E(SPARC_RET_INT64)
+	st	%o0, [%i2]
+	st	%o1, [%i2+4]
+	ret
+	 restore
+E(SPARC_RET_INT128)
+	std	%o0, [%i2]
+	std	%o2, [%i2+8]
+	ret
+	 restore
+E(SPARC_RET_F_8)
+	st	%f7, [%i2+7*4]
+	nop
+	st	%f6, [%i2+6*4]
+	nop
+E(SPARC_RET_F_6)
+	st	%f5, [%i2+5*4]
+	nop
+	st	%f4, [%i2+4*4]
+	nop
+E(SPARC_RET_F_4)
+	st	%f3, [%i2+3*4]
+	nop
+	st	%f2, [%i2+2*4]
+	nop
+E(SPARC_RET_F_2)
+	st	%f1, [%i2+4]
+	st	%f0, [%i2]
+	ret
+	 restore
+E(SP_V8_RET_CPLX8)
+	stb	%o0, [%i2+1]
+	b	0f
+	 srl	%o0, 8, %o0
+E(SPARC_RET_F_1)
+	st	%f0, [%i2]
+	ret
+	 restore
+
+	.align	8
+9:	sth	%o0, [%i2]
+	ret
+	 restore
+	.align	8
+0:	stb	%o0, [%i2]
+	ret
+	 restore
+
+	! Struct returning functions expect and skip the unimp here.
+	! To make it worse, conforming callees examine the unimp and
+	! make sure the low 12 bits of the unimp match the size of
+	! the struct being returned.
+	.align	8
+8:	call	1f				! load pc in %o7
+	 sll	%l1, 2, %l0			! size * 4
+1:	sll	%l1, 4, %l1			! size * 16
+	add	%l0, %l1, %l0			! size * 20
+	add	%o7, %l0, %o7			! o7 = 8b + size*20
+	jmp	%o7+(2f-8b)
+	 mov	%i5, %g2			! load static chain
+2:
+
+/* The Sun assembler doesn't understand .rept 0x1000.  */
+#define rept1			\
+	call	%i1;		\
+	 nop;			\
+	unimp	(. - 2b) / 20;	\
+	ret;			\
+	 restore
+
+#define rept16				\
+	rept1; rept1; rept1; rept1;	\
+	rept1; rept1; rept1; rept1;	\
+	rept1; rept1; rept1; rept1;	\
+	rept1; rept1; rept1; rept1
+
+#define rept256				\
+	rept16; rept16; rept16; rept16;	\
+	rept16; rept16; rept16; rept16;	\
+	rept16; rept16; rept16; rept16;	\
+	rept16; rept16; rept16; rept16
+
+	rept256; rept256; rept256; rept256
+	rept256; rept256; rept256; rept256
+	rept256; rept256; rept256; rept256
+	rept256; rept256; rept256; rept256
+
+.LUW2:
+	.size	C(ffi_call_v8),. - C(ffi_call_v8)
+
+
+/* 16*4 register window + 1*4 struct return + 6*4 args backing store
+   + 8*4 return storage + 1*4 alignment.  */
+#define	STACKFRAME	(16*4 + 4 + 6*4 + 8*4 + 4)
+
+/* ffi_closure_v8(...)
+
+   Receives the closure argument in %g2.   */
+
+#ifdef HAVE_AS_REGISTER_PSEUDO_OP
+	.register	%g2, #scratch
+#endif
+
+	.align 8
+	.globl	C(ffi_go_closure_v8)
+	.type	C(ffi_go_closure_v8),#function
+	FFI_HIDDEN(C(ffi_go_closure_v8))
+
+C(ffi_go_closure_v8):
+.LUW3:
+	save	%sp, -STACKFRAME, %sp
+.LUW4:
+	ld	[%g2+4], %o0			! load cif
+	ld	[%g2+8], %o1			! load fun
+	b	0f
+	 mov	%g2, %o2			! load user_data
+.LUW5:
+	.size	C(ffi_go_closure_v8), . - C(ffi_go_closure_v8)
+
+	.align 8
+	.globl	C(ffi_closure_v8)
+	.type	C(ffi_closure_v8),#function
+	FFI_HIDDEN(C(ffi_closure_v8))
+
+C(ffi_closure_v8):
+.LUW6:
+	save	%sp, -STACKFRAME, %sp
+.LUW7:
+	ld	[%g2+FFI_TRAMPOLINE_SIZE], %o0		! load cif
+	ld	[%g2+FFI_TRAMPOLINE_SIZE+4], %o1	! load fun
+	ld	[%g2+FFI_TRAMPOLINE_SIZE+8], %o2	! load user_data
+0:
+	! Store all of the potential argument registers in va_list format.
+	st	%i0, [%fp+68+0]
+	st	%i1, [%fp+68+4]
+	st	%i2, [%fp+68+8]
+	st	%i3, [%fp+68+12]
+	st	%i4, [%fp+68+16]
+	st	%i5, [%fp+68+20]
+
+	! Call ffi_closure_sparc_inner to do the bulk of the work.
+	add	%fp, -8*4, %o3
+	call	ffi_closure_sparc_inner_v8
+	 add	%fp,  64, %o4
+
+0:	call	1f
+	 and	%o0, SPARC_FLAG_RET_MASK, %o0
+1:	sll	%o0, 4, %o0	! o0 = o0 * 16
+	add	%o7, %o0, %o7	! o7 = 0b + o0*16
+	jmp	%o7+(2f-0b)
+	 add	%fp, -8*4, %i2
+	 
+	! Note that each entry is 4 insns, enforced by the E macro.
+	.align	16
+2:
+E(SPARC_RET_VOID)
+	ret
+	 restore
+E(SPARC_RET_STRUCT)
+	ld	[%i2], %i0
+	jmp	%i7+12
+	 restore
+E(SPARC_RET_UINT8)
+	ldub	[%i2+3], %i0
+	ret
+	 restore
+E(SPARC_RET_SINT8)
+	ldsb	[%i2+3], %i0
+	ret
+	 restore
+E(SPARC_RET_UINT16)
+	lduh	[%i2+2], %i0
+	ret
+	 restore
+E(SPARC_RET_SINT16)
+	ldsh	[%i2+2], %i0
+	ret
+	 restore
+E(SPARC_RET_UINT32)
+	ld	[%i2], %i0
+	ret
+	 restore
+E(SP_V8_RET_CPLX16)
+	ld	[%i2], %i0
+	ret
+	 restore
+E(SPARC_RET_INT64)
+	ldd	[%i2], %i0
+	ret
+	 restore
+E(SPARC_RET_INT128)
+	ldd	[%i2], %i0
+	ldd	[%i2+8], %i2
+	ret
+	 restore
+E(SPARC_RET_F_8)
+	ld	[%i2+7*4], %f7
+	nop
+	ld	[%i2+6*4], %f6
+	nop
+E(SPARC_RET_F_6)
+	ld	[%i2+5*4], %f5
+	nop
+	ld	[%i2+4*4], %f4
+	nop
+E(SPARC_RET_F_4)
+	ld	[%i2+3*4], %f3
+	nop
+	ld	[%i2+2*4], %f2
+	nop
+E(SPARC_RET_F_2)
+	ldd	[%i2], %f0
+	ret
+	 restore
+E(SP_V8_RET_CPLX8)
+	lduh	[%i2], %i0
+	ret
+	 restore
+E(SPARC_RET_F_1)
+	ld	[%i2], %f0
+	ret
+	 restore
+
+.LUW8:
+	.size	C(ffi_closure_v8), . - C(ffi_closure_v8)
+
+#ifdef HAVE_RO_EH_FRAME
+        .section        ".eh_frame",#alloc
+#else
+        .section        ".eh_frame",#alloc,#write
+#endif
+
+#ifdef HAVE_AS_SPARC_UA_PCREL
+# define FDE_ADDR(X)	%r_disp32(X)
+#else
+# define FDE_ADDR(X)	X
+#endif
+
+	.align 4
+.LCIE:
+	.long	.LECIE - .LSCIE		! CIE Length
+.LSCIE:
+	.long	0			! CIE Identifier Tag
+	.byte	1			! CIE Version
+	.ascii	"zR\0"			! CIE Augmentation
+	.byte	4			! CIE Code Alignment Factor
+	.byte	0x7c			! CIE Data Alignment Factor
+	.byte	15			! CIE RA Column
+	.byte	1			! Augmentation size
+#ifdef HAVE_AS_SPARC_UA_PCREL
+	.byte	0x1b			! FDE Encoding (pcrel sdata4)
+#else
+	.byte	0x50			! FDE Encoding (aligned absolute)
+#endif
+	.byte	0xc, 14, 0		! DW_CFA_def_cfa, %o6, offset 0
+	.align	4
+.LECIE:
+
+	.long	.LEFDE1 - .LSFDE1	! FDE Length
+.LSFDE1:
+	.long	.LSFDE1 - .LCIE		! FDE CIE offset
+	.long	FDE_ADDR(.LUW0)		! Initial location
+	.long	.LUW2 - .LUW0		! Address range
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	4
+.LEFDE1:
+
+	.long	.LEFDE2 - .LSFDE2	! FDE Length
+.LSFDE2:
+	.long	.LSFDE2 - .LCIE		! FDE CIE offset
+	.long	FDE_ADDR(.LUW3)		! Initial location
+	.long	.LUW5 - .LUW3		! Address range
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	4
+.LEFDE2:
+
+	.long	.LEFDE3 - .LSFDE3	! FDE Length
+.LSFDE3:
+	.long	.LSFDE3 - .LCIE		! FDE CIE offset
+	.long	FDE_ADDR(.LUW6)		! Initial location
+	.long	.LUW8 - .LUW6		! Address range
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	4
+.LEFDE3:
+
+#endif /* !SPARC64 */
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/sparc/v9.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/v9.S b/libffi-3.4.6/src/sparc/v9.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/v9.S	
@@ -0,0 +1,440 @@
+/* -----------------------------------------------------------------------
+   v9.S - Copyright (c) 2000, 2003, 2004, 2008 Red Hat, Inc.
+   
+   SPARC 64-bit Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM	
+#include <fficonfig.h>
+#include <ffi.h>
+#include "internal.h"
+
+#ifdef SPARC64
+
+#define C2(X, Y)  X ## Y
+#define C1(X, Y)  C2(X, Y)
+
+#ifdef __USER_LABEL_PREFIX__
+# define C(Y)	C1(__USER_LABEL_PREFIX__, Y)
+#else
+# define C(Y)	Y
+#endif
+#define L(Y)	C1(.L, Y)
+
+#if defined(__sun__) && defined(__svr4__)
+# define E(INDEX)	.align 16
+#else
+# define E(INDEX)	.align 16; .org 2b + INDEX * 16
+#endif
+
+#define STACK_BIAS 2047
+
+	.text
+        .align 8
+	.globl	C(ffi_call_v9)
+	.type	C(ffi_call_v9),#function
+	FFI_HIDDEN(C(ffi_call_v9))
+
+C(ffi_call_v9):
+.LUW0:
+	save	%sp, %o4, %sp
+.LUW1:
+	mov	%i0, %o0			! copy cif
+	add	%sp, STACK_BIAS+128+48, %o1	! load args area
+	mov	%i2, %o2			! copy rvalue
+	call	C(ffi_prep_args_v9)
+	 mov	%i3, %o3			! copy avalue
+
+	andcc	%o0, SPARC_FLAG_FP_ARGS, %g0	! need fp regs?
+	add	%sp, 48, %sp			! deallocate prep frame
+	be,pt	%xcc, 1f
+	 mov	%o0, %l0			! save flags
+
+	ldd	[%sp+STACK_BIAS+128], %f0	! load all fp arg regs
+	ldd	[%sp+STACK_BIAS+128+8], %f2
+	ldd	[%sp+STACK_BIAS+128+16], %f4
+	ldd	[%sp+STACK_BIAS+128+24], %f6
+	ldd	[%sp+STACK_BIAS+128+32], %f8
+	ldd	[%sp+STACK_BIAS+128+40], %f10
+	ldd	[%sp+STACK_BIAS+128+48], %f12
+	ldd	[%sp+STACK_BIAS+128+56], %f14
+	ldd	[%sp+STACK_BIAS+128+64], %f16
+	ldd	[%sp+STACK_BIAS+128+72], %f18
+	ldd	[%sp+STACK_BIAS+128+80], %f20
+	ldd	[%sp+STACK_BIAS+128+88], %f22
+	ldd	[%sp+STACK_BIAS+128+96], %f24
+	ldd	[%sp+STACK_BIAS+128+104], %f26
+	ldd	[%sp+STACK_BIAS+128+112], %f28
+	ldd	[%sp+STACK_BIAS+128+120], %f30
+
+1:	ldx	[%sp+STACK_BIAS+128], %o0	! load all int arg regs
+	ldx	[%sp+STACK_BIAS+128+8], %o1
+	ldx	[%sp+STACK_BIAS+128+16], %o2
+	ldx	[%sp+STACK_BIAS+128+24], %o3
+	ldx	[%sp+STACK_BIAS+128+32], %o4
+	ldx	[%sp+STACK_BIAS+128+40], %o5
+	call	%i1
+	 mov	%i5, %g5			! load static chain
+
+0:	call	1f		! load pc in %o7
+	 and	%l0, SPARC_FLAG_RET_MASK, %l1
+1:	sll	%l1, 4, %l1
+	add	%o7, %l1, %o7	! o7 = 0b + ret_type*16
+	jmp	%o7+(2f-0b)
+	 nop
+
+	.align	16
+2:
+E(SPARC_RET_VOID)
+	return	%i7+8
+	 nop
+E(SPARC_RET_STRUCT)
+	add	%sp, STACK_BIAS-64+128+48, %l2
+	sub	%sp, 64, %sp
+	b	8f
+	 stx	%o0, [%l2]
+E(SPARC_RET_UINT8)
+	and	%o0, 0xff, %i0
+	return	%i7+8
+	  stx	%o0, [%o2]
+E(SPARC_RET_SINT8)
+	sll	%o0, 24, %o0
+	sra	%o0, 24, %i0
+	return	%i7+8
+	 stx	%o0, [%o2]
+E(SPARC_RET_UINT16)
+	sll	%o0, 16, %o0
+	srl	%o0, 16, %i0
+	return	%i7+8
+	 stx	%o0, [%o2]
+E(SPARC_RET_SINT16)
+	sll	%o0, 16, %o0
+	sra	%o0, 16, %i0
+	return	%i7+8
+	 stx	%o0, [%o2]
+E(SPARC_RET_UINT32)
+	srl	%o0, 0, %i0
+	return	%i7+8
+	 stx	%o0, [%o2]
+E(SP_V9_RET_SINT32)
+	sra	%o0, 0, %i0
+	return	%i7+8
+	 stx	%o0, [%o2]
+E(SPARC_RET_INT64)
+	stx	%o0, [%i2]
+	return	%i7+8
+	 nop
+E(SPARC_RET_INT128)
+	stx	%o0, [%i2]
+	stx	%o1, [%i2+8]
+	return	%i7+8
+	 nop
+E(SPARC_RET_F_8)
+	st	%f7, [%i2+7*4]
+	nop
+	st	%f6, [%i2+6*4]
+	nop
+E(SPARC_RET_F_6)
+	st	%f5, [%i2+5*4]
+	nop
+	st	%f4, [%i2+4*4]
+	nop
+E(SPARC_RET_F_4)
+	std	%f2, [%i2+2*4]
+	return	%i7+8
+	 std	%f0, [%o2]
+E(SPARC_RET_F_2)
+	return	%i7+8
+	 std	%f0, [%o2]
+E(SP_V9_RET_F_3)
+	st	%f2, [%i2+2*4]
+	nop
+	st	%f1, [%i2+1*4]
+	nop
+E(SPARC_RET_F_1)
+	return	%i7+8
+	 st	%f0, [%o2]
+
+	! Finish the SPARC_RET_STRUCT sequence.
+	.align	8
+8:	stx	%o1, [%l2+8]
+	stx	%o2, [%l2+16]
+	stx	%o3, [%l2+24]
+	std	%f0, [%l2+32]
+	std	%f2, [%l2+40]
+	std	%f4, [%l2+48]
+	std	%f6, [%l2+56]
+
+	! Copy the structure into place.
+	srl	%l0, SPARC_SIZEMASK_SHIFT, %o0	! load size_mask
+	mov	%i2, %o1			! load dst
+	mov	%l2, %o2			! load src_gp
+	call	C(ffi_struct_float_copy)
+	 add	%l2, 32, %o3			! load src_fp
+
+	return	%i7+8
+	 nop
+
+.LUW2:
+	.size	C(ffi_call_v9), . - C(ffi_call_v9)
+
+
+#undef STACKFRAME
+#define	STACKFRAME	 336	/* 16*8 register window +
+				   6*8 args backing store +
+				   20*8 locals */
+#define	FP		%fp+STACK_BIAS
+
+/* ffi_closure_v9(...)
+
+   Receives the closure argument in %g1.   */
+
+	.align 8
+	.globl	C(ffi_go_closure_v9)
+	.type	C(ffi_go_closure_v9),#function
+	FFI_HIDDEN(C(ffi_go_closure_v9))
+
+C(ffi_go_closure_v9):
+.LUW3:
+	save	%sp, -STACKFRAME, %sp
+.LUW4:
+	ldx	[%g5+8], %o0
+	ldx	[%g5+16], %o1
+	b	0f
+	 mov	%g5, %o2
+
+.LUW5:
+	.size	C(ffi_go_closure_v9), . - C(ffi_go_closure_v9)
+
+	.align 8
+	.globl	C(ffi_closure_v9)
+	.type	C(ffi_closure_v9),#function
+	FFI_HIDDEN(C(ffi_closure_v9))
+
+C(ffi_closure_v9):
+.LUW6:
+	save	%sp, -STACKFRAME, %sp
+.LUW7:
+	ldx	[%g1+FFI_TRAMPOLINE_SIZE], %o0
+	ldx	[%g1+FFI_TRAMPOLINE_SIZE+8], %o1
+	ldx	[%g1+FFI_TRAMPOLINE_SIZE+16], %o2
+0:
+	! Store all of the potential argument registers in va_list format.
+	stx	%i0, [FP+128+0]
+	stx	%i1, [FP+128+8]
+	stx	%i2, [FP+128+16]
+	stx	%i3, [FP+128+24]
+	stx	%i4, [FP+128+32]
+	stx	%i5, [FP+128+40]
+
+	! Store possible floating point argument registers too.
+	std	%f0,  [FP-128]
+	std	%f2,  [FP-120]
+	std	%f4,  [FP-112]
+	std	%f6,  [FP-104]
+	std	%f8,  [FP-96]
+	std	%f10, [FP-88]
+	std     %f12, [FP-80]
+	std     %f14, [FP-72]
+	std     %f16, [FP-64]
+	std     %f18, [FP-56]
+	std     %f20, [FP-48]
+	std     %f22, [FP-40]
+	std     %f24, [FP-32]
+	std     %f26, [FP-24]
+	std     %f28, [FP-16]
+	std     %f30, [FP-8]
+
+	! Call ffi_closure_sparc_inner to do the bulk of the work.
+	add	%fp, STACK_BIAS-160, %o3
+	add	%fp, STACK_BIAS+128, %o4
+	call	C(ffi_closure_sparc_inner_v9)
+	 add	%fp, STACK_BIAS-128, %o5
+
+0:	call	1f		! load pc in %o7
+	 and	%o0, SPARC_FLAG_RET_MASK, %o0
+1:	sll	%o0, 4, %o0	! o2 = i2 * 16
+	add	%o7, %o0, %o7	! o7 = 0b + i2*16
+	jmp	%o7+(2f-0b)
+	 nop
+
+	! Note that we cannot load the data in the delay slot of
+	! the return insn because the data is in the stack frame
+	! that is deallocated by the return.
+	.align	16
+2:
+E(SPARC_RET_VOID)
+	return	%i7+8
+	 nop
+E(SPARC_RET_STRUCT)
+	ldx	[FP-160], %i0
+	ldd	[FP-160], %f0
+	b	8f
+	 ldx	[FP-152], %i1
+E(SPARC_RET_UINT8)
+	ldub	[FP-160+7], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_SINT8)
+	ldsb	[FP-160+7], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_UINT16)
+	lduh	[FP-160+6], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_SINT16)
+	ldsh	[FP-160+6], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_UINT32)
+	lduw	[FP-160+4], %i0
+	return	%i7+8
+	 nop
+E(SP_V9_RET_SINT32)
+	ldsw	[FP-160+4], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_INT64)
+	ldx	[FP-160], %i0
+	return	%i7+8
+	 nop
+E(SPARC_RET_INT128)
+	ldx	[FP-160], %i0
+	ldx	[FP-160+8], %i1
+	return	%i7+8
+	 nop
+E(SPARC_RET_F_8)
+	ld	[FP-160+7*4], %f7
+	nop
+	ld	[FP-160+6*4], %f6
+	nop
+E(SPARC_RET_F_6)
+	ld	[FP-160+5*4], %f5
+	nop
+	ld	[FP-160+4*4], %f4
+	nop
+E(SPARC_RET_F_4)
+	ldd	[FP-160], %f0
+	ldd	[FP-160+8], %f2
+	return	%i7+8
+	 nop
+E(SPARC_RET_F_2)
+	ldd	[FP-160], %f0
+	return	%i7+8
+	 nop
+E(SP_V9_RET_F_3)
+	ld	[FP-160+2*4], %f2
+	nop
+	ld	[FP-160+1*4], %f1
+	nop
+E(SPARC_RET_F_1)
+	ld	[FP-160], %f0
+	return	%i7+8
+	 nop
+
+	! Finish the SPARC_RET_STRUCT sequence.
+	.align	8
+8:	ldd	[FP-152], %f2
+	ldx	[FP-144], %i2
+	ldd	[FP-144], %f4
+	ldx	[FP-136], %i3
+	ldd	[FP-136], %f6
+	return	%i7+8
+	 nop
+
+.LUW8:
+	.size	C(ffi_closure_v9), . - C(ffi_closure_v9)
+
+#ifdef HAVE_RO_EH_FRAME
+        .section        ".eh_frame",#alloc
+#else
+        .section        ".eh_frame",#alloc,#write
+#endif
+
+#ifdef HAVE_AS_SPARC_UA_PCREL
+# define FDE_RANGE(B, E)  .long %r_disp32(B), E - B
+#else
+# define FDE_RANGE(B, E)  .align 8; .xword B, E - B
+#endif
+
+	.align 8
+.LCIE:
+	.long	.LECIE - .LSCIE		! CIE Length
+.LSCIE:
+	.long	0			! CIE Identifier Tag
+	.byte	1			! CIE Version
+	.ascii	"zR\0"			! CIE Augmentation
+	.byte	4			! CIE Code Alignment Factor
+	.byte	0x78			! CIE Data Alignment Factor
+	.byte	15			! CIE RA Column
+	.byte	1			! Augmentation size
+#ifdef HAVE_AS_SPARC_UA_PCREL
+	.byte	0x1b			! FDE Encoding (pcrel sdata4)
+#else
+	.byte	0x50			! FDE Encoding (aligned absolute)
+#endif
+	.byte	0xc, 14, 0xff, 0xf	! DW_CFA_def_cfa, %o6, offset 0x7ff
+	.align	8
+.LECIE:
+
+	.long	.LEFDE1 - .LSFDE1	! FDE Length
+.LSFDE1:
+	.long	.LSFDE1 - .LCIE		! FDE CIE offset
+	FDE_RANGE(.LUW0, .LUW2)
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	8
+.LEFDE1:
+
+	.long	.LEFDE2 - .LSFDE2	! FDE Length
+.LSFDE2:
+	.long	.LSFDE2 - .LCIE		! FDE CIE offset
+	FDE_RANGE(.LUW3, .LUW5)
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	8
+.LEFDE2:
+
+	.long	.LEFDE3 - .LSFDE3	! FDE Length
+.LSFDE3:
+	.long	.LSFDE3 - .LCIE		! FDE CIE offset
+	FDE_RANGE(.LUW6, .LUW8)
+	.byte	0			! Augmentation size
+	.byte	0x40+1			! DW_CFA_advance_loc 4
+	.byte	0xd, 30			! DW_CFA_def_cfa_register, %i6
+	.byte	0x2d			! DW_CFA_GNU_window_save
+	.byte	0x9, 15, 31		! DW_CFA_register, %o7, %i7
+	.align	8
+.LEFDE3:
+
+#endif /* SPARC64 */
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/sparc/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/ffi.c b/libffi-3.4.6/src/sparc/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/ffi.c	
@@ -0,0 +1,468 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2011, 2013 Anthony Green
+           Copyright (c) 1996, 2003-2004, 2007-2008 Red Hat, Inc.
+   
+   SPARC Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include "internal.h"
+
+#ifndef SPARC64
+
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 128-bit type.  */
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+/* Perform machine dependent cif processing */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  ffi_type *rtype = cif->rtype;
+  int rtt = rtype->type;
+  size_t bytes;
+  int i, n, flags;
+
+  /* Set the return type flag */
+  switch (rtt)
+    {
+    case FFI_TYPE_VOID:
+      flags = SPARC_RET_VOID;
+      break;
+    case FFI_TYPE_FLOAT:
+      flags = SPARC_RET_F_1;
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = SPARC_RET_F_2;
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+    case FFI_TYPE_STRUCT:
+      flags = (rtype->size & 0xfff) << SPARC_SIZEMASK_SHIFT;
+      flags |= SPARC_RET_STRUCT;
+      break;
+    case FFI_TYPE_SINT8:
+      flags = SPARC_RET_SINT8;
+      break;
+    case FFI_TYPE_UINT8:
+      flags = SPARC_RET_UINT8;
+      break;
+    case FFI_TYPE_SINT16:
+      flags = SPARC_RET_SINT16;
+      break;
+    case FFI_TYPE_UINT16:
+      flags = SPARC_RET_UINT16;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+      flags = SPARC_RET_UINT32;
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      flags = SPARC_RET_INT64;
+      break;
+    case FFI_TYPE_COMPLEX:
+      rtt = rtype->elements[0]->type;
+      switch (rtt)
+	{
+	case FFI_TYPE_FLOAT:
+	  flags = SPARC_RET_F_2;
+	  break;
+	case FFI_TYPE_DOUBLE:
+	  flags = SPARC_RET_F_4;
+	  break;
+	case FFI_TYPE_LONGDOUBLE:
+	  flags = SPARC_RET_F_8;
+	  break;
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  flags = SPARC_RET_INT128;
+	  break;
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	  flags = SPARC_RET_INT64;
+	  break;
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	  flags = SP_V8_RET_CPLX16;
+	  break;
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	  flags = SP_V8_RET_CPLX8;
+	  break;
+	default:
+	  abort();
+	}
+      break;
+    default:
+      abort();
+    }
+  cif->flags = flags;
+
+  bytes = 0;
+  for (i = 0, n = cif->nargs; i < n; ++i)
+    {
+      ffi_type *ty = cif->arg_types[i];
+      size_t z = ty->size;
+      int tt = ty->type;
+
+      switch (tt)
+	{
+	case FFI_TYPE_STRUCT:
+	case FFI_TYPE_LONGDOUBLE:
+	by_reference:
+	  /* Passed by reference.  */
+	  z = 4;
+	  break;
+
+	case FFI_TYPE_COMPLEX:
+	  tt = ty->elements[0]->type;
+	  if (tt == FFI_TYPE_FLOAT || z > 8)
+	    goto by_reference;
+	  /* FALLTHRU */
+
+	default:
+	  z = FFI_ALIGN(z, 4);
+	}
+      bytes += z;
+    }
+
+  /* Sparc call frames require that space is allocated for 6 args,
+     even if they aren't used. Make that space if necessary.  */
+  if (bytes < 6 * 4)
+    bytes = 6 * 4;
+
+  /* The ABI always requires space for the struct return pointer.  */
+  bytes += 4;
+
+  /* The stack must be 2 word aligned, so round bytes up appropriately. */
+  bytes = FFI_ALIGN(bytes, 2 * 4);
+
+  /* Include the call frame to prep_args.  */
+  bytes += 4*16 + 4*8;
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+extern void ffi_call_v8(ffi_cif *cif, void (*fn)(void), void *rvalue,
+			void **avalue, size_t bytes, void *closure) FFI_HIDDEN;
+
+int FFI_HIDDEN
+ffi_prep_args_v8(ffi_cif *cif, unsigned long *argp, void *rvalue, void **avalue)
+{
+  ffi_type **p_arg;
+  int flags = cif->flags;
+  int i, nargs;
+
+  if (rvalue == NULL)
+    {
+      if ((flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)
+	{
+	  /* Since we pass the pointer to the callee, we need a value.
+	     We allowed for this space in ffi_call, before ffi_call_v8
+	     alloca'd the space.  */
+	  rvalue = (char *)argp + cif->bytes;
+	}
+      else
+	{
+	  /* Otherwise, we can ignore the return value.  */
+	  flags = SPARC_RET_VOID;
+	}
+    }
+
+  /* This could only really be done when we are returning a structure.
+     However, the space is reserved so we can do it unconditionally.  */
+  *argp++ = (unsigned long)rvalue;
+
+#ifdef USING_PURIFY
+  /* Purify will probably complain in our assembly routine,
+     unless we zero out this memory. */
+  memset(argp, 0, 6*4);
+#endif
+
+  p_arg = cif->arg_types;
+  for (i = 0, nargs = cif->nargs; i < nargs; i++)
+    {
+      ffi_type *ty = p_arg[i];
+      void *a = avalue[i];
+      int tt = ty->type;
+      size_t z;
+
+      switch (tt)
+	{
+	case FFI_TYPE_STRUCT:
+	case FFI_TYPE_LONGDOUBLE:
+	by_reference:
+	  *argp++ = (unsigned long)a;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  memcpy(argp, a, 8);
+	  argp += 2;
+	  break;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  *argp++ = *(unsigned *)a;
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  *argp++ = *(UINT8 *)a;
+	  break;
+	case FFI_TYPE_SINT8:
+	  *argp++ = *(SINT8 *)a;
+	  break;
+	case FFI_TYPE_UINT16:
+	  *argp++ = *(UINT16 *)a;
+	  break;
+	case FFI_TYPE_SINT16:
+	  *argp++ = *(SINT16 *)a;
+	  break;
+
+        case FFI_TYPE_COMPLEX:
+	  tt = ty->elements[0]->type;
+	  z = ty->size;
+	  if (tt == FFI_TYPE_FLOAT || z > 8)
+	    goto by_reference;
+	  if (z < 4)
+	    {
+	      memcpy((char *)argp + 4 - z, a, z);
+	      argp++;
+	    }
+	  else
+	    {
+	      memcpy(argp, a, z);
+	      argp += z / 4;
+	    }
+	  break;
+
+	default:
+	  abort();
+	}
+    }
+
+  return flags;
+}
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	      void **avalue, void *closure)
+{
+  size_t bytes = cif->bytes;
+
+  FFI_ASSERT (cif->abi == FFI_V8);
+
+  /* If we've not got a return value, we need to create one if we've
+     got to pass the return value to the callee.  Otherwise ignore it.  */
+  if (rvalue == NULL
+      && (cif->flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)
+    bytes += FFI_ALIGN (cif->rtype->size, 8);
+
+  ffi_call_v8(cif, fn, rvalue, avalue, -bytes, closure);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+#ifdef __GNUC__
+static inline void
+ffi_flush_icache (void *p)
+{
+  /* SPARC v8 requires 5 instructions for flush to be visible */
+  asm volatile ("iflush	%0; iflush %0+8; nop; nop; nop; nop; nop"
+		: : "r" (p) : "memory");
+}
+#else
+extern void ffi_flush_icache (void *) FFI_HIDDEN;
+#endif
+
+extern void ffi_closure_v8(void) FFI_HIDDEN;
+extern void ffi_go_closure_v8(void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+  unsigned long ctx = (unsigned long) closure;
+  unsigned long fn = (unsigned long) ffi_closure_v8;
+
+  if (cif->abi != FFI_V8)
+    return FFI_BAD_ABI;
+
+  tramp[0] = 0x03000000 | fn >> 10;	/* sethi %hi(fn), %g1	*/
+  tramp[1] = 0x05000000 | ctx >> 10;	/* sethi %hi(ctx), %g2	*/
+  tramp[2] = 0x81c06000 | (fn & 0x3ff);	/* jmp   %g1+%lo(fn)	*/
+  tramp[3] = 0x8410a000 | (ctx & 0x3ff);/* or    %g2, %lo(ctx)	*/
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  ffi_flush_icache (closure);
+
+  return FFI_OK;
+}
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+  if (cif->abi != FFI_V8)
+    return FFI_BAD_ABI;
+
+  closure->tramp = ffi_go_closure_v8;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+int FFI_HIDDEN
+ffi_closure_sparc_inner_v8(ffi_cif *cif, 
+			   void (*fun)(ffi_cif*, void*, void**, void*),
+			   void *user_data, void *rvalue,
+			   unsigned long *argp)
+{
+  ffi_type **arg_types;
+  void **avalue;
+  int i, nargs, flags;
+
+  arg_types = cif->arg_types;
+  nargs = cif->nargs;
+  flags = cif->flags;
+  avalue = alloca(nargs * sizeof(void *));
+
+  /* Copy the caller's structure return address so that the closure
+     returns the data directly to the caller.  Also install it so we
+     can return the address in %o0.  */
+  if ((flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)
+    {
+      void *new_rvalue = (void *)*argp;
+      *(void **)rvalue = new_rvalue;
+      rvalue = new_rvalue;
+    }
+
+  /* Always skip the structure return address.  */
+  argp++;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *ty = arg_types[i];
+      int tt = ty->type;
+      void *a = argp;
+      size_t z;
+
+      switch (tt)
+	{
+	case FFI_TYPE_STRUCT:
+	case FFI_TYPE_LONGDOUBLE:
+	by_reference:
+	  /* Straight copy of invisible reference.  */
+	  a = (void *)*argp;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  if ((unsigned long)a & 7)
+	    {
+	      /* Align on a 8-byte boundary.  */
+	      UINT64 *tmp = alloca(8);
+	      *tmp = ((UINT64)argp[0] << 32) | argp[1];
+	      a = tmp;
+	    }
+	  argp++;
+	  break;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  break;
+        case FFI_TYPE_UINT16:
+        case FFI_TYPE_SINT16:
+	  a += 2;
+	  break;
+        case FFI_TYPE_UINT8:
+        case FFI_TYPE_SINT8:
+	  a += 3;
+	  break;
+
+        case FFI_TYPE_COMPLEX:
+	  tt = ty->elements[0]->type;
+	  z = ty->size;
+	  if (tt == FFI_TYPE_FLOAT || z > 8)
+	    goto by_reference;
+	  if (z < 4)
+	    a += 4 - z;
+	  else if (z > 4)
+	    argp++;
+	  break;
+
+	default:
+	  abort();
+	}
+      argp++;
+      avalue[i] = a;
+    }
+
+  /* Invoke the closure.  */
+  fun (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_sparc how to perform return type promotions.  */
+  return flags;
+}
+#endif /* !SPARC64 */
Index: libffi-3.4.6/src/sparc/ffi64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/ffi64.c b/libffi-3.4.6/src/sparc/ffi64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/ffi64.c	
@@ -0,0 +1,630 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2011, 2013 Anthony Green
+           Copyright (c) 1996, 2003-2004, 2007-2008 Red Hat, Inc.
+
+   SPARC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include "internal.h"
+
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 128-bit type.  */
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+#ifdef SPARC64
+
+/* Flatten the contents of a structure to the parts that are passed in
+   floating point registers.  The return is a bit mask wherein bit N
+   set means bytes [4*n, 4*n+3] are passed in %fN.
+
+   We encode both the (running) size (maximum 32) and mask (maxumum 255)
+   into one integer.  The size is placed in the low byte, so that align
+   and addition work correctly.  The mask is placed in the second byte.  */
+
+static int
+ffi_struct_float_mask (ffi_type *outer_type, int size_mask)
+{
+  ffi_type **elts;
+  ffi_type *t;
+
+  if (outer_type->type == FFI_TYPE_COMPLEX)
+    {
+      int m = 0, tt = outer_type->elements[0]->type;
+      size_t z = outer_type->size;
+
+      if (tt == FFI_TYPE_FLOAT
+	  || tt == FFI_TYPE_DOUBLE
+	  || tt == FFI_TYPE_LONGDOUBLE)
+        m = (1 << (z / 4)) - 1;
+      return (m << 8) | z;
+    }
+  FFI_ASSERT (outer_type->type == FFI_TYPE_STRUCT);
+
+  for (elts = outer_type->elements; (t = *elts) != NULL; elts++)
+    {
+      size_t z = t->size;
+      int o, m, tt;
+
+      size_mask = FFI_ALIGN(size_mask, t->alignment);
+      switch (t->type)
+	{
+	case FFI_TYPE_STRUCT:
+	  size_mask = ffi_struct_float_mask (t, size_mask);
+	  continue;
+	case FFI_TYPE_COMPLEX:
+	  tt = t->elements[0]->type;
+	  if (tt != FFI_TYPE_FLOAT
+	      && tt != FFI_TYPE_DOUBLE
+	      && tt != FFI_TYPE_LONGDOUBLE)
+	    break;
+	  /* FALLTHRU */
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	  m = (1 << (z / 4)) - 1;	/* compute mask for type */
+	  o = (size_mask >> 2) & 0x3f;	/* extract word offset */
+	  size_mask |= m << (o + 8);	/* insert mask into place */
+	  break;
+	}
+      size_mask += z;
+    }
+
+  size_mask = FFI_ALIGN(size_mask, outer_type->alignment);
+  FFI_ASSERT ((size_mask & 0xff) == outer_type->size);
+
+  return size_mask;
+}
+
+/* Merge floating point data into integer data.  If the structure is
+   entirely floating point, simply return a pointer to the fp data.  */
+
+static void *
+ffi_struct_float_merge (int size_mask, void *vi, void *vf)
+{
+  int size = size_mask & 0xff;
+  int mask = size_mask >> 8;
+  int n = size >> 2;
+
+  if (mask == 0)
+    return vi;
+  else if (mask == (1 << n) - 1)
+    return vf;
+  else
+    {
+      unsigned int *wi = vi, *wf = vf;
+      int i;
+
+      for (i = 0; i < n; ++i)
+	if ((mask >> i) & 1)
+	  wi[i] = wf[i];
+
+      return vi;
+    }
+}
+
+/* Similar, but place the data into VD in the end.  */
+
+void FFI_HIDDEN
+ffi_struct_float_copy (int size_mask, void *vd, void *vi, void *vf)
+{
+  int size = size_mask & 0xff;
+  int mask = size_mask >> 8;
+  int n = size >> 2;
+
+  if (mask == 0)
+    ;
+  else if (mask == (1 << n) - 1)
+    vi = vf;
+  else
+    {
+      unsigned int *wd = vd, *wi = vi, *wf = vf;
+      int i;
+
+      for (i = 0; i < n; ++i)
+	wd[i] = ((mask >> i) & 1 ? wf : wi)[i];
+      return;
+    }
+  memcpy (vd, vi, size);
+}
+
+/* Perform machine dependent cif processing */
+
+static ffi_status
+ffi_prep_cif_machdep_core(ffi_cif *cif)
+{
+  ffi_type *rtype = cif->rtype;
+  int rtt = rtype->type;
+  size_t bytes = 0;
+  int i, n, flags;
+
+  /* Set the return type flag */
+  switch (rtt)
+    {
+    case FFI_TYPE_VOID:
+      flags = SPARC_RET_VOID;
+      break;
+    case FFI_TYPE_FLOAT:
+      flags = SPARC_RET_F_1;
+      break;
+    case FFI_TYPE_DOUBLE:
+      flags = SPARC_RET_F_2;
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      flags = SPARC_RET_F_4;
+      break;
+
+    case FFI_TYPE_COMPLEX:
+    case FFI_TYPE_STRUCT:
+      if (rtype->size > 32)
+	{
+	  flags = SPARC_RET_VOID | SPARC_FLAG_RET_IN_MEM;
+	  bytes = 8;
+	}
+      else
+	{
+	  int size_mask = ffi_struct_float_mask (rtype, 0);
+	  int word_size = (size_mask >> 2) & 0x3f;
+	  int all_mask = (1 << word_size) - 1;
+	  int fp_mask = size_mask >> 8;
+
+	  flags = (size_mask << SPARC_SIZEMASK_SHIFT) | SPARC_RET_STRUCT;
+
+	  /* For special cases of all-int or all-fp, we can return
+	     the value directly without popping through a struct copy.  */
+	  if (fp_mask == 0)
+	    {
+	      if (rtype->alignment >= 8)
+		{
+		  if (rtype->size == 8)
+		    flags = SPARC_RET_INT64;
+		  else if (rtype->size == 16)
+		    flags = SPARC_RET_INT128;
+		}
+	    }
+	  else if (fp_mask == all_mask)
+	    switch (word_size)
+	      {
+	      case 1: flags = SPARC_RET_F_1; break;
+	      case 2: flags = SPARC_RET_F_2; break;
+	      case 3: flags = SP_V9_RET_F_3; break;
+	      case 4: flags = SPARC_RET_F_4; break;
+	      /* 5 word structures skipped; handled via RET_STRUCT.  */
+	      case 6: flags = SPARC_RET_F_6; break;
+	      /* 7 word structures skipped; handled via RET_STRUCT.  */
+	      case 8: flags = SPARC_RET_F_8; break;
+	      }
+	}
+      break;
+
+    case FFI_TYPE_SINT8:
+      flags = SPARC_RET_SINT8;
+      break;
+    case FFI_TYPE_UINT8:
+      flags = SPARC_RET_UINT8;
+      break;
+    case FFI_TYPE_SINT16:
+      flags = SPARC_RET_SINT16;
+      break;
+    case FFI_TYPE_UINT16:
+      flags = SPARC_RET_UINT16;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      flags = SP_V9_RET_SINT32;
+      break;
+    case FFI_TYPE_UINT32:
+      flags = SPARC_RET_UINT32;
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_POINTER:
+      flags = SPARC_RET_INT64;
+      break;
+
+    default:
+      abort();
+    }
+
+  bytes = 0;
+  for (i = 0, n = cif->nargs; i < n; ++i)
+    {
+      ffi_type *ty = cif->arg_types[i];
+      size_t z = ty->size;
+      size_t a = ty->alignment;
+
+      switch (ty->type)
+	{
+	case FFI_TYPE_COMPLEX:
+	case FFI_TYPE_STRUCT:
+	  /* Large structs passed by reference.  */
+	  if (z > 16)
+	    {
+	      a = z = 8;
+	      break;
+	    }
+	  /* Small structs may be passed in integer or fp regs or both.  */
+	  if (bytes >= 16*8)
+	    break;
+	  if ((ffi_struct_float_mask (ty, 0) & 0xff00) == 0)
+	    break;
+	  /* FALLTHRU */
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	  flags |= SPARC_FLAG_FP_ARGS;
+	  break;
+	}
+      bytes = FFI_ALIGN(bytes, a);
+      bytes += FFI_ALIGN(z, 8);
+    }
+
+  /* Sparc call frames require that space is allocated for 6 args,
+     even if they aren't used. Make that space if necessary. */
+  if (bytes < 6 * 8)
+    bytes = 6 * 8;
+
+  /* The stack must be 2 word aligned, so round bytes up appropriately. */
+  bytes = FFI_ALIGN(bytes, 16);
+
+  /* Include the call frame to prep_args.  */
+  bytes += 8*16 + 8*8;
+
+  cif->bytes = bytes;
+  cif->flags = flags;
+  return FFI_OK;
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  cif->nfixedargs = cif->nargs;
+  return ffi_prep_cif_machdep_core(cif);
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned nfixedargs, unsigned ntotalargs)
+{
+  cif->nfixedargs = nfixedargs;
+  return ffi_prep_cif_machdep_core(cif);
+}
+
+extern void ffi_call_v9(ffi_cif *cif, void (*fn)(void), void *rvalue,
+			void **avalue, size_t bytes, void *closure) FFI_HIDDEN;
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+int FFI_HIDDEN
+ffi_prep_args_v9(ffi_cif *cif, unsigned long *argp, void *rvalue, void **avalue)
+{
+  ffi_type **p_arg;
+  int flags = cif->flags;
+  int i, nargs;
+
+  if (rvalue == NULL)
+    {
+      if (flags & SPARC_FLAG_RET_IN_MEM)
+	{
+	  /* Since we pass the pointer to the callee, we need a value.
+	     We allowed for this space in ffi_call, before ffi_call_v8
+	     alloca'd the space.  */
+	  rvalue = (char *)argp + cif->bytes;
+	}
+      else
+	{
+	  /* Otherwise, we can ignore the return value.  */
+	  flags = SPARC_RET_VOID;
+	}
+    }
+
+#ifdef USING_PURIFY
+  /* Purify will probably complain in our assembly routine,
+     unless we zero out this memory. */
+  memset(argp, 0, 6*8);
+#endif
+
+  if (flags & SPARC_FLAG_RET_IN_MEM)
+    *argp++ = (unsigned long)rvalue;
+
+  p_arg = cif->arg_types;
+  for (i = 0, nargs = cif->nargs; i < nargs; i++)
+    {
+      ffi_type *ty = p_arg[i];
+      void *a = avalue[i];
+      size_t z;
+
+      switch (ty->type)
+	{
+	case FFI_TYPE_SINT8:
+	  *argp++ = *(SINT8 *)a;
+	  break;
+	case FFI_TYPE_UINT8:
+	  *argp++ = *(UINT8 *)a;
+	  break;
+	case FFI_TYPE_SINT16:
+	  *argp++ = *(SINT16 *)a;
+	  break;
+	case FFI_TYPE_UINT16:
+	  *argp++ = *(UINT16 *)a;
+	  break;
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	  *argp++ = *(SINT32 *)a;
+	  break;
+	case FFI_TYPE_UINT32:
+	  *argp++ = *(UINT32 *)a;
+	  break;
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  *argp++ = *(UINT64 *)a;
+	  break;
+	case FFI_TYPE_FLOAT:
+	  flags |= SPARC_FLAG_FP_ARGS;
+	  *argp++ = *(UINT32 *)a;
+	  break;
+	case FFI_TYPE_DOUBLE:
+	  flags |= SPARC_FLAG_FP_ARGS;
+	  *argp++ = *(UINT64 *)a;
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	case FFI_TYPE_COMPLEX:
+	case FFI_TYPE_STRUCT:
+	  z = ty->size;
+	  if (z > 16)
+	    {
+	      /* For structures larger than 16 bytes we pass reference.  */
+	      *argp++ = (unsigned long)a;
+	      break;
+	    }
+	  if (((unsigned long)argp & 15) && ty->alignment > 8)
+	    argp++;
+	  memcpy(argp, a, z);
+	  argp += FFI_ALIGN(z, 8) / 8;
+	  break;
+
+	default:
+	  abort();
+	}
+    }
+
+  return flags;
+}
+
+static void
+ffi_call_int(ffi_cif *cif, void (*fn)(void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  size_t bytes = cif->bytes;
+  size_t i, nargs = cif->nargs;
+  ffi_type **arg_types = cif->arg_types;
+
+  FFI_ASSERT (cif->abi == FFI_V9);
+
+  if (rvalue == NULL && (cif->flags & SPARC_FLAG_RET_IN_MEM))
+    bytes += FFI_ALIGN (cif->rtype->size, 16);
+
+  /* If we have any large structure arguments, make a copy so we are passing
+     by value.  */
+  for (i = 0; i < nargs; i++)
+    {
+      ffi_type *at = arg_types[i];
+      int size = at->size;
+      if (at->type == FFI_TYPE_STRUCT && size > 4)
+        {
+          char *argcopy = alloca (size);
+          memcpy (argcopy, avalue[i], size);
+          avalue[i] = argcopy;
+        }
+    }  
+  
+  ffi_call_v9(cif, fn, rvalue, avalue, -bytes, closure);
+}
+
+void
+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go(ffi_cif *cif, void (*fn)(void), void *rvalue,
+	    void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+#ifdef __GNUC__
+static inline void
+ffi_flush_icache (void *p)
+{
+  asm volatile ("flush	%0; flush %0+8" : : "r" (p) : "memory");
+}
+#else
+extern void ffi_flush_icache (void *) FFI_HIDDEN;
+#endif
+
+extern void ffi_closure_v9(void) FFI_HIDDEN;
+extern void ffi_go_closure_v9(void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+  unsigned long fn;
+
+  if (cif->abi != FFI_V9)
+    return FFI_BAD_ABI;
+
+  /* Trampoline address is equal to the closure address.  We take advantage
+     of that to reduce the trampoline size by 8 bytes. */
+  fn = (unsigned long) ffi_closure_v9;
+  tramp[0] = 0x83414000;	/* rd	%pc, %g1	*/
+  tramp[1] = 0xca586010;	/* ldx	[%g1+16], %g5	*/
+  tramp[2] = 0x81c14000;	/* jmp	%g5		*/
+  tramp[3] = 0x01000000;	/* nop			*/
+  *((unsigned long *) &tramp[4]) = fn;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  ffi_flush_icache (closure);
+
+  return FFI_OK;
+}
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+  if (cif->abi != FFI_V9)
+    return FFI_BAD_ABI;
+
+  closure->tramp = ffi_go_closure_v9;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+int FFI_HIDDEN
+ffi_closure_sparc_inner_v9(ffi_cif *cif,
+			   void (*fun)(ffi_cif*, void*, void**, void*),
+			   void *user_data, void *rvalue,
+			   unsigned long *gpr, unsigned long *fpr)
+{
+  ffi_type **arg_types;
+  void **avalue;
+  int i, argn, argx, nargs, flags, nfixedargs;
+
+  arg_types = cif->arg_types;
+  nargs = cif->nargs;
+  flags = cif->flags;
+  nfixedargs = cif->nfixedargs;
+
+  avalue = alloca(nargs * sizeof(void *));
+
+  /* Copy the caller's structure return address so that the closure
+     returns the data directly to the caller.  */
+  if (flags & SPARC_FLAG_RET_IN_MEM)
+    {
+      rvalue = (void *) gpr[0];
+      /* Skip the structure return address.  */
+      argn = 1;
+    }
+  else
+    argn = 0;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  for (i = 0; i < nargs; i++, argn = argx)
+    {
+      int named = i < nfixedargs;
+      ffi_type *ty = arg_types[i];
+      void *a = &gpr[argn];
+      size_t z;
+
+      argx = argn + 1;
+      switch (ty->type)
+	{
+	case FFI_TYPE_COMPLEX:
+	case FFI_TYPE_STRUCT:
+	  z = ty->size;
+	  if (z > 16)
+	    a = *(void **)a;
+	  else
+	    {
+	      argx = argn + FFI_ALIGN (z, 8) / 8;
+	      if (named && argn < 16)
+		{
+		  int size_mask = ffi_struct_float_mask (ty, 0);
+		  int argn_mask = (0xffff00 >> argn) & 0xff00;
+
+		  /* Eliminate fp registers off the end.  */
+		  size_mask = (size_mask & 0xff) | (size_mask & argn_mask);
+		  a = ffi_struct_float_merge (size_mask, gpr+argn, fpr+argn);
+		}
+	    }
+	  break;
+
+	case FFI_TYPE_LONGDOUBLE:
+	  argn = FFI_ALIGN (argn, 2);
+	  a = (named && argn < 16 ? fpr : gpr) + argn;
+	  argx = argn + 2;
+	  break;
+	case FFI_TYPE_DOUBLE:
+	  if (named && argn < 16)
+	    a = fpr + argn;
+	  break;
+	case FFI_TYPE_FLOAT:
+	  if (named && argn < 16)
+	    a = fpr + argn;
+	  a += 4;
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_POINTER:
+	  break;
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	  a += 4;
+	  break;
+        case FFI_TYPE_UINT16:
+        case FFI_TYPE_SINT16:
+	  a += 6;
+	  break;
+        case FFI_TYPE_UINT8:
+        case FFI_TYPE_SINT8:
+	  a += 7;
+	  break;
+
+	default:
+	  abort();
+	}
+      avalue[i] = a;
+    }
+
+  /* Invoke the closure.  */
+  fun (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_sparc how to perform return type promotions.  */
+  return flags;
+}
+#endif /* SPARC64 */
Index: libffi-3.4.6/src/sparc/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/internal.h b/libffi-3.4.6/src/sparc/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/internal.h	
@@ -0,0 +1,26 @@
+#define SPARC_RET_VOID		0
+#define SPARC_RET_STRUCT	1
+#define SPARC_RET_UINT8		2
+#define SPARC_RET_SINT8		3
+#define SPARC_RET_UINT16	4
+#define SPARC_RET_SINT16	5
+#define SPARC_RET_UINT32	6
+#define SP_V9_RET_SINT32	7	/* v9 only */
+#define SP_V8_RET_CPLX16	7	/* v8 only */
+#define SPARC_RET_INT64		8
+#define SPARC_RET_INT128	9
+
+/* Note that F_7 is missing, and is handled by SPARC_RET_STRUCT.  */
+#define SPARC_RET_F_8		10
+#define SPARC_RET_F_6		11
+#define SPARC_RET_F_4		12
+#define SPARC_RET_F_2		13
+#define SP_V9_RET_F_3		14	/* v9 only */
+#define SP_V8_RET_CPLX8		14	/* v8 only */
+#define SPARC_RET_F_1		15
+
+#define SPARC_FLAG_RET_MASK	15
+#define SPARC_FLAG_RET_IN_MEM	32
+#define SPARC_FLAG_FP_ARGS	64
+
+#define SPARC_SIZEMASK_SHIFT	8
Index: libffi-3.4.6/src/sparc/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/sparc/ffitarget.h b/libffi-3.4.6/src/sparc/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/sparc/ffitarget.h	
@@ -0,0 +1,81 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+   Target configuration macros for SPARC.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#if defined(__arch64__) || defined(__sparcv9)
+#ifndef SPARC64
+#define SPARC64
+#endif
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+#ifdef SPARC64
+  FFI_V9,
+  FFI_DEFAULT_ABI = FFI_V9,
+#else
+  FFI_V8,
+  FFI_DEFAULT_ABI = FFI_V8,
+#endif
+  FFI_LAST_ABI
+} ffi_abi;
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION 1
+#define FFI_TARGET_HAS_COMPLEX_TYPE 1
+
+#ifdef SPARC64
+# define FFI_TARGET_SPECIFIC_VARIADIC 1
+# define FFI_EXTRA_CIF_FIELDS  unsigned int nfixedargs
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#ifdef SPARC64
+#define FFI_TRAMPOLINE_SIZE 24
+#else
+#define FFI_TRAMPOLINE_SIZE 16
+#endif
+
+#endif
+
Index: libffi-3.4.6/src/wasm32/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/wasm32/ffi.c b/libffi-3.4.6/src/wasm32/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/wasm32/ffi.c	
@@ -0,0 +1,947 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2018-2023  Hood Chatham, Brion Vibber, Kleis Auke Wolthuizen, and others.
+
+   wasm32/emscripten Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <emscripten/emscripten.h>
+
+#ifdef DEBUG_F
+#define LOG_DEBUG(args...)  \
+  console.warn(`====LIBFFI(line __LINE__)`, args)
+#else
+#define LOG_DEBUG(args...) 0
+#endif
+
+#define EM_JS_MACROS(ret, name, args, body...) EM_JS(ret, name, args, body)
+
+#if WASM_BIGINT
+EM_JS_DEPS(libffi, "$getWasmTableEntry,$setWasmTableEntry,$getEmptyTableSlot,$convertJsFunctionToWasm");
+#define CALL_FUNCTION_POINTER(ptr, args...) \
+  (LOG_DEBUG("CALL_FUNC_PTR", ptr, args),   \
+  getWasmTableEntry(ptr).apply(null, args))
+
+#define JS_FUNCTION_TO_WASM convertJsFunctionToWasm
+#else
+EM_JS_DEPS(libffi, "$getWasmTableEntry,$setWasmTableEntry,$getEmptyTableSlot,$convertJsFunctionToWasm,$dynCall,$generateFuncType,$uleb128Encode");
+#define CALL_FUNCTION_POINTER(ptr, args...)     \
+  (LOG_DEBUG("CALL_FUNC_PTR", sig, ptr, args),  \
+  dynCall(sig, ptr, args))
+
+#define JS_FUNCTION_TO_WASM createLegalizerWrapper
+#endif
+
+// Signature calculations are not needed if WASM_BIGINT is present.
+#if WASM_BIGINT
+#define SIG(sig)
+#else
+#define SIG(sig) sig
+#endif
+
+#define DEREF_U8(addr, offset) HEAPU8[addr + offset]
+#define DEREF_S8(addr, offset) HEAP8[addr + offset]
+#define DEREF_U16(addr, offset) HEAPU16[(addr >> 1) + offset]
+#define DEREF_S16(addr, offset) HEAP16[(addr >> 1) + offset]
+#define DEREF_U32(addr, offset) HEAPU32[(addr >> 2) + offset]
+#define DEREF_S32(addr, offset) HEAP32[(addr >> 2) + offset]
+
+#define DEREF_F32(addr, offset) HEAPF32[(addr >> 2) + offset]
+#define DEREF_F64(addr, offset) HEAPF64[(addr >> 3) + offset]
+
+#if WASM_BIGINT
+// We have HEAPU64 in this case.
+#define DEREF_U64(addr, offset) HEAPU64[(addr >> 3) + offset]
+#endif
+
+
+#define CHECK_FIELD_OFFSET(struct, field, offset)                                  \
+  _Static_assert(                                                                  \
+    offsetof(struct, field) == offset,                                             \
+    "Memory layout of '" #struct "' has changed: '" #field "' is in an unexpected location");
+
+CHECK_FIELD_OFFSET(ffi_cif, abi, 4*0);
+CHECK_FIELD_OFFSET(ffi_cif, nargs, 4*1);
+CHECK_FIELD_OFFSET(ffi_cif, arg_types, 4*2);
+CHECK_FIELD_OFFSET(ffi_cif, rtype, 4*3);
+CHECK_FIELD_OFFSET(ffi_cif, nfixedargs, 4*6);
+
+#define CIF__ABI(addr) DEREF_U32(addr, 0)
+#define CIF__NARGS(addr) DEREF_U32(addr, 1)
+#define CIF__ARGTYPES(addr) DEREF_U32(addr, 2)
+#define CIF__RTYPE(addr) DEREF_U32(addr, 3)
+#define CIF__NFIXEDARGS(addr) DEREF_U32(addr, 6)
+
+CHECK_FIELD_OFFSET(ffi_type, size, 0);
+CHECK_FIELD_OFFSET(ffi_type, alignment, 4);
+CHECK_FIELD_OFFSET(ffi_type, type, 6);
+CHECK_FIELD_OFFSET(ffi_type, elements, 8);
+
+#define FFI_TYPE__SIZE(addr) DEREF_U32(addr, 0)
+#define FFI_TYPE__ALIGN(addr) DEREF_U16(addr + 4, 0)
+#define FFI_TYPE__TYPEID(addr) DEREF_U16(addr + 6, 0)
+#define FFI_TYPE__ELEMENTS(addr) DEREF_U32(addr + 8, 0)
+
+#define ALIGN_ADDRESS(addr, align) (addr &= (~((align) - 1)))
+#define STACK_ALLOC(stack, size, align) ((stack -= (size)), ALIGN_ADDRESS(stack, align))
+
+// Most wasm runtimes support at most 1000 Js trampoline args.
+#define MAX_ARGS 1000
+
+#include <stddef.h>
+
+#define VARARGS_FLAG 1
+
+#define FFI_OK_MACRO 0
+_Static_assert(FFI_OK_MACRO == FFI_OK, "FFI_OK must be 0");
+
+#define FFI_BAD_TYPEDEF_MACRO 1
+_Static_assert(FFI_BAD_TYPEDEF_MACRO == FFI_BAD_TYPEDEF, "FFI_BAD_TYPEDEF must be 1");
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  if (cif->abi != FFI_WASM32_EMSCRIPTEN)
+    return FFI_BAD_ABI;
+  // This is called after ffi_prep_cif_machdep_var so we need to avoid
+  // overwriting cif->nfixedargs.
+  if (!(cif->flags & VARARGS_FLAG))
+    cif->nfixedargs = cif->nargs;
+  if (cif->nargs > MAX_ARGS)
+    return FFI_BAD_TYPEDEF;
+  if (cif->rtype->type == FFI_TYPE_COMPLEX)
+    return FFI_BAD_TYPEDEF;
+  // If they put the COMPLEX type into a struct we won't notice, but whatever.
+  for (int i = 0; i < cif->nargs; i++)
+    if (cif->arg_types[i]->type == FFI_TYPE_COMPLEX)
+      return FFI_BAD_TYPEDEF;
+  return FFI_OK;
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned nfixedargs, unsigned ntotalargs)
+{
+  cif->flags |= VARARGS_FLAG;
+  cif->nfixedargs = nfixedargs;
+  // The varargs takes up one extra argument
+  if (cif->nfixedargs + 1 > MAX_ARGS)
+    return FFI_BAD_TYPEDEF;
+  return FFI_OK;
+}
+
+/**
+ * A Javascript helper function. This takes an argument typ which is a wasm
+ * pointer to an ffi_type object. It returns a pair a type and a type id.
+ *
+ *    - If it is not a struct, return its type and its typeid field.
+ *    - If it is a struct of size >= 2, return the type and its typeid (which
+ *      will be FFI_TYPE_STRUCT)
+ *    - If it is a struct of size 0, return FFI_TYPE_VOID (????? this is broken)
+ *    - If it is a struct of size 1, replace it with the single field and apply
+ *      the same logic again to that.
+ *
+ * By always unboxing structs up front, we can avoid messy casework later.
+ */
+EM_JS_MACROS(
+void,
+unbox_small_structs, (ffi_type type_ptr), {
+  var type_id = FFI_TYPE__TYPEID(type_ptr);
+  while (type_id === FFI_TYPE_STRUCT) {
+    // Don't unbox single element structs if they are bigger than 16 bytes. This
+    // is a work around for the fact that Python will give incorrect values for
+    // the size of the field in these cases: it says that the struct has pointer
+    // size and alignment and are of type pointer, even though it is more
+    // accurately a struct and has a larger size. Keeping it as a struct here
+    // will let us get the ABI right (which is in fact that the true argument is
+    // a pointer to the stack... so maybe Python issn't so wrong??)
+    //
+    // See the Python comment here:
+    // https://github.com/python/cpython/blob/a16a9f978f42b8a09297c1efbf33877f6388c403/Modules/_ctypes/stgdict.c#L718-L779
+    if (FFI_TYPE__SIZE(type_ptr) > 16) {
+      break;
+    }
+    var elements = FFI_TYPE__ELEMENTS(type_ptr);
+    var first_element = DEREF_U32(elements, 0);
+    if (first_element === 0) {
+      type_id = FFI_TYPE_VOID;
+      break;
+    } else if (DEREF_U32(elements, 1) === 0) {
+      type_ptr = first_element;
+      type_id = FFI_TYPE__TYPEID(first_element);
+    } else {
+      break;
+    }
+  }
+  return [type_ptr, type_id];
+})
+
+EM_JS_MACROS(
+void,
+ffi_call_js, (ffi_cif *cif, ffi_fp fn, void *rvalue, void **avalue),
+{
+  var abi = CIF__ABI(cif);
+  var nargs = CIF__NARGS(cif);
+  var nfixedargs = CIF__NFIXEDARGS(cif);
+  var arg_types_ptr = CIF__ARGTYPES(cif);
+  var rtype_unboxed = unbox_small_structs(CIF__RTYPE(cif));
+  var rtype_ptr = rtype_unboxed[0];
+  var rtype_id = rtype_unboxed[1];
+  var orig_stack_ptr = stackSave();
+  var cur_stack_ptr = orig_stack_ptr;
+
+  var args = [];
+  // Does our onwards call return by argument or normally? We return by argument
+  // no matter what.
+  var ret_by_arg = false;
+
+  if (rtype_id === FFI_TYPE_COMPLEX) {
+    throw new Error('complex ret marshalling nyi');
+  }
+  if (rtype_id < 0 || rtype_id > FFI_TYPE_LAST) {
+    throw new Error('Unexpected rtype ' + rtype_id);
+  }
+  // If the return type is a struct with multiple entries or a long double, the
+  // function takes an extra first argument which is a pointer to return value.
+  // Conveniently, we've already received a pointer to return value, so we can
+  // just use this. We also mark a flag that we don't need to convert the return
+  // value of the dynamic call back to C.
+  if (rtype_id === FFI_TYPE_LONGDOUBLE || rtype_id === FFI_TYPE_STRUCT) {
+    args.push(rvalue);
+    ret_by_arg = true;
+  }
+
+  SIG(var sig = "");
+
+#if !WASM_BIGINT
+  switch(rtype_id) {
+  case FFI_TYPE_VOID:
+    SIG(sig = 'v');
+    break;
+  case FFI_TYPE_STRUCT:
+  case FFI_TYPE_LONGDOUBLE:
+    SIG(sig = 'vi');
+    break;
+  case FFI_TYPE_INT:
+  case FFI_TYPE_UINT8:
+  case FFI_TYPE_SINT8:
+  case FFI_TYPE_UINT16:
+  case FFI_TYPE_SINT16:
+  case FFI_TYPE_UINT32:
+  case FFI_TYPE_SINT32:
+  case FFI_TYPE_POINTER:
+    SIG(sig = 'i');
+    break;
+  case FFI_TYPE_FLOAT:
+    SIG(sig = 'f');
+    break;
+  case FFI_TYPE_DOUBLE:
+    SIG(sig = 'd');
+    break;
+  case FFI_TYPE_UINT64:
+  case FFI_TYPE_SINT64:
+    SIG(sig = 'j');
+    break;
+  }
+#endif
+
+  // Accumulate a Javascript list of arguments for the Javascript wrapper for
+  // the wasm function. The Javascript wrapper does a type conversion from
+  // Javascript to C automatically, here we manually do the inverse conversion
+  // from C to Javascript.
+  for (var i = 0; i < nfixedargs; i++) {
+    var arg_ptr = DEREF_U32(avalue, i);
+    var arg_unboxed = unbox_small_structs(DEREF_U32(arg_types_ptr, i));
+    var arg_type_ptr = arg_unboxed[0];
+    var arg_type_id = arg_unboxed[1];
+
+    // It's okay here to always use unsigned integers as long as the size is 32
+    // or 64 bits. Smaller sizes get extended to 32 bits differently according
+    // to whether they are signed or unsigned.
+    switch (arg_type_id) {
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_POINTER:
+      args.push(DEREF_U32(arg_ptr, 0));
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_FLOAT:
+      args.push(DEREF_F32(arg_ptr, 0));
+      SIG(sig += 'f');
+      break;
+    case FFI_TYPE_DOUBLE:
+      args.push(DEREF_F64(arg_ptr, 0));
+      SIG(sig += 'd');
+      break;
+    case FFI_TYPE_UINT8:
+      args.push(DEREF_U8(arg_ptr, 0));
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_SINT8:
+      args.push(DEREF_S8(arg_ptr, 0));
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_UINT16:
+      args.push(DEREF_U16(arg_ptr, 0));
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_SINT16:
+      args.push(DEREF_S16(arg_ptr, 0));
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      #if WASM_BIGINT
+      args.push(DEREF_U64(arg_ptr, 0));
+      #else
+      args.push(DEREF_U32(arg_ptr, 0));
+      args.push(DEREF_U32(arg_ptr, 1));
+      #endif
+      SIG(sig += 'j');
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      // long double is passed as a pair of BigInts.
+      #if WASM_BIGINT
+      args.push(DEREF_U64(arg_ptr, 0));
+      args.push(DEREF_U64(arg_ptr, 1));
+      #else
+      args.push(DEREF_U32(arg_ptr, 0));
+      args.push(DEREF_U32(arg_ptr, 1));
+      args.push(DEREF_U32(arg_ptr, 2));
+      args.push(DEREF_U32(arg_ptr, 3));
+      #endif
+      SIG(sig += "jj");
+      break;
+    case FFI_TYPE_STRUCT:
+      // Nontrivial structs are passed by pointer.
+      // Have to copy the struct onto the stack though because C ABI says it's
+      // call by value.
+      var size = FFI_TYPE__SIZE(arg_type_ptr);
+      var align = FFI_TYPE__ALIGN(arg_type_ptr);
+      STACK_ALLOC(cur_stack_ptr, size, align);
+      HEAP8.subarray(cur_stack_ptr, cur_stack_ptr+size).set(HEAP8.subarray(arg_ptr, arg_ptr + size));
+      args.push(cur_stack_ptr);
+      SIG(sig += 'i');
+      break;
+    case FFI_TYPE_COMPLEX:
+      throw new Error('complex marshalling nyi');
+    default:
+      throw new Error('Unexpected type ' + arg_type_id);
+    }
+  }
+
+  // Wasm functions can't directly manipulate the callstack, so varargs
+  // arguments have to go on a separate stack. A varags function takes one extra
+  // argument which is a pointer to where on the separate stack the args are
+  // located. Because stacks are allocated backwards, we have to loop over the
+  // varargs backwards.
+  //
+  // We don't have any way of knowing how many args were actually passed, so we
+  // just always copy extra nonsense past the end. The ownwards call will know
+  // not to look at it.
+  if (nfixedargs != nargs) {
+    SIG(sig += 'i');
+    var struct_arg_info = [];
+    for (var i = nargs - 1;  i >= nfixedargs; i--) {
+      var arg_ptr = DEREF_U32(avalue, i);
+      var arg_unboxed = unbox_small_structs(DEREF_U32(arg_types_ptr, i));
+      var arg_type_ptr = arg_unboxed[0];
+      var arg_type_id = arg_unboxed[1];
+      switch (arg_type_id) {
+      case FFI_TYPE_UINT8:
+      case FFI_TYPE_SINT8:
+        STACK_ALLOC(cur_stack_ptr, 1, 1);
+        DEREF_U8(cur_stack_ptr, 0) = DEREF_U8(arg_ptr, 0);
+        break;
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_SINT16:
+        STACK_ALLOC(cur_stack_ptr, 2, 2);
+        DEREF_U16(cur_stack_ptr, 0) = DEREF_U16(arg_ptr, 0);
+        break;
+      case FFI_TYPE_INT:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_POINTER:
+      case FFI_TYPE_FLOAT:
+        STACK_ALLOC(cur_stack_ptr, 4, 4);
+        DEREF_U32(cur_stack_ptr, 0) = DEREF_U32(arg_ptr, 0);
+        break;
+      case FFI_TYPE_DOUBLE:
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+        STACK_ALLOC(cur_stack_ptr, 8, 8);
+        DEREF_U32(cur_stack_ptr, 0) = DEREF_U32(arg_ptr, 0);
+        DEREF_U32(cur_stack_ptr, 1) = DEREF_U32(arg_ptr, 1);
+        break;
+      case FFI_TYPE_LONGDOUBLE:
+        STACK_ALLOC(cur_stack_ptr, 16, 8);
+        DEREF_U32(cur_stack_ptr, 0) = DEREF_U32(arg_ptr, 0);
+        DEREF_U32(cur_stack_ptr, 1) = DEREF_U32(arg_ptr, 1);
+        DEREF_U32(cur_stack_ptr, 2) = DEREF_U32(arg_ptr, 2);
+        DEREF_U32(cur_stack_ptr, 3) = DEREF_U32(arg_ptr, 3);
+        break;
+      case FFI_TYPE_STRUCT:
+        // Again, struct must be passed by pointer.
+        // But ABI is by value, so have to copy struct onto stack.
+        // Currently arguments are going onto stack so we can't put it there now. Come back for this.
+        STACK_ALLOC(cur_stack_ptr, 4, 4);
+        struct_arg_info.push([cur_stack_ptr, arg_ptr, FFI_TYPE__SIZE(arg_type_ptr), FFI_TYPE__ALIGN(arg_type_ptr)]);
+        break;
+      case FFI_TYPE_COMPLEX:
+        throw new Error('complex arg marshalling nyi');
+      default:
+        throw new Error('Unexpected argtype ' + arg_type_id);
+      }
+    }
+    // extra normal argument which is the pointer to the varargs.
+    args.push(cur_stack_ptr);
+    // Now allocate variable struct args on stack too.
+    for (var i = 0; i < struct_arg_info.length; i++) {
+      var struct_info = struct_arg_info[i];
+      var arg_target = struct_info[0];
+      var arg_ptr = struct_info[1];
+      var size = struct_info[2];
+      var align = struct_info[3];
+      STACK_ALLOC(cur_stack_ptr, size, align);
+      HEAP8.subarray(cur_stack_ptr, cur_stack_ptr+size).set(HEAP8.subarray(arg_ptr, arg_ptr + size));
+      DEREF_U32(arg_target, 0) = cur_stack_ptr;
+    }
+  }
+  stackRestore(cur_stack_ptr);
+  stackAlloc(0); // stackAlloc enforces alignment invariants on the stack pointer
+  var result = CALL_FUNCTION_POINTER(fn, args);
+  // Put the stack pointer back (we moved it if there were any struct args or we
+  // made a varargs call)
+  stackRestore(orig_stack_ptr);
+
+  // We need to return by argument. If return value was a nontrivial struct or
+  // long double, the onwards call already put the return value in rvalue
+  if (ret_by_arg) {
+    return;
+  }
+
+  // Otherwise the result was automatically converted from C into Javascript and
+  // we need to manually convert it back to C.
+  switch (rtype_id) {
+  case FFI_TYPE_VOID:
+    break;
+  case FFI_TYPE_INT:
+  case FFI_TYPE_UINT32:
+  case FFI_TYPE_SINT32:
+  case FFI_TYPE_POINTER:
+    DEREF_U32(rvalue, 0) = result;
+    break;
+  case FFI_TYPE_FLOAT:
+    DEREF_F32(rvalue, 0) = result;
+    break;
+  case FFI_TYPE_DOUBLE:
+    DEREF_F64(rvalue, 0) = result;
+    break;
+  case FFI_TYPE_UINT8:
+  case FFI_TYPE_SINT8:
+    DEREF_U8(rvalue, 0) = result;
+    break;
+  case FFI_TYPE_UINT16:
+  case FFI_TYPE_SINT16:
+    DEREF_U16(rvalue, 0) = result;
+    break;
+  case FFI_TYPE_UINT64:
+  case FFI_TYPE_SINT64:
+    #if WASM_BIGINT
+    DEREF_U64(rvalue, 0) = result;
+    #else
+    DEREF_U32(rvalue, 0) = result;
+    DEREF_U32(rvalue, 1) = getTempRet0();
+    #endif
+    break;
+  case FFI_TYPE_COMPLEX:
+    throw new Error('complex ret marshalling nyi');
+  default:
+    throw new Error('Unexpected rtype ' + rtype_id);
+  }
+});
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue) {
+  ffi_call_js(cif, fn, rvalue, avalue);
+}
+
+CHECK_FIELD_OFFSET(ffi_closure, ftramp, 4*0);
+CHECK_FIELD_OFFSET(ffi_closure, cif, 4*1);
+CHECK_FIELD_OFFSET(ffi_closure, fun, 4*2);
+CHECK_FIELD_OFFSET(ffi_closure, user_data, 4*3);
+
+#define CLOSURE__wrapper(addr) DEREF_U32(addr, 0)
+#define CLOSURE__cif(addr) DEREF_U32(addr, 1)
+#define CLOSURE__fun(addr) DEREF_U32(addr, 2)
+#define CLOSURE__user_data(addr) DEREF_U32(addr, 3)
+
+EM_JS_MACROS(void *, ffi_closure_alloc_js, (size_t size, void **code), {
+  var closure = _malloc(size);
+  var index = getEmptyTableSlot();
+  DEREF_U32(code, 0) = index;
+  CLOSURE__wrapper(closure) = index;
+  return closure;
+})
+
+void * __attribute__ ((visibility ("default")))
+ffi_closure_alloc(size_t size, void **code) {
+  return ffi_closure_alloc_js(size, code);
+}
+
+EM_JS_MACROS(void, ffi_closure_free_js, (void *closure), {
+  var index = CLOSURE__wrapper(closure);
+  freeTableIndexes.push(index);
+  _free(closure);
+})
+
+void __attribute__ ((visibility ("default")))
+ffi_closure_free(void *closure) {
+  return ffi_closure_free_js(closure);
+}
+
+#if !WASM_BIGINT
+
+// When !WASM_BIGINT, we assume there is no JS bigint integration, so JavaScript
+// functions cannot take 64 bit integer arguments.
+//
+// We need to make our own wasm legalizer adaptor that splits 64 bit integer
+// arguments and then calls the JavaScript trampoline, then the JavaScript
+// trampoline reassembles them, calls the closure, then splits the result (if
+// it's a 64 bit integer) and the adaptor puts it back together.
+//
+// This is basically the reverse of the Emscripten function
+// createDyncallWrapper.
+EM_JS(void, createLegalizerWrapper, (int trampoline, int sig), {
+  if(!sig.includes("j")) {
+    return convertJsFunctionToWasm(trampoline, sig);
+  }
+  var sections = [];
+  var prelude = [
+    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
+    0x01, 0x00, 0x00, 0x00, // version: 1
+  ];
+  sections.push(prelude);
+  var wrappersig = [
+    // if return type is j, we will put the upper 32 bits into tempRet0.
+    sig[0].replace("j", "i"),
+    // in the rest of the argument list, one 64 bit integer is legalized into
+    // two 32 bit integers.
+    sig.slice(1).replace(/j/g, "ii"),
+  ].join("");
+
+  var typeSectionBody = [
+    0x03, // number of types = 3
+  ];
+  generateFuncType(wrappersig, typeSectionBody); // The signature of the wrapper we are generating
+  generateFuncType(sig, typeSectionBody); // the signature of the function pointer we will call
+  generateFuncType("i", typeSectionBody); // the signature of getTempRet0
+
+  var typeSection = [0x01 /* Type section code */];
+  uleb128Encode(typeSectionBody.length, typeSection); // length of section in bytes
+  typeSection.push.apply(typeSection, typeSectionBody);
+  sections.push(typeSection);
+
+  var importSection = [
+    0x02, // import section code
+    0x0d, // length of section in bytes
+    0x02, // number of imports = 2
+    // Import the getTempRet0 function, which we will call "r"
+    0x01, 0x65, // name "e"
+    0x01, 0x72, // name "r"
+    0x00, // importing a function
+    0x02, // type 2 = () -> i32
+    // Import the wrapped function, which we will call "f"
+    0x01, 0x65, // name "e"
+    0x01, 0x66, // name "f"
+    0x00, // importing a function
+    0x00, // type 0 = wrappersig
+  ];
+  sections.push(importSection);
+
+  var functionSection = [
+    0x03, // function section code
+    0x02, // length of section in bytes
+    0x01, // number of functions = 1
+    0x01, // type 1 = sig
+  ];
+  sections.push(functionSection);
+
+  var exportSection = [
+    0x07, // export section code
+    0x05, // length of section in bytes
+    0x01, // One export
+    0x01, 0x66, // name "f"
+    0x00, // type: function
+    0x02, // function index 2 = the wrapper function
+  ];
+  sections.push(exportSection);
+
+  var convert_code = [];
+  convert_code.push(0x00); // no local variables (except the arguments)
+
+  function localGet(j) {
+    convert_code.push(0x20); // local.get
+    uleb128Encode(j, convert_code);
+  }
+
+  for (var i = 1; i < sig.length; i++) {
+    if (sig[i] == "j") {
+      localGet(i - 1);
+      convert_code.push(
+        0xa7 // i32.wrap_i64
+      );
+      localGet(i - 1);
+      convert_code.push(
+        0x42, 0x20, // i64.const 32
+        0x88,       // i64.shr_u
+        0xa7        // i32.wrap_i64
+      );
+    } else {
+      localGet(i - 1);
+    }
+  }
+  convert_code.push(
+    0x10, 0x01 // call f
+  );
+  if (sig[0] === "j") {
+    // Need to reassemble a 64 bit integer. Lower 32 bits is on stack. Upper 32
+    // bits we get from getTempRet0
+    convert_code.push(
+      0xad,       // i64.extend_i32_unsigned
+      0x10, 0x00, // Call function 0 (r = getTempRet0)
+      // join lower 32 bits and upper 32 bits
+      0xac,       // i64.extend_i32_signed
+      0x42, 0x20, // i64.const 32
+      0x86,       // i64.shl,
+      0x84        // i64.or
+    );
+  }
+  convert_code.push(0x0b); // end
+
+  var codeBody = [0x01]; // one code
+  uleb128Encode(convert_code.length, codeBody);
+  codeBody.push.apply(codeBody, convert_code);
+  var codeSection = [0x0a /* Code section code */];
+  uleb128Encode(codeBody.length, codeSection);
+  codeSection.push.apply(codeSection, codeBody);
+  sections.push(codeSection);
+
+  var bytes = new Uint8Array([].concat.apply([], sections));
+  // We can compile this wasm module synchronously because it is small.
+  var module = new WebAssembly.Module(bytes);
+  var instance = new WebAssembly.Instance(module, {
+    e: {
+      r: getTempRet0,
+      f: trampoline,
+    },
+  });
+  return instance.exports.f;
+});
+#endif
+
+EM_JS_MACROS(
+ffi_status,
+ffi_prep_closure_loc_js,
+(ffi_closure *closure, ffi_cif *cif, void *fun, void *user_data, void *codeloc),
+{
+  var abi = CIF__ABI(cif);
+  var nargs = CIF__NARGS(cif);
+  var nfixedargs = CIF__NFIXEDARGS(cif);
+  var arg_types_ptr = CIF__ARGTYPES(cif);
+  var rtype_unboxed = unbox_small_structs(CIF__RTYPE(cif));
+  var rtype_ptr = rtype_unboxed[0];
+  var rtype_id = rtype_unboxed[1];
+
+  // First construct the signature of the javascript trampoline we are going to create.
+  // Important: this is the signature for calling us, the onward call always has sig viiii.
+  var sig;
+  var ret_by_arg = false;
+  switch (rtype_id) {
+  case FFI_TYPE_VOID:
+    sig = 'v';
+    break;
+  case FFI_TYPE_STRUCT:
+  case FFI_TYPE_LONGDOUBLE:
+    // Return via a first pointer argument.
+    sig = 'vi';
+    ret_by_arg = true;
+    break;
+  case FFI_TYPE_INT:
+  case FFI_TYPE_UINT8:
+  case FFI_TYPE_SINT8:
+  case FFI_TYPE_UINT16:
+  case FFI_TYPE_SINT16:
+  case FFI_TYPE_UINT32:
+  case FFI_TYPE_SINT32:
+  case FFI_TYPE_POINTER:
+    sig = 'i';
+    break;
+  case FFI_TYPE_FLOAT:
+    sig = 'f';
+    break;
+  case FFI_TYPE_DOUBLE:
+    sig = 'd';
+    break;
+  case FFI_TYPE_UINT64:
+  case FFI_TYPE_SINT64:
+    sig = 'j';
+    break;
+  case FFI_TYPE_COMPLEX:
+    throw new Error('complex ret marshalling nyi');
+  default:
+    throw new Error('Unexpected rtype ' + rtype_id);
+  }
+  var unboxed_arg_type_id_list = [];
+  var unboxed_arg_type_info_list = [];
+  for (var i = 0; i < nargs; i++) {
+    var arg_unboxed = unbox_small_structs(DEREF_U32(arg_types_ptr, i));
+    var arg_type_ptr = arg_unboxed[0];
+    var arg_type_id = arg_unboxed[1];
+    unboxed_arg_type_id_list.push(arg_type_id);
+    unboxed_arg_type_info_list.push([FFI_TYPE__SIZE(arg_type_ptr), FFI_TYPE__ALIGN(arg_type_ptr)]);
+  }
+  for (var i = 0; i < nfixedargs; i++) {
+    switch (unboxed_arg_type_id_list[i]) {
+    case FFI_TYPE_INT:
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_STRUCT:
+      sig += 'i';
+      break;
+    case FFI_TYPE_FLOAT:
+      sig += 'f';
+      break;
+    case FFI_TYPE_DOUBLE:
+      sig += 'd';
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      sig += 'jj';
+      break;
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      sig += 'j';
+      break;
+    case FFI_TYPE_COMPLEX:
+      throw new Error('complex marshalling nyi');
+    default:
+      throw new Error('Unexpected argtype ' + arg_type_id);
+    }
+  }
+  if (nfixedargs < nargs) {
+    // extra pointer to varargs stack
+    sig += "i";
+  }
+  LOG_DEBUG("CREATE_CLOSURE",  "sig:", sig);
+  function trampoline() {
+    var args = Array.prototype.slice.call(arguments);
+    var size = 0;
+    var orig_stack_ptr = stackSave();
+    var cur_ptr = orig_stack_ptr;
+    var ret_ptr;
+    var jsarg_idx = 0;
+    // Should we return by argument or not? The onwards call returns by argument
+    // no matter what. (Warning: ret_by_arg means the opposite in ffi_call)
+    if (ret_by_arg) {
+      ret_ptr = args[jsarg_idx++];
+    } else {
+      // We might return 4 bytes or 8 bytes, allocate 8 just in case.
+      STACK_ALLOC(cur_ptr, 8, 8);
+      ret_ptr = cur_ptr;
+    }
+    cur_ptr -= 4 * nargs;
+    var args_ptr = cur_ptr;
+    var carg_idx = 0;
+    // Here we either have the actual argument, or a pair of BigInts for long
+    // double, or a pointer to struct. We have to store into args_ptr[i] a
+    // pointer to the ith argument. If the argument is a struct, just store the
+    // pointer. Otherwise allocate stack space and copy the js argument onto the
+    // stack.
+    for (; carg_idx < nfixedargs; carg_idx++) {
+      // jsarg_idx might start out as 0 or 1 depending on ret_by_arg
+      // it advances an extra time for long double
+      var cur_arg = args[jsarg_idx++];
+      var arg_type_info = unboxed_arg_type_info_list[carg_idx];
+      var arg_size = arg_type_info[0];
+      var arg_align = arg_type_info[1];
+      var arg_type_id = unboxed_arg_type_id_list[carg_idx];
+      switch (arg_type_id) {
+      case FFI_TYPE_UINT8:
+      case FFI_TYPE_SINT8:
+        // Bad things happen if we don't align to 4 here
+        STACK_ALLOC(cur_ptr, 1, 4);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        DEREF_U8(cur_ptr, 0) = cur_arg;
+        break;
+      case FFI_TYPE_UINT16:
+      case FFI_TYPE_SINT16:
+        // Bad things happen if we don't align to 4 here
+        STACK_ALLOC(cur_ptr, 2, 4);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        DEREF_U16(cur_ptr, 0) = cur_arg;
+        break;
+      case FFI_TYPE_INT:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_POINTER:
+        STACK_ALLOC(cur_ptr, 4, 4);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        DEREF_U32(cur_ptr, 0) = cur_arg;
+        break;
+      case FFI_TYPE_STRUCT:
+        // cur_arg is already a pointer to struct
+        // copy it onto stack to pass by value
+        STACK_ALLOC(cur_ptr, arg_size, arg_align);
+        HEAP8.subarray(cur_ptr, cur_ptr + arg_size).set(HEAP8.subarray(cur_arg, cur_arg + arg_size));
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        break;
+      case FFI_TYPE_FLOAT:
+        STACK_ALLOC(cur_ptr, 4, 4);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        DEREF_F32(cur_ptr, 0) = cur_arg;
+        break;
+      case FFI_TYPE_DOUBLE:
+        STACK_ALLOC(cur_ptr, 8, 8);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        DEREF_F64(cur_ptr, 0) = cur_arg;
+        break;
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+        STACK_ALLOC(cur_ptr, 8, 8);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        #if WASM_BIGINT
+        DEREF_U64(cur_ptr, 0) = cur_arg;
+        #else
+        // Bigint arg was split by legalizer adaptor
+        DEREF_U32(cur_ptr, 0) = cur_arg;
+        cur_arg = args[jsarg_idx++];
+        DEREF_U32(cur_ptr, 1) = cur_arg;
+        #endif
+        break;
+      case FFI_TYPE_LONGDOUBLE:
+        STACK_ALLOC(cur_ptr, 16, 8);
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+        #if WASM_BIGINT
+        DEREF_U64(cur_ptr, 0) = cur_arg;
+        cur_arg = args[jsarg_idx++];
+        DEREF_U64(cur_ptr, 1) = cur_arg;
+        #else
+        // Was split by legalizer adaptor
+        DEREF_U32(cur_ptr, 0) = cur_arg;
+        cur_arg = args[jsarg_idx++];
+        DEREF_U32(cur_ptr, 1) = cur_arg;
+        cur_arg = args[jsarg_idx++];
+        DEREF_U32(cur_ptr, 2) = cur_arg;
+        cur_arg = args[jsarg_idx++];
+        DEREF_U32(cur_ptr, 3) = cur_arg;
+        #endif
+        break;
+      }
+    }
+    // If its a varargs call, last js argument is a pointer to the varargs.
+    var varargs = args[args.length - 1];
+    // We have no way of knowing how many varargs were actually provided, this
+    // fills the rest of the stack space allocated with nonsense. The onward
+    // call will know to ignore the nonsense.
+
+    // We either have a pointer to the argument if the argument is not a struct
+    // or a pointer to pointer to struct. We need to store a pointer to the
+    // argument into args_ptr[i]
+    for (; carg_idx < nargs; carg_idx++) {
+      var arg_type_id = unboxed_arg_type_id_list[carg_idx];
+      var arg_type_info = unboxed_arg_type_info_list[carg_idx];
+      var arg_size = arg_type_info[0];
+      var arg_align = arg_type_info[1];
+      if (arg_type_id === FFI_TYPE_STRUCT) {
+        // In this case varargs is a pointer to pointer to struct so we need to
+        // deref once
+        var struct_ptr = DEREF_U32(varargs, 0);
+        STACK_ALLOC(cur_ptr, arg_size, arg_align);
+        HEAP8.subarray(cur_ptr, cur_ptr + arg_size).set(HEAP8.subarray(struct_ptr, struct_ptr + arg_size));
+        DEREF_U32(args_ptr, carg_idx) = cur_ptr;
+      } else {
+        DEREF_U32(args_ptr, carg_idx) = varargs;
+      }
+      varargs += 4;
+    }
+    stackRestore(cur_ptr);
+    stackAlloc(0); // stackAlloc enforces alignment invariants on the stack pointer
+    LOG_DEBUG("CALL_CLOSURE",  "closure:", closure, "fptr", CLOSURE__fun(closure), "cif",  CLOSURE__cif(closure));
+    getWasmTableEntry(CLOSURE__fun(closure))(
+        CLOSURE__cif(closure), ret_ptr, args_ptr,
+        CLOSURE__user_data(closure)
+    );
+    stackRestore(orig_stack_ptr);
+
+    // If we aren't supposed to return by argument, figure out what to return.
+    if (!ret_by_arg) {
+      switch (sig[0]) {
+      case "i":
+        return DEREF_U32(ret_ptr, 0);
+      case "j":
+        #if WASM_BIGINT
+        return DEREF_U64(ret_ptr, 0);
+        #else
+        // Split the return i64, set the upper 32 bits into tempRet0 and return
+        // the lower 32 bits.
+        setTempRet0(DEREF_U32(ret_ptr, 1));
+        return DEREF_U32(ret_ptr, 0);
+        #endif
+      case "d":
+        return DEREF_F64(ret_ptr, 0);
+      case "f":
+        return DEREF_F32(ret_ptr, 0);
+      }
+    }
+  }
+  try {
+    var wasm_trampoline = JS_FUNCTION_TO_WASM(trampoline, sig);
+  } catch(e) {
+    return FFI_BAD_TYPEDEF_MACRO;
+  }
+  setWasmTableEntry(codeloc, wasm_trampoline);
+  CLOSURE__cif(closure) = cif;
+  CLOSURE__fun(closure) = fun;
+  CLOSURE__user_data(closure) = user_data;
+  return FFI_OK_MACRO;
+})
+
+// EM_JS does not correctly handle function pointer arguments, so we need a
+// helper
+ffi_status ffi_prep_closure_loc(ffi_closure *closure, ffi_cif *cif,
+                                void (*fun)(ffi_cif *, void *, void **, void *),
+                                void *user_data, void *codeloc) {
+  if (cif->abi != FFI_WASM32_EMSCRIPTEN)
+    return FFI_BAD_ABI;
+  return ffi_prep_closure_loc_js(closure, cif, (void *)fun, user_data,
+                                     codeloc);
+}
Index: libffi-3.4.6/src/wasm32/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/wasm32/ffitarget.h b/libffi-3.4.6/src/wasm32/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/wasm32/ffitarget.h	
@@ -0,0 +1,62 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2018-2023  Hood Chatham, Brion Vibber, Kleis Auke Wolthuizen, and others.
+
+   Target configuration macros for wasm32.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+// TODO: https://github.com/emscripten-core/emscripten/issues/9868
+typedef void (*ffi_fp)(void);
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_WASM32, // "raw", no structures, varargs, or closures (not implemented!)
+  FFI_WASM32_EMSCRIPTEN, // structures, varargs, and split 64-bit params
+  FFI_LAST_ABI,
+#ifdef __EMSCRIPTEN__
+  FFI_DEFAULT_ABI = FFI_WASM32_EMSCRIPTEN
+#else
+  FFI_DEFAULT_ABI = FFI_WASM32
+#endif
+} ffi_abi;
+
+#define FFI_CLOSURES 1
+// #define FFI_GO_CLOSURES 0
+#define FFI_TRAMPOLINE_SIZE 4
+// #define FFI_NATIVE_RAW_API 0
+#define FFI_TARGET_SPECIFIC_VARIADIC 1
+#define FFI_EXTRA_CIF_FIELDS  unsigned int nfixedargs
+
+#endif
Index: libffi-3.4.6/src/xtensa/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/xtensa/ffi.c b/libffi-3.4.6/src/xtensa/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/xtensa/ffi.c	
@@ -0,0 +1,306 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2013 Tensilica, Inc.
+
+   XTENSA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+/*
+                                 |----------------------------------------|
+                                 |                                        |
+    on entry to ffi_call ---->   |----------------------------------------|
+                                 | caller stack frame for registers a0-a3 |
+                                 |----------------------------------------|
+                                 |                                        |
+                                 |         additional arguments           |
+    entry of the function --->   |----------------------------------------|
+                                 |    copy of function arguments a2-a7    |
+                                 | -  -  -  -  -  -  -  -  -  -  -  -  -  |
+                                 |                                        |
+
+    The area below the entry line becomes the new stack frame for the function.
+
+*/
+
+
+#define FFI_TYPE_STRUCT_REGS FFI_TYPE_LAST
+
+
+extern void ffi_call_SYSV(void *rvalue, unsigned rsize, unsigned flags,
+			  void(*fn)(void), unsigned nbytes, extended_cif*);
+extern void ffi_closure_SYSV(void) FFI_HIDDEN;
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  switch(cif->rtype->type) {
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT16:
+      cif->flags = cif->rtype->type;
+      break;
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+      cif->flags = FFI_TYPE_UINT32;
+      break;
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      cif->flags = FFI_TYPE_UINT64; // cif->rtype->type;
+      break;
+    case FFI_TYPE_STRUCT:
+      cif->flags = FFI_TYPE_STRUCT; //_REGS;
+      /* Up to 16 bytes are returned in registers */
+      if (cif->rtype->size > 4 * 4) {
+        /* returned structure is referenced by a register; use 8 bytes
+           (including 4 bytes for potential additional alignment) */
+        cif->flags = FFI_TYPE_STRUCT;	
+        cif->bytes += 8;
+      }
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_UINT32;
+      break;
+  }
+
+  /* Round up stack size needed for arguments.
+     Allocate FFI_REGISTER_ARGS_SPACE bytes when there are only arguments
+     passed in registers, round space reserved for arguments passed on stack
+     up to ABI-specified alignment.  */
+  if (cif->bytes < FFI_REGISTER_NARGS * 4)
+    cif->bytes = FFI_REGISTER_ARGS_SPACE;
+  else
+    cif->bytes = FFI_REGISTER_ARGS_SPACE +
+	    FFI_ALIGN(cif->bytes - FFI_REGISTER_NARGS * 4,
+		      XTENSA_STACK_ALIGNMENT);
+  return FFI_OK;
+}
+
+void ffi_prep_args(extended_cif *ecif, unsigned char* stack)
+{
+  unsigned int i;
+  unsigned long *addr;
+  ffi_type **ptr;
+
+  union {
+    void **v;
+    char **c;
+    signed char **sc;
+    unsigned char **uc;
+    signed short **ss;
+    unsigned short **us;
+    unsigned int **i;
+    long long **ll;
+    float **f;
+    double **d;
+  } p_argv;
+
+  /* Verify that everything is aligned up properly */
+  FFI_ASSERT (((unsigned long) stack & 0x7) == 0);
+
+  p_argv.v = ecif->avalue;
+  addr = (unsigned long*)stack;
+
+  /* structures with a size greater than 16 bytes are passed in memory */
+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT && ecif->cif->rtype->size > 16)
+  {
+    *addr++ = (unsigned long)ecif->rvalue;
+  }
+
+  for (i = ecif->cif->nargs, ptr = ecif->cif->arg_types;
+       i > 0;
+       i--, ptr++, p_argv.v++)
+  {
+    switch ((*ptr)->type)
+    {
+      case FFI_TYPE_SINT8:
+        *addr++ = **p_argv.sc;
+        break;
+      case FFI_TYPE_UINT8:
+        *addr++ = **p_argv.uc;
+        break;
+      case FFI_TYPE_SINT16:
+        *addr++ = **p_argv.ss;
+        break;
+      case FFI_TYPE_UINT16:
+        *addr++ = **p_argv.us;
+        break;
+      case FFI_TYPE_FLOAT:
+      case FFI_TYPE_INT:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_POINTER:
+        *addr++ = **p_argv.i;
+        break;
+      case FFI_TYPE_DOUBLE:
+      case FFI_TYPE_UINT64:
+      case FFI_TYPE_SINT64:
+        if (((unsigned long)addr & 4) != 0)
+          addr++;
+        *(unsigned long long*)addr = **p_argv.ll;
+	addr += sizeof(unsigned long long) / sizeof (addr);
+        break;
+
+      case FFI_TYPE_STRUCT:
+      {
+        unsigned long offs;
+        unsigned long size;
+
+        if (((unsigned long)addr & 4) != 0 && (*ptr)->alignment > 4)
+          addr++;
+
+        offs = (unsigned long) addr - (unsigned long) stack;
+        size = (*ptr)->size;
+
+        /* Entire structure must fit the argument registers or referenced */
+        if (offs < FFI_REGISTER_NARGS * 4
+            && offs + size > FFI_REGISTER_NARGS * 4)
+          addr = (unsigned long*) (stack + FFI_REGISTER_NARGS * 4);
+
+        memcpy((char*) addr, *p_argv.c, size);
+        addr += (size + 3) / 4;
+        break;
+      }
+
+      default:
+        FFI_ASSERT(0);
+    }
+  }
+}
+
+
+void ffi_call(ffi_cif* cif, void(*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+  unsigned long rsize = cif->rtype->size;
+  int flags = cif->flags;
+  void *alloc = NULL;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* Note that for structures that are returned in registers (size <= 16 bytes)
+     we allocate a temporary buffer and use memcpy to copy it to the final 
+     destination. The reason is that the target address might be misaligned or
+     the length not a multiple of 4 bytes. Handling all those cases would be
+     very complex.  */
+
+  if (flags == FFI_TYPE_STRUCT && (rsize <= 16 || rvalue == NULL))
+  {
+    alloc = alloca(FFI_ALIGN(rsize, 4));
+    ecif.rvalue = alloc;
+  }
+  else
+  {
+    ecif.rvalue = rvalue;
+  }
+
+  if (cif->abi != FFI_SYSV)
+    FFI_ASSERT(0);
+
+  ffi_call_SYSV (ecif.rvalue, rsize, cif->flags, fn, cif->bytes, &ecif);
+
+  if (alloc != NULL && rvalue != NULL)
+    memcpy(rvalue, alloc, rsize);
+}
+
+extern void ffi_trampoline();
+extern void ffi_cacheflush(void* start, void* end);
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*, void*, void**, void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  /* copye trampoline to stack and patch 'ffi_closure_SYSV' pointer */
+  memcpy(closure->tramp, ffi_trampoline, FFI_TRAMPOLINE_SIZE);
+  *(unsigned int*)(&closure->tramp[8]) = (unsigned int)ffi_closure_SYSV;
+
+  // Do we have this function?
+  // __builtin___clear_cache(closer->tramp, closer->tramp + FFI_TRAMPOLINE_SIZE)
+  ffi_cacheflush(closure->tramp, closure->tramp + FFI_TRAMPOLINE_SIZE);
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+  return FFI_OK; 
+}
+
+
+long FFI_HIDDEN
+ffi_closure_SYSV_inner(ffi_closure *closure, void **values, void *rvalue)
+{
+  ffi_cif *cif;
+  ffi_type **arg_types;
+  void **avalue;
+  int i, areg;
+
+  cif = closure->cif;
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  areg = 0;
+
+  int rtype = cif->rtype->type;
+  if (rtype == FFI_TYPE_STRUCT && cif->rtype->size > 4 * 4)
+  {
+    rvalue = *values;
+    areg++;
+  }
+
+  cif = closure->cif; 
+  arg_types = cif->arg_types;
+  avalue = alloca(cif->nargs * sizeof(void *));
+
+  for (i = 0; i < cif->nargs; i++)
+  {
+    if (arg_types[i]->alignment == 8 && (areg & 1) != 0)
+      areg++;
+
+    // skip the entry a1, * framework, see ffi_trampoline
+    if (areg == FFI_REGISTER_NARGS)
+      areg = (FFI_REGISTER_ARGS_SPACE + 32) / 4;
+
+    if (arg_types[i]->type == FFI_TYPE_STRUCT)
+    {
+      int numregs = ((arg_types[i]->size + 3) & ~3) / 4;
+      if (areg < FFI_REGISTER_NARGS && areg + numregs > FFI_REGISTER_NARGS)
+        areg = (FFI_REGISTER_ARGS_SPACE + 32) / 4;
+    }
+
+    avalue[i] = &values[areg];
+    areg += (arg_types[i]->size + 3) / 4;
+  }
+
+  (closure->fun)(cif, rvalue, avalue, closure->user_data);
+
+  return rtype;
+}
Index: libffi-3.4.6/src/xtensa/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/xtensa/sysv.S b/libffi-3.4.6/src/xtensa/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/xtensa/sysv.S	
@@ -0,0 +1,268 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2013 Tensilica, Inc.
+   
+   XTENSA Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define ENTRY(name) .text; .globl name; .type  name,@function; .align 4; name:
+#define END(name) .size name , . - name
+
+/* Assert that the table below is in sync with ffi.h.  */
+
+#if	   FFI_TYPE_UINT8 != 5          \
+        || FFI_TYPE_SINT8 != 6          \
+        || FFI_TYPE_UINT16 != 7         \
+        || FFI_TYPE_SINT16 != 8         \
+        || FFI_TYPE_UINT32 != 9         \
+        || FFI_TYPE_SINT32 != 10        \
+        || FFI_TYPE_UINT64 != 11
+#error "xtensa/sysv.S out of sync with ffi.h"
+#endif
+
+#define FFI_REGISTER_ARGS_OFFSET ((XTENSA_STACK_ALIGNMENT - \
+				   FFI_REGISTER_NARGS * 4) & \
+				   (XTENSA_STACK_ALIGNMENT - 1))
+
+/* ffi_call_SYSV (rvalue, rbytes, flags, (*fnaddr)(), bytes, ecif)
+      void *rvalue;            a2
+      unsigned long rbytes;    a3
+      unsigned flags;          a4
+      void (*fnaddr)();        a5
+      unsigned long bytes;     a6
+      extended_cif* ecif)      a7
+*/
+
+ENTRY(ffi_call_SYSV)
+
+	entry	a1, 32              # 32 byte frame for using call8 below
+
+	mov	a10, a7             # a10(->arg0): ecif
+	sub	a11, a1, a6         # a11(->arg1): stack pointer
+	mov	a7, a1              # fp
+	movsp	a1, a11             # set new sp = old_sp - bytes
+
+	# align ffi_prep_args stack argument so that arguments
+	# passed on stack if any start on 16-byte aligned boundary
+
+	addi	a11, a11, FFI_REGISTER_ARGS_OFFSET
+
+	movi	a8, ffi_prep_args
+	callx8	a8                  # ffi_prep_args(ecif, stack)
+
+	# prepare to move stack pointer back
+	# to point to arguments passed on stack
+
+	addi	a6, a1, FFI_REGISTER_ARGS_SPACE
+	
+	# we can pass up to 6 arguments in registers
+	# for simplicity, just load 6 arguments
+
+	l32i	a10, a1, FFI_REGISTER_ARGS_OFFSET + 0
+	l32i	a11, a1, FFI_REGISTER_ARGS_OFFSET + 4
+	l32i	a12, a1, FFI_REGISTER_ARGS_OFFSET + 8
+	l32i	a13, a1, FFI_REGISTER_ARGS_OFFSET + 12
+	l32i	a14, a1, FFI_REGISTER_ARGS_OFFSET + 16
+	l32i	a15, a1, FFI_REGISTER_ARGS_OFFSET + 20
+
+	# move stack pointer
+
+	movsp	a1, a6
+
+	callx8	a5                  # (*fn)(args...)
+
+	# Handle return value(s)
+
+	beqz	a2, .Lexit
+
+	movi	a5, FFI_TYPE_STRUCT
+	bne	a4, a5, .Lstore
+	movi	a5, 16
+	blt	a5, a3, .Lexit
+
+	s32i	a10, a2, 0
+	blti	a3, 5, .Lexit
+	addi	a3, a3, -1
+	s32i	a11, a2, 4
+	blti	a3, 8, .Lexit
+	s32i	a12, a2, 8
+	blti	a3, 12, .Lexit
+	s32i	a13, a2, 12
+
+.Lexit:	retw
+
+.Lstore:
+	addi	a4, a4, -FFI_TYPE_UINT8
+	bgei	a4, 7, .Lexit	# should never happen
+	movi	a6, store_calls
+	add	a4, a4, a4
+	addx4	a6, a4, a6	# store_table + idx * 8
+	jx	a6
+
+	.align	8
+store_calls:
+	# UINT8
+	s8i	a10, a2, 0
+	retw
+
+	# SINT8
+	.align	8
+	s8i	a10, a2, 0
+	retw
+
+	# UINT16
+	.align	8
+	s16i	a10, a2, 0
+	retw
+
+	# SINT16
+	.align	8
+	s16i	a10, a2, 0
+	retw
+
+	# UINT32
+	.align	8
+	s32i	a10, a2, 0
+	retw
+
+	# SINT32
+	.align	8
+	s32i	a10, a2, 0
+	retw
+
+	# UINT64
+	.align	8
+	s32i	a10, a2, 0
+	s32i	a11, a2, 4
+	retw
+
+END(ffi_call_SYSV)
+
+
+/*
+ * void ffi_cacheflush (unsigned long start, unsigned long end)
+ */
+
+#define EXTRA_ARGS_SIZE	24
+
+ENTRY(ffi_cacheflush)
+
+	entry	a1, 32
+
+1:	
+#if XCHAL_DCACHE_SIZE
+	dhwbi	a2, 0
+#endif
+#if XCHAL_ICACHE_SIZE
+	ihi	a2, 0
+#endif
+	addi	a2, a2, 4
+	blt	a2, a3, 1b
+
+	retw
+
+END(ffi_cacheflush)
+
+/* ffi_trampoline is copied to the stack */
+
+ENTRY(ffi_trampoline)
+
+	/* 32 bytes for spill + spill overflow area of a frame that uses
+	   call8,
+	   FFI_REGISTER_NARGS * 4 bytes for arguments passed in registers,
+	   aligned up to 4 to maintain 16 byte stack alignment,
+	   4 * 4 bytes for the result.
+	   This size must be in sync with ffi_closure_SYSV_inner logic.
+	 */
+	entry	a1, 32 + FFI_REGISTER_ARGS_SPACE + (4 * 4)   # [ 0]
+	j	2f                                # [ 3]
+	.align	4                                 # [ 6]
+1:	.long	0                                 # [ 8]
+2:	l32r	a15, 1b                           # [12]
+	_mov 	a14, a0                           # [15]
+	callx0	a15                               # [18]
+                                                  # [21]
+END(ffi_trampoline)
+
+/*
+ * ffi_closure()
+ *
+ * a0:  closure + 21
+ * a14: return address (a0)
+ */
+
+ENTRY(ffi_closure_SYSV)
+
+	/* intentionally omitting entry here */
+
+	# restore return address (a0) and move pointer to closure to a10
+	addi	a10, a0, -21
+	mov	a0, a14
+
+	# allow up to 4 arguments as return values
+	addi	a11, a1, 4 * 4
+
+	# save up to 6 arguments to stack (allocated by entry below)
+	s32i	a2, a11,  0
+	s32i	a3, a11,  4
+	s32i	a4, a11,  8
+	s32i	a5, a11, 12
+	s32i	a6, a11, 16
+	s32i	a7, a11, 20
+
+	movi	a8, ffi_closure_SYSV_inner
+	mov	a12, a1
+	callx8	a8			# .._inner(*closure, **avalue, *rvalue)
+
+	# load up to four return arguments
+	l32i	a2, a1,  0
+	l32i	a3, a1,  4
+	l32i	a4, a1,  8
+	l32i	a5, a1, 12
+
+	# (sign-)extend return value
+	movi	a11, FFI_TYPE_UINT8
+	bne	a10, a11, 1f
+	extui	a2, a2, 0, 8
+	retw
+
+1:	movi	a11, FFI_TYPE_SINT8
+	bne	a10, a11, 1f
+	sext	a2, a2, 7
+	retw
+
+1:	movi	a11, FFI_TYPE_UINT16
+	bne	a10, a11, 1f
+	extui	a2, a2, 0, 16
+	retw
+
+1:	movi	a11, FFI_TYPE_SINT16
+	bne	a10, a11, 1f
+	sext	a2, a2, 15
+
+1:	retw
+
+END(ffi_closure_SYSV)
Index: libffi-3.4.6/src/xtensa/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/xtensa/ffitarget.h b/libffi-3.4.6/src/xtensa/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/xtensa/ffitarget.h	
@@ -0,0 +1,57 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2013 Tensilica, Inc.
+   Target configuration macros for XTENSA.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long	ffi_arg;
+typedef signed long	ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+#define FFI_REGISTER_NARGS	6
+#define XTENSA_STACK_ALIGNMENT	16
+#define FFI_REGISTER_ARGS_SPACE ((FFI_REGISTER_NARGS * 4 + \
+				  XTENSA_STACK_ALIGNMENT - 1) & \
+				  -XTENSA_STACK_ALIGNMENT)
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+#define FFI_TRAMPOLINE_SIZE 24
+
+#endif
Index: libffi-3.4.6/src/aarch64/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/aarch64/ffi.c b/libffi-3.4.6/src/aarch64/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/aarch64/ffi.c	
@@ -0,0 +1,1142 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#if defined(__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_common.h>
+#include "internal.h"
+#ifdef _WIN32
+#include <windows.h> /* FlushInstructionCache */
+#endif
+#include <tramp.h>
+
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 128-bit type.  */
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+union _d
+{
+  UINT64 d;
+  UINT32 s[2];
+};
+
+struct _v
+{
+  union _d d[2] __attribute__((aligned(16)));
+};
+
+struct call_context
+{
+  struct _v v[N_V_ARG_REG];
+  UINT64 x[N_X_ARG_REG];
+};
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#ifdef HAVE_PTRAUTH
+#include <ptrauth.h>
+#endif
+#include <mach/vm_param.h>
+#endif
+
+#else
+
+#if defined (__clang__) && defined (__APPLE__)
+extern void sys_icache_invalidate (void *start, size_t len);
+#endif
+
+static inline void
+ffi_clear_cache (void *start, void *end)
+{
+#if defined (__clang__) && defined (__APPLE__)
+  sys_icache_invalidate (start, (char *)end - (char *)start);
+#elif defined (__GNUC__)
+  __builtin___clear_cache (start, end);
+#elif defined (_WIN32)
+  FlushInstructionCache(GetCurrentProcess(), start, (char*)end - (char*)start);
+#else
+#error "Missing builtin to flush instruction cache"
+#endif
+}
+
+#endif
+
+/* A subroutine of is_vfp_type.  Given a structure type, return the type code
+   of the first non-structure element.  Recurse for structure elements.
+   Return -1 if the structure is in fact empty, i.e. no nested elements.  */
+
+static int
+is_hfa0 (const ffi_type *ty)
+{
+  ffi_type **elements = ty->elements;
+  int i, ret = -1;
+
+  if (elements != NULL)
+    for (i = 0; elements[i]; ++i)
+      {
+        ret = elements[i]->type;
+        if (ret == FFI_TYPE_STRUCT || ret == FFI_TYPE_COMPLEX)
+          {
+            ret = is_hfa0 (elements[i]);
+            if (ret < 0)
+              continue;
+          }
+        break;
+      }
+
+  return ret;
+}
+
+/* A subroutine of is_vfp_type.  Given a structure type, return true if all
+   of the non-structure elements are the same as CANDIDATE.  */
+
+static int
+is_hfa1 (const ffi_type *ty, int candidate)
+{
+  ffi_type **elements = ty->elements;
+  int i;
+
+  if (elements != NULL)
+    for (i = 0; elements[i]; ++i)
+      {
+        int t = elements[i]->type;
+        if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)
+          {
+            if (!is_hfa1 (elements[i], candidate))
+              return 0;
+          }
+        else if (t != candidate)
+          return 0;
+      }
+
+  return 1;
+}
+
+/* Determine if TY may be allocated to the FP registers.  This is both an
+   fp scalar type as well as an homogenous floating point aggregate (HFA).
+   That is, a structure consisting of 1 to 4 members of all the same type,
+   where that type is an fp scalar.
+
+   Returns non-zero iff TY is an HFA.  The result is the AARCH64_RET_*
+   constant for the type.  */
+
+static int
+is_vfp_type (const ffi_type *ty)
+{
+  ffi_type **elements;
+  int candidate, i;
+  size_t size, ele_count;
+
+  /* Quickest tests first.  */
+  candidate = ty->type;
+  switch (candidate)
+    {
+    default:
+      return 0;
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_LONGDOUBLE:
+      ele_count = 1;
+      goto done;
+    case FFI_TYPE_COMPLEX:
+      candidate = ty->elements[0]->type;
+      switch (candidate)
+	{
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	  ele_count = 2;
+	  goto done;
+	}
+      return 0;
+    case FFI_TYPE_STRUCT:
+      break;
+    }
+
+  /* No HFA types are smaller than 4 bytes, or larger than 64 bytes.  */
+  size = ty->size;
+  if (size < 4 || size > 64)
+    return 0;
+
+  /* Find the type of the first non-structure member.  */
+  elements = ty->elements;
+  candidate = elements[0]->type;
+  if (candidate == FFI_TYPE_STRUCT || candidate == FFI_TYPE_COMPLEX)
+    {
+      for (i = 0; ; ++i)
+        {
+          candidate = is_hfa0 (elements[i]);
+          if (candidate >= 0)
+            break;
+        }
+    }
+
+  /* If the first member is not a floating point type, it's not an HFA.
+     Also quickly re-check the size of the structure.  */
+  switch (candidate)
+    {
+    case FFI_TYPE_FLOAT:
+      ele_count = size / sizeof(float);
+      if (size != ele_count * sizeof(float))
+        return 0;
+      break;
+    case FFI_TYPE_DOUBLE:
+      ele_count = size / sizeof(double);
+      if (size != ele_count * sizeof(double))
+        return 0;
+      break;
+    case FFI_TYPE_LONGDOUBLE:
+      ele_count = size / sizeof(long double);
+      if (size != ele_count * sizeof(long double))
+        return 0;
+      break;
+    default:
+      return 0;
+    }
+  if (ele_count > 4)
+    return 0;
+
+  /* Finally, make sure that all scalar elements are the same type.  */
+  for (i = 0; elements[i]; ++i)
+    {
+      int t = elements[i]->type;
+      if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)
+        {
+          if (!is_hfa1 (elements[i], candidate))
+            return 0;
+        }
+      else if (t != candidate)
+        return 0;
+    }
+
+  /* All tests succeeded.  Encode the result.  */
+ done:
+  return candidate * 4 + (4 - (int)ele_count);
+}
+
+/* Representation of the procedure call argument marshalling
+   state.
+
+   The terse state variable names match the names used in the AARCH64
+   PCS.
+
+   The struct area is allocated downwards from the top of the argument
+   area.  It is used to hold copies of structures passed by value that are
+   bigger than 16 bytes.  */
+
+struct arg_state
+{
+  unsigned ngrn;                /* Next general-purpose register number. */
+  unsigned nsrn;                /* Next vector register number. */
+  size_t nsaa;                  /* Next stack offset. */
+  size_t next_struct_area;	/* Place to allocate big structs. */
+
+#if defined (__APPLE__)
+  unsigned allocating_variadic;
+#endif
+};
+
+/* Initialize a procedure call argument marshalling state.  */
+static void
+arg_init (struct arg_state *state, size_t size)
+{
+  state->ngrn = 0;
+  state->nsrn = 0;
+  state->nsaa = 0;
+  state->next_struct_area = size;
+#if defined (__APPLE__)
+  state->allocating_variadic = 0;
+#endif
+}
+
+/* Allocate an aligned slot on the stack and return a pointer to it.  */
+static void *
+allocate_to_stack (struct arg_state *state, void *stack,
+		   size_t alignment, size_t size)
+{
+  size_t nsaa = state->nsaa;
+
+  /* Round up the NSAA to the larger of 8 or the natural
+     alignment of the argument's type.  */
+#if defined (__APPLE__)
+  if (state->allocating_variadic && alignment < 8)
+    alignment = 8;
+#else
+  if (alignment < 8)
+    alignment = 8;
+#endif
+
+  nsaa = FFI_ALIGN (nsaa, alignment);
+  state->nsaa = nsaa + size;
+
+  return (char *)stack + nsaa;
+}
+
+/* Allocate and copy a structure that is passed by value on the stack and
+   return a pointer to it.  */
+static void *
+allocate_and_copy_struct_to_stack (struct arg_state *state, void *stack,
+				   size_t alignment, size_t size, void *value)
+{
+  size_t dest = state->next_struct_area - size;
+
+  /* Round down to the natural alignment of the value.  */
+  dest = FFI_ALIGN_DOWN (dest, alignment);
+  state->next_struct_area = dest;
+
+  return memcpy ((char *) stack + dest, value, size);
+}
+
+static ffi_arg
+extend_integer_type (void *source, int type)
+{
+  switch (type)
+    {
+    case FFI_TYPE_UINT8:
+      {
+        UINT8 u8;
+        memcpy (&u8, source, sizeof (u8));
+        return u8;
+      }
+    case FFI_TYPE_SINT8:
+      {
+        SINT8 s8;
+        memcpy (&s8, source, sizeof (s8));
+        return s8;
+      }
+    case FFI_TYPE_UINT16:
+      {
+        UINT16 u16;
+        memcpy (&u16, source, sizeof (u16));
+        return u16;
+      }
+    case FFI_TYPE_SINT16:
+      {
+        SINT16 s16;
+        memcpy (&s16, source, sizeof (s16));
+        return s16;
+      }
+    case FFI_TYPE_UINT32:
+      {
+        UINT32 u32;
+        memcpy (&u32, source, sizeof (u32));
+        return u32;
+      }
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      {
+        SINT32 s32;
+        memcpy (&s32, source, sizeof (s32));
+        return s32;
+      }
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      {
+        UINT64 u64;
+        memcpy (&u64, source, sizeof (u64));
+        return u64;
+      }
+    case FFI_TYPE_POINTER:
+      {
+        uintptr_t uptr;
+        memcpy (&uptr, source, sizeof (uptr));
+        return uptr;
+      }
+    default:
+      abort();
+    }
+}
+
+#if defined(_MSC_VER)
+void extend_hfa_type (void *dest, void *src, int h);
+#else
+static void
+extend_hfa_type (void *dest, void *src, int h)
+{
+  ssize_t f = h - AARCH64_RET_S4;
+  void *x0;
+
+#define BTI_J "hint #36"
+  asm volatile (
+	"adr	%0, 0f\n"
+"	add	%0, %0, %1\n"
+"	br	%0\n"
+"0:	"BTI_J"\n"			/* S4 */
+"	ldp	s16, s17, [%3]\n"
+"	ldp	s18, s19, [%3, #8]\n"
+"	b	4f\n"
+"	"BTI_J"\n"			/* S3 */
+"	ldp	s16, s17, [%3]\n"
+"	ldr	s18, [%3, #8]\n"
+"	b	3f\n"
+"	"BTI_J"\n"			/* S2 */
+"	ldp	s16, s17, [%3]\n"
+"	b	2f\n"
+"	nop\n"
+"	"BTI_J"\n"			/* S1 */
+"	ldr	s16, [%3]\n"
+"	b	1f\n"
+"	nop\n"
+"	"BTI_J"\n"			/* D4 */
+"	ldp	d16, d17, [%3]\n"
+"	ldp	d18, d19, [%3, #16]\n"
+"	b	4f\n"
+"	"BTI_J"\n"			/* D3 */
+"	ldp	d16, d17, [%3]\n"
+"	ldr	d18, [%3, #16]\n"
+"	b	3f\n"
+"	"BTI_J"\n"			/* D2 */
+"	ldp	d16, d17, [%3]\n"
+"	b	2f\n"
+"	nop\n"
+"	"BTI_J"\n"			/* D1 */
+"	ldr	d16, [%3]\n"
+"	b	1f\n"
+"	nop\n"
+"	"BTI_J"\n"			/* Q4 */
+"	ldp	q16, q17, [%3]\n"
+"	ldp	q18, q19, [%3, #32]\n"
+"	b	4f\n"
+"	"BTI_J"\n"			/* Q3 */
+"	ldp	q16, q17, [%3]\n"
+"	ldr	q18, [%3, #32]\n"
+"	b	3f\n"
+"	"BTI_J"\n"			/* Q2 */
+"	ldp	q16, q17, [%3]\n"
+"	b	2f\n"
+"	nop\n"
+"	"BTI_J"\n"			/* Q1 */
+"	ldr	q16, [%3]\n"
+"	b	1f\n"
+"4:	str	q19, [%2, #48]\n"
+"3:	str	q18, [%2, #32]\n"
+"2:	str	q17, [%2, #16]\n"
+"1:	str	q16, [%2]"
+    : "=&r"(x0)
+    : "r"(f * 16), "r"(dest), "r"(src)
+    : "memory", "v16", "v17", "v18", "v19");
+}
+#endif
+
+#if defined(_MSC_VER)
+void* compress_hfa_type (void *dest, void *src, int h);
+#else
+static void *
+compress_hfa_type (void *dest, void *reg, int h)
+{
+  switch (h)
+    {
+    case AARCH64_RET_S1:
+      if (dest == reg)
+	{
+#ifdef __AARCH64EB__
+	  dest += 12;
+#endif
+	}
+      else
+	*(float *)dest = *(float *)reg;
+      break;
+    case AARCH64_RET_S2:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "st2 { v16.s, v17.s }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17");
+      break;
+    case AARCH64_RET_S3:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "ldr q18, [%1, #32]\n\t"
+	   "st3 { v16.s, v17.s, v18.s }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17", "v18");
+      break;
+    case AARCH64_RET_S4:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "ldp q18, q19, [%1, #32]\n\t"
+	   "st4 { v16.s, v17.s, v18.s, v19.s }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17", "v18", "v19");
+      break;
+
+    case AARCH64_RET_D1:
+      if (dest == reg)
+	{
+#ifdef __AARCH64EB__
+	  dest += 8;
+#endif
+	}
+      else
+	*(double *)dest = *(double *)reg;
+      break;
+    case AARCH64_RET_D2:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "st2 { v16.d, v17.d }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17");
+      break;
+    case AARCH64_RET_D3:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "ldr q18, [%1, #32]\n\t"
+	   "st3 { v16.d, v17.d, v18.d }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17", "v18");
+      break;
+    case AARCH64_RET_D4:
+      asm ("ldp q16, q17, [%1]\n\t"
+	   "ldp q18, q19, [%1, #32]\n\t"
+	   "st4 { v16.d, v17.d, v18.d, v19.d }[0], [%0]"
+	   : : "r"(dest), "r"(reg) : "memory", "v16", "v17", "v18", "v19");
+      break;
+
+    default:
+      if (dest != reg)
+	return memcpy (dest, reg, 16 * (4 - (h & 3)));
+      break;
+    }
+  return dest;
+}
+#endif
+
+/* Either allocate an appropriate register for the argument type, or if
+   none are available, allocate a stack slot and return a pointer
+   to the allocated space.  */
+
+static void *
+allocate_int_to_reg_or_stack (struct call_context *context,
+			      struct arg_state *state,
+			      void *stack, size_t size)
+{
+  if (state->ngrn < N_X_ARG_REG)
+    return &context->x[state->ngrn++];
+
+  state->ngrn = N_X_ARG_REG;
+  return allocate_to_stack (state, stack, size, size);
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  ffi_type *rtype = cif->rtype;
+  size_t bytes = cif->bytes;
+  int flags, i, n;
+
+  switch (rtype->type)
+    {
+    case FFI_TYPE_VOID:
+      flags = AARCH64_RET_VOID;
+      break;
+    case FFI_TYPE_UINT8:
+      flags = AARCH64_RET_UINT8;
+      break;
+    case FFI_TYPE_UINT16:
+      flags = AARCH64_RET_UINT16;
+      break;
+    case FFI_TYPE_UINT32:
+      flags = AARCH64_RET_UINT32;
+      break;
+    case FFI_TYPE_SINT8:
+      flags = AARCH64_RET_SINT8;
+      break;
+    case FFI_TYPE_SINT16:
+      flags = AARCH64_RET_SINT16;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      flags = AARCH64_RET_SINT32;
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      flags = AARCH64_RET_INT64;
+      break;
+    case FFI_TYPE_POINTER:
+      flags = (sizeof(void *) == 4 ? AARCH64_RET_UINT32 : AARCH64_RET_INT64);
+      break;
+
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_LONGDOUBLE:
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_COMPLEX:
+      flags = is_vfp_type (rtype);
+      if (flags == 0)
+	{
+	  size_t s = rtype->size;
+	  if (s > 16)
+	    {
+	      flags = AARCH64_RET_VOID | AARCH64_RET_IN_MEM;
+	      bytes += 8;
+	    }
+	  else if (s == 16)
+	    flags = AARCH64_RET_INT128;
+	  else if (s == 8)
+	    flags = AARCH64_RET_INT64;
+	  else
+	    flags = AARCH64_RET_INT128 | AARCH64_RET_NEED_COPY;
+	}
+      break;
+
+    default:
+      abort();
+    }
+
+  for (i = 0, n = cif->nargs; i < n; i++)
+    if (is_vfp_type (cif->arg_types[i]))
+      {
+	flags |= AARCH64_FLAG_ARG_V;
+	break;
+      }
+
+  /* Round the stack up to a multiple of the stack alignment requirement. */
+  cif->bytes = (unsigned) FFI_ALIGN(bytes, 16);
+  cif->flags = flags;
+#if defined (__APPLE__)
+  cif->aarch64_nfixedargs = 0;
+#endif
+
+  return FFI_OK;
+}
+
+#if defined (__APPLE__)
+/* Perform Apple-specific cif processing for variadic calls */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,
+			 unsigned int ntotalargs)
+{
+  ffi_status status = ffi_prep_cif_machdep (cif);
+  cif->aarch64_nfixedargs = nfixedargs;
+  return status;
+}
+#else
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs)
+{
+  ffi_status status = ffi_prep_cif_machdep (cif);
+  cif->flags |= AARCH64_FLAG_VARARG;
+  return status;
+}
+#endif /* __APPLE__ */
+
+extern void ffi_call_SYSV (struct call_context *context, void *frame,
+			   void (*fn)(void), void *rvalue, int flags,
+			   void *closure) FFI_HIDDEN;
+
+/* Call a function with the provided arguments and capture the return
+   value.  */
+static void
+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,
+	      void **avalue, void *closure)
+{
+  struct call_context *context;
+  void *stack, *frame, *rvalue;
+  struct arg_state state;
+  size_t stack_bytes, rtype_size, rsize;
+  int i, nargs, flags, isvariadic = 0;
+  ffi_type *rtype;
+
+  flags = cif->flags;
+  rtype = cif->rtype;
+  rtype_size = rtype->size;
+  stack_bytes = cif->bytes;
+
+  if (flags & AARCH64_FLAG_VARARG)
+  {
+    isvariadic = 1;
+    flags &= ~AARCH64_FLAG_VARARG;
+  }
+
+  /* If the target function returns a structure via hidden pointer,
+     then we cannot allow a null rvalue.  Otherwise, mash a null
+     rvalue to void return type.  */
+  rsize = 0;
+  if (flags & AARCH64_RET_IN_MEM)
+    {
+      if (orig_rvalue == NULL)
+	rsize = rtype_size;
+    }
+  else if (orig_rvalue == NULL)
+    flags &= AARCH64_FLAG_ARG_V;
+  else if (flags & AARCH64_RET_NEED_COPY)
+    rsize = 16;
+
+  /* Allocate consectutive stack for everything we'll need.
+     The frame uses 40 bytes for: lr, fp, rvalue, flags, sp */
+  context = alloca (sizeof(struct call_context) + stack_bytes + 40 + rsize);
+  stack = context + 1;
+  frame = (void*)((uintptr_t)stack + (uintptr_t)stack_bytes);
+  rvalue = (rsize ? (void*)((uintptr_t)frame + 40) : orig_rvalue);
+
+  arg_init (&state, stack_bytes);
+  for (i = 0, nargs = cif->nargs; i < nargs; i++)
+    {
+      ffi_type *ty = cif->arg_types[i];
+      size_t s = ty->size;
+      void *a = avalue[i];
+      int h, t;
+      void *dest;
+
+      t = ty->type;
+      switch (t)
+	{
+	case FFI_TYPE_VOID:
+	  FFI_ASSERT (0);
+	  break;
+
+	/* If the argument is a basic type the argument is allocated to an
+	   appropriate register, or if none are available, to the stack.  */
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_POINTER:
+	do_pointer:
+	  {
+	    ffi_arg ext = extend_integer_type (a, t);
+	    if (state.ngrn < N_X_ARG_REG)
+	      context->x[state.ngrn++] = ext;
+	    else
+	      {
+		void *d = allocate_to_stack (&state, stack, ty->alignment, s);
+		state.ngrn = N_X_ARG_REG;
+		/* Note that the default abi extends each argument
+		   to a full 64-bit slot, while the iOS abi allocates
+		   only enough space. */
+#ifdef __APPLE__
+		memcpy(d, a, s);
+#else
+		*(ffi_arg *)d = ext;
+#endif
+	      }
+	  }
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	case FFI_TYPE_STRUCT:
+	case FFI_TYPE_COMPLEX:
+	  {
+	    h = is_vfp_type (ty);
+	    if (h)
+	      {
+              int elems = 4 - (h & 3);
+              if (cif->abi == FFI_WIN64 && isvariadic)
+              {
+                if (state.ngrn + elems <= N_X_ARG_REG)
+                {
+                  dest = &context->x[state.ngrn];
+                  state.ngrn += elems;
+                  extend_hfa_type(dest, a, h);
+                  break;
+                }
+                state.nsrn = N_X_ARG_REG;
+                dest = allocate_to_stack(&state, stack, ty->alignment, s);
+              }
+              else
+              {
+                if (state.nsrn + elems <= N_V_ARG_REG)
+                {
+                  dest = &context->v[state.nsrn];
+                  state.nsrn += elems;
+                  extend_hfa_type (dest, a, h);
+                  break;
+                }
+                state.nsrn = N_V_ARG_REG;
+                dest = allocate_to_stack (&state, stack, ty->alignment, s);
+              }
+	      }
+	    else if (s > 16)
+	      {
+		/* If the argument is a composite type that is larger than 16
+		   bytes, then the argument is copied to memory, and
+		   the argument is replaced by a pointer to the copy.  */
+		dest = allocate_and_copy_struct_to_stack (&state, stack,
+							  ty->alignment, s,
+							  avalue[i]);
+		a = &dest;
+		t = FFI_TYPE_POINTER;
+		s = sizeof (void *);
+		goto do_pointer;
+	      }
+	    else
+	      {
+		size_t n = (s + 7) / 8;
+		if (state.ngrn + n <= N_X_ARG_REG)
+		  {
+		    /* If the argument is a composite type and the size in
+		       double-words is not more than the number of available
+		       X registers, then the argument is copied into
+		       consecutive X registers.  */
+		    dest = &context->x[state.ngrn];
+                    state.ngrn += (unsigned int)n;
+		  }
+		else
+		  {
+		    /* Otherwise, there are insufficient X registers. Further
+		       X register allocations are prevented, the NSAA is
+		       adjusted and the argument is copied to memory at the
+		       adjusted NSAA.  */
+		    state.ngrn = N_X_ARG_REG;
+		    dest = allocate_to_stack (&state, stack, ty->alignment, s);
+		  }
+		}
+	      memcpy (dest, a, s);
+	    }
+	  break;
+
+	default:
+	  abort();
+	}
+
+#if defined (__APPLE__)
+      if (i + 1 == cif->aarch64_nfixedargs)
+	{
+	  state.ngrn = N_X_ARG_REG;
+	  state.nsrn = N_V_ARG_REG;
+	  state.allocating_variadic = 1;
+	}
+#endif
+    }
+
+  ffi_call_SYSV (context, frame, fn, rvalue, flags, closure);
+
+  if (flags & AARCH64_RET_NEED_COPY)
+    memcpy (orig_rvalue, rvalue, rtype_size);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+#if FFI_CLOSURES
+
+#ifdef FFI_GO_CLOSURES
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+#endif /* FFI_GO_CLOSURES */
+
+/* Build a trampoline.  */
+
+extern void ffi_closure_SYSV (void) FFI_HIDDEN;
+extern void ffi_closure_SYSV_V (void) FFI_HIDDEN;
+#if defined(FFI_EXEC_STATIC_TRAMP)
+extern void ffi_closure_SYSV_alt (void) FFI_HIDDEN;
+extern void ffi_closure_SYSV_V_alt (void) FFI_HIDDEN;
+#endif
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)
+    return FFI_BAD_ABI;
+
+  void (*start)(void);
+
+  if (cif->flags & AARCH64_FLAG_ARG_V)
+    start = ffi_closure_SYSV_V;
+  else
+    start = ffi_closure_SYSV;
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+# ifdef __MACH__
+#  ifdef HAVE_PTRAUTH
+  codeloc = ptrauth_auth_data(codeloc, ptrauth_key_function_pointer, 0);
+#  endif
+  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);
+  config[0] = closure;
+  config[1] = start;
+# endif
+#else
+  static const unsigned char trampoline[16] = {
+    0x90, 0x00, 0x00, 0x58,	/* ldr	x16, tramp+16	*/
+    0xf1, 0xff, 0xff, 0x10,	/* adr	x17, tramp+0	*/
+    0x00, 0x02, 0x1f, 0xd6	/* br	x16		*/
+  };
+  char *tramp = closure->tramp;
+
+# if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      /* Initialize the static trampoline's parameters. */
+      if (start == ffi_closure_SYSV_V)
+          start = ffi_closure_SYSV_V_alt;
+      else
+          start = ffi_closure_SYSV_alt;
+      ffi_tramp_set_parms (closure->ftramp, start, closure);
+      goto out;
+    }
+# endif
+
+  /* Initialize the dynamic trampoline. */
+  memcpy (tramp, trampoline, sizeof(trampoline));
+
+  *(UINT64 *)(tramp + 16) = (uintptr_t)start;
+
+  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);
+
+  /* Also flush the cache for code mapping.  */
+# ifdef _WIN32
+  // Not using dlmalloc.c for Windows ARM64 builds
+  // so calling ffi_data_to_code_pointer() isn't necessary
+  unsigned char *tramp_code = tramp;
+# else
+  unsigned char *tramp_code = ffi_data_to_code_pointer (tramp);
+# endif
+  ffi_clear_cache (tramp_code, tramp_code + FFI_TRAMPOLINE_SIZE);
+# if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+# endif
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+#ifdef FFI_GO_CLOSURES
+extern void ffi_go_closure_SYSV (void) FFI_HIDDEN;
+extern void ffi_go_closure_SYSV_V (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif* cif,
+                     void (*fun)(ffi_cif*,void*,void**,void*))
+{
+  void (*start)(void);
+
+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)
+    return FFI_BAD_ABI;
+
+  if (cif->flags & AARCH64_FLAG_ARG_V)
+    start = ffi_go_closure_SYSV_V;
+  else
+    start = ffi_go_closure_SYSV;
+
+  closure->tramp = start;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+#endif /* FFI_GO_CLOSURES */
+
+/* Primary handler to setup and invoke a function within a closure.
+
+   A closure when invoked enters via the assembler wrapper
+   ffi_closure_SYSV(). The wrapper allocates a call context on the
+   stack, saves the interesting registers (from the perspective of
+   the calling convention) into the context then passes control to
+   ffi_closure_SYSV_inner() passing the saved context and a pointer to
+   the stack at the point ffi_closure_SYSV() was invoked.
+
+   On the return path the assembler wrapper will reload call context
+   registers.
+
+   ffi_closure_SYSV_inner() marshalls the call context into ffi value
+   descriptors, invokes the wrapped function, then marshalls the return
+   value back into the call context.  */
+
+int FFI_HIDDEN
+ffi_closure_SYSV_inner (ffi_cif *cif,
+			void (*fun)(ffi_cif*,void*,void**,void*),
+			void *user_data,
+			struct call_context *context,
+			void *stack, void *rvalue, void *struct_rvalue)
+{
+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
+  int i, h, nargs, flags, isvariadic = 0;
+  struct arg_state state;
+
+  arg_init (&state, cif->bytes);
+
+  flags = cif->flags;
+  if (flags & AARCH64_FLAG_VARARG)
+  {
+    isvariadic = 1;
+    flags &= ~AARCH64_FLAG_VARARG;
+  }
+
+  for (i = 0, nargs = cif->nargs; i < nargs; i++)
+    {
+      ffi_type *ty = cif->arg_types[i];
+      int t = ty->type;
+      size_t n, s = ty->size;
+
+      switch (t)
+	{
+	case FFI_TYPE_VOID:
+	  FFI_ASSERT (0);
+	  break;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_POINTER:
+	  avalue[i] = allocate_int_to_reg_or_stack (context, &state, stack, s);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_LONGDOUBLE:
+	case FFI_TYPE_STRUCT:
+	case FFI_TYPE_COMPLEX:
+	  h = is_vfp_type (ty);
+	  if (h)
+	    {
+	      n = 4 - (h & 3);
+              if (cif->abi == FFI_WIN64 && isvariadic)
+                {
+                  if (state.ngrn + n <= N_X_ARG_REG)
+                    {
+                      void *reg = &context->x[state.ngrn];
+                      state.ngrn += (unsigned int)n;
+
+                      /* Eeek! We need a pointer to the structure, however the
+                       homogeneous float elements are being passed in individual
+                       registers, therefore for float and double the structure
+                       is not represented as a contiguous sequence of bytes in
+                       our saved register context.  We don't need the original
+                       contents of the register storage, so we reformat the
+                       structure into the same memory.  */
+                      avalue[i] = compress_hfa_type(reg, reg, h);
+                    }
+                  else
+                    {
+                      state.ngrn = N_X_ARG_REG;
+                      state.nsrn = N_V_ARG_REG;
+                      avalue[i] = allocate_to_stack(&state, stack,
+                             ty->alignment, s);
+                    }
+                }
+              else
+                {
+                  if (state.nsrn + n <= N_V_ARG_REG)
+                    {
+                      void *reg = &context->v[state.nsrn];
+                      state.nsrn += (unsigned int)n;
+                      avalue[i] = compress_hfa_type(reg, reg, h);
+                    }
+                  else
+                    {
+                      state.nsrn = N_V_ARG_REG;
+                      avalue[i] = allocate_to_stack(&state, stack,
+                                                   ty->alignment, s);
+                    }
+                }
+            }
+          else if (s > 16)
+            {
+              /* Replace Composite type of size greater than 16 with a
+                  pointer.  */
+#ifdef __ILP32__
+             UINT64 avalue_tmp;
+             memcpy (&avalue_tmp,
+                  allocate_int_to_reg_or_stack (context, &state,
+                                               stack, sizeof (void *)),
+                  sizeof (UINT64));
+             avalue[i] = (void *)(UINT32)avalue_tmp;
+#else
+              avalue[i] = *(void **)
+              allocate_int_to_reg_or_stack (context, &state, stack,
+                                         sizeof (void *));
+#endif
+            }
+          else
+            {
+              n = (s + 7) / 8;
+              if (state.ngrn + n <= N_X_ARG_REG)
+                {
+                  avalue[i] = &context->x[state.ngrn];
+                  state.ngrn += (unsigned int)n;
+                }
+              else
+                {
+                  state.ngrn = N_X_ARG_REG;
+                  avalue[i] = allocate_to_stack(&state, stack,
+                                           ty->alignment, s);
+                }
+            }
+          break;
+
+        default:
+          abort();
+      }
+
+#if defined (__APPLE__)
+      if (i + 1 == cif->aarch64_nfixedargs)
+	{
+	  state.ngrn = N_X_ARG_REG;
+	  state.nsrn = N_V_ARG_REG;
+	  state.allocating_variadic = 1;
+	}
+#endif
+    }
+
+  if (flags & AARCH64_RET_IN_MEM)
+    rvalue = struct_rvalue;
+
+  fun (cif, rvalue, avalue, user_data);
+
+  return flags;
+}
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void *
+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)
+{
+  extern void *trampoline_code_table;
+
+  *tramp_size = AARCH64_TRAMP_SIZE;
+  *map_size = AARCH64_TRAMP_MAP_SIZE;
+  return &trampoline_code_table;
+}
+#endif
+
+#endif /* FFI_CLOSURES */
+
+#endif /* (__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)*/
Index: libffi-3.4.6/src/aarch64/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/aarch64/sysv.S b/libffi-3.4.6/src/aarch64/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/aarch64/sysv.S	
@@ -0,0 +1,693 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#if defined(__aarch64__) || defined(__arm64__)
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+#ifdef __USER_LABEL_PREFIX__
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+/* Use the right prefix for global labels.  */
+#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
+#else
+#define CNAME(x) x
+#endif
+#endif
+
+#ifdef __APPLE__
+# define L(X)     CONCAT1(L, X)
+#else
+# define L(X)     CONCAT1(.L, X)
+#endif
+
+#ifdef __AARCH64EB__
+# define BE(X)	X
+#else
+# define BE(X)	0
+#endif
+
+#ifdef __ILP32__
+#define PTR_REG(n)      w##n
+#else
+#define PTR_REG(n)      x##n
+#endif
+
+#ifdef __ILP32__
+#define PTR_SIZE	4
+#else
+#define PTR_SIZE	8
+#endif
+
+#define BTI_C hint #34
+#define BTI_J hint #36
+/*
+ * The ELF Notes section needs to indicate if BTI is supported, as the first ELF loaded that doesn't
+ * declare this support disables it for the whole process.
+ */
+# define GNU_PROPERTY_AARCH64_BTI (1 << 0)         /* Has Branch Target Identification */
+	.text
+	.align 4
+
+/* ffi_call_SYSV
+   extern void ffi_call_SYSV (void *stack, void *frame,
+			      void (*fn)(void), void *rvalue,
+			      int flags, void *closure);
+
+   Therefore on entry we have:
+
+   x0 stack
+   x1 frame
+   x2 fn
+   x3 rvalue
+   x4 flags
+   x5 closure
+*/
+
+	cfi_startproc
+CNAME(ffi_call_SYSV):
+	BTI_C
+	/* Sign the lr with x1 since that is where it will be stored */
+	SIGN_LR_WITH_REG(x1)
+
+	/* Use a stack frame allocated by our caller.  */
+#if defined(HAVE_PTRAUTH) && defined(__APPLE__)
+	/* darwin's libunwind assumes that the cfa is the sp and that's the data
+	 * used to sign the lr.  In order to allow unwinding through this
+	 * function it is necessary to point the cfa at the signing register.
+	 */
+	cfi_def_cfa(x1, 0);
+#else
+	cfi_def_cfa(x1, 40);
+#endif
+	stp	x29, x30, [x1]
+	mov	x9, sp
+	str	x9, [x1, #32]
+	mov	x29, x1
+	mov	sp, x0
+	cfi_def_cfa_register(x29)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+
+	mov	x9, x2			/* save fn */
+	mov	x8, x3			/* install structure return */
+#ifdef FFI_GO_CLOSURES
+	mov	x18, x5			/* install static chain */
+#endif
+	stp	x3, x4, [x29, #16]	/* save rvalue and flags */
+
+	/* Load the vector argument passing registers, if necessary.  */
+	tbz	w4, #AARCH64_FLAG_ARG_V_BIT, 1f
+	ldp     q0, q1, [sp, #0]
+	ldp     q2, q3, [sp, #32]
+	ldp     q4, q5, [sp, #64]
+	ldp     q6, q7, [sp, #96]
+1:
+	/* Load the core argument passing registers, including
+	   the structure return pointer.  */
+	ldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]
+	ldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]
+	ldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]
+	ldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]
+
+	/* Deallocate the context, leaving the stacked arguments.  */
+	add	sp, sp, #CALL_CONTEXT_SIZE
+
+	BRANCH_AND_LINK_TO_REG     x9			/* call fn */
+
+	ldp	x3, x4, [x29, #16]	/* reload rvalue and flags */
+
+	/* Partially deconstruct the stack frame.  */
+	ldr	x9, [x29, #32]
+	mov	sp, x9
+	cfi_def_cfa_register (sp)
+	mov	x2, x29			/* Preserve for auth */
+	ldp     x29, x30, [x29]
+
+	/* Save the return value as directed.  */
+	adr	x5, 0f
+	and	w4, w4, #AARCH64_RET_MASK
+	add	x5, x5, x4, lsl #4
+	br	x5
+
+	/* Note that each table entry is 4 insns, and thus 16 bytes.
+	   For integer data, note that we're storing into ffi_arg
+	   and therefore we want to extend to 64 bits; these types
+	   have two consecutive entries allocated for them.  */
+	.align	4
+0:	BTI_J				/* VOID */
+	b 99f
+	nop 
+	nop
+1:	BTI_J				/* INT64 */
+	str	x0, [x3]
+	b 99f
+	nop
+2:	BTI_J				/* INT128 */
+	stp	x0, x1, [x3]
+	b 99f
+	nop
+3:	brk	#1000			/* UNUSED */
+	b 99f
+	nop
+	nop
+4:	brk	#1000			/* UNUSED */
+	b 99f
+	nop
+	nop
+5:	brk	#1000			/* UNUSED */
+	b 99f
+	nop
+	nop
+6:	brk	#1000			/* UNUSED */
+	b 99f
+	nop
+	nop
+7:	brk	#1000			/* UNUSED */
+	b 99f
+	nop
+	nop
+8:	BTI_J				/* S4 */
+	st4	{ v0.s, v1.s, v2.s, v3.s }[0], [x3]
+	b 99f
+	nop
+9:	BTI_J				/* S3 */
+	st3	{ v0.s, v1.s, v2.s }[0], [x3]
+	b 99f
+	nop
+10:	BTI_J				/* S2 */
+	stp	s0, s1, [x3]
+	b 99f
+	nop
+11:	BTI_J
+	str	s0, [x3]		/* S1 */
+	b 99f
+	nop
+12:	BTI_J				/* D4 */
+	st4	{ v0.d, v1.d, v2.d, v3.d }[0], [x3]
+	b 99f
+	nop
+13:	BTI_J				/* D3 */
+	st3	{ v0.d, v1.d, v2.d }[0], [x3]
+	b 99f
+	nop
+14:	BTI_J				/* D2 */
+	stp	d0, d1, [x3]
+	b 99f
+	nop
+15:	BTI_J				/* D1 */
+	str	d0, [x3]
+	b 99f
+	nop
+16:	BTI_J				/* Q4 */
+	str	q3, [x3, #48]
+	nop
+	nop
+17:	BTI_J				/* Q3 */
+	str	q2, [x3, #32]
+	nop
+	nop
+18:	BTI_J				/* Q2 */
+	stp	q0, q1, [x3]
+	b 99f
+	nop
+19:	BTI_J				/* Q1 */
+	str	q0, [x3]
+	b 99f
+	nop
+20:	BTI_J				/* UINT8 */
+	uxtb	w0, w0
+	str	x0, [x3]
+	nop
+21:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+22:	BTI_J				/* UINT16 */
+	uxth	w0, w0
+	str	x0, [x3]
+	nop
+23:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+24:	BTI_J				/* UINT32 */
+	mov	w0, w0
+	str	x0, [x3]
+	nop
+25:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+26:	BTI_J				/* SINT8 */
+	sxtb	x0, w0
+	str	x0, [x3]
+	nop
+27:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+28:	BTI_J				/* SINT16 */
+	sxth	x0, w0
+	str	x0, [x3]
+	nop
+29:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+30:	BTI_J				/* SINT32 */
+	sxtw	x0, w0
+	str	x0, [x3]
+	nop
+31:	b 99f				/* reserved */
+	nop
+	nop
+	nop
+
+	/* Return now that result has been populated. */
+99:
+	AUTH_LR_WITH_REG(x2)
+	ret
+
+	cfi_endproc
+
+	.globl	CNAME(ffi_call_SYSV)
+	FFI_HIDDEN(CNAME(ffi_call_SYSV))
+#ifdef __ELF__
+	.type	CNAME(ffi_call_SYSV), #function
+	.size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)
+#endif
+
+#if FFI_CLOSURES
+
+/* ffi_closure_SYSV
+
+   Closure invocation glue. This is the low level code invoked directly by
+   the closure trampoline to setup and call a closure.
+
+   On entry x17 points to a struct ffi_closure, x16 has been clobbered
+   all other registers are preserved.
+
+   We allocate a call context and save the argument passing registers,
+   then invoked the generic C ffi_closure_SYSV_inner() function to do all
+   the real work, on return we load the result passing registers back from
+   the call context.
+*/
+
+#define ffi_closure_SYSV_FS (8*2 + CALL_CONTEXT_SIZE + 64)
+
+	.align 4
+CNAME(ffi_closure_SYSV_V):
+	cfi_startproc
+	BTI_C
+	SIGN_LR
+	stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!
+	cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+
+	/* Save the argument passing vector registers.  */
+	stp     q0, q1, [sp, #16 + 0]
+	stp     q2, q3, [sp, #16 + 32]
+	stp     q4, q5, [sp, #16 + 64]
+	stp     q6, q7, [sp, #16 + 96]
+	b	0f
+	cfi_endproc
+
+	.globl	CNAME(ffi_closure_SYSV_V)
+	FFI_HIDDEN(CNAME(ffi_closure_SYSV_V))
+#ifdef __ELF__
+	.type	CNAME(ffi_closure_SYSV_V), #function
+	.size	CNAME(ffi_closure_SYSV_V), . - CNAME(ffi_closure_SYSV_V)
+#endif
+
+	.align	4
+	cfi_startproc
+CNAME(ffi_closure_SYSV):
+	BTI_C
+	SIGN_LR
+	stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!
+	cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+0:
+	mov     x29, sp
+
+	/* Save the argument passing core registers.  */
+	stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]
+	stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]
+	stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]
+	stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]
+
+	/* Load ffi_closure_inner arguments.  */
+	ldp	PTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]	/* load cif, fn */
+	ldr	PTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]	/* load user_data */
+#ifdef FFI_GO_CLOSURES
+L(do_closure):
+#endif
+	add	x3, sp, #16				/* load context */
+	add	x4, sp, #ffi_closure_SYSV_FS		/* load stack */
+	add	x5, sp, #16+CALL_CONTEXT_SIZE		/* load rvalue */
+	mov	x6, x8					/* load struct_rval */
+	bl      CNAME(ffi_closure_SYSV_inner)
+
+	/* Load the return value as directed.  */
+	adr	x1, 0f
+	and	w0, w0, #AARCH64_RET_MASK
+	add	x1, x1, x0, lsl #4
+	add	x3, sp, #16+CALL_CONTEXT_SIZE
+	br	x1
+
+	/* Note that each table entry is 4 insns, and thus 16 bytes.  */
+	.align	4
+0:	BTI_J				/* VOID */
+	b	99f
+	nop
+	nop
+1:	BTI_J				/* INT64 */
+	ldr	x0, [x3]
+	b	99f
+	nop
+2:	BTI_J				/* INT128 */
+	ldp	x0, x1, [x3]
+	b	99f
+	nop
+3:	brk	#1000			/* UNUSED */
+	nop
+	nop
+	nop
+4:	brk	#1000			/* UNUSED */
+	nop
+	nop
+	nop
+5:	brk	#1000			/* UNUSED */
+	nop
+	nop
+	nop
+6:	brk	#1000			/* UNUSED */
+	nop
+	nop
+	nop
+7:	brk	#1000			/* UNUSED */
+	nop
+	nop
+	nop
+8:	BTI_J				/* S4 */
+	ldr	s3, [x3, #12]
+	nop
+	nop
+9:	BTI_J				/* S3 */
+	ldr	s2, [x3, #8]
+	nop
+	nop
+10:	BTI_J				/* S2 */
+	ldp	s0, s1, [x3]
+	b	99f
+	nop
+11:	BTI_J				/* S1 */
+	ldr	s0, [x3]
+	b	99f
+	nop
+12:	BTI_J				/* D4 */
+	ldr	d3, [x3, #24]
+	nop
+	nop
+13:	BTI_J				/* D3 */
+	ldr	d2, [x3, #16]
+	nop
+	nop
+14:	BTI_J				/* D2 */
+	ldp	d0, d1, [x3]
+	b	99f
+	nop
+15:	BTI_J				/* D1 */
+	ldr	d0, [x3]
+	b	99f
+	nop
+16:	BTI_J				/* Q4 */
+	ldr	q3, [x3, #48]
+	nop
+	nop
+17:	BTI_J				/* Q3 */
+	ldr	q2, [x3, #32]
+	nop
+	nop
+18:	BTI_J				/* Q2 */
+	ldp	q0, q1, [x3]
+	b	99f
+	nop
+19:	BTI_J				/* Q1 */
+	ldr	q0, [x3]
+	b	99f
+	nop
+20:	BTI_J				/* UINT8 */
+	ldrb	w0, [x3, #BE(7)]
+	b	99f
+	nop
+21:	brk	#1000			/* reserved */
+	nop
+	nop
+	nop
+22:	BTI_J				/* UINT16 */
+	ldrh	w0, [x3, #BE(6)]
+	b	99f
+	nop
+23:	brk	#1000			/* reserved */
+	nop
+	nop
+	nop
+24:	BTI_J				/* UINT32 */
+	ldr	w0, [x3, #BE(4)]
+	b	99f
+	nop
+25:	brk	#1000			/* reserved */
+	nop
+	nop
+	nop
+26:	BTI_J				/* SINT8 */
+	ldrsb	x0, [x3, #BE(7)]
+	b	99f
+	nop
+27:	brk	#1000			/* reserved */
+	nop
+	nop
+	nop
+28:	BTI_J				/* SINT16 */
+	ldrsh	x0, [x3, #BE(6)]
+	b	99f
+	nop
+29:	brk	#1000			/* reserved */
+	nop
+	nop
+	nop
+30:	BTI_J				/* SINT32 */
+	ldrsw	x0, [x3, #BE(4)]
+	nop
+	nop
+31:					/* reserved */
+99:	ldp     x29, x30, [sp], #ffi_closure_SYSV_FS
+	cfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)
+	cfi_restore (x29)
+	cfi_restore (x30)
+	AUTH_LR_AND_RET
+	cfi_endproc
+
+	.globl	CNAME(ffi_closure_SYSV)
+	FFI_HIDDEN(CNAME(ffi_closure_SYSV))
+#ifdef __ELF__
+	.type	CNAME(ffi_closure_SYSV), #function
+	.size	CNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)
+#endif
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+	.align 4
+CNAME(ffi_closure_SYSV_V_alt):
+	/* See the comments above trampoline_code_table. */
+	ldr	x17, [sp, #8]			/* Load closure in x17 */
+	add	sp, sp, #16			/* Restore the stack */
+	b	CNAME(ffi_closure_SYSV_V)
+
+	.globl	CNAME(ffi_closure_SYSV_V_alt)
+	FFI_HIDDEN(CNAME(ffi_closure_SYSV_V_alt))
+#ifdef __ELF__
+	.type	CNAME(ffi_closure_SYSV_V_alt), #function
+	.size	CNAME(ffi_closure_SYSV_V_alt), . - CNAME(ffi_closure_SYSV_V_alt)
+#endif
+
+	.align 4
+CNAME(ffi_closure_SYSV_alt):
+	/* See the comments above trampoline_code_table. */
+	ldr	x17, [sp, #8]			/* Load closure in x17 */
+	add	sp, sp, #16			/* Restore the stack */
+	b	CNAME(ffi_closure_SYSV)
+
+	.globl	CNAME(ffi_closure_SYSV_alt)
+	FFI_HIDDEN(CNAME(ffi_closure_SYSV_alt))
+#ifdef __ELF__
+	.type	CNAME(ffi_closure_SYSV_alt), #function
+	.size	CNAME(ffi_closure_SYSV_alt), . - CNAME(ffi_closure_SYSV_alt)
+#endif
+
+/*
+ * Below is the definition of the trampoline code table. Each element in
+ * the code table is a trampoline.
+ */
+/*
+ * The trampoline uses register x17. It saves the original value of x17 on
+ * the stack.
+ *
+ * The trampoline has two parameters - target code to jump to and data for
+ * the target code. The trampoline extracts the parameters from its parameter
+ * block (see tramp_table_map()). The trampoline saves the data address on
+ * the stack. Finally, it jumps to the target code.
+ *
+ * The target code can choose to:
+ *
+ * - restore the value of x17
+ * - load the data address in a register
+ * - restore the stack pointer to what it was when the trampoline was invoked.
+ */
+	.align	AARCH64_TRAMP_MAP_SHIFT
+CNAME(trampoline_code_table):
+	.rept	AARCH64_TRAMP_MAP_SIZE / AARCH64_TRAMP_SIZE
+	sub	sp, sp, #16		/* Make space on the stack */
+	str	x17, [sp]		/* Save x17 on stack */
+	adr	x17, #16376		/* Get data address */
+	ldr	x17, [x17]		/* Copy data into x17 */
+	str	x17, [sp, #8]		/* Save data on stack */
+	adr	x17, #16372		/* Get code address */
+	ldr	x17, [x17]		/* Load code address into x17 */
+	br	x17			/* Jump to code */
+	.endr
+
+	.globl CNAME(trampoline_code_table)
+	FFI_HIDDEN(CNAME(trampoline_code_table))
+#ifdef __ELF__
+	.type	CNAME(trampoline_code_table), #function
+	.size	CNAME(trampoline_code_table), . - CNAME(trampoline_code_table)
+#endif
+	.align	AARCH64_TRAMP_MAP_SHIFT
+#endif /* FFI_EXEC_STATIC_TRAMP */
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#include <mach/machine/vm_param.h>
+    .align PAGE_MAX_SHIFT
+CNAME(ffi_closure_trampoline_table_page):
+    .rept PAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE
+    adr x16, -PAGE_MAX_SIZE
+    ldp x17, x16, [x16]
+    br x16
+	nop		/* each entry in the trampoline config page is 2*sizeof(void*) so the trampoline itself cannot be smaller than 16 bytes */
+    .endr
+
+    .globl CNAME(ffi_closure_trampoline_table_page)
+    FFI_HIDDEN(CNAME(ffi_closure_trampoline_table_page))
+    #ifdef __ELF__
+    	.type	CNAME(ffi_closure_trampoline_table_page), #function
+    	.size	CNAME(ffi_closure_trampoline_table_page), . - CNAME(ffi_closure_trampoline_table_page)
+    #endif
+#endif
+
+#endif /* FFI_EXEC_TRAMPOLINE_TABLE */
+
+#ifdef FFI_GO_CLOSURES
+	.align 4
+CNAME(ffi_go_closure_SYSV_V):
+	cfi_startproc
+	BTI_C
+	stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!
+	cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+
+	/* Save the argument passing vector registers.  */
+	stp     q0, q1, [sp, #16 + 0]
+	stp     q2, q3, [sp, #16 + 32]
+	stp     q4, q5, [sp, #16 + 64]
+	stp     q6, q7, [sp, #16 + 96]
+	b	0f
+	cfi_endproc
+
+	.globl	CNAME(ffi_go_closure_SYSV_V)
+	FFI_HIDDEN(CNAME(ffi_go_closure_SYSV_V))
+#ifdef __ELF__
+	.type	CNAME(ffi_go_closure_SYSV_V), #function
+	.size	CNAME(ffi_go_closure_SYSV_V), . - CNAME(ffi_go_closure_SYSV_V)
+#endif
+
+	.align	4
+	cfi_startproc
+CNAME(ffi_go_closure_SYSV):
+	BTI_C
+	stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!
+	cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+0:
+	mov     x29, sp
+
+	/* Save the argument passing core registers.  */
+	stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]
+	stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]
+	stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]
+	stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]
+
+	/* Load ffi_closure_inner arguments.  */
+	ldp	PTR_REG(0), PTR_REG(1), [x18, #PTR_SIZE]/* load cif, fn */
+	mov	x2, x18					/* load user_data */
+	b	L(do_closure)
+	cfi_endproc
+
+	.globl	CNAME(ffi_go_closure_SYSV)
+	FFI_HIDDEN(CNAME(ffi_go_closure_SYSV))
+#ifdef __ELF__
+	.type	CNAME(ffi_go_closure_SYSV), #function
+	.size	CNAME(ffi_go_closure_SYSV), . - CNAME(ffi_go_closure_SYSV)
+#endif
+#endif /* FFI_GO_CLOSURES */
+#endif /* FFI_CLOSURES */
+#endif /* __arm64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section .note.GNU-stack,"",%progbits
+
+	.pushsection .note.gnu.property, "a";
+	.balign 8;
+	.long 4;
+	.long 0x10;
+	.long 0x5;
+	.asciz "GNU";
+	.long 0xc0000000; /* GNU_PROPERTY_AARCH64_FEATURE_1_AND */
+	.long 4;
+	.long GNU_PROPERTY_AARCH64_BTI;
+	.long 0;
+	.popsection;
+#endif
+
Index: libffi-3.4.6/src/aarch64/internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/aarch64/internal.h b/libffi-3.4.6/src/aarch64/internal.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/aarch64/internal.h	
@@ -0,0 +1,100 @@
+/* 
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#define AARCH64_RET_VOID	0
+#define AARCH64_RET_INT64	1
+#define AARCH64_RET_INT128	2
+
+#define AARCH64_RET_UNUSED3	3
+#define AARCH64_RET_UNUSED4	4
+#define AARCH64_RET_UNUSED5	5
+#define AARCH64_RET_UNUSED6	6
+#define AARCH64_RET_UNUSED7	7
+
+/* Note that FFI_TYPE_FLOAT == 2, _DOUBLE == 3, _LONGDOUBLE == 4,
+   so _S4 through _Q1 are layed out as (TYPE * 4) + (4 - COUNT).  */
+#define AARCH64_RET_S4		8
+#define AARCH64_RET_S3		9
+#define AARCH64_RET_S2		10
+#define AARCH64_RET_S1		11
+
+#define AARCH64_RET_D4		12
+#define AARCH64_RET_D3		13
+#define AARCH64_RET_D2		14
+#define AARCH64_RET_D1		15
+
+#define AARCH64_RET_Q4		16
+#define AARCH64_RET_Q3		17
+#define AARCH64_RET_Q2		18
+#define AARCH64_RET_Q1		19
+
+/* Note that each of the sub-64-bit integers gets two entries.  */
+#define AARCH64_RET_UINT8	20
+#define AARCH64_RET_UINT16	22
+#define AARCH64_RET_UINT32	24
+
+#define AARCH64_RET_SINT8	26
+#define AARCH64_RET_SINT16	28
+#define AARCH64_RET_SINT32	30
+
+#define AARCH64_RET_MASK	31
+
+#define AARCH64_RET_IN_MEM	(1 << 5)
+#define AARCH64_RET_NEED_COPY	(1 << 6)
+
+#define AARCH64_FLAG_ARG_V_BIT	7
+#define AARCH64_FLAG_ARG_V	(1 << AARCH64_FLAG_ARG_V_BIT)
+#define AARCH64_FLAG_VARARG	(1 << 8)
+
+#define N_X_ARG_REG		8
+#define N_V_ARG_REG		8
+#define CALL_CONTEXT_SIZE	(N_V_ARG_REG * 16 + N_X_ARG_REG * 8)
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+/*
+ * For the trampoline code table mapping, a mapping size of 16K is chosen to
+ * cover the base page sizes of 4K and 16K.
+ */
+#define AARCH64_TRAMP_MAP_SHIFT	14
+#define AARCH64_TRAMP_MAP_SIZE	(1 << AARCH64_TRAMP_MAP_SHIFT)
+#define AARCH64_TRAMP_SIZE	32
+
+#endif
+
+/* Helpers for writing assembly compatible with arm ptr auth */
+#ifdef LIBFFI_ASM
+
+#ifdef HAVE_PTRAUTH
+#define SIGN_LR pacibsp
+#define SIGN_LR_WITH_REG(x) pacib lr, x
+#define AUTH_LR_AND_RET retab
+#define AUTH_LR_WITH_REG(x) autib lr, x
+#define BRANCH_AND_LINK_TO_REG blraaz
+#define BRANCH_TO_REG braaz
+#else
+#define SIGN_LR
+#define SIGN_LR_WITH_REG(x)
+#define AUTH_LR_AND_RET ret
+#define AUTH_LR_WITH_REG(x)
+#define BRANCH_AND_LINK_TO_REG blr
+#define BRANCH_TO_REG br
+#endif
+
+#endif
Index: libffi-3.4.6/src/aarch64/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/aarch64/ffitarget.h b/libffi-3.4.6/src/aarch64/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/aarch64/ffitarget.h	
@@ -0,0 +1,97 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+#ifdef __ILP32__
+#define FFI_SIZEOF_ARG 8
+#define FFI_SIZEOF_JAVA_RAW  4
+typedef unsigned long long ffi_arg;
+typedef signed long long ffi_sarg;
+#elif defined(_WIN32)
+#define FFI_SIZEOF_ARG 8
+typedef unsigned long long ffi_arg;
+typedef signed long long ffi_sarg;
+#else
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+#endif
+
+typedef enum ffi_abi
+  {
+    FFI_FIRST_ABI = 0,
+    FFI_SYSV,
+    FFI_WIN64,
+    FFI_LAST_ABI,
+#if defined(_WIN32)
+    FFI_DEFAULT_ABI = FFI_WIN64
+#else
+    FFI_DEFAULT_ABI = FFI_SYSV
+#endif
+  } ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#if defined (FFI_EXEC_TRAMPOLINE_TABLE) && FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+#define FFI_TRAMPOLINE_SIZE 16
+#define FFI_TRAMPOLINE_CLOSURE_OFFSET 16
+#else
+#error "No trampoline table implementation"
+#endif
+
+#else
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE
+#endif
+
+#ifdef _WIN32
+#define FFI_EXTRA_CIF_FIELDS unsigned is_variadic
+#endif
+#define FFI_TARGET_SPECIFIC_VARIADIC
+
+/* ---- Internal ---- */
+
+#if defined (__APPLE__)
+#define FFI_EXTRA_CIF_FIELDS unsigned aarch64_nfixedargs
+#elif !defined(_WIN32)
+/* iOS and Windows reserve x18 for the system.  Disable Go closures until
+   a new static chain is chosen.  */
+#define FFI_GO_CLOSURES 1
+#endif
+
+#ifndef _WIN32
+/* No complex type on Windows */
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+#endif
+
+#endif
Index: libffi-3.4.6/src/aarch64/win64_armasm.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/aarch64/win64_armasm.S b/libffi-3.4.6/src/aarch64/win64_armasm.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/aarch64/win64_armasm.S	
@@ -0,0 +1,506 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_cfi.h>
+#include "internal.h"
+
+	OPT	2 /*disable listing */
+/* For some macros to add unwind information */
+#include "ksarm64.h"
+	OPT	1 /*re-enable listing */
+
+#define BE(X)	0
+#define PTR_REG(n)      x##n
+#define PTR_SIZE	8
+
+	IMPORT ffi_closure_SYSV_inner
+	EXPORT	ffi_call_SYSV
+	EXPORT	ffi_closure_SYSV_V
+	EXPORT	ffi_closure_SYSV
+	EXPORT	extend_hfa_type
+	EXPORT	compress_hfa_type
+#ifdef FFI_GO_CLOSURES
+	EXPORT	ffi_go_closure_SYSV_V
+	EXPORT	ffi_go_closure_SYSV
+#endif
+
+	TEXTAREA, ALIGN=8
+
+/* ffi_call_SYSV
+   extern void ffi_call_SYSV (void *stack, void *frame,
+			      void (*fn)(void), void *rvalue,
+			      int flags, void *closure);
+   Therefore on entry we have:
+   x0 stack
+   x1 frame
+   x2 fn
+   x3 rvalue
+   x4 flags
+   x5 closure
+*/
+
+	NESTED_ENTRY ffi_call_SYSV_fake
+
+	/* For unwind information, Windows has to store fp and lr  */
+	PROLOG_SAVE_REG_PAIR	x29, x30, #-32!
+
+	ALTERNATE_ENTRY ffi_call_SYSV
+	/* Use a stack frame allocated by our caller. */
+	stp	x29, x30, [x1]
+	mov	x29, x1
+	mov	sp, x0
+
+	mov	x9, x2			/* save fn */
+	mov	x8, x3			/* install structure return */
+#ifdef FFI_GO_CLOSURES
+	/*mov	x18, x5			install static chain */
+#endif
+	stp	x3, x4, [x29, #16]	/* save rvalue and flags */
+	
+	/* Load the vector argument passing registers, if necessary.  */
+	tbz	x4, #AARCH64_FLAG_ARG_V_BIT, ffi_call_SYSV_L1
+	ldp	q0, q1, [sp, #0]
+	ldp	q2, q3, [sp, #32]
+	ldp	q4, q5, [sp, #64]
+	ldp	q6, q7, [sp, #96]
+
+ffi_call_SYSV_L1
+	/* Load the core argument passing registers, including
+	   the structure return pointer.  */
+	ldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]
+	ldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]
+	ldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]
+	ldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]
+
+	/* Deallocate the context, leaving the stacked arguments.  */
+	add	sp, sp, #CALL_CONTEXT_SIZE	
+
+	blr     x9			/* call fn */
+
+	ldp	x3, x4, [x29, #16]	/* reload rvalue and flags */
+
+	/* Partially deconstruct the stack frame. */
+	mov     sp, x29 
+	ldp     x29, x30, [x29]
+
+	/* Save the return value as directed.  */
+	adr	x5, ffi_call_SYSV_return
+	and	w4, w4, #AARCH64_RET_MASK
+	add	x5, x5, x4, lsl #3
+	br	x5
+	
+	/* Note that each table entry is 2 insns, and thus 8 bytes.
+	   For integer data, note that we're storing into ffi_arg
+	   and therefore we want to extend to 64 bits; these types
+	   have two consecutive entries allocated for them.  */
+	ALIGN 4
+ffi_call_SYSV_return
+	ret				/* VOID */
+	nop
+	str	x0, [x3]		/* INT64 */
+	ret
+	stp	x0, x1, [x3]		/* INT128 */
+	ret
+	brk	#1000			/* UNUSED */
+	ret
+	brk	#1000			/* UNUSED */
+	ret
+	brk	#1000			/* UNUSED */
+	ret
+	brk	#1000			/* UNUSED */
+	ret
+	brk	#1000			/* UNUSED */
+	ret
+	st4	{ v0.s, v1.s, v2.s, v3.s }[0], [x3]	/* S4 */
+	ret
+	st3	{ v0.s, v1.s, v2.s }[0], [x3]	/* S3 */
+	ret
+	stp	s0, s1, [x3]		/* S2 */
+	ret
+	str	s0, [x3]		/* S1 */
+	ret
+	st4	{ v0.d, v1.d, v2.d, v3.d }[0], [x3]	/* D4 */
+	ret
+	st3	{ v0.d, v1.d, v2.d }[0], [x3]	/* D3 */
+	ret
+	stp	d0, d1, [x3]		/* D2 */
+	ret
+	str	d0, [x3]		/* D1 */
+	ret
+	str	q3, [x3, #48]		/* Q4 */
+	nop
+	str	q2, [x3, #32]		/* Q3 */
+	nop
+	stp	q0, q1, [x3]		/* Q2 */
+	ret
+	str	q0, [x3]		/* Q1 */
+	ret
+	uxtb	w0, w0			/* UINT8 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	uxth	w0, w0			/* UINT16 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	mov	w0, w0			/* UINT32 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	sxtb	x0, w0			/* SINT8 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	sxth	x0, w0			/* SINT16 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	sxtw	x0, w0			/* SINT32 */
+	str	x0, [x3]
+	ret				/* reserved */
+	nop
+	
+	
+	NESTED_END ffi_call_SYSV_fake
+	
+
+/* ffi_closure_SYSV
+   Closure invocation glue. This is the low level code invoked directly by
+   the closure trampoline to setup and call a closure.
+   On entry x17 points to a struct ffi_closure, x16 has been clobbered
+   all other registers are preserved.
+   We allocate a call context and save the argument passing registers,
+   then invoked the generic C ffi_closure_SYSV_inner() function to do all
+   the real work, on return we load the result passing registers back from
+   the call context.
+*/
+
+#define ffi_closure_SYSV_FS (8*2 + CALL_CONTEXT_SIZE + 64)
+
+	NESTED_ENTRY	ffi_closure_SYSV_V
+	PROLOG_SAVE_REG_PAIR	x29, x30, #-ffi_closure_SYSV_FS!
+
+	/* Save the argument passing vector registers.  */
+	stp	q0, q1, [sp, #16 + 0]
+	stp	q2, q3, [sp, #16 + 32]
+	stp	q4, q5, [sp, #16 + 64]
+	stp	q6, q7, [sp, #16 + 96]
+
+	b	ffi_closure_SYSV_save_argument
+	NESTED_END	ffi_closure_SYSV_V
+
+	NESTED_ENTRY	ffi_closure_SYSV
+	PROLOG_SAVE_REG_PAIR	x29, x30, #-ffi_closure_SYSV_FS!
+
+ffi_closure_SYSV_save_argument
+	/* Save the argument passing core registers.  */
+	stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]
+	stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]
+	stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]
+	stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]
+
+	/* Load ffi_closure_inner arguments.  */
+	ldp	PTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]	/* load cif, fn */
+	ldr	PTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]	/* load user_data */
+
+do_closure
+	add	x3, sp, #16							/* load context */
+	add	x4, sp, #ffi_closure_SYSV_FS		/* load stack */
+	add	x5, sp, #16+CALL_CONTEXT_SIZE		/* load rvalue */
+	mov	x6, x8					/* load struct_rval */
+
+	bl	ffi_closure_SYSV_inner
+
+	/* Load the return value as directed.  */
+	adr	x1, ffi_closure_SYSV_return_base
+	and	w0, w0, #AARCH64_RET_MASK
+	add	x1, x1, x0, lsl #3
+	add	x3, sp, #16+CALL_CONTEXT_SIZE
+	br	x1
+
+	/* Note that each table entry is 2 insns, and thus 8 bytes.  */
+	ALIGN	8
+ffi_closure_SYSV_return_base
+	b	ffi_closure_SYSV_epilog			/* VOID */
+	nop
+	ldr	x0, [x3]		/* INT64 */
+	b	ffi_closure_SYSV_epilog
+	ldp	x0, x1, [x3]		/* INT128 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* UNUSED */
+	nop
+	brk	#1000			/* UNUSED */
+	nop
+	brk	#1000			/* UNUSED */
+	nop
+	brk	#1000			/* UNUSED */
+	nop
+	brk	#1000			/* UNUSED */
+	nop
+	ldr	s3, [x3, #12]		/* S4 */
+	nop
+	ldr	s2, [x3, #8]		/* S3 */
+	nop
+	ldp	s0, s1, [x3]		/* S2 */
+	b	ffi_closure_SYSV_epilog
+	ldr	s0, [x3]		/* S1 */
+	b	ffi_closure_SYSV_epilog
+	ldr	d3, [x3, #24]		/* D4 */
+	nop
+	ldr	d2, [x3, #16]		/* D3 */
+	nop
+	ldp	d0, d1, [x3]		/* D2 */
+	b	ffi_closure_SYSV_epilog
+	ldr	d0, [x3]		/* D1 */
+	b	ffi_closure_SYSV_epilog
+	ldr	q3, [x3, #48]		/* Q4 */
+	nop
+	ldr	q2, [x3, #32]		/* Q3 */
+	nop
+	ldp	q0, q1, [x3]		/* Q2 */
+	b	ffi_closure_SYSV_epilog
+	ldr	q0, [x3]		/* Q1 */
+	b	ffi_closure_SYSV_epilog
+	ldrb	w0, [x3, #BE(7)]	/* UINT8 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* reserved */
+	nop
+	ldrh	w0, [x3, #BE(6)]	/* UINT16 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* reserved */
+	nop
+	ldr	w0, [x3, #BE(4)]	/* UINT32 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* reserved */
+	nop
+	ldrsb	x0, [x3, #BE(7)]	/* SINT8 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* reserved */
+	nop
+	ldrsh	x0, [x3, #BE(6)]	/* SINT16 */
+	b	ffi_closure_SYSV_epilog
+	brk	#1000			/* reserved */
+	nop
+	ldrsw	x0, [x3, #BE(4)]	/* SINT32 */
+	nop
+					/* reserved */
+
+ffi_closure_SYSV_epilog
+	EPILOG_RESTORE_REG_PAIR	x29, x30, #ffi_closure_SYSV_FS!
+	EPILOG_RETURN
+	NESTED_END	ffi_closure_SYSV
+
+
+#ifdef FFI_GO_CLOSURES
+	NESTED_ENTRY	ffi_go_closure_SYSV_V
+	PROLOG_SAVE_REG_PAIR	x29, x30, #-ffi_closure_SYSV_FS!
+
+	/* Save the argument passing vector registers.  */
+	stp	q0, q1, [sp, #16 + 0]
+	stp	q2, q3, [sp, #16 + 32]
+	stp	q4, q5, [sp, #16 + 64]
+	stp	q6, q7, [sp, #16 + 96]
+	b	ffi_go_closure_SYSV_save_argument
+	NESTED_END	ffi_go_closure_SYSV_V
+
+	NESTED_ENTRY	ffi_go_closure_SYSV
+	PROLOG_SAVE_REG_PAIR	x29, x30, #-ffi_closure_SYSV_FS!
+
+ffi_go_closure_SYSV_save_argument
+	/* Save the argument passing core registers.  */
+	stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]
+	stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]
+	stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]
+	stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]
+
+	/* Load ffi_closure_inner arguments.  */
+	ldp	PTR_REG(0), PTR_REG(1), [x18, #PTR_SIZE]/* load cif, fn */
+	mov	x2, x18					/* load user_data */
+	b	do_closure
+	NESTED_END	ffi_go_closure_SYSV
+
+#endif /* FFI_GO_CLOSURES */
+
+
+/* void extend_hfa_type (void *dest, void *src, int h) */
+
+	LEAF_ENTRY	extend_hfa_type
+
+	adr	x3, extend_hfa_type_jump_base
+	and	w2, w2, #AARCH64_RET_MASK
+	sub	x2, x2, #AARCH64_RET_S4
+	add	x3, x3, x2, lsl #4
+	br	x3
+
+	ALIGN	4
+extend_hfa_type_jump_base
+	ldp	s16, s17, [x1]		/* S4 */
+	ldp	s18, s19, [x1, #8]
+	b	extend_hfa_type_store_4
+	nop
+
+	ldp	s16, s17, [x1]		/* S3 */
+	ldr	s18, [x1, #8]
+	b	extend_hfa_type_store_3
+	nop
+
+	ldp	s16, s17, [x1]		/* S2 */
+	b	extend_hfa_type_store_2
+	nop
+	nop
+
+	ldr	s16, [x1]		/* S1 */
+	b	extend_hfa_type_store_1
+	nop
+	nop
+
+	ldp	d16, d17, [x1]		/* D4 */
+	ldp	d18, d19, [x1, #16]
+	b       extend_hfa_type_store_4
+	nop
+
+	ldp     d16, d17, [x1]		/* D3 */
+	ldr     d18, [x1, #16]
+	b	extend_hfa_type_store_3
+	nop
+
+	ldp	d16, d17, [x1]		/* D2 */
+	b	extend_hfa_type_store_2
+	nop
+	nop
+
+	ldr	d16, [x1]		/* D1 */
+	b	extend_hfa_type_store_1
+	nop
+	nop
+
+	ldp	q16, q17, [x1]		/* Q4 */
+	ldp	q18, q19, [x1, #16]
+	b	extend_hfa_type_store_4
+	nop
+
+	ldp	q16, q17, [x1]		/* Q3 */
+	ldr	q18, [x1, #16]
+	b	extend_hfa_type_store_3
+	nop
+
+	ldp	q16, q17, [x1]		/* Q2 */
+	b	extend_hfa_type_store_2
+	nop
+	nop
+
+	ldr	q16, [x1]		/* Q1 */
+	b	extend_hfa_type_store_1
+
+extend_hfa_type_store_4
+	str	q19, [x0, #48]
+extend_hfa_type_store_3
+	str	q18, [x0, #32]
+extend_hfa_type_store_2
+	str	q17, [x0, #16]
+extend_hfa_type_store_1
+	str	q16, [x0]
+	ret
+
+	LEAF_END	extend_hfa_type
+
+
+/* void compress_hfa_type (void *dest, void *reg, int h) */
+
+	LEAF_ENTRY	compress_hfa_type
+
+	adr	x3, compress_hfa_type_jump_base
+	and	w2, w2, #AARCH64_RET_MASK
+	sub	x2, x2, #AARCH64_RET_S4
+	add	x3, x3, x2, lsl #4
+	br	x3
+
+	ALIGN	4
+compress_hfa_type_jump_base
+	ldp	q16, q17, [x1]		/* S4 */
+	ldp	q18, q19, [x1, #32]
+	st4	{ v16.s, v17.s, v18.s, v19.s }[0], [x0]
+	ret
+
+	ldp	q16, q17, [x1]		/* S3 */
+	ldr	q18, [x1, #32]
+	st3	{ v16.s, v17.s, v18.s }[0], [x0]
+	ret
+
+	ldp	q16, q17, [x1]		/* S2 */
+	st2	{ v16.s, v17.s }[0], [x0]
+	ret
+	nop
+
+	ldr	q16, [x1]		/* S1 */
+	st1	{ v16.s }[0], [x0]
+	ret
+	nop
+
+	ldp	q16, q17, [x1]		/* D4 */
+	ldp	q18, q19, [x1, #32]
+	st4	{ v16.d, v17.d, v18.d, v19.d }[0], [x0]
+	ret
+
+	ldp	q16, q17, [x1]		/* D3 */
+	ldr	q18, [x1, #32]
+	st3	{ v16.d, v17.d, v18.d }[0], [x0]
+	ret
+
+	ldp	q16, q17, [x1]		/* D2 */
+	st2	{ v16.d, v17.d }[0], [x0]
+	ret
+	nop
+
+	ldr	q16, [x1]		/* D1 */
+	st1	{ v16.d }[0], [x0]
+	ret
+	nop
+
+	ldp	q16, q17, [x1]		/* Q4 */
+	ldp	q18, q19, [x1, #32]
+	b	compress_hfa_type_store_q4
+	nop
+
+	ldp	q16, q17, [x1]		/* Q3 */
+	ldr	q18, [x1, #32]
+	b	compress_hfa_type_store_q3
+	nop
+
+	ldp	q16, q17, [x1]		/* Q2 */
+	stp	q16, q17, [x0]
+	ret
+	nop
+
+	ldr	q16, [x1]		/* Q1 */
+	str	q16, [x0]
+	ret
+
+compress_hfa_type_store_q4
+	str	q19, [x0, #48]
+compress_hfa_type_store_q3
+	str	q18, [x0, #32]
+	stp	q16, q17, [x0]
+	ret
+
+	LEAF_END	compress_hfa_type
+
+	END
\ No newline at end of file
Index: libffi-3.4.6/src/debug.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/debug.c b/libffi-3.4.6/src/debug.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/debug.c	
@@ -0,0 +1,64 @@
+/* -----------------------------------------------------------------------
+   debug.c - Copyright (c) 1996 Red Hat, Inc.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/* General debugging routines */
+
+void ffi_stop_here(void)
+{
+  /* This function is only useful for debugging purposes.
+     Place a breakpoint on ffi_stop_here to be notified of
+     significant events. */
+}
+
+/* This function should only be called via the FFI_ASSERT() macro */
+
+NORETURN void ffi_assert(const char *expr, const char *file, int line)
+{
+  fprintf(stderr, "ASSERTION FAILURE: %s at %s:%d\n", expr, file, line);
+  ffi_stop_here();
+  abort();
+}
+
+/* Perform a sanity check on an ffi_type structure */
+
+void ffi_type_test(ffi_type *a, const char *file, int line)
+{
+  FFI_ASSERT_AT(a != NULL, file, line);
+
+  FFI_ASSERT_AT(a->type <= FFI_TYPE_LAST, file, line);
+  FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->size > 0, file, line);
+  FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->alignment > 0, file, line);
+  FFI_ASSERT_AT((a->type != FFI_TYPE_STRUCT && a->type != FFI_TYPE_COMPLEX)
+		|| a->elements != NULL, file, line);
+  FFI_ASSERT_AT(a->type != FFI_TYPE_COMPLEX
+		|| (a->elements != NULL
+		    && a->elements[0] != NULL && a->elements[1] == NULL),
+		file, line);
+
+}
Index: libffi-3.4.6/src/powerpc/aix.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/aix.S b/libffi-3.4.6/src/powerpc/aix.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/aix.S	
@@ -0,0 +1,566 @@
+/* -----------------------------------------------------------------------
+   aix.S - Copyright (c) 2002, 2009 Free Software Foundation, Inc.
+   based on darwin.S by John Hornkvist
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+	.set r0,0
+	.set r1,1
+	.set r2,2
+	.set r3,3
+	.set r4,4
+	.set r5,5
+	.set r6,6
+	.set r7,7
+	.set r8,8
+	.set r9,9
+	.set r10,10
+	.set r11,11
+	.set r12,12
+	.set r13,13
+	.set r14,14
+	.set r15,15
+	.set r16,16
+	.set r17,17
+	.set r18,18
+	.set r19,19
+	.set r20,20
+	.set r21,21
+	.set r22,22
+	.set r23,23
+	.set r24,24
+	.set r25,25
+	.set r26,26
+	.set r27,27
+	.set r28,28
+	.set r29,29
+	.set r30,30
+	.set r31,31
+	.set f0,0
+	.set f1,1
+	.set f2,2
+	.set f3,3
+	.set f4,4
+	.set f5,5
+	.set f6,6
+	.set f7,7
+	.set f8,8
+	.set f9,9
+	.set f10,10
+	.set f11,11
+	.set f12,12
+	.set f13,13
+	.set f14,14
+	.set f15,15
+	.set f16,16
+	.set f17,17
+	.set f18,18
+	.set f19,19
+	.set f20,20
+	.set f21,21
+
+	.extern .ffi_prep_args
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#define JUMPTARGET(name) name
+#define L(x) x
+	.file "aix.S"
+	.toc
+
+	/* void ffi_call_AIX(extended_cif *ecif, unsigned long bytes,
+	 *		     unsigned int flags, unsigned int *rvalue,
+	 *		     void (*fn)(),
+	 *		     void (*prep_args)(extended_cif*, unsigned *const));
+	 * r3=ecif, r4=bytes, r5=flags, r6=rvalue, r7=fn, r8=prep_args
+	 */
+
+.csect .text[PR]
+	.align 2
+	.globl ffi_call_AIX
+	.globl .ffi_call_AIX
+.csect ffi_call_AIX[DS]
+ffi_call_AIX:
+#ifdef __64BIT__
+	.llong .ffi_call_AIX, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_call_AIX:
+	.function .ffi_call_AIX,.ffi_call_AIX,16,044,LFE..0-LFB..0
+	.bf __LINE__
+	.line 1
+LFB..0:
+	/* Save registers we use.  */
+	mflr	r0
+
+	std	r28,-32(r1)
+	std	r29,-24(r1)
+	std	r30,-16(r1)
+	std	r31, -8(r1)
+
+	std	r0, 16(r1)
+LCFI..0:
+	mr	r28, r1		/* our AP.  */
+	stdux	r1, r1, r4
+LCFI..1:
+
+	/* Save arguments over call...  */
+	mr	r31, r5	/* flags, */
+	mr	r30, r6	/* rvalue, */
+	mr	r29, r7	/* function address.  */
+	std	r2, 40(r1)
+
+	/* Call ffi_prep_args.  */
+	mr	r4, r1
+	bl	.ffi_prep_args
+	nop
+
+	/* Now do the call.  */
+	ld	r0, 0(r29)
+	ld	r2, 8(r29)
+	ld	r11, 16(r29)
+	/* Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40, r31
+	mtctr	r0
+	/* Load all those argument registers.  */
+	/* We have set up a nice stack frame, just load it into registers. */
+	ld	r3, 40+(1*8)(r1)
+	ld	r4, 40+(2*8)(r1)
+	ld	r5, 40+(3*8)(r1)
+	ld	r6, 40+(4*8)(r1)
+	nop
+	ld	r7, 40+(5*8)(r1)
+	ld	r8, 40+(6*8)(r1)
+	ld	r9, 40+(7*8)(r1)
+	ld	r10,40+(8*8)(r1)
+
+L1:
+	/* Load all the FP registers.  */
+	bf	6,L2 /* 2f + 0x18 */
+	lfd	f1,-32-(13*8)(r28)
+	lfd	f2,-32-(12*8)(r28)
+	lfd	f3,-32-(11*8)(r28)
+	lfd	f4,-32-(10*8)(r28)
+	nop
+	lfd	f5,-32-(9*8)(r28)
+	lfd	f6,-32-(8*8)(r28)
+	lfd	f7,-32-(7*8)(r28)
+	lfd	f8,-32-(6*8)(r28)
+	nop
+	lfd	f9,-32-(5*8)(r28)
+	lfd	f10,-32-(4*8)(r28)
+	lfd	f11,-32-(3*8)(r28)
+	lfd	f12,-32-(2*8)(r28)
+	nop
+	lfd	f13,-32-(1*8)(r28)
+
+L2:
+	/* Make the call.  */
+	bctrl
+	ld	r2, 40(r1)
+
+	/* Now, deal with the return value.  */
+	mtcrf	0x01, r31
+
+	bt	30, L(done_return_value)
+	bt	29, L(fp_return_value)
+	std	r3, 0(r30)
+
+	/* Fall through...  */
+
+L(done_return_value):
+	/* Restore the registers we used and return.  */
+	mr	r1, r28
+	ld	r0, 16(r28)
+	ld	r28, -32(r1)
+	mtlr	r0
+	ld	r29, -24(r1)
+	ld	r30, -16(r1)
+	ld	r31, -8(r1)
+	blr
+
+L(fp_return_value):
+	bf	28, L(float_return_value)
+	stfd	f1, 0(r30)
+	bf	31, L(done_return_value)
+	stfd	f2, 8(r30)
+	b	L(done_return_value)
+L(float_return_value):
+	stfs	f1, 0(r30)
+	b	L(done_return_value)
+LFE..0:
+#else /* ! __64BIT__ */
+	
+	.long .ffi_call_AIX, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_call_AIX:
+	.function .ffi_call_AIX,.ffi_call_AIX,16,044,LFE..0-LFB..0
+	.bf __LINE__
+	.line 1
+LFB..0:
+	/* Save registers we use.  */
+	mflr	r0
+
+	stw	r28,-16(r1)
+	stw	r29,-12(r1)
+	stw	r30, -8(r1)
+	stw	r31, -4(r1)
+
+	stw	r0, 8(r1)
+LCFI..0:
+	mr	r28, r1		/* out AP.  */
+	stwux	r1, r1, r4
+LCFI..1:
+
+	/* Save arguments over call...  */
+	mr	r31, r5	/* flags, */
+	mr	r30, r6	/* rvalue, */
+	mr	r29, r7	/* function address, */
+	stw	r2, 20(r1)
+
+	/* Call ffi_prep_args.  */
+	mr	r4, r1
+	bl	.ffi_prep_args
+	nop
+
+	/* Now do the call.  */
+	lwz	r0, 0(r29)
+	lwz	r2, 4(r29)
+	lwz	r11, 8(r29)
+	/* Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40, r31
+	mtctr	r0
+	/* Load all those argument registers.  */
+	/* We have set up a nice stack frame, just load it into registers. */
+	lwz	r3, 20+(1*4)(r1)
+	lwz	r4, 20+(2*4)(r1)
+	lwz	r5, 20+(3*4)(r1)
+	lwz	r6, 20+(4*4)(r1)
+	nop
+	lwz	r7, 20+(5*4)(r1)
+	lwz	r8, 20+(6*4)(r1)
+	lwz	r9, 20+(7*4)(r1)
+	lwz	r10,20+(8*4)(r1)
+
+L1:
+	/* Load all the FP registers.  */
+	bf	6,L2 /* 2f + 0x18 */
+	lfd	f1,-16-(13*8)(r28)
+	lfd	f2,-16-(12*8)(r28)
+	lfd	f3,-16-(11*8)(r28)
+	lfd	f4,-16-(10*8)(r28)
+	nop
+	lfd	f5,-16-(9*8)(r28)
+	lfd	f6,-16-(8*8)(r28)
+	lfd	f7,-16-(7*8)(r28)
+	lfd	f8,-16-(6*8)(r28)
+	nop
+	lfd	f9,-16-(5*8)(r28)
+	lfd	f10,-16-(4*8)(r28)
+	lfd	f11,-16-(3*8)(r28)
+	lfd	f12,-16-(2*8)(r28)
+	nop
+	lfd	f13,-16-(1*8)(r28)
+
+L2:
+	/* Make the call.  */
+	bctrl
+	lwz	r2, 20(r1)
+
+	/* Now, deal with the return value.  */
+	mtcrf	0x01, r31
+
+	bt	30, L(done_return_value)
+	bt	29, L(fp_return_value)
+	stw	r3, 0(r30)
+	bf	28, L(done_return_value)
+	stw	r4, 4(r30)
+
+	/* Fall through...  */
+
+L(done_return_value):
+	/* Restore the registers we used and return.  */
+	mr	r1, r28
+	lwz	r0, 8(r28)
+	lwz	r28,-16(r1)
+	mtlr	r0
+	lwz	r29,-12(r1)
+	lwz	r30, -8(r1)
+	lwz	r31, -4(r1)
+	blr
+
+L(fp_return_value):
+	bf	28, L(float_return_value)
+	stfd	f1, 0(r30)
+	b	L(done_return_value)
+L(float_return_value):
+	stfs	f1, 0(r30)
+	b	L(done_return_value)
+LFE..0:
+#endif
+	.ef __LINE__
+	.long 0
+	.byte 0,0,0,1,128,4,0,0
+/* END(ffi_call_AIX) */
+
+	/* void ffi_call_go_AIX(extended_cif *ecif, unsigned long bytes,
+	 *		        unsigned int flags, unsigned int *rvalue,
+	 *		        void (*fn)(),
+	 *		        void (*prep_args)(extended_cif*, unsigned *const),
+	 *                      void *closure);
+	 * r3=ecif, r4=bytes, r5=flags, r6=rvalue, r7=fn, r8=prep_args, r9=closure
+	 */
+
+.csect .text[PR]
+	.align 2
+	.globl ffi_call_go_AIX
+	.globl .ffi_call_go_AIX
+.csect ffi_call_go_AIX[DS]
+ffi_call_go_AIX:
+#ifdef __64BIT__
+	.llong .ffi_call_go_AIX, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_call_go_AIX:
+	.function .ffi_call_go_AIX,.ffi_call_go_AIX,16,044,LFE..1-LFB..1
+	.bf __LINE__
+	.line 1
+LFB..1:
+	/* Save registers we use.  */
+	mflr	r0
+
+	std	r28,-32(r1)
+	std	r29,-24(r1)
+	std	r30,-16(r1)
+	std	r31, -8(r1)
+
+	std	r9, 8(r1)	/* closure, saved in cr field. */
+	std	r0, 16(r1)
+LCFI..2:
+	mr	r28, r1		/* our AP.  */
+	stdux	r1, r1, r4
+LCFI..3:
+
+	/* Save arguments over call...  */
+	mr	r31, r5	/* flags, */
+	mr	r30, r6	/* rvalue, */
+	mr	r29, r7	/* function address,  */
+	std	r2, 40(r1)
+
+	/* Call ffi_prep_args.  */
+	mr	r4, r1
+	bl	.ffi_prep_args
+	nop
+
+	/* Now do the call.  */
+	ld	r0, 0(r29)
+	ld	r2, 8(r29)
+	ld      r11, 8(r28)	/* closure */
+	/* Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40, r31
+	mtctr	r0
+	/* Load all those argument registers.  */
+	/* We have set up a nice stack frame, just load it into registers. */
+	ld	r3, 40+(1*8)(r1)
+	ld	r4, 40+(2*8)(r1)
+	ld	r5, 40+(3*8)(r1)
+	ld	r6, 40+(4*8)(r1)
+	nop
+	ld	r7, 40+(5*8)(r1)
+	ld	r8, 40+(6*8)(r1)
+	ld	r9, 40+(7*8)(r1)
+	ld	r10,40+(8*8)(r1)
+
+	b	L1
+LFE..1:
+#else /* ! __64BIT__ */
+	
+	.long .ffi_call_go_AIX, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_call_go_AIX:
+	.function .ffi_call_go_AIX,.ffi_call_go_AIX,16,044,LFE..1-LFB..1
+	.bf __LINE__
+	.line 1
+	/* Save registers we use.  */
+LFB..1:
+	mflr	r0
+
+	stw	r28,-16(r1)
+	stw	r29,-12(r1)
+	stw	r30, -8(r1)
+	stw	r31, -4(r1)
+
+	stw	r9, 4(r1)	/* closure, saved in cr field.  */
+	stw	r0, 8(r1)
+LCFI..2:
+	mr	r28, r1		/* out AP.  */
+	stwux	r1, r1, r4
+LCFI..3:
+
+	/* Save arguments over call...  */
+	mr	r31, r5	/* flags, */
+	mr	r30, r6	/* rvalue, */
+	mr	r29, r7	/* function address, */
+	stw	r2, 20(r1)
+
+	/* Call ffi_prep_args.  */
+	mr	r4, r1
+	bl	.ffi_prep_args
+	nop
+
+	/* Now do the call.  */
+	lwz	r0, 0(r29)
+	lwz	r2, 4(r29)
+	lwz	r11, 4(r28)	/* closure */
+	/* Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40, r31
+	mtctr	r0
+	/* Load all those argument registers.  */
+	/* We have set up a nice stack frame, just load it into registers. */
+	lwz	r3, 20+(1*4)(r1)
+	lwz	r4, 20+(2*4)(r1)
+	lwz	r5, 20+(3*4)(r1)
+	lwz	r6, 20+(4*4)(r1)
+	nop
+	lwz	r7, 20+(5*4)(r1)
+	lwz	r8, 20+(6*4)(r1)
+	lwz	r9, 20+(7*4)(r1)
+	lwz	r10,20+(8*4)(r1)
+
+	b	L1
+LFE..1:
+#endif
+	.ef __LINE__
+	.long 0
+	.byte 0,0,0,1,128,4,0,0
+/* END(ffi_call_go_AIX) */
+
+.csect .text[PR]
+	.align 2
+	.globl ffi_call_DARWIN
+	.globl .ffi_call_DARWIN
+.csect ffi_call_DARWIN[DS]
+ffi_call_DARWIN:
+#ifdef __64BIT__
+	.llong .ffi_call_DARWIN, TOC[tc0], 0
+#else
+	.long .ffi_call_DARWIN, TOC[tc0], 0
+#endif
+	.csect .text[PR]
+.ffi_call_DARWIN:
+	blr
+	.long 0
+	.byte 0,0,0,0,0,0,0,0
+/* END(ffi_call_DARWIN) */
+
+/* EH frame stuff.  */
+
+#define LR_REGNO		0x41		/* Link Register (65), see rs6000.md */
+#ifdef __64BIT__
+#define PTRSIZE			8
+#define LOG2_PTRSIZE		3
+#define FDE_ENCODING		0x1c		/* DW_EH_PE_pcrel|DW_EH_PE_sdata8 */
+#define EH_DATA_ALIGN_FACT	0x78		/* LEB128 -8 */
+#else
+#define PTRSIZE			4
+#define LOG2_PTRSIZE		2
+#define FDE_ENCODING		0x1b		/* DW_EH_PE_pcrel|DW_EH_PE_sdata4 */
+#define EH_DATA_ALIGN_FACT	0x7c		/* LEB128 -4 */
+#endif
+	.csect	_unwind.ro_[RO],4
+	.align	LOG2_PTRSIZE
+	.globl	_GLOBAL__F_libffi_src_powerpc_aix
+_GLOBAL__F_libffi_src_powerpc_aix:
+Lframe..1:
+	.vbyte	4,LECIE..1-LSCIE..1	/* CIE Length */
+LSCIE..1:
+	.vbyte	4,0			/* CIE Identifier Tag */
+	.byte	0x3			/* CIE Version */
+	.byte	"zR"			/* CIE Augmentation */
+	.byte	0
+	.byte	0x1			/* uleb128 0x1; CIE Code Alignment Factor */
+	.byte	EH_DATA_ALIGN_FACT	/* leb128 -4/-8; CIE Data Alignment Factor */
+	.byte	0x41			/* CIE RA Column */
+	.byte	0x1			/* uleb128 0x1; Augmentation size */
+	.byte	FDE_ENCODING		/* FDE Encoding (pcrel|sdata4/8) */
+	.byte	0xc			/* DW_CFA_def_cfa */
+	.byte	0x1			/*     uleb128 0x1; Register r1 */
+	.byte	0			/*     uleb128 0x0; Offset 0 */
+	.align	LOG2_PTRSIZE
+LECIE..1:
+LSFDE..1:
+	.vbyte	4,LEFDE..1-LASFDE..1	/* FDE Length */
+LASFDE..1:
+	.vbyte	4,LASFDE..1-Lframe..1	/* FDE CIE offset */
+	.vbyte	PTRSIZE,LFB..0-$	/* FDE initial location */
+	.vbyte	PTRSIZE,LFE..0-LFB..0	/* FDE address range */
+	.byte   0			/* uleb128 0x0; Augmentation size */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..0-LFB..0
+	.byte	0x11			/* DW_CFA_def_offset_extended_sf */
+	.byte	LR_REGNO		/*     uleb128 LR_REGNO; Register LR */
+	.byte	0x7e			/*     leb128 -2; Offset -2 (8/16) */
+	.byte	0x9f			/* DW_CFA_offset Register r31 */
+	.byte	0x1			/*     uleb128 0x1; Offset 1 (-4/-8) */
+	.byte	0x9e			/* DW_CFA_offset Register r30 */
+	.byte	0x2			/*     uleb128 0x2; Offset 2 (-8/-16) */
+	.byte	0x9d			/* DW_CFA_offset Register r29 */
+	.byte	0x3			/*     uleb128 0x3; Offset 3 (-12/-24) */
+	.byte	0x9c			/* DW_CFA_offset Register r28 */
+	.byte	0x4			/*     uleb128 0x4; Offset 4 (-16/-32) */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..1-LCFI..0
+	.byte	0xd			/* DW_CFA_def_cfa_register */
+	.byte	0x1c			/*     uleb128 28; Register r28 */
+	.align	LOG2_PTRSIZE
+LEFDE..1:
+LSFDE..2:
+	.vbyte	4,LEFDE..2-LASFDE..2	/* FDE Length */
+LASFDE..2:
+	.vbyte	4,LASFDE..2-Lframe..1	/* FDE CIE offset */
+	.vbyte	PTRSIZE,LFB..1-$	/* FDE initial location */
+	.vbyte	PTRSIZE,LFE..1-LFB..1	/* FDE address range */
+	.byte   0			/* uleb128 0x0; Augmentation size */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..2-LFB..1
+	.byte	0x11			/* DW_CFA_def_offset_extended_sf */
+	.byte	LR_REGNO		/*     uleb128 LR_REGNO; Register LR */
+	.byte	0x7e			/*     leb128 -2; Offset -2 (8/16) */
+	.byte	0x9f			/* DW_CFA_offset Register r31 */
+	.byte	0x1			/*     uleb128 0x1; Offset 1 (-4/-8) */
+	.byte	0x9e			/* DW_CFA_offset Register r30 */
+	.byte	0x2			/*     uleb128 0x2; Offset 2 (-8/-16) */
+	.byte	0x9d			/* DW_CFA_offset Register r29 */
+	.byte	0x3			/*     uleb128 0x3; Offset 3 (-12/-24) */
+	.byte	0x9c			/* DW_CFA_offset Register r28 */
+	.byte	0x4			/*     uleb128 0x4; Offset 4 (-16/-32) */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..3-LCFI..2
+	.byte	0xd			/* DW_CFA_def_cfa_register */
+	.byte	0x1c			/*     uleb128 28; Register r28 */
+	.align	LOG2_PTRSIZE
+LEFDE..2:
+	.vbyte	4,0			/* End of FDEs */
+
+	.csect	.text[PR]
+	.ref	_GLOBAL__F_libffi_src_powerpc_aix	/* Prevents garbage collection by AIX linker */
+
Index: libffi-3.4.6/src/powerpc/asm.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/asm.h b/libffi-3.4.6/src/powerpc/asm.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/asm.h	
@@ -0,0 +1,125 @@
+/* -----------------------------------------------------------------------
+   asm.h - Copyright (c) 1998 Geoffrey Keating
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define ASM_GLOBAL_DIRECTIVE .globl
+
+
+#define C_SYMBOL_NAME(name) name
+/* Macro for a label.  */
+#ifdef	__STDC__
+#define C_LABEL(name)		name##:
+#else
+#define C_LABEL(name)		name/**/:
+#endif
+
+/* This seems to always be the case on PPC.  */
+#define ALIGNARG(log2) log2
+/* For ELF we need the `.type' directive to make shared libs work right.  */
+#define ASM_TYPE_DIRECTIVE(name,typearg) .type name,typearg;
+#define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+/* If compiled for profiling, call `_mcount' at the start of each function.  */
+#ifdef	PROF
+/* The mcount code relies on the return address being on the stack
+   to locate our caller and so it can restore it; so store one just
+   for its benefit.  */
+#ifdef PIC
+#define CALL_MCOUNT							      \
+  .pushsection;								      \
+  .section ".data";							      \
+  .align ALIGNARG(2);							      \
+0:.long 0;								      \
+  .previous;								      \
+  mflr  %r0;								      \
+  stw   %r0,4(%r1);							      \
+  bl    _GLOBAL_OFFSET_TABLE_@local-4;					      \
+  mflr  %r11;								      \
+  lwz   %r0,0b@got(%r11);						      \
+  bl    JUMPTARGET(_mcount);
+#else  /* PIC */
+#define CALL_MCOUNT							      \
+  .section ".data";							      \
+  .align ALIGNARG(2);							      \
+0:.long 0;								      \
+  .previous;								      \
+  mflr  %r0;								      \
+  lis   %r11,0b@ha;							      \
+  stw   %r0,4(%r1);							      \
+  addi  %r0,%r11,0b@l;							      \
+  bl    JUMPTARGET(_mcount);
+#endif /* PIC */
+#else  /* PROF */
+#define CALL_MCOUNT		/* Do nothing.  */
+#endif /* PROF */
+
+#define	ENTRY(name)							      \
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name);				      \
+  ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function)			      \
+  .align ALIGNARG(2);							      \
+  C_LABEL(name)								      \
+  CALL_MCOUNT
+
+#define EALIGN_W_0  /* No words to insert.  */
+#define EALIGN_W_1  nop
+#define EALIGN_W_2  nop;nop
+#define EALIGN_W_3  nop;nop;nop
+#define EALIGN_W_4  EALIGN_W_3;nop
+#define EALIGN_W_5  EALIGN_W_4;nop
+#define EALIGN_W_6  EALIGN_W_5;nop
+#define EALIGN_W_7  EALIGN_W_6;nop
+
+/* EALIGN is like ENTRY, but does alignment to 'words'*4 bytes
+   past a 2^align boundary.  */
+#ifdef PROF
+#define EFFI_ALIGN(name, alignt, words)					      \
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name);				      \
+  ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function)			      \
+  .align ALIGNARG(2);							      \
+  C_LABEL(name)								      \
+  CALL_MCOUNT								      \
+  b 0f;									      \
+  .align ALIGNARG(alignt);						      \
+  EALIGN_W_##words;							      \
+  0:
+#else /* PROF */
+#define EFFI_ALIGN(name, alignt, words)					      \
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name);				      \
+  ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function)			      \
+  .align ALIGNARG(alignt);						      \
+  EALIGN_W_##words;							      \
+  C_LABEL(name)
+#endif
+
+#define END(name)							      \
+  ASM_SIZE_DIRECTIVE(name)
+
+#ifdef PIC
+#define JUMPTARGET(name) name##@plt
+#else
+#define JUMPTARGET(name) name
+#endif
+
+/* Local labels stripped out by the linker.  */
+#define L(x) .L##x
Index: libffi-3.4.6/src/powerpc/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffi.c b/libffi-3.4.6/src/powerpc/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffi.c	
@@ -0,0 +1,175 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (C) 2013 IBM
+           Copyright (C) 2011 Anthony Green
+           Copyright (C) 2011 Kyle Moffett
+           Copyright (C) 2008 Red Hat, Inc
+           Copyright (C) 2007, 2008 Free Software Foundation, Inc
+	   Copyright (c) 1998 Geoffrey Keating
+
+   PowerPC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include "ffi.h"
+#include "ffi_common.h"
+#include "ffi_powerpc.h"
+
+#if HAVE_LONG_DOUBLE_VARIANT
+/* Adjust ffi_type_longdouble.  */
+void FFI_HIDDEN
+ffi_prep_types (ffi_abi abi)
+{
+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+#  ifdef POWERPC64
+  ffi_prep_types_linux64 (abi);
+#  else
+  ffi_prep_types_sysv (abi);
+#  endif
+# endif
+}
+#endif
+
+/* Perform machine dependent cif processing */
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+#ifdef POWERPC64
+  return ffi_prep_cif_linux64 (cif);
+#else
+  return ffi_prep_cif_sysv (cif);
+#endif
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_machdep_var (ffi_cif *cif,
+			  unsigned int nfixedargs MAYBE_UNUSED,
+			  unsigned int ntotalargs MAYBE_UNUSED)
+{
+#ifdef POWERPC64
+  return ffi_prep_cif_linux64_var (cif, nfixedargs, ntotalargs);
+#else
+  return ffi_prep_cif_sysv (cif);
+#endif
+}
+
+static void
+ffi_call_int (ffi_cif *cif,
+	      void (*fn) (void),
+	      void *rvalue,
+	      void **avalue,
+	      void *closure)
+{
+  /* The final SYSV ABI says that structures smaller or equal 8 bytes
+     are returned in r3/r4.  A draft ABI used by linux instead returns
+     them in memory.
+
+     We bounce-buffer SYSV small struct return values so that sysv.S
+     can write r3 and r4 to memory without worrying about struct size.
+   
+     For ELFv2 ABI, use a bounce buffer for homogeneous structs too,
+     for similar reasons. This bounce buffer must be aligned to 16
+     bytes for use with homogeneous structs of vectors (float128).  */
+  float128 smst_buffer[8];
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  ecif.rvalue = rvalue;
+  if ((cif->flags & FLAG_RETURNS_SMST) != 0)
+    ecif.rvalue = smst_buffer;
+  /* Ensure that we have a valid struct return value.
+     FIXME: Isn't this just papering over a user problem?  */
+  else if (!rvalue && cif->rtype->type == FFI_TYPE_STRUCT)
+    ecif.rvalue = alloca (cif->rtype->size);
+
+#ifdef POWERPC64
+  ffi_call_LINUX64 (&ecif, fn, ecif.rvalue, cif->flags, closure,
+		    -(long) cif->bytes);
+#else
+  ffi_call_SYSV (&ecif, fn, ecif.rvalue, cif->flags, closure, -cif->bytes);
+#endif
+
+  /* Check for a bounce-buffered return value */
+  if (rvalue && ecif.rvalue == smst_buffer)
+    {
+      unsigned int rsize = cif->rtype->size;
+#ifndef __LITTLE_ENDIAN__
+      /* The SYSV ABI returns a structure of up to 4 bytes in size
+	 left-padded in r3.  */
+# ifndef POWERPC64
+      if (rsize <= 4)
+	memcpy (rvalue, (char *) smst_buffer + 4 - rsize, rsize);
+      else
+# endif
+	/* The SYSV ABI returns a structure of up to 8 bytes in size
+	   left-padded in r3/r4, and the ELFv2 ABI similarly returns a
+	   structure of up to 8 bytes in size left-padded in r3. But
+	   note that a structure of a single float is not paddded.  */
+	if (rsize <= 8 && (cif->flags & FLAG_RETURNS_FP) == 0)
+	  memcpy (rvalue, (char *) smst_buffer + 8 - rsize, rsize);
+	else
+#endif
+	  memcpy (rvalue, smst_buffer, rsize);
+    }
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	     void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure,
+		      ffi_cif *cif,
+		      void (*fun) (ffi_cif *, void *, void **, void *),
+		      void *user_data,
+		      void *codeloc)
+{
+#ifdef POWERPC64
+  return ffi_prep_closure_loc_linux64 (closure, cif, fun, user_data, codeloc);
+#else
+  return ffi_prep_closure_loc_sysv (closure, cif, fun, user_data, codeloc);
+#endif
+}
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure,
+		     ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+#ifdef POWERPC64
+  closure->tramp = ffi_go_closure_linux64;
+#else
+  closure->tramp = ffi_go_closure_sysv;
+#endif
+  closure->cif = cif;
+  closure->fun = fun;
+  return FFI_OK;
+}
Index: libffi-3.4.6/src/powerpc/t-aix
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/t-aix b/libffi-3.4.6/src/powerpc/t-aix
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/t-aix	
@@ -0,0 +1,5 @@
+# This file is needed by GCC in order to correctly build AIX FAT
+# library for libffi.
+# However, it has no sense to include this code here, as it depends
+# on GCC multilib architecture.
+# Thus, this file is a simple stub replaced in GCC repository.
Index: libffi-3.4.6/src/powerpc/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/sysv.S b/libffi-3.4.6/src/powerpc/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/sysv.S	
@@ -0,0 +1,173 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 1998 Geoffrey Keating
+   Copyright (C) 2007 Free Software Foundation, Inc
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <powerpc/asm.h>
+
+#ifndef POWERPC64
+FFI_HIDDEN(ffi_call_SYSV)
+ENTRY(ffi_call_SYSV)
+	.cfi_startproc
+	/* Save the old stack pointer as AP.  */
+	mr	%r10,%r1
+	.cfi_def_cfa_register 10
+
+	/* Allocate the stack space we need.  */
+	stwux	%r1,%r1,%r8
+	/* Save registers we use.  */
+	mflr	%r9
+	stw	%r28,-16(%r10)
+	stw	%r29,-12(%r10)
+	stw	%r30, -8(%r10)
+	stw	%r31, -4(%r10)
+	stw	%r9,   4(%r10)
+	.cfi_offset 65, 4
+	.cfi_offset 31, -4
+	.cfi_offset 30, -8
+	.cfi_offset 29, -12
+	.cfi_offset 28, -16
+
+	/* Save arguments over call...  */
+	stw	%r7,   -20(%r10)	/* closure, */
+	mr	%r31,%r6		/* flags, */
+	mr	%r30,%r5		/* rvalue, */
+	mr	%r29,%r4		/* function address, */
+	mr	%r28,%r10		/* our AP. */
+	.cfi_def_cfa_register 28
+
+	/* Call ffi_prep_args_SYSV.  */
+	mr	%r4,%r1
+	bl	ffi_prep_args_SYSV@local
+
+	/* Now do the call.  */
+	/* Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40,%r31
+	/* Get the address to call into CTR.  */
+	mtctr	%r29
+	/* Load all those argument registers.  */
+	lwz	%r3,-24-(8*4)(%r28)
+	lwz	%r4,-24-(7*4)(%r28)
+	lwz	%r5,-24-(6*4)(%r28)
+	lwz	%r6,-24-(5*4)(%r28)
+	bf-	5,1f
+	nop
+	lwz	%r7,-24-(4*4)(%r28)
+	lwz	%r8,-24-(3*4)(%r28)
+	lwz	%r9,-24-(2*4)(%r28)
+	lwz	%r10,-24-(1*4)(%r28)
+	nop
+1:
+
+#ifndef __NO_FPRS__
+	/* Load all the FP registers.  */
+	bf-	6,2f
+	lfd	%f1,-24-(8*4)-(8*8)(%r28)
+	lfd	%f2,-24-(8*4)-(7*8)(%r28)
+	lfd	%f3,-24-(8*4)-(6*8)(%r28)
+	lfd	%f4,-24-(8*4)-(5*8)(%r28)
+	nop
+	lfd	%f5,-24-(8*4)-(4*8)(%r28)
+	lfd	%f6,-24-(8*4)-(3*8)(%r28)
+	lfd	%f7,-24-(8*4)-(2*8)(%r28)
+	lfd	%f8,-24-(8*4)-(1*8)(%r28)
+#endif
+2:
+
+	/* Make the call.  */
+	lwz	%r11, -20(%r28)
+	bctrl
+
+	/* Now, deal with the return value.  */
+	mtcrf	0x03,%r31 /* cr6-cr7  */
+	bt-	31,L(small_struct_return_value)
+	bt-	30,L(done_return_value)
+#ifndef __NO_FPRS__
+	bt-	29,L(fp_return_value)
+#endif
+	stw	%r3,0(%r30)
+	bf+	27,L(done_return_value)
+	stw	%r4,4(%r30)
+	bf	26,L(done_return_value)
+	stw     %r5,8(%r30)
+	stw	%r6,12(%r30)
+	/* Fall through...  */
+
+L(done_return_value):
+	/* Restore the registers we used and return.  */
+	lwz	%r9,   4(%r28)
+	lwz	%r31, -4(%r28)
+	mtlr	%r9
+	lwz	%r30, -8(%r28)
+	lwz	%r29,-12(%r28)
+	lwz	%r28,-16(%r28)
+	.cfi_remember_state
+	/* At this point we don't have a cfa register.  Say all our
+	   saved regs have been restored.  */
+	.cfi_same_value 65
+	.cfi_same_value 31
+	.cfi_same_value 30
+	.cfi_same_value 29
+	.cfi_same_value 28
+	/* Hopefully this works..  */
+	.cfi_def_cfa_register 1
+	.cfi_offset 1, 0
+	lwz	%r1,0(%r1)
+	.cfi_same_value 1
+	blr
+
+#ifndef __NO_FPRS__
+L(fp_return_value):
+	.cfi_restore_state
+	bf	27,L(float_return_value)
+	stfd	%f1,0(%r30)
+	bf	26,L(done_return_value)
+	stfd	%f2,8(%r30)
+	b	L(done_return_value)
+L(float_return_value):
+	stfs	%f1,0(%r30)
+	b	L(done_return_value)
+#endif
+
+L(small_struct_return_value):
+	/*
+	 * The C code always allocates a properly-aligned 8-byte bounce
+	 * buffer to make this assembly code very simple.  Just write out
+	 * r3 and r4 to the buffer to allow the C code to handle the rest.
+	 */
+	stw %r3, 0(%r30)
+	stw %r4, 4(%r30)
+	b L(done_return_value)
+	.cfi_endproc
+
+END(ffi_call_SYSV)
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+#endif
Index: libffi-3.4.6/src/powerpc/darwin.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/darwin.S b/libffi-3.4.6/src/powerpc/darwin.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/darwin.S	
@@ -0,0 +1,378 @@
+/* -----------------------------------------------------------------------
+   darwin.S - Copyright (c) 2000 John Hornkvist
+	      Copyright (c) 2004, 2010 Free Software Foundation, Inc.
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#if defined(__ppc64__)
+#define MODE_CHOICE(x, y) y
+#else
+#define MODE_CHOICE(x, y) x
+#endif
+
+#define machine_choice	MODE_CHOICE(ppc7400,ppc64)
+
+; Define some pseudo-opcodes for size-independent load & store of GPRs ...
+#define lgu		MODE_CHOICE(lwzu, ldu)
+#define lg		MODE_CHOICE(lwz,ld)
+#define sg		MODE_CHOICE(stw,std)
+#define sgu		MODE_CHOICE(stwu,stdu)
+#define sgux		MODE_CHOICE(stwux,stdux)
+
+; ... and the size of GPRs and their storage indicator.
+#define GPR_BYTES	MODE_CHOICE(4,8)
+#define LOG2_GPR_BYTES	MODE_CHOICE(2,3)	/* log2(GPR_BYTES) */
+#define g_long		MODE_CHOICE(long, quad)	/* usage is ".g_long" */
+
+; From the ABI doc: "Mac OS X ABI Function Call Guide" Version 2009-02-04.
+#define LINKAGE_SIZE	MODE_CHOICE(24,48)
+#define PARAM_AREA	MODE_CHOICE(32,64)
+#define SAVED_LR_OFFSET	MODE_CHOICE(8,16)	/* save position for lr */
+
+/* If there is any FP stuff we make space for all of the regs.  */
+#define SAVED_FPR_COUNT 13
+#define FPR_SIZE	8
+#define RESULT_BYTES	16
+
+/* This should be kept in step with the same value in ffi_darwin.c.  */
+#define ASM_NEEDS_REGISTERS 4
+#define SAVE_REGS_SIZE (ASM_NEEDS_REGISTERS * GPR_BYTES)
+
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define JUMPTARGET(name) name
+#define L(x) x
+
+	.text
+	.align 2
+	.globl _ffi_prep_args
+
+	.align 2
+	.globl _ffi_call_DARWIN
+
+	/* We arrive here with:
+	   r3 = ptr to extended cif.
+	   r4 = -bytes.
+	   r5 = cif flags.
+	   r6 = ptr to return value.
+	   r7 = fn pointer (user func).
+	   r8 = fn pointer (ffi_prep_args).
+	   r9 = ffi_type* for the ret val.  */
+
+_ffi_call_DARWIN:
+Lstartcode:
+	mr   	r12,r8	/* We only need r12 until the call,
+			   so it does not have to be saved.  */
+LFB1:
+	/* Save the old stack pointer as AP.  */
+	mr	r8,r1
+LCFI0:
+	
+	/* Save the retval type in parents frame.  */
+	sg	r9,(LINKAGE_SIZE+6*GPR_BYTES)(r8)
+
+	/* Allocate the stack space we need.  */
+	sgux	r1,r1,r4
+
+	/* Save registers we use.  */
+	mflr	r9
+	sg	r9,SAVED_LR_OFFSET(r8)
+
+	sg	r28,-(4 * GPR_BYTES)(r8)	
+	sg	r29,-(3 * GPR_BYTES)(r8)
+	sg	r30,-(2 * GPR_BYTES)(r8)
+	sg	r31,-(    GPR_BYTES)(r8)
+
+#if !defined(POWERPC_DARWIN)
+	/* The TOC slot is reserved in the Darwin ABI and r2 is volatile.  */
+	sg	r2,(5 * GPR_BYTES)(r1)
+#endif
+
+LCFI1:
+
+	/* Save arguments over call.  */
+	mr	r31,r5	/* flags,  */
+	mr	r30,r6	/* rvalue,  */
+	mr	r29,r7	/* function address,  */
+	mr	r28,r8	/* our AP.  */
+LCFI2:
+	/* Call ffi_prep_args. r3 = extended cif, r4 = stack ptr copy.  */
+	mr	r4,r1
+	li	r9,0
+
+	mtctr	r12 /* r12 holds address of _ffi_prep_args.  */
+	bctrl
+
+#if !defined(POWERPC_DARWIN)
+	/* The TOC slot is reserved in the Darwin ABI and r2 is volatile.  */
+	lg     r2,(5 * GPR_BYTES)(r1)
+#endif
+	/* Now do the call.
+	   Set up cr1 with bits 4-7 of the flags.  */
+	mtcrf	0x40,r31
+	/* Get the address to call into CTR.  */
+	mtctr	r29
+	/* Load all those argument registers.
+	   We have set up a nice stack frame, just load it into registers.  */
+	lg     r3, (LINKAGE_SIZE                )(r1)
+	lg     r4, (LINKAGE_SIZE +     GPR_BYTES)(r1)
+	lg     r5, (LINKAGE_SIZE + 2 * GPR_BYTES)(r1)
+	lg     r6, (LINKAGE_SIZE + 3 * GPR_BYTES)(r1)
+	nop
+	lg     r7, (LINKAGE_SIZE + 4 * GPR_BYTES)(r1)
+	lg     r8, (LINKAGE_SIZE + 5 * GPR_BYTES)(r1)
+	lg     r9, (LINKAGE_SIZE + 6 * GPR_BYTES)(r1)
+	lg     r10,(LINKAGE_SIZE + 7 * GPR_BYTES)(r1)
+
+L1:
+	/* ... Load all the FP registers.  */
+	bf	6,L2	/* No floats to load.  */
+	lfd	f1, -SAVE_REGS_SIZE-(13*FPR_SIZE)(r28)
+	lfd	f2, -SAVE_REGS_SIZE-(12*FPR_SIZE)(r28)
+	lfd	f3, -SAVE_REGS_SIZE-(11*FPR_SIZE)(r28)
+	lfd	f4, -SAVE_REGS_SIZE-(10*FPR_SIZE)(r28)
+	nop
+	lfd	f5, -SAVE_REGS_SIZE-( 9*FPR_SIZE)(r28)
+	lfd	f6, -SAVE_REGS_SIZE-( 8*FPR_SIZE)(r28)
+	lfd	f7, -SAVE_REGS_SIZE-( 7*FPR_SIZE)(r28)
+	lfd	f8, -SAVE_REGS_SIZE-( 6*FPR_SIZE)(r28)
+	nop
+	lfd     f9, -SAVE_REGS_SIZE-( 5*FPR_SIZE)(r28)
+	lfd     f10,-SAVE_REGS_SIZE-( 4*FPR_SIZE)(r28)
+	lfd     f11,-SAVE_REGS_SIZE-( 3*FPR_SIZE)(r28)
+	lfd     f12,-SAVE_REGS_SIZE-( 2*FPR_SIZE)(r28)
+	nop
+	lfd     f13,-SAVE_REGS_SIZE-( 1*FPR_SIZE)(r28)
+
+L2:
+	mr	r12,r29	/* Put the target address in r12 as specified.  */
+	mtctr  	r12
+	nop
+	nop
+
+	/* Make the call.  */
+	bctrl
+
+	/* Now, deal with the return value.  */
+
+	/* m64 structure returns can occupy the same set of registers as
+	   would be used to pass such a structure as arg0 - so take care 
+	   not to step on any possibly hot regs.  */
+
+	/* Get the flags.. */
+	mtcrf	0x03,r31 ; we need c6 & cr7 now.
+	; FLAG_RETURNS_NOTHING also covers struct ret-by-ref.
+	bt	30,L(done_return_value)	  ; FLAG_RETURNS_NOTHING
+	bf	27,L(scalar_return_value) ; not FLAG_RETURNS_STRUCT
+	
+	/* OK, so we have a struct.  */
+#if defined(__ppc64__)
+	bt	31,L(maybe_return_128) ; FLAG_RETURNS_128BITS, special case 
+
+	/* OK, we have to map the return back to a mem struct.
+	   We are about to trample the parents param area, so recover the
+	   return type.  r29 is free, since the call is done.  */
+	lg	r29,(LINKAGE_SIZE + 6 * GPR_BYTES)(r28)
+
+	sg	r3, (LINKAGE_SIZE                )(r28)
+	sg	r4, (LINKAGE_SIZE +     GPR_BYTES)(r28)
+	sg	r5, (LINKAGE_SIZE + 2 * GPR_BYTES)(r28)
+	sg	r6, (LINKAGE_SIZE + 3 * GPR_BYTES)(r28)
+	nop
+	sg	r7, (LINKAGE_SIZE + 4 * GPR_BYTES)(r28)
+	sg	r8, (LINKAGE_SIZE + 5 * GPR_BYTES)(r28)
+	sg	r9, (LINKAGE_SIZE + 6 * GPR_BYTES)(r28)
+	sg	r10,(LINKAGE_SIZE + 7 * GPR_BYTES)(r28)
+	/* OK, so do the block move - we trust that memcpy will not trample
+	   the fprs...  */
+	mr 	r3,r30 ; dest
+	addi	r4,r28,LINKAGE_SIZE ; source
+	/* The size is a size_t, should be long.  */
+	lg	r5,0(r29)
+	/* Figure out small structs */
+	cmpi	0,r5,4
+	bgt	L3	; 1, 2 and 4 bytes have special rules.
+	cmpi	0,r5,3
+	beq	L3	; not 3
+	addi	r4,r4,8
+	subf	r4,r5,r4
+L3:
+	bl	_memcpy
+	
+	/* ... do we need the FP registers? - recover the flags.. */
+	mtcrf	0x03,r31 ; we need c6 & cr7 now.
+	bf	29,L(done_return_value)	/* No floats in the struct.  */
+	stfd	f1, -SAVE_REGS_SIZE-(13*FPR_SIZE)(r28)
+	stfd	f2, -SAVE_REGS_SIZE-(12*FPR_SIZE)(r28)
+	stfd	f3, -SAVE_REGS_SIZE-(11*FPR_SIZE)(r28)
+	stfd	f4, -SAVE_REGS_SIZE-(10*FPR_SIZE)(r28)
+	nop
+	stfd	f5, -SAVE_REGS_SIZE-( 9*FPR_SIZE)(r28)
+	stfd	f6, -SAVE_REGS_SIZE-( 8*FPR_SIZE)(r28)
+	stfd	f7, -SAVE_REGS_SIZE-( 7*FPR_SIZE)(r28)
+	stfd	f8, -SAVE_REGS_SIZE-( 6*FPR_SIZE)(r28)
+	nop
+	stfd	f9, -SAVE_REGS_SIZE-( 5*FPR_SIZE)(r28)
+	stfd	f10,-SAVE_REGS_SIZE-( 4*FPR_SIZE)(r28)
+	stfd	f11,-SAVE_REGS_SIZE-( 3*FPR_SIZE)(r28)
+	stfd	f12,-SAVE_REGS_SIZE-( 2*FPR_SIZE)(r28)
+	nop
+	stfd	f13,-SAVE_REGS_SIZE-( 1*FPR_SIZE)(r28)
+
+	mr	r3,r29	; ffi_type *
+	mr	r4,r30	; dest
+	addi	r5,r28,-SAVE_REGS_SIZE-(13*FPR_SIZE) ; fprs
+	xor	r6,r6,r6
+	sg	r6,(LINKAGE_SIZE + 7 * GPR_BYTES)(r28)
+	addi	r6,r28,(LINKAGE_SIZE + 7 * GPR_BYTES) ; point to a zeroed counter.
+	bl 	_darwin64_struct_floats_to_mem
+
+	b L(done_return_value)
+#else
+	stw	r3,0(r30) ; m32 the only struct return in reg is 4 bytes.
+#endif
+	b L(done_return_value)
+
+L(fp_return_value):
+	/* Do we have long double to store?  */
+	bf	31,L(fd_return_value) ; FLAG_RETURNS_128BITS
+	stfd	f1,0(r30)
+	stfd	f2,FPR_SIZE(r30)
+	b	L(done_return_value)
+
+L(fd_return_value):
+	/* Do we have double to store?  */
+	bf	28,L(float_return_value)
+	stfd	f1,0(r30)
+	b	L(done_return_value)
+
+L(float_return_value):
+	/* We only have a float to store.  */
+	stfs	f1,0(r30)
+	b	L(done_return_value)
+
+L(scalar_return_value):
+	bt	29,L(fp_return_value)	; FLAG_RETURNS_FP
+	; ffi_arg is defined as unsigned long. 
+	sg	r3,0(r30)		; Save the reg.
+	bf	28,L(done_return_value) ; not FLAG_RETURNS_64BITS 
+
+#if defined(__ppc64__)
+L(maybe_return_128):
+	std	r3,0(r30)
+	bf	31,L(done_return_value) ; not FLAG_RETURNS_128BITS 
+	std	r4,8(r30)
+#else
+	stw	r4,4(r30)
+#endif
+
+	/* Fall through.  */
+	/* We want this at the end to simplify eh epilog computation.  */
+
+L(done_return_value):
+	/* Restore the registers we used and return.  */
+	lg	r29,SAVED_LR_OFFSET(r28)
+	; epilog
+	lg	r31,-(1 * GPR_BYTES)(r28)
+	mtlr	r29
+	lg	r30,-(2 * GPR_BYTES)(r28)
+	lg	r29,-(3 * GPR_BYTES)(r28)
+	lg	r28,-(4 * GPR_BYTES)(r28)
+	lg	r1,0(r1)
+	blr
+LFE1:
+	.align	1
+/* END(_ffi_call_DARWIN)  */
+
+/* Provide a null definition of _ffi_call_AIX.  */
+	.text
+	.globl _ffi_call_AIX
+	.align 2
+_ffi_call_AIX:
+	blr
+/* END(_ffi_call_AIX)  */
+
+/* EH stuff.  */
+
+#define EH_DATA_ALIGN_FACT MODE_CHOICE(0x7c,0x78)
+
+	.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
+EH_frame1:
+	.set	L$set$0,LECIE1-LSCIE1
+	.long	L$set$0	; Length of Common Information Entry
+LSCIE1:
+	.long	0x0	; CIE Identifier Tag
+	.byte	0x1	; CIE Version
+	.ascii	"zR\0"	; CIE Augmentation
+	.byte	0x1	; uleb128 0x1; CIE Code Alignment Factor
+	.byte	EH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor
+	.byte	0x41	; CIE RA Column
+	.byte	0x1	; uleb128 0x1; Augmentation size
+	.byte	0x10	; FDE Encoding (pcrel)
+	.byte	0xc	; DW_CFA_def_cfa
+	.byte	0x1	; uleb128 0x1
+	.byte	0x0	; uleb128 0x0
+	.align	LOG2_GPR_BYTES
+LECIE1:
+
+	.globl _ffi_call_DARWIN.eh
+_ffi_call_DARWIN.eh:
+LSFDE1:
+	.set	L$set$1,LEFDE1-LASFDE1
+	.long	L$set$1	; FDE Length
+LASFDE1:
+	.long	LASFDE1-EH_frame1 ; FDE CIE offset
+	.g_long	Lstartcode-.	; FDE initial location
+	.set	L$set$3,LFE1-Lstartcode
+	.g_long	L$set$3	; FDE address range
+	.byte   0x0     ; uleb128 0x0; Augmentation size
+	.byte	0x4	; DW_CFA_advance_loc4
+	.set	L$set$4,LCFI0-Lstartcode
+	.long	L$set$4
+	.byte	0xd	; DW_CFA_def_cfa_register
+	.byte	0x08	; uleb128 0x08
+	.byte	0x4	; DW_CFA_advance_loc4
+	.set	L$set$5,LCFI1-LCFI0
+	.long	L$set$5
+	.byte   0x11    ; DW_CFA_offset_extended_sf
+	.byte	0x41	; uleb128 0x41
+	.byte   0x7e    ; sleb128 -2
+	.byte	0x9f	; DW_CFA_offset, column 0x1f
+	.byte	0x1	; uleb128 0x1
+	.byte	0x9e	; DW_CFA_offset, column 0x1e
+	.byte	0x2	; uleb128 0x2
+	.byte	0x9d	; DW_CFA_offset, column 0x1d
+	.byte	0x3	; uleb128 0x3
+	.byte	0x9c	; DW_CFA_offset, column 0x1c
+	.byte	0x4	; uleb128 0x4
+	.byte	0x4	; DW_CFA_advance_loc4
+	.set	L$set$6,LCFI2-LCFI1
+	.long	L$set$6
+	.byte	0xd	; DW_CFA_def_cfa_register
+	.byte	0x1c	; uleb128 0x1c
+	.align LOG2_GPR_BYTES
+LEFDE1:
+	.align 1
+
Index: libffi-3.4.6/src/powerpc/linux64.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/linux64.S b/libffi-3.4.6/src/powerpc/linux64.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/linux64.S	
@@ -0,0 +1,293 @@
+/* -----------------------------------------------------------------------
+   sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>
+	    Copyright (c) 2008 Red Hat, Inc.
+
+   PowerPC64 Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.machine altivec
+
+#ifdef POWERPC64
+	.hidden	ffi_call_LINUX64
+	.globl	ffi_call_LINUX64
+	.text
+	.cfi_startproc
+# if _CALL_ELF == 2
+ffi_call_LINUX64:
+#  ifndef __PCREL__
+	addis	%r2, %r12, .TOC.-ffi_call_LINUX64@ha
+	addi	%r2, %r2, .TOC.-ffi_call_LINUX64@l
+#  endif
+	.localentry ffi_call_LINUX64, . - ffi_call_LINUX64
+# else
+	.section	".opd","aw"
+	.align	3
+ffi_call_LINUX64:
+#  ifdef _CALL_LINUX
+	.quad	.L.ffi_call_LINUX64,.TOC.@tocbase,0
+	.type	ffi_call_LINUX64,@function
+	.text
+.L.ffi_call_LINUX64:
+#  else
+	.hidden	.ffi_call_LINUX64
+	.globl	.ffi_call_LINUX64
+	.quad	.ffi_call_LINUX64,.TOC.@tocbase,0
+	.size	ffi_call_LINUX64,24
+	.type	.ffi_call_LINUX64,@function
+	.text
+.ffi_call_LINUX64:
+#  endif
+# endif
+	mflr	%r0
+	std	%r28, -32(%r1)
+	std	%r29, -24(%r1)
+	std	%r30, -16(%r1)
+	std	%r31, -8(%r1)
+	std	%r7, 8(%r1)	/* closure, saved in cr field.  */
+	std	%r0, 16(%r1)
+
+	mr	%r28, %r1	/* our AP.  */
+	.cfi_def_cfa_register 28
+	.cfi_offset 65, 16
+	.cfi_offset 31, -8
+	.cfi_offset 30, -16
+	.cfi_offset 29, -24
+	.cfi_offset 28, -32
+
+	stdux	%r1, %r1, %r8
+	mr	%r31, %r6	/* flags, */
+	mr	%r30, %r5	/* rvalue, */
+	mr	%r29, %r4	/* function address.  */
+/* Save toc pointer, not for the ffi_prep_args64 call, but for the later
+   bctrl function call.  */
+# if _CALL_ELF == 2
+	std	%r2, 24(%r1)
+# else
+	std	%r2, 40(%r1)
+# endif
+
+	/* Call ffi_prep_args64.  */
+	mr	%r4, %r1
+# if defined _CALL_LINUX || _CALL_ELF == 2
+#  ifdef __PCREL__
+	bl	ffi_prep_args64@notoc
+#  else
+	bl	ffi_prep_args64
+	nop
+#  endif
+# else
+	bl	.ffi_prep_args64
+	nop
+# endif
+
+# if _CALL_ELF == 2
+	mr	%r12, %r29
+# else
+	ld	%r12, 0(%r29)
+	ld	%r2, 8(%r29)
+# endif
+	/* Now do the call.  */
+	/* Set up cr1 with bits 3-7 of the flags.  */
+	mtcrf	0xc0, %r31
+
+	/* Get the address to call into CTR.  */
+	mtctr	%r12
+	/* Load all those argument registers.  */
+	addi	%r29, %r28, -32-(8*8)
+	ld	%r3,  (0*8)(%r29)
+	ld	%r4,  (1*8)(%r29)
+	ld	%r5,  (2*8)(%r29)
+	ld	%r6,  (3*8)(%r29)
+	bf-	5, 1f
+	ld	%r7,  (4*8)(%r29)
+	ld	%r8,  (5*8)(%r29)
+	ld	%r9,  (6*8)(%r29)
+	ld	%r10, (7*8)(%r29)
+1:
+
+	/* Load all the FP registers.  */
+	bf-	6, 2f
+	addi	%r29, %r29, -(14*8)
+	lfd	%f1,  ( 1*8)(%r29)
+	lfd	%f2,  ( 2*8)(%r29)
+	lfd	%f3,  ( 3*8)(%r29)
+	lfd	%f4,  ( 4*8)(%r29)
+	lfd	%f5,  ( 5*8)(%r29)
+	lfd	%f6,  ( 6*8)(%r29)
+	lfd	%f7,  ( 7*8)(%r29)
+	lfd	%f8,  ( 8*8)(%r29)
+	lfd	%f9,  ( 9*8)(%r29)
+	lfd	%f10, (10*8)(%r29)
+	lfd	%f11, (11*8)(%r29)
+	lfd	%f12, (12*8)(%r29)
+	lfd	%f13, (13*8)(%r29)
+2:
+
+	/* Load all the vector registers.  */
+	bf-	3, 3f
+	addi	%r29, %r29, -16
+	lvx	%v13, 0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v12, 0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v11, 0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v10, 0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v9,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v8,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v7,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v6,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v5,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v4,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v3,  0, %r29
+	addi	%r29, %r29, -16
+	lvx	%v2,  0, %r29
+3:
+
+	/* Make the call.  */
+	ld	%r11, 8(%r28)
+	bctrl
+
+	/* This must follow the call immediately, the unwinder
+	   uses this to find out if r2 has been saved or not.  */
+# if _CALL_ELF == 2
+	ld	%r2, 24(%r1)
+# else
+	ld	%r2, 40(%r1)
+# endif
+
+	/* Now, deal with the return value.  */
+	mtcrf	0x01, %r31
+	bt	31, .Lstruct_return_value
+	bt	30, .Ldone_return_value
+	bt	29, .Lfp_return_value
+	bt	28, .Lvec_return_value
+	std	%r3, 0(%r30)
+	/* Fall through...  */
+
+.Ldone_return_value:
+	/* Restore the registers we used and return.  */
+	mr	%r1, %r28
+	.cfi_def_cfa_register 1
+	ld	%r0, 16(%r28)
+	ld	%r28, -32(%r28)
+	mtlr	%r0
+	ld	%r29, -24(%r1)
+	ld	%r30, -16(%r1)
+	ld	%r31, -8(%r1)
+	blr
+
+.Lvec_return_value:
+	stvx	%v2, 0, %r30
+	b	.Ldone_return_value
+
+.Lfp_return_value:
+	.cfi_def_cfa_register 28
+	mtcrf	0x02, %r31 /* cr6  */
+	bf	27, .Lfloat_return_value
+	stfd	%f1, 0(%r30)
+	bf	26, .Ldone_return_value
+	stfd	%f2, 8(%r30)
+	b	.Ldone_return_value
+.Lfloat_return_value:
+	stfs	%f1, 0(%r30)
+	b	.Ldone_return_value
+
+.Lstruct_return_value:
+	bf	29, .Lvec_homog_or_small_struct
+	mtcrf	0x02, %r31 /* cr6  */
+	bf	27, .Lfloat_homog_return_value
+	stfd	%f1, 0(%r30)
+	stfd	%f2, 8(%r30)
+	stfd	%f3, 16(%r30)
+	stfd	%f4, 24(%r30)
+	stfd	%f5, 32(%r30)
+	stfd	%f6, 40(%r30)
+	stfd	%f7, 48(%r30)
+	stfd	%f8, 56(%r30)
+	b	.Ldone_return_value
+
+.Lfloat_homog_return_value:
+	stfs	%f1, 0(%r30)
+	stfs	%f2, 4(%r30)
+	stfs	%f3, 8(%r30)
+	stfs	%f4, 12(%r30)
+	stfs	%f5, 16(%r30)
+	stfs	%f6, 20(%r30)
+	stfs	%f7, 24(%r30)
+	stfs	%f8, 28(%r30)
+	b	.Ldone_return_value
+
+.Lvec_homog_or_small_struct:
+	bf	28, .Lsmall_struct
+	stvx	%v2, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v3, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v4, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v5, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v6, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v7, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v8, 0, %r30
+	addi	%r30, %r30, 16
+	stvx	%v9, 0, %r30
+	b	.Ldone_return_value
+
+.Lsmall_struct:
+	std	%r3, 0(%r30)
+	std	%r4, 8(%r30)
+	b	.Ldone_return_value
+
+	.cfi_endproc
+# if _CALL_ELF == 2
+	.size	ffi_call_LINUX64,.-ffi_call_LINUX64
+# else
+#  ifdef _CALL_LINUX
+	.size	ffi_call_LINUX64,.-.L.ffi_call_LINUX64
+#  else
+	.long	0
+	.byte	0,12,0,1,128,4,0,0
+	.size	.ffi_call_LINUX64,.-.ffi_call_LINUX64
+#  endif
+# endif
+
+#endif
+
+#if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/powerpc/ffi_sysv.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffi_sysv.c b/libffi-3.4.6/src/powerpc/ffi_sysv.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffi_sysv.c	
@@ -0,0 +1,923 @@
+/* -----------------------------------------------------------------------
+   ffi_sysv.c - Copyright (C) 2013 IBM
+                Copyright (C) 2011 Anthony Green
+                Copyright (C) 2011 Kyle Moffett
+                Copyright (C) 2008 Red Hat, Inc
+                Copyright (C) 2007, 2008 Free Software Foundation, Inc
+                Copyright (c) 1998 Geoffrey Keating
+
+   PowerPC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include "ffi.h"
+
+#ifndef POWERPC64
+#include "ffi_common.h"
+#include "ffi_powerpc.h"
+
+
+/* About the SYSV ABI.  */
+#define ASM_NEEDS_REGISTERS 6
+#define NUM_GPR_ARG_REGISTERS 8
+#define NUM_FPR_ARG_REGISTERS 8
+
+
+#if HAVE_LONG_DOUBLE_VARIANT && FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+/* Adjust size of ffi_type_longdouble.  */
+void FFI_HIDDEN
+ffi_prep_types_sysv (ffi_abi abi)
+{
+  if ((abi & (FFI_SYSV | FFI_SYSV_LONG_DOUBLE_128)) == FFI_SYSV)
+    {
+      ffi_type_longdouble.size = 8;
+      ffi_type_longdouble.alignment = 8;
+    }
+  else
+    {
+      ffi_type_longdouble.size = 16;
+      ffi_type_longdouble.alignment = 16;
+    }
+}
+#endif
+
+/* Transform long double, double and float to other types as per abi.  */
+static int
+translate_float (int abi, int type)
+{
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+  if (type == FFI_TYPE_LONGDOUBLE
+      && (abi & FFI_SYSV_LONG_DOUBLE_128) == 0)
+    type = FFI_TYPE_DOUBLE;
+#endif
+  if ((abi & FFI_SYSV_SOFT_FLOAT) != 0)
+    {
+      if (type == FFI_TYPE_FLOAT)
+	type = FFI_TYPE_UINT32;
+      else if (type == FFI_TYPE_DOUBLE)
+	type = FFI_TYPE_UINT64;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      else if (type == FFI_TYPE_LONGDOUBLE)
+	type = FFI_TYPE_UINT128;
+    }
+  else if ((abi & FFI_SYSV_IBM_LONG_DOUBLE) == 0)
+    {
+      if (type == FFI_TYPE_LONGDOUBLE)
+	type = FFI_TYPE_STRUCT;
+#endif
+    }
+  return type;
+}
+
+/* Perform machine dependent cif processing */
+static ffi_status
+ffi_prep_cif_sysv_core (ffi_cif *cif)
+{
+  ffi_type **ptr;
+  unsigned bytes;
+  unsigned i, fpr_count = 0, gpr_count = 0, stack_count = 0;
+  unsigned flags = cif->flags;
+  unsigned struct_copy_size = 0;
+  unsigned type = cif->rtype->type;
+  unsigned size = cif->rtype->size;
+
+  /* The machine-independent calculation of cif->bytes doesn't work
+     for us.  Redo the calculation.  */
+
+  /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */
+  bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);
+
+  /* Space for the GPR registers.  */
+  bytes += NUM_GPR_ARG_REGISTERS * sizeof (int);
+
+  /* Return value handling.  The rules for SYSV are as follows:
+     - 32-bit (or less) integer values are returned in gpr3;
+     - Structures of size <= 4 bytes also returned in gpr3;
+     - 64-bit integer values and structures between 5 and 8 bytes are returned
+     in gpr3 and gpr4;
+     - Larger structures are allocated space and a pointer is passed as
+     the first argument.
+     - Single/double FP values are returned in fpr1;
+     - long doubles (if not equivalent to double) are returned in
+     fpr1,fpr2 for Linux and as for large structs for SysV.  */
+
+  type = translate_float (cif->abi, type);
+
+  switch (type)
+    {
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      flags |= FLAG_RETURNS_128BITS;
+      /* Fall through.  */
+#endif
+    case FFI_TYPE_DOUBLE:
+      flags |= FLAG_RETURNS_64BITS;
+      /* Fall through.  */
+    case FFI_TYPE_FLOAT:
+      flags |= FLAG_RETURNS_FP;
+#ifdef __NO_FPRS__
+      return FFI_BAD_ABI;
+#endif
+      break;
+
+    case FFI_TYPE_UINT128:
+      flags |= FLAG_RETURNS_128BITS;
+      /* Fall through.  */
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      flags |= FLAG_RETURNS_64BITS;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* The final SYSV ABI says that structures smaller or equal 8 bytes
+	 are returned in r3/r4.  A draft ABI used by linux instead
+	 returns them in memory.  */
+      if ((cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8)
+	{
+	  flags |= FLAG_RETURNS_SMST;
+	  break;
+	}
+      gpr_count++;
+      flags |= FLAG_RETVAL_REFERENCE;
+      /* Fall through.  */
+    case FFI_TYPE_VOID:
+      flags |= FLAG_RETURNS_NOTHING;
+      break;
+
+    default:
+      /* Returns 32-bit integer, or similar.  Nothing to do here.  */
+      break;
+    }
+
+  /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the
+     first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest
+     goes on the stack.  Structures and long doubles (if not equivalent
+     to double) are passed as a pointer to a copy of the structure.
+     Stuff on the stack needs to keep proper alignment.  */
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+      unsigned short typenum = (*ptr)->type;
+
+      typenum = translate_float (cif->abi, typenum);
+
+      switch (typenum)
+	{
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  if (fpr_count >= NUM_FPR_ARG_REGISTERS - 1)
+	    {
+	      fpr_count = NUM_FPR_ARG_REGISTERS;
+	      /* 8-byte align long doubles.  */
+	      stack_count += stack_count & 1;
+	      stack_count += 4;
+	    }
+	  else
+	    fpr_count += 2;
+#ifdef __NO_FPRS__
+	  return FFI_BAD_ABI;
+#endif
+	  break;
+#endif
+
+	case FFI_TYPE_DOUBLE:
+	  if (fpr_count >= NUM_FPR_ARG_REGISTERS)
+	    {
+	      /* 8-byte align doubles.  */
+	      stack_count += stack_count & 1;
+	      stack_count += 2;
+	    }
+	  else
+	    fpr_count += 1;
+#ifdef __NO_FPRS__
+	  return FFI_BAD_ABI;
+#endif
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  if (fpr_count >= NUM_FPR_ARG_REGISTERS)
+	    /* Yes, we don't follow the ABI, but neither does gcc.  */
+	    stack_count += 1;
+	  else
+	    fpr_count += 1;
+#ifdef __NO_FPRS__
+	  return FFI_BAD_ABI;
+#endif
+	  break;
+
+	case FFI_TYPE_UINT128:
+	  /* A long double in FFI_LINUX_SOFT_FLOAT can use only a set
+	     of four consecutive gprs. If we do not have enough, we
+	     have to adjust the gpr_count value.  */
+	  if (gpr_count >= NUM_GPR_ARG_REGISTERS - 3)
+	    gpr_count = NUM_GPR_ARG_REGISTERS;
+	  if (gpr_count >= NUM_GPR_ARG_REGISTERS)
+	    stack_count += 4;
+	  else
+	    gpr_count += 4;
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  /* 'long long' arguments are passed as two words, but
+	     either both words must fit in registers or both go
+	     on the stack.  If they go on the stack, they must
+	     be 8-byte-aligned.
+
+	     Also, only certain register pairs can be used for
+	     passing long long int -- specifically (r3,r4), (r5,r6),
+	     (r7,r8), (r9,r10).  */
+	  gpr_count += gpr_count & 1;
+	  if (gpr_count >= NUM_GPR_ARG_REGISTERS)
+	    {
+	      stack_count += stack_count & 1;
+	      stack_count += 2;
+	    }
+	  else
+	    gpr_count += 2;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  /* We must allocate space for a copy of these to enforce
+	     pass-by-value.  Pad the space up to a multiple of 16
+	     bytes (the maximum alignment required for anything under
+	     the SYSV ABI).  */
+	  struct_copy_size += ((*ptr)->size + 15) & ~0xF;
+	  /* Fall through (allocate space for the pointer).  */
+
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	  /* Everything else is passed as a 4-byte word in a GPR, either
+	     the object itself or a pointer to it.  */
+	  if (gpr_count >= NUM_GPR_ARG_REGISTERS)
+	    stack_count += 1;
+	  else
+	    gpr_count += 1;
+	  break;
+
+	default:
+	  FFI_ASSERT (0);
+	}
+    }
+
+  if (fpr_count != 0)
+    flags |= FLAG_FP_ARGUMENTS;
+  if (gpr_count > 4)
+    flags |= FLAG_4_GPR_ARGUMENTS;
+  if (struct_copy_size != 0)
+    flags |= FLAG_ARG_NEEDS_COPY;
+
+  /* Space for the FPR registers, if needed.  */
+  if (fpr_count != 0)
+    bytes += NUM_FPR_ARG_REGISTERS * sizeof (double);
+
+  /* Stack space.  */
+  bytes += stack_count * sizeof (int);
+
+  /* The stack space allocated needs to be a multiple of 16 bytes.  */
+  bytes = (bytes + 15) & ~0xF;
+
+  /* Add in the space for the copied structures.  */
+  bytes += struct_copy_size;
+
+  cif->flags = flags;
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_sysv (ffi_cif *cif)
+{
+  if ((cif->abi & FFI_SYSV) == 0)
+    {
+      /* This call is from old code.  Translate to new ABI values.  */
+      cif->flags |= FLAG_COMPAT;
+      switch (cif->abi)
+	{
+	default:
+	  return FFI_BAD_ABI;
+
+	case FFI_COMPAT_SYSV:
+	  cif->abi = FFI_SYSV | FFI_SYSV_STRUCT_RET | FFI_SYSV_LONG_DOUBLE_128;
+	  break;
+
+	case FFI_COMPAT_GCC_SYSV:
+	  cif->abi = FFI_SYSV | FFI_SYSV_LONG_DOUBLE_128;
+	  break;
+
+	case FFI_COMPAT_LINUX:
+	  cif->abi = (FFI_SYSV | FFI_SYSV_IBM_LONG_DOUBLE
+		      | FFI_SYSV_LONG_DOUBLE_128);
+	  break;
+
+	case FFI_COMPAT_LINUX_SOFT_FLOAT:
+	  cif->abi = (FFI_SYSV | FFI_SYSV_SOFT_FLOAT | FFI_SYSV_IBM_LONG_DOUBLE
+		      | FFI_SYSV_LONG_DOUBLE_128);
+	  break;
+	}
+    }
+  return ffi_prep_cif_sysv_core (cif);
+}
+
+/* ffi_prep_args_SYSV is called by the assembly routine once stack space
+   has been allocated for the function's arguments.
+
+   The stack layout we want looks like this:
+
+   |   Return address from ffi_call_SYSV 4bytes	|	higher addresses
+   |--------------------------------------------|
+   |   Previous backchain pointer	4	|       stack pointer here
+   |--------------------------------------------|<+ <<<	on entry to
+   |   Saved r28-r31			4*4	| |	ffi_call_SYSV
+   |--------------------------------------------| |
+   |   GPR registers r3-r10		8*4	| |	ffi_call_SYSV
+   |--------------------------------------------| |
+   |   FPR registers f1-f8 (optional)	8*8	| |
+   |--------------------------------------------| |	stack	|
+   |   Space for copied structures		| |	grows	|
+   |--------------------------------------------| |	down    V
+   |   Parameters that didn't fit in registers  | |
+   |--------------------------------------------| |	lower addresses
+   |   Space for callee's LR		4	| |
+   |--------------------------------------------| |	stack pointer here
+   |   Current backchain pointer	4	|-/	during
+   |--------------------------------------------|   <<<	ffi_call_SYSV
+
+*/
+
+void FFI_HIDDEN
+ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)
+{
+  const unsigned bytes = ecif->cif->bytes;
+  const unsigned flags = ecif->cif->flags;
+
+  typedef union
+  {
+    char *c;
+    unsigned *u;
+    long long *ll;
+    float *f;
+    double *d;
+  } valp;
+
+  /* 'stacktop' points at the previous backchain pointer.  */
+  valp stacktop;
+
+  /* 'gpr_base' points at the space for gpr3, and grows upwards as
+     we use GPR registers.  */
+  valp gpr_base;
+  valp gpr_end;
+
+#ifndef __NO_FPRS__
+  /* 'fpr_base' points at the space for fpr1, and grows upwards as
+     we use FPR registers.  */
+  valp fpr_base;
+  valp fpr_end;
+#endif
+
+  /* 'copy_space' grows down as we put structures in it.  It should
+     stay 16-byte aligned.  */
+  valp copy_space;
+
+  /* 'next_arg' grows up as we put parameters in it.  */
+  valp next_arg;
+
+  int i;
+  ffi_type **ptr;
+#ifndef __NO_FPRS__
+  double double_tmp;
+#endif
+  union
+  {
+    void **v;
+    char **c;
+    signed char **sc;
+    unsigned char **uc;
+    signed short **ss;
+    unsigned short **us;
+    unsigned int **ui;
+    long long **ll;
+    float **f;
+    double **d;
+  } p_argv;
+  size_t struct_copy_size;
+  unsigned gprvalue;
+
+  stacktop.c = (char *) stack + bytes;
+  gpr_end.u = stacktop.u - ASM_NEEDS_REGISTERS;
+  gpr_base.u = gpr_end.u - NUM_GPR_ARG_REGISTERS;
+#ifndef __NO_FPRS__
+  fpr_end.d = gpr_base.d;
+  fpr_base.d = fpr_end.d - NUM_FPR_ARG_REGISTERS;
+  copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);
+#else
+  copy_space.c = gpr_base.c;
+#endif
+  next_arg.u = stack + 2;
+
+  /* Check that everything starts aligned properly.  */
+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) copy_space.c & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);
+  FFI_ASSERT ((bytes & 0xF) == 0);
+  FFI_ASSERT (copy_space.c >= next_arg.c);
+
+  /* Deal with return values that are actually pass-by-reference.  */
+  if (flags & FLAG_RETVAL_REFERENCE)
+    *gpr_base.u++ = (unsigned) (char *) ecif->rvalue;
+
+  /* Now for the arguments.  */
+  p_argv.v = ecif->avalue;
+  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;
+       i > 0;
+       i--, ptr++, p_argv.v++)
+    {
+      unsigned int typenum = (*ptr)->type;
+
+      typenum = translate_float (ecif->cif->abi, typenum);
+
+      /* Now test the translated value */
+      switch (typenum)
+	{
+#ifndef __NO_FPRS__
+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  double_tmp = (*p_argv.d)[0];
+
+	  if (fpr_base.d >= fpr_end.d - 1)
+	    {
+	      fpr_base.d = fpr_end.d;
+	      if (((next_arg.u - stack) & 1) != 0)
+		next_arg.u += 1;
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
+	      double_tmp = (*p_argv.d)[1];
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
+	    }
+	  else
+	    {
+	      *fpr_base.d++ = double_tmp;
+	      double_tmp = (*p_argv.d)[1];
+	      *fpr_base.d++ = double_tmp;
+	    }
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+# endif
+	case FFI_TYPE_DOUBLE:
+	  double_tmp = **p_argv.d;
+
+	  if (fpr_base.d >= fpr_end.d)
+	    {
+	      if (((next_arg.u - stack) & 1) != 0)
+		next_arg.u += 1;
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
+	    }
+	  else
+	    *fpr_base.d++ = double_tmp;
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  double_tmp = **p_argv.f;
+	  if (fpr_base.d >= fpr_end.d)
+	    {
+	      *next_arg.f = (float) double_tmp;
+	      next_arg.u += 1;
+	    }
+	  else
+	    *fpr_base.d++ = double_tmp;
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+#endif /* have FPRs */
+
+	case FFI_TYPE_UINT128:
+	  /* The soft float ABI for long doubles works like this, a long double
+	     is passed in four consecutive GPRs if available.  A maximum of 2
+	     long doubles can be passed in gprs.  If we do not have 4 GPRs
+	     left, the long double is passed on the stack, 4-byte aligned.  */
+	  if (gpr_base.u >= gpr_end.u - 3)
+	    {
+	      unsigned int ii;
+	      gpr_base.u = gpr_end.u;
+	      for (ii = 0; ii < 4; ii++)
+		{
+		  unsigned int int_tmp = (*p_argv.ui)[ii];
+		  *next_arg.u++ = int_tmp;
+		}
+	    }
+	  else
+	    {
+	      unsigned int ii;
+	      for (ii = 0; ii < 4; ii++)
+		{
+		  unsigned int int_tmp = (*p_argv.ui)[ii];
+		  *gpr_base.u++ = int_tmp;
+		}
+	    }
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  if (gpr_base.u >= gpr_end.u - 1)
+	    {
+	      gpr_base.u = gpr_end.u;
+	      if (((next_arg.u - stack) & 1) != 0)
+		next_arg.u++;
+	      *next_arg.ll = **p_argv.ll;
+	      next_arg.u += 2;
+	    }
+	  else
+	    {
+	      /* The abi states only certain register pairs can be
+		 used for passing long long int specifically (r3,r4),
+		 (r5,r6), (r7,r8), (r9,r10).  If next arg is long long
+		 but not correct starting register of pair then skip
+		 until the proper starting register.  */
+	      if (((gpr_end.u - gpr_base.u) & 1) != 0)
+		gpr_base.u++;
+	      *gpr_base.ll++ = **p_argv.ll;
+	    }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  struct_copy_size = ((*ptr)->size + 15) & ~0xF;
+	  copy_space.c -= struct_copy_size;
+	  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);
+
+	  gprvalue = (unsigned long) copy_space.c;
+
+	  FFI_ASSERT (copy_space.c > next_arg.c);
+	  FFI_ASSERT (flags & FLAG_ARG_NEEDS_COPY);
+	  goto putgpr;
+
+	case FFI_TYPE_UINT8:
+	  gprvalue = **p_argv.uc;
+	  goto putgpr;
+	case FFI_TYPE_SINT8:
+	  gprvalue = **p_argv.sc;
+	  goto putgpr;
+	case FFI_TYPE_UINT16:
+	  gprvalue = **p_argv.us;
+	  goto putgpr;
+	case FFI_TYPE_SINT16:
+	  gprvalue = **p_argv.ss;
+	  goto putgpr;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+
+	  gprvalue = **p_argv.ui;
+
+	putgpr:
+	  if (gpr_base.u >= gpr_end.u)
+	    *next_arg.u++ = gprvalue;
+	  else
+	    *gpr_base.u++ = gprvalue;
+	  break;
+	}
+    }
+
+  /* Check that we didn't overrun the stack...  */
+  FFI_ASSERT (copy_space.c >= next_arg.c);
+  FFI_ASSERT (gpr_base.u <= gpr_end.u);
+#ifndef __NO_FPRS__
+  FFI_ASSERT (fpr_base.u <= fpr_end.u);
+#endif
+  FFI_ASSERT (((flags & FLAG_4_GPR_ARGUMENTS) != 0)
+	      == (gpr_end.u - gpr_base.u < 4));
+}
+
+#define MIN_CACHE_LINE_SIZE 8
+
+static void
+flush_icache (char *wraddr, char *xaddr, int size)
+{
+  int i;
+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)
+    __asm__ volatile ("icbi 0,%0;" "dcbf 0,%1;"
+		      : : "r" (xaddr + i), "r" (wraddr + i) : "memory");
+  __asm__ volatile ("icbi 0,%0;" "dcbf 0,%1;" "sync;" "isync;"
+		    : : "r"(xaddr + size - 1), "r"(wraddr + size - 1)
+		    : "memory");
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_closure_loc_sysv (ffi_closure *closure,
+			   ffi_cif *cif,
+			   void (*fun) (ffi_cif *, void *, void **, void *),
+			   void *user_data,
+			   void *codeloc)
+{
+  unsigned int *tramp;
+
+  if (cif->abi < FFI_SYSV || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  tramp = (unsigned int *) &closure->tramp[0];
+  tramp[0] = 0x7c0802a6;  /*   mflr    r0 */
+  tramp[1] = 0x429f0005;  /*   bcl     20,31,.+4 */
+  tramp[2] = 0x7d6802a6;  /*   mflr    r11 */
+  tramp[3] = 0x7c0803a6;  /*   mtlr    r0 */
+  tramp[4] = 0x800b0018;  /*   lwz     r0,24(r11) */
+  tramp[5] = 0x816b001c;  /*   lwz     r11,28(r11) */
+  tramp[6] = 0x7c0903a6;  /*   mtctr   r0 */
+  tramp[7] = 0x4e800420;  /*   bctr */
+  *(void **) &tramp[8] = (void *) ffi_closure_SYSV; /* function */
+  *(void **) &tramp[9] = codeloc;                   /* context */
+
+  /* Flush the icache.  */
+  flush_icache ((char *)tramp, (char *)codeloc, 8 * 4);
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+/* Basically the trampoline invokes ffi_closure_SYSV, and on
+   entry, r11 holds the address of the closure.
+   After storing the registers that could possibly contain
+   parameters to be passed into the stack frame and setting
+   up space for a return value, ffi_closure_SYSV invokes the
+   following helper function to do most of the work.  */
+
+int
+ffi_closure_helper_SYSV (ffi_cif *cif,
+			 void (*fun) (ffi_cif *, void *, void **, void *),
+			 void *user_data,
+			 void *rvalue,
+			 unsigned long *pgr,
+			 ffi_dblfl *pfr,
+			 unsigned long *pst)
+{
+  /* rvalue is the pointer to space for return value in closure assembly */
+  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */
+  /* pfr is the pointer to where f1-f8 are stored in ffi_closure_SYSV  */
+  /* pst is the pointer to outgoing parameter stack in original caller */
+
+  void **          avalue;
+  ffi_type **      arg_types;
+  long             i, avn;
+#ifndef __NO_FPRS__
+  long             nf = 0;   /* number of floating registers already used */
+#endif
+  long             ng = 0;   /* number of general registers already used */
+
+  unsigned       size     = cif->rtype->size;
+  unsigned short rtypenum = cif->rtype->type;
+
+  avalue = alloca (cif->nargs * sizeof (void *));
+
+  /* First translate for softfloat/nonlinux */
+  rtypenum = translate_float (cif->abi, rtypenum);
+
+  /* Copy the caller's structure return value address so that the closure
+     returns the data directly to the caller.
+     For FFI_SYSV the result is passed in r3/r4 if the struct size is less
+     or equal 8 bytes.  */
+  if (rtypenum == FFI_TYPE_STRUCT
+      && !((cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8))
+    {
+      rvalue = (void *) *pgr;
+      ng++;
+      pgr++;
+    }
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  while (i < avn) {
+    unsigned short typenum = arg_types[i]->type;
+
+    /* We may need to handle some values depending on ABI.  */
+    typenum = translate_float (cif->abi, typenum);
+
+    switch (typenum)
+      {
+#ifndef __NO_FPRS__
+      case FFI_TYPE_FLOAT:
+	/* Unfortunately float values are stored as doubles
+	   in the ffi_closure_SYSV code (since we don't check
+	   the type in that routine).  */
+	if (nf < NUM_FPR_ARG_REGISTERS)
+	  {
+	    /* FIXME? here we are really changing the values
+	       stored in the original calling routines outgoing
+	       parameter stack.  This is probably a really
+	       naughty thing to do but...  */
+	    double temp = pfr->d;
+	    pfr->f = (float) temp;
+	    avalue[i] = pfr;
+	    nf++;
+	    pfr++;
+	  }
+	else
+	  {
+	    avalue[i] = pst;
+	    pst += 1;
+	  }
+	break;
+
+      case FFI_TYPE_DOUBLE:
+	if (nf < NUM_FPR_ARG_REGISTERS)
+	  {
+	    avalue[i] = pfr;
+	    nf++;
+	    pfr++;
+	  }
+	else
+	  {
+	    if (((long) pst) & 4)
+	      pst++;
+	    avalue[i] = pst;
+	    pst += 2;
+	  }
+	break;
+
+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      case FFI_TYPE_LONGDOUBLE:
+	if (nf < NUM_FPR_ARG_REGISTERS - 1)
+	  {
+	    avalue[i] = pfr;
+	    pfr += 2;
+	    nf += 2;
+	  }
+	else
+	  {
+	    if (((long) pst) & 4)
+	      pst++;
+	    avalue[i] = pst;
+	    pst += 4;
+	    nf = 8;
+	  }
+	break;
+# endif
+#endif
+
+      case FFI_TYPE_UINT128:
+	/* Test if for the whole long double, 4 gprs are available.
+	   otherwise the stuff ends up on the stack.  */
+	if (ng < NUM_GPR_ARG_REGISTERS - 3)
+	  {
+	    avalue[i] = pgr;
+	    pgr += 4;
+	    ng += 4;
+	  }
+	else
+	  {
+	    avalue[i] = pst;
+	    pst += 4;
+	    ng = 8+4;
+	  }
+	break;
+
+      case FFI_TYPE_SINT8:
+      case FFI_TYPE_UINT8:
+#ifndef __LITTLE_ENDIAN__
+	if (ng < NUM_GPR_ARG_REGISTERS)
+	  {
+	    avalue[i] = (char *) pgr + 3;
+	    ng++;
+	    pgr++;
+	  }
+	else
+	  {
+	    avalue[i] = (char *) pst + 3;
+	    pst++;
+	  }
+	break;
+#endif
+
+      case FFI_TYPE_SINT16:
+      case FFI_TYPE_UINT16:
+#ifndef __LITTLE_ENDIAN__
+	if (ng < NUM_GPR_ARG_REGISTERS)
+	  {
+	    avalue[i] = (char *) pgr + 2;
+	    ng++;
+	    pgr++;
+	  }
+	else
+	  {
+	    avalue[i] = (char *) pst + 2;
+	    pst++;
+	  }
+	break;
+#endif
+
+      case FFI_TYPE_SINT32:
+      case FFI_TYPE_UINT32:
+      case FFI_TYPE_POINTER:
+	if (ng < NUM_GPR_ARG_REGISTERS)
+	  {
+	    avalue[i] = pgr;
+	    ng++;
+	    pgr++;
+	  }
+	else
+	  {
+	    avalue[i] = pst;
+	    pst++;
+	  }
+	break;
+
+      case FFI_TYPE_STRUCT:
+	/* Structs are passed by reference. The address will appear in a
+	   gpr if it is one of the first 8 arguments.  */
+	if (ng < NUM_GPR_ARG_REGISTERS)
+	  {
+	    avalue[i] = (void *) *pgr;
+	    ng++;
+	    pgr++;
+	  }
+	else
+	  {
+	    avalue[i] = (void *) *pst;
+	    pst++;
+	  }
+	break;
+
+      case FFI_TYPE_SINT64:
+      case FFI_TYPE_UINT64:
+	/* Passing long long ints are complex, they must
+	   be passed in suitable register pairs such as
+	   (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)
+	   and if the entire pair aren't available then the outgoing
+	   parameter stack is used for both but an alignment of 8
+	   must will be kept.  So we must either look in pgr
+	   or pst to find the correct address for this type
+	   of parameter.  */
+	if (ng < NUM_GPR_ARG_REGISTERS - 1)
+	  {
+	    if (ng & 1)
+	      {
+		/* skip r4, r6, r8 as starting points */
+		ng++;
+		pgr++;
+	      }
+	    avalue[i] = pgr;
+	    ng += 2;
+	    pgr += 2;
+	  }
+	else
+	  {
+	    if (((long) pst) & 4)
+	      pst++;
+	    avalue[i] = pst;
+	    pst += 2;
+	    ng = NUM_GPR_ARG_REGISTERS;
+	  }
+	break;
+
+      default:
+	FFI_ASSERT (0);
+      }
+
+    i++;
+  }
+
+  (*fun) (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_SYSV how to perform return type promotions.
+     Because the FFI_SYSV ABI returns the structures <= 8 bytes in
+     r3/r4 we have to tell ffi_closure_SYSV how to treat them.  We
+     combine the base type FFI_SYSV_TYPE_SMALL_STRUCT with the size of
+     the struct less one.  We never have a struct with size zero.
+     See the comment in ffitarget.h about ordering.  */
+  if (rtypenum == FFI_TYPE_STRUCT
+      && (cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8)
+    return FFI_SYSV_TYPE_SMALL_STRUCT - 1 + size;
+  return rtypenum;
+}
+#endif
Index: libffi-3.4.6/src/powerpc/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffitarget.h b/libffi-3.4.6/src/powerpc/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffitarget.h	
@@ -0,0 +1,204 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012  Anthony Green
+                 Copyright (C) 2007, 2008, 2010 Free Software Foundation, Inc
+                 Copyright (c) 1996-2003  Red Hat, Inc.
+
+   Target configuration macros for PowerPC.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+#if defined (POWERPC) && defined (__powerpc64__)	/* linux64 */
+#ifndef POWERPC64
+#define POWERPC64
+#endif
+#elif defined (POWERPC_DARWIN) && defined (__ppc64__)	/* Darwin64 */
+#ifndef POWERPC64
+#define POWERPC64
+#endif
+#ifndef POWERPC_DARWIN64
+#define POWERPC_DARWIN64
+#endif
+#elif defined (POWERPC_AIX) && defined (__64BIT__)	/* AIX64 */
+#ifndef POWERPC64
+#define POWERPC64
+#endif
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+
+#if defined (POWERPC_AIX)
+  FFI_AIX,
+  FFI_DARWIN,
+  FFI_DEFAULT_ABI = FFI_AIX,
+  FFI_LAST_ABI
+
+#elif defined (POWERPC_DARWIN)
+  FFI_AIX,
+  FFI_DARWIN,
+  FFI_DEFAULT_ABI = FFI_DARWIN,
+  FFI_LAST_ABI
+
+#else
+  /* The FFI_COMPAT values are used by old code.  Since libffi may be
+     a shared library we have to support old values for backwards
+     compatibility.  */
+  FFI_COMPAT_SYSV,
+  FFI_COMPAT_GCC_SYSV,
+  FFI_COMPAT_LINUX64,
+  FFI_COMPAT_LINUX,
+  FFI_COMPAT_LINUX_SOFT_FLOAT,
+
+# if defined (POWERPC64)
+  /* This bit, always set in new code, must not be set in any of the
+     old FFI_COMPAT values that might be used for 64-bit linux.  We
+     only need worry about FFI_COMPAT_LINUX64, but to be safe avoid
+     all old values.  */
+  FFI_LINUX = 8,
+  /* This and following bits can reuse FFI_COMPAT values.  */
+  FFI_LINUX_STRUCT_ALIGN = 1,
+  FFI_LINUX_LONG_DOUBLE_128 = 2,
+  FFI_LINUX_LONG_DOUBLE_IEEE128 = 4,
+  FFI_DEFAULT_ABI = (FFI_LINUX
+#  ifdef __STRUCT_PARM_ALIGN__
+		     | FFI_LINUX_STRUCT_ALIGN
+#  endif
+#  ifdef __LONG_DOUBLE_128__
+		     | FFI_LINUX_LONG_DOUBLE_128
+#   ifdef __LONG_DOUBLE_IEEE128__
+		     | FFI_LINUX_LONG_DOUBLE_IEEE128
+#   endif
+#  endif
+		     ),
+  FFI_LAST_ABI = 16
+
+# else
+  /* This bit, always set in new code, must not be set in any of the
+     old FFI_COMPAT values that might be used for 32-bit linux/sysv/bsd.  */
+  FFI_SYSV = 8,
+  /* This and following bits can reuse FFI_COMPAT values.  */
+  FFI_SYSV_SOFT_FLOAT = 1,
+  FFI_SYSV_STRUCT_RET = 2,
+  FFI_SYSV_IBM_LONG_DOUBLE = 4,
+  FFI_SYSV_LONG_DOUBLE_128 = 16,
+
+  FFI_DEFAULT_ABI = (FFI_SYSV
+#  ifdef __NO_FPRS__
+		     | FFI_SYSV_SOFT_FLOAT
+#  endif
+#  if (defined (__SVR4_STRUCT_RETURN)					\
+       || defined (POWERPC_FREEBSD) && !defined (__AIX_STRUCT_RETURN))
+		     | FFI_SYSV_STRUCT_RET
+#  endif
+#  if __LDBL_MANT_DIG__ == 106
+		     | FFI_SYSV_IBM_LONG_DOUBLE
+#  endif
+#  ifdef __LONG_DOUBLE_128__
+		     | FFI_SYSV_LONG_DOUBLE_128
+#  endif
+		     ),
+  FFI_LAST_ABI = 32
+# endif
+#endif
+
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+#if defined (POWERPC) || defined (POWERPC_FREEBSD)
+# define FFI_GO_CLOSURES 1
+# define FFI_TARGET_SPECIFIC_VARIADIC 1
+# define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs
+#endif
+#if defined (POWERPC_AIX)
+# define FFI_GO_CLOSURES 1
+#endif
+
+/* ppc_closure.S and linux64_closure.S expect this.  */
+#define FFI_PPC_TYPE_LAST FFI_TYPE_POINTER
+
+/* We define additional types below.  If generic types are added that
+   must be supported by powerpc libffi then it is likely that
+   FFI_PPC_TYPE_LAST needs increasing *and* the jump tables in
+   ppc_closure.S and linux64_closure.S be extended.  */
+
+#if !(FFI_TYPE_LAST == FFI_PPC_TYPE_LAST		\
+      || (FFI_TYPE_LAST == FFI_TYPE_COMPLEX		\
+	  && !defined FFI_TARGET_HAS_COMPLEX_TYPE))
+# error "You likely have a broken powerpc libffi"
+#endif
+
+/* Needed for soft-float long-double-128 support.  */
+#define FFI_TYPE_UINT128 (FFI_PPC_TYPE_LAST + 1)
+
+/* Needed for FFI_SYSV small structure returns.  */
+#define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_PPC_TYPE_LAST + 2)
+
+/* Used by ELFv2 for homogenous structure returns.  */
+#define FFI_V2_TYPE_VECTOR		(FFI_PPC_TYPE_LAST + 1)
+#define FFI_V2_TYPE_VECTOR_HOMOG	(FFI_PPC_TYPE_LAST + 2)
+#define FFI_V2_TYPE_FLOAT_HOMOG		(FFI_PPC_TYPE_LAST + 3)
+#define FFI_V2_TYPE_DOUBLE_HOMOG	(FFI_PPC_TYPE_LAST + 4)
+#define FFI_V2_TYPE_SMALL_STRUCT	(FFI_PPC_TYPE_LAST + 5)
+
+#if _CALL_ELF == 2
+# define FFI_TRAMPOLINE_SIZE 32
+#else
+# if defined(POWERPC64) || defined(POWERPC_AIX)
+#  if defined(POWERPC_DARWIN64)
+#    define FFI_TRAMPOLINE_SIZE 48
+#  else
+#    define FFI_TRAMPOLINE_SIZE 24
+#  endif
+# else /* POWERPC || POWERPC_AIX */
+#  define FFI_TRAMPOLINE_SIZE 40
+# endif
+#endif
+
+#ifndef LIBFFI_ASM
+#if defined(POWERPC_DARWIN) || defined(POWERPC_AIX)
+struct ffi_aix_trampoline_struct {
+    void * code_pointer;	/* Pointer to ffi_closure_ASM */
+    void * toc;			/* TOC */
+    void * static_chain;	/* Pointer to closure */
+};
+#endif
+#endif
+
+#endif
Index: libffi-3.4.6/src/powerpc/ffi_darwin.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffi_darwin.c b/libffi-3.4.6/src/powerpc/ffi_darwin.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffi_darwin.c	
@@ -0,0 +1,1464 @@
+/* -----------------------------------------------------------------------
+   ffi_darwin.c
+
+   Copyright (C) 1998 Geoffrey Keating
+   Copyright (C) 2001 John Hornkvist
+   Copyright (C) 2002, 2006, 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   FFI support for Darwin and AIX.
+   
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+extern void ffi_closure_ASM (void);
+
+#if defined (FFI_GO_CLOSURES)
+extern void ffi_go_closure_ASM (void);
+#endif
+
+enum {
+  /* The assembly depends on these exact flags.  
+     For Darwin64 (when FLAG_RETURNS_STRUCT is set):
+       FLAG_RETURNS_FP indicates that the structure embeds FP data.
+       FLAG_RETURNS_128BITS signals a special struct size that is not
+       expanded for float content.  */
+  FLAG_RETURNS_128BITS	= 1 << (31-31), /* These go in cr7  */
+  FLAG_RETURNS_NOTHING	= 1 << (31-30),
+  FLAG_RETURNS_FP	= 1 << (31-29),
+  FLAG_RETURNS_64BITS	= 1 << (31-28),
+
+  FLAG_RETURNS_STRUCT	= 1 << (31-27), /* This goes in cr6  */
+
+  FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),
+  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI  */
+  FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),
+  FLAG_RETVAL_REFERENCE = 1 << (31- 4)
+};
+
+/* About the DARWIN ABI.  */
+enum {
+  NUM_GPR_ARG_REGISTERS = 8,
+  NUM_FPR_ARG_REGISTERS = 13,
+  LINKAGE_AREA_GPRS = 6
+};
+
+enum { ASM_NEEDS_REGISTERS = 4 }; /* r28-r31 */
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments.
+   
+   m32/m64
+
+   The stack layout we want looks like this:
+
+   |   Return address from ffi_call_DARWIN      |	higher addresses
+   |--------------------------------------------|
+   |   Previous backchain pointer	4/8	|	stack pointer here
+   |--------------------------------------------|<+ <<<	on entry to
+   |   ASM_NEEDS_REGISTERS=r28-r31   4*(4/8)	| |	ffi_call_DARWIN
+   |--------------------------------------------| |
+   |   When we have any FP activity... the	| |
+   |   FPRs occupy NUM_FPR_ARG_REGISTERS slots	| |
+   |   here fp13 .. fp1 from high to low addr.	| |
+   ~						~ ~
+   |   Parameters      (at least 8*4/8=32/64)	| | NUM_GPR_ARG_REGISTERS
+   |--------------------------------------------| |
+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8	| |
+   |--------------------------------------------| |	stack	|
+   |   Reserved                       2*4/8	| |	grows	|
+   |--------------------------------------------| |	down	V
+   |   Space for callee's LR		4/8	| |
+   |--------------------------------------------| |	lower addresses
+   |   Saved CR [low word for m64]      4/8	| |
+   |--------------------------------------------| |     stack pointer here
+   |   Current backchain pointer	4/8	|-/	during
+   |--------------------------------------------|   <<<	ffi_call_DARWIN
+
+   */
+
+#if defined(POWERPC_DARWIN64)
+static void
+darwin64_pass_struct_by_value 
+  (ffi_type *, char *, unsigned, unsigned *, double **, unsigned long **);
+#endif
+
+/* This depends on GPR_SIZE = sizeof (unsigned long) */
+
+void
+ffi_prep_args (extended_cif *ecif, unsigned long *const stack)
+{
+  const unsigned bytes = ecif->cif->bytes;
+  const unsigned flags = ecif->cif->flags;
+  const unsigned nargs = ecif->cif->nargs;
+#if !defined(POWERPC_DARWIN64) 
+  const ffi_abi abi = ecif->cif->abi;
+#endif
+
+  /* 'stacktop' points at the previous backchain pointer.  */
+  unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));
+
+  /* 'fpr_base' points at the space for fpr1, and grows upwards as
+     we use FPR registers.  */
+  double *fpr_base = (double *) (stacktop - ASM_NEEDS_REGISTERS) - NUM_FPR_ARG_REGISTERS;
+  int gp_count = 0, fparg_count = 0;
+
+  /* 'next_arg' grows up as we put parameters in it.  */
+  unsigned long *next_arg = stack + LINKAGE_AREA_GPRS; /* 6 reserved positions.  */
+
+  int i;
+  double double_tmp;
+  void **p_argv = ecif->avalue;
+  unsigned long gprvalue;
+  ffi_type** ptr = ecif->cif->arg_types;
+#if !defined(POWERPC_DARWIN64) 
+  char *dest_cpy;
+#endif
+  unsigned size_al = 0;
+
+  /* Check that everything starts aligned properly.  */
+  FFI_ASSERT(((unsigned) (char *) stack & 0xF) == 0);
+  FFI_ASSERT(((unsigned) (char *) stacktop & 0xF) == 0);
+  FFI_ASSERT((bytes & 0xF) == 0);
+
+  /* Deal with return values that are actually pass-by-reference.
+     Rule:
+     Return values are referenced by r3, so r4 is the first parameter.  */
+
+  if (flags & FLAG_RETVAL_REFERENCE)
+    *next_arg++ = (unsigned long) (char *) ecif->rvalue;
+
+  /* Now for the arguments.  */
+  for (i = nargs; i > 0; i--, ptr++, p_argv++)
+    {
+      switch ((*ptr)->type)
+	{
+	/* If a floating-point parameter appears before all of the general-
+	   purpose registers are filled, the corresponding GPRs that match
+	   the size of the floating-point parameter are skipped.  */
+	case FFI_TYPE_FLOAT:
+	  double_tmp = *(float *) *p_argv;
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS)
+	    *fpr_base++ = double_tmp;
+#if defined(POWERPC_DARWIN)
+	  *(float *)next_arg = *(float *) *p_argv;
+#else
+	  *(double *)next_arg = double_tmp;
+#endif
+	  next_arg++;
+	  gp_count++;
+	  fparg_count++;
+	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  double_tmp = *(double *) *p_argv;
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS)
+	    *fpr_base++ = double_tmp;
+	  *(double *)next_arg = double_tmp;
+#ifdef POWERPC64
+	  next_arg++;
+	  gp_count++;
+#else
+	  next_arg += 2;
+	  gp_count += 2;
+#endif
+	  fparg_count++;
+	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+
+	case FFI_TYPE_LONGDOUBLE:
+#  if defined(POWERPC64) && !defined(POWERPC_DARWIN64)
+	  /* ??? This will exceed the regs count when the value starts at fp13
+	     and it will not put the extra bit on the stack.  */
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS)
+	    *(long double *) fpr_base++ = *(long double *) *p_argv;
+	  else
+	    *(long double *) next_arg = *(long double *) *p_argv;
+	  next_arg += 2;
+	  fparg_count += 2;
+#  else
+	  double_tmp = ((double *) *p_argv)[0];
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS)
+	    *fpr_base++ = double_tmp;
+	  *(double *) next_arg = double_tmp;
+#    if defined(POWERPC_DARWIN64)
+	  next_arg++;
+	  gp_count++;
+#    else
+	  next_arg += 2;
+	  gp_count += 2;
+#    endif
+	  fparg_count++;
+	  double_tmp = ((double *) *p_argv)[1];
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS)
+	    *fpr_base++ = double_tmp;
+	  *(double *) next_arg = double_tmp;
+#    if defined(POWERPC_DARWIN64)
+	  next_arg++;
+	  gp_count++;
+#    else
+	  next_arg += 2;
+	  gp_count += 2;
+#    endif
+	  fparg_count++;
+#  endif
+	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  break;
+#endif
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+#ifdef POWERPC64
+	  gprvalue = *(long long *) *p_argv;
+	  goto putgpr;
+#else
+	  *(long long *) next_arg = *(long long *) *p_argv;
+	  next_arg += 2;
+	  gp_count += 2;
+#endif
+	  break;
+	case FFI_TYPE_POINTER:
+	  gprvalue = *(unsigned long *) *p_argv;
+	  goto putgpr;
+	case FFI_TYPE_UINT8:
+	  gprvalue = *(unsigned char *) *p_argv;
+	  goto putgpr;
+	case FFI_TYPE_SINT8:
+	  gprvalue = *(signed char *) *p_argv;
+	  goto putgpr;
+	case FFI_TYPE_UINT16:
+	  gprvalue = *(unsigned short *) *p_argv;
+	  goto putgpr;
+	case FFI_TYPE_SINT16:
+	  gprvalue = *(signed short *) *p_argv;
+	  goto putgpr;
+
+	case FFI_TYPE_STRUCT:
+	  size_al = (*ptr)->size;
+#if defined(POWERPC_DARWIN64)
+	  next_arg = (unsigned long *)FFI_ALIGN((char *)next_arg, (*ptr)->alignment);
+	  darwin64_pass_struct_by_value (*ptr, (char *) *p_argv, 
+					 (unsigned) size_al,
+					 (unsigned int *) &fparg_count,
+					 &fpr_base, &next_arg);
+#else
+	  dest_cpy = (char *) next_arg;
+
+	  /* If the first member of the struct is a double, then include enough
+	     padding in the struct size to align it to double-word.  */
+	  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)
+	    size_al = FFI_ALIGN((*ptr)->size, 8);
+
+#  if defined(POWERPC64) 
+	  FFI_ASSERT (abi != FFI_DARWIN);
+	  memcpy ((char *) dest_cpy, (char *) *p_argv, size_al);
+	  next_arg += (size_al + 7) / 8;
+#  else
+	  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,
+	     SI 4 bytes) are aligned as if they were those modes.
+	     Structures with 3 byte in size are padded upwards.  */
+	  if (size_al < 3 && abi == FFI_DARWIN)
+	    dest_cpy += 4 - size_al;
+
+	  memcpy((char *) dest_cpy, (char *) *p_argv, size_al);
+	  next_arg += (size_al + 3) / 4;
+#  endif
+#endif
+	  break;
+
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	  gprvalue = *(signed int *) *p_argv;
+	  goto putgpr;
+
+	case FFI_TYPE_UINT32:
+	  gprvalue = *(unsigned int *) *p_argv;
+	putgpr:
+	  *next_arg++ = gprvalue;
+	  gp_count++;
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  /* Check that we didn't overrun the stack...  */
+  /* FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);
+     FFI_ASSERT((unsigned *)fpr_base
+     	     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);
+     FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);  */
+}
+
+#if defined(POWERPC_DARWIN64)
+
+/* See if we can put some of the struct into fprs.
+   This should not be called for structures of size 16 bytes, since these are not
+   broken out this way.  */
+static void
+darwin64_scan_struct_for_floats (ffi_type *s, unsigned *nfpr)
+{
+  int i;
+
+  FFI_ASSERT (s->type == FFI_TYPE_STRUCT)
+
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      ffi_type *p = s->elements[i];
+      switch (p->type)
+	{
+	  case FFI_TYPE_STRUCT:
+	    darwin64_scan_struct_for_floats (p, nfpr);
+	    break;
+	  case FFI_TYPE_LONGDOUBLE:
+	    (*nfpr) += 2;
+	    break;
+	  case FFI_TYPE_DOUBLE:
+	  case FFI_TYPE_FLOAT:
+	    (*nfpr) += 1;
+	    break;
+	  default:
+	    break;    
+	}
+    }
+}
+
+static int
+darwin64_struct_size_exceeds_gprs_p (ffi_type *s, char *src, unsigned *nfpr)
+{
+  unsigned struct_offset=0, i;
+
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      char *item_base;
+      ffi_type *p = s->elements[i];
+      /* Find the start of this item (0 for the first one).  */
+      if (i > 0)
+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);
+
+      item_base = src + struct_offset;
+
+      switch (p->type)
+	{
+	  case FFI_TYPE_STRUCT:
+	    if (darwin64_struct_size_exceeds_gprs_p (p, item_base, nfpr))
+	      return 1;
+	    break;
+	  case FFI_TYPE_LONGDOUBLE:
+	    if (*nfpr >= NUM_FPR_ARG_REGISTERS)
+	      return 1;
+	    (*nfpr) += 1;
+	    item_base += 8;
+	  /* FALL THROUGH */
+	  case FFI_TYPE_DOUBLE:
+	    if (*nfpr >= NUM_FPR_ARG_REGISTERS)
+	      return 1;
+	    (*nfpr) += 1;
+	    break;
+	  case FFI_TYPE_FLOAT:
+	    if (*nfpr >= NUM_FPR_ARG_REGISTERS)
+	      return 1;
+	    (*nfpr) += 1;
+	    break;
+	  default:
+	    /* If we try and place any item, that is non-float, once we've
+	       exceeded the 8 GPR mark, then we can't fit the struct.  */
+	    if ((unsigned long)item_base >= 8*8) 
+	      return 1;
+	    break;    
+	}
+      /* now count the size of what we just used.  */
+      struct_offset += p->size;
+    }
+  return 0;
+}
+
+/* Can this struct be returned by value?  */
+int 
+darwin64_struct_ret_by_value_p (ffi_type *s)
+{
+  unsigned nfp = 0;
+
+  FFI_ASSERT (s && s->type == FFI_TYPE_STRUCT);
+  
+  /* The largest structure we can return is 8long + 13 doubles.  */
+  if (s->size > 168)
+    return 0;
+  
+  /* We can't pass more than 13 floats.  */
+  darwin64_scan_struct_for_floats (s, &nfp);
+  if (nfp > 13)
+    return 0;
+  
+  /* If there are not too many floats, and the struct is
+     small enough to accommodate in the GPRs, then it must be OK.  */
+  if (s->size <= 64)
+    return 1;
+  
+  /* Well, we have to look harder.  */
+  nfp = 0;
+  if (darwin64_struct_size_exceeds_gprs_p (s, NULL, &nfp))
+    return 0;
+  
+  return 1;
+}
+
+void
+darwin64_pass_struct_floats (ffi_type *s, char *src, 
+			     unsigned *nfpr, double **fprs)
+{
+  int i;
+  double *fpr_base = *fprs;
+  unsigned struct_offset = 0;
+
+  /* We don't assume anything about the alignment of the source.  */
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      char *item_base;
+      ffi_type *p = s->elements[i];
+      /* Find the start of this item (0 for the first one).  */
+      if (i > 0)
+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);
+      item_base = src + struct_offset;
+
+      switch (p->type)
+	{
+	  case FFI_TYPE_STRUCT:
+	    darwin64_pass_struct_floats (p, item_base, nfpr,
+					   &fpr_base);
+	    break;
+	  case FFI_TYPE_LONGDOUBLE:
+	    if (*nfpr < NUM_FPR_ARG_REGISTERS)
+	      *fpr_base++ = *(double *)item_base;
+	    (*nfpr) += 1;
+	    item_base += 8;
+	  /* FALL THROUGH */
+	  case FFI_TYPE_DOUBLE:
+	    if (*nfpr < NUM_FPR_ARG_REGISTERS)
+	      *fpr_base++ = *(double *)item_base;
+	    (*nfpr) += 1;
+	    break;
+	  case FFI_TYPE_FLOAT:
+	    if (*nfpr < NUM_FPR_ARG_REGISTERS)
+	      *fpr_base++ = (double) *(float *)item_base;
+	    (*nfpr) += 1;
+	    break;
+	  default:
+	    break;    
+	}
+      /* now count the size of what we just used.  */
+      struct_offset += p->size;
+    }
+  /* Update the scores.  */
+  *fprs = fpr_base;
+}
+
+/* Darwin64 special rules.
+   Break out a struct into params and float registers.  */
+static void
+darwin64_pass_struct_by_value (ffi_type *s, char *src, unsigned size,
+			       unsigned *nfpr, double **fprs, unsigned long **arg)
+{
+  unsigned long *next_arg = *arg;
+  char *dest_cpy = (char *)next_arg;
+
+  FFI_ASSERT (s->type == FFI_TYPE_STRUCT)
+
+  if (!size)
+    return;
+
+  /* First... special cases.  */
+  if (size < 3
+      || (size == 4 
+	  && s->elements[0] 
+	  && s->elements[0]->type != FFI_TYPE_FLOAT))
+    {
+      /* Must be at least one GPR, padding is unspecified in value, 
+	 let's make it zero.  */
+      *next_arg = 0UL; 
+      dest_cpy += 8 - size;
+      memcpy ((char *) dest_cpy, src, size);
+      next_arg++;
+    }
+  else if (size == 16)
+    {
+      memcpy ((char *) dest_cpy, src, size);
+      next_arg += 2;
+    }
+  else
+    {
+      /* now the general case, we consider embedded floats.  */
+      memcpy ((char *) dest_cpy, src, size);
+      darwin64_pass_struct_floats (s, src, nfpr, fprs);
+      next_arg += (size+7)/8;
+    }
+    
+  *arg = next_arg;
+}
+
+double *
+darwin64_struct_floats_to_mem (ffi_type *s, char *dest, double *fprs, unsigned *nf)
+{
+  int i;
+  unsigned struct_offset = 0;
+
+  /* We don't assume anything about the alignment of the source.  */
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      char *item_base;
+      ffi_type *p = s->elements[i];
+      /* Find the start of this item (0 for the first one).  */
+      if (i > 0)
+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);
+      item_base = dest + struct_offset;
+
+      switch (p->type)
+	{
+	  case FFI_TYPE_STRUCT:
+	    fprs = darwin64_struct_floats_to_mem (p, item_base, fprs, nf);
+	    break;
+	  case FFI_TYPE_LONGDOUBLE:
+	    if (*nf < NUM_FPR_ARG_REGISTERS)
+	      {
+		*(double *)item_base = *fprs++ ;
+		(*nf) += 1;
+	      }
+	    item_base += 8;
+	  /* FALL THROUGH */
+	  case FFI_TYPE_DOUBLE:
+	    if (*nf < NUM_FPR_ARG_REGISTERS)
+	      {
+		*(double *)item_base = *fprs++ ;
+		(*nf) += 1;
+	      }
+	    break;
+	  case FFI_TYPE_FLOAT:
+	    if (*nf < NUM_FPR_ARG_REGISTERS)
+	      {
+		*(float *)item_base = (float) *fprs++ ;
+		(*nf) += 1;
+	      }
+	    break;
+	  default:
+	    break;    
+	}
+      /* now count the size of what we just used.  */
+      struct_offset += p->size;
+    }
+  return fprs;
+}
+
+#endif
+
+/* Adjust the size of S to be correct for Darwin.
+   On Darwin m32, the first field of a structure has natural alignment.  
+   On Darwin m64, all fields have natural alignment.  */
+
+static void
+darwin_adjust_aggregate_sizes (ffi_type *s)
+{
+  int i;
+
+  if (s->type != FFI_TYPE_STRUCT)
+    return;
+
+  s->size = 0;
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      ffi_type *p;
+      int align;
+      
+      p = s->elements[i];
+      if (p->type == FFI_TYPE_STRUCT)
+	darwin_adjust_aggregate_sizes (p);
+#if defined(POWERPC_DARWIN64)
+      /* Natural alignment for all items.  */
+      align = p->alignment;
+#else
+      /* Natural alignment for the first item... */
+      if (i == 0)
+	align = p->alignment;
+      else if (p->alignment == 16 || p->alignment < 4)
+	/* .. subsequent items with vector or align < 4 have natural align.  */
+	align = p->alignment;
+      else
+	/* .. or align is 4.  */
+	align = 4;
+#endif
+      /* Pad, if necessary, before adding the current item.  */
+      s->size = FFI_ALIGN(s->size, align) + p->size;
+    }
+  
+  s->size = FFI_ALIGN(s->size, s->alignment);
+  
+  /* This should not be necessary on m64, but harmless.  */
+  if (s->elements[0]->type == FFI_TYPE_UINT64
+      || s->elements[0]->type == FFI_TYPE_SINT64
+      || s->elements[0]->type == FFI_TYPE_DOUBLE
+      || s->elements[0]->alignment == 8)
+    s->alignment = s->alignment > 8 ? s->alignment : 8;
+  /* Do not add additional tail padding.  */
+}
+
+/* Adjust the size of S to be correct for AIX.
+   Word-align double unless it is the first member of a structure recursively.
+   Return non-zero if we found a recursive first member aggregate of interest. */
+
+static int
+aix_adjust_aggregate_sizes (ffi_type *s, int outer_most_type_or_first_member)
+{
+  int i, nested_first_member=0, final_align, rc=0;
+
+  if (s->type != FFI_TYPE_STRUCT)
+    return 0;
+
+  s->size = 0;
+  for (i = 0; s->elements[i] != NULL; i++)
+    {
+      ffi_type p;
+      int align;
+
+      /* nested aggregates layout differently on AIX, so take a copy of the type */
+      p = *(s->elements[i]);
+      if (i == 0)
+        nested_first_member = aix_adjust_aggregate_sizes(&p, outer_most_type_or_first_member);
+      else
+        aix_adjust_aggregate_sizes(&p, 0);
+      align = p.alignment;
+      if (i != 0 && p.type == FFI_TYPE_DOUBLE)
+        align = 4;
+      s->size = FFI_ALIGN(s->size, align) + p.size;
+    }
+
+  final_align=s->alignment;
+  if ((s->elements[0]->type == FFI_TYPE_UINT64
+          || s->elements[0]->type == FFI_TYPE_SINT64
+          || s->elements[0]->type == FFI_TYPE_DOUBLE
+          || s->elements[0]->alignment == 8 || nested_first_member)) {
+      final_align = s->alignment > 8 ? s->alignment : 8;
+      rc=1;
+      /* still use the adjusted alignment to calculate tail padding, but don't adjust the types alignment if
+         we aren't in the recursive first position */
+      if (outer_most_type_or_first_member)
+        s->alignment=final_align;
+  }
+
+  s->size = FFI_ALIGN(s->size, final_align);
+  return rc;
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* All this is for the DARWIN ABI.  */
+  unsigned i;
+  ffi_type **ptr;
+  unsigned bytes;
+  unsigned fparg_count = 0, intarg_count = 0;
+  unsigned flags = 0;
+  unsigned size_al = 0;
+
+  /* All the machine-independent calculation of cif->bytes will be wrong.
+     All the calculation of structure sizes will also be wrong.
+     Redo the calculation for DARWIN.  */
+
+  if (cif->abi == FFI_DARWIN)
+    {
+      darwin_adjust_aggregate_sizes (cif->rtype);
+      for (i = 0; i < cif->nargs; i++)
+	darwin_adjust_aggregate_sizes (cif->arg_types[i]);
+    }
+
+  if (cif->abi == FFI_AIX)
+    {
+      aix_adjust_aggregate_sizes (cif->rtype, 1);
+      for (i = 0; i < cif->nargs; i++)
+	aix_adjust_aggregate_sizes (cif->arg_types[i], 1);
+    }
+
+  /* Space for the frame pointer, callee's LR, CR, etc, and for
+     the asm's temp regs.  */
+
+  bytes = (LINKAGE_AREA_GPRS + ASM_NEEDS_REGISTERS) * sizeof(unsigned long);
+
+  /* Return value handling.  
+    The rules m32 are as follows:
+     - 32-bit (or less) integer values are returned in gpr3;
+     - structures of size <= 4 bytes also returned in gpr3;
+     - 64-bit integer values [??? and structures between 5 and 8 bytes] are
+       returned in gpr3 and gpr4;
+     - Single/double FP values are returned in fpr1;
+     - Long double FP (if not equivalent to double) values are returned in
+       fpr1 and fpr2;
+     m64:
+     - 64-bit or smaller integral values are returned in GPR3
+     - Single/double FP values are returned in fpr1;
+     - Long double FP values are returned in fpr1 and fpr2;
+     m64 Structures:
+     - If the structure could be accommodated in registers were it to be the
+       first argument to a routine, then it is returned in those registers.
+     m32/m64 structures otherwise:
+     - Larger structures values are allocated space and a pointer is passed
+       as the first argument.  */
+  switch (cif->rtype->type)
+    {
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      flags |= FLAG_RETURNS_128BITS;
+      flags |= FLAG_RETURNS_FP;
+      break;
+#endif
+
+    case FFI_TYPE_DOUBLE:
+      flags |= FLAG_RETURNS_64BITS;
+      /* Fall through.  */
+    case FFI_TYPE_FLOAT:
+      flags |= FLAG_RETURNS_FP;
+      break;
+
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+#ifdef POWERPC64
+    case FFI_TYPE_POINTER:
+#endif
+      flags |= FLAG_RETURNS_64BITS;
+      break;
+
+    case FFI_TYPE_STRUCT:
+#if defined(POWERPC_DARWIN64)
+      {
+	/* Can we fit the struct into regs?  */
+	if (darwin64_struct_ret_by_value_p (cif->rtype))
+	  {
+	    unsigned nfpr = 0;
+	    flags |= FLAG_RETURNS_STRUCT;
+	    if (cif->rtype->size != 16)
+	      darwin64_scan_struct_for_floats (cif->rtype, &nfpr) ;
+	    else
+	      flags |= FLAG_RETURNS_128BITS;
+	    /* Will be 0 for 16byte struct.  */
+	    if (nfpr)
+	      flags |= FLAG_RETURNS_FP;
+	  }
+	else /* By ref. */
+	  {
+	    flags |= FLAG_RETVAL_REFERENCE;
+	    flags |= FLAG_RETURNS_NOTHING;
+	    intarg_count++;
+	  }
+      }
+#elif defined(DARWIN_PPC)
+      if (cif->rtype->size <= 4)
+	flags |= FLAG_RETURNS_STRUCT;
+      else /* else by reference.  */
+	{
+	  flags |= FLAG_RETVAL_REFERENCE;
+	  flags |= FLAG_RETURNS_NOTHING;
+	  intarg_count++;
+	}
+#else /* assume we pass by ref.  */
+      flags |= FLAG_RETVAL_REFERENCE;
+      flags |= FLAG_RETURNS_NOTHING;
+      intarg_count++;
+#endif
+      break;
+    case FFI_TYPE_VOID:
+      flags |= FLAG_RETURNS_NOTHING;
+      break;
+
+    default:
+      /* Returns 32-bit integer, or similar.  Nothing to do here.  */
+      break;
+    }
+
+  /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the
+     first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest
+     goes on the stack.  
+     ??? Structures are passed as a pointer to a copy of the structure. 
+     Stuff on the stack needs to keep proper alignment.  
+     For m64 the count is effectively of half-GPRs.  */
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+      unsigned align_words;
+      switch ((*ptr)->type)
+	{
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+	  fparg_count++;
+#if !defined(POWERPC_DARWIN64)
+	  /* If this FP arg is going on the stack, it must be
+	     8-byte-aligned.  */
+	  if (fparg_count > NUM_FPR_ARG_REGISTERS
+	      && (intarg_count & 0x01) != 0)
+	    intarg_count++;
+#endif
+	  break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  fparg_count += 2;
+	  /* If this FP arg is going on the stack, it must be
+	     16-byte-aligned.  */
+	  if (fparg_count >= NUM_FPR_ARG_REGISTERS)
+#if defined (POWERPC64)
+	    intarg_count = FFI_ALIGN(intarg_count, 2);
+#else
+	    intarg_count = FFI_ALIGN(intarg_count, 4);
+#endif
+	  break;
+#endif
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+#if defined(POWERPC64)
+	  intarg_count++;
+#else
+	  /* 'long long' arguments are passed as two words, but
+	     either both words must fit in registers or both go
+	     on the stack.  If they go on the stack, they must
+	     be 8-byte-aligned.  */
+	  if (intarg_count == NUM_GPR_ARG_REGISTERS-1
+	      || (intarg_count >= NUM_GPR_ARG_REGISTERS 
+	          && (intarg_count & 0x01) != 0))
+	    intarg_count++;
+	  intarg_count += 2;
+#endif
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  size_al = (*ptr)->size;
+#if defined(POWERPC_DARWIN64)
+	  align_words = (*ptr)->alignment >> 3;
+	  if (align_words)
+	    intarg_count = FFI_ALIGN(intarg_count, align_words);
+	  /* Base size of the struct.  */
+	  intarg_count += (size_al + 7) / 8;
+	  /* If 16 bytes then don't worry about floats.  */
+	  if (size_al != 16)
+	    /* Scan through for floats to be placed in regs.  */
+	    darwin64_scan_struct_for_floats (*ptr, &fparg_count) ;
+#else
+	  align_words = (*ptr)->alignment >> 2;
+	  if (align_words)
+	    intarg_count = FFI_ALIGN(intarg_count, align_words);
+	  /* If the first member of the struct is a double, then align
+	     the struct to double-word. 
+	  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)
+	    size_al = FFI_ALIGN((*ptr)->size, 8); */
+#  ifdef POWERPC64
+	  intarg_count += (size_al + 7) / 8;
+#  else
+	  intarg_count += (size_al + 3) / 4;
+#  endif
+#endif
+	  break;
+
+	default:
+	  /* Everything else is passed as a 4-byte word in a GPR, either
+	     the object itself or a pointer to it.  */
+	  intarg_count++;
+	  break;
+	}
+    }
+
+  if (fparg_count != 0)
+    flags |= FLAG_FP_ARGUMENTS;
+
+#if defined(POWERPC_DARWIN64)
+  /* Space to image the FPR registers, if needed - which includes when they might be
+     used in a struct return.  */
+  if (fparg_count != 0 
+      || ((flags & FLAG_RETURNS_STRUCT)
+	   && (flags & FLAG_RETURNS_FP)))
+    bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);
+#else
+  /* Space for the FPR registers, if needed.  */
+  if (fparg_count != 0)
+    bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);
+#endif
+
+  /* Stack space.  */
+#ifdef POWERPC64
+  if ((intarg_count + fparg_count) > NUM_GPR_ARG_REGISTERS)
+    bytes += (intarg_count + fparg_count) * sizeof(long);
+#else
+  if ((intarg_count + 2 * fparg_count) > NUM_GPR_ARG_REGISTERS)
+    bytes += (intarg_count + 2 * fparg_count) * sizeof(long);
+#endif
+  else
+    bytes += NUM_GPR_ARG_REGISTERS * sizeof(long);
+
+  /* The stack space allocated needs to be a multiple of 16 bytes.  */
+  bytes = FFI_ALIGN(bytes, 16) ;
+
+  cif->flags = flags;
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,
+			 void (*fn)(void), void (*fn2)(void));
+
+#if defined (FFI_GO_CLOSURES)
+extern void ffi_call_go_AIX(extended_cif *, long, unsigned, unsigned *,
+			    void (*fn)(void), void (*fn2)(void), void *closure);
+#endif
+
+extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,
+			    void (*fn)(void), void (*fn2)(void), ffi_type*);
+
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return
+     value address then we need to make one.  */
+
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca (cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_AIX:
+      ffi_call_AIX(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,
+		   FFI_FN(ffi_prep_args));
+      break;
+    case FFI_DARWIN:
+      ffi_call_DARWIN(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,
+		      FFI_FN(ffi_prep_args), cif->rtype);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#if defined (FFI_GO_CLOSURES)
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	     void *closure)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return
+     value address then we need to make one.  */
+
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      ecif.rvalue = alloca (cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_AIX:
+      ffi_call_go_AIX(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,
+		      FFI_FN(ffi_prep_args), closure);
+      break;
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+#endif
+
+static void flush_icache(char *);
+static void flush_range(char *, int);
+
+/* The layout of a function descriptor.  A C function pointer really
+   points to one of these.  */
+
+typedef struct aix_fd_struct {
+  void *code_pointer;
+  void *toc;
+} aix_fd;
+
+/* here I'd like to add the stack frame layout we use in darwin_closure.S
+   and aix_closure.S
+
+   m32/m64
+
+   The stack layout looks like this:
+
+   |   Additional params...			| |     Higher address
+   ~						~ ~
+   |   Parameters      (at least 8*4/8=32/64)	| | NUM_GPR_ARG_REGISTERS
+   |--------------------------------------------| |
+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8	| |
+   |--------------------------------------------| |
+   |   Reserved                       2*4/8	| |
+   |--------------------------------------------| |
+   |   Space for callee's LR		4/8	| |
+   |--------------------------------------------| |
+   |   Saved CR [low word for m64]      4/8	| |
+   |--------------------------------------------| |
+   |   Current backchain pointer	4/8	|-/ Parent's frame.
+   |--------------------------------------------| <+ <<< on entry to ffi_closure_ASM
+   |   Result Bytes			16	| |
+   |--------------------------------------------| |
+   ~   padding to 16-byte alignment		~ ~
+   |--------------------------------------------| |
+   |   NUM_FPR_ARG_REGISTERS slots		| |
+   |   here fp13 .. fp1		       13*8	| |
+   |--------------------------------------------| |
+   |   R3..R10			  8*4/8=32/64	| | NUM_GPR_ARG_REGISTERS
+   |--------------------------------------------| |
+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8	| |
+   |--------------------------------------------| |	stack	|
+   |   Reserved [compiler,binder]     2*4/8	| |	grows	|
+   |--------------------------------------------| |	down	V
+   |   Space for callee's LR		4/8	| |
+   |--------------------------------------------| |	lower addresses
+   |   Saved CR [low word for m64]      4/8	| |
+   |--------------------------------------------| |     stack pointer here
+   |   Current backchain pointer	4/8	|-/	during
+   |--------------------------------------------|   <<<	ffi_closure_ASM.
+
+*/
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+		      ffi_cif* cif,
+		      void (*fun)(ffi_cif*, void*, void**, void*),
+		      void *user_data,
+		      void *codeloc)
+{
+  unsigned int *tramp;
+  struct ffi_aix_trampoline_struct *tramp_aix;
+  aix_fd *fd;
+
+  switch (cif->abi)
+    {
+      case FFI_DARWIN:
+
+	FFI_ASSERT (cif->abi == FFI_DARWIN);
+
+	tramp = (unsigned int *) &closure->tramp[0];
+#if defined(POWERPC_DARWIN64)
+	tramp[0] = 0x7c0802a6;  /*   mflr    r0  */
+	tramp[1] = 0x429f0015;  /*   bcl-    20,4*cr7+so,  +0x18 (L1)  */
+	/* We put the addresses here.  */
+	tramp[6] = 0x7d6802a6;  /*L1:   mflr    r11  */
+	tramp[7] = 0xe98b0000;  /*   ld     r12,0(r11) function address  */
+	tramp[8] = 0x7c0803a6;  /*   mtlr    r0   */
+	tramp[9] = 0x7d8903a6;  /*   mtctr   r12  */
+	tramp[10] = 0xe96b0008;  /*   lwz     r11,8(r11) static chain  */
+	tramp[11] = 0x4e800420;  /*   bctr  */
+
+	*((unsigned long *)&tramp[2]) = (unsigned long) ffi_closure_ASM; /* function  */
+	*((unsigned long *)&tramp[4]) = (unsigned long) codeloc; /* context  */
+#else
+	tramp[0] = 0x7c0802a6;  /*   mflr    r0  */
+	tramp[1] = 0x429f000d;  /*   bcl-    20,4*cr7+so,0x10  */
+	tramp[4] = 0x7d6802a6;  /*   mflr    r11  */
+	tramp[5] = 0x818b0000;  /*   lwz     r12,0(r11) function address  */
+	tramp[6] = 0x7c0803a6;  /*   mtlr    r0   */
+	tramp[7] = 0x7d8903a6;  /*   mtctr   r12  */
+	tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11) static chain  */
+	tramp[9] = 0x4e800420;  /*   bctr  */
+	tramp[2] = (unsigned long) ffi_closure_ASM; /* function  */
+	tramp[3] = (unsigned long) codeloc; /* context  */
+#endif
+	closure->cif = cif;
+	closure->fun = fun;
+	closure->user_data = user_data;
+
+	/* Flush the icache. Only necessary on Darwin.  */
+	flush_range(codeloc, FFI_TRAMPOLINE_SIZE);
+
+	break;
+
+    case FFI_AIX:
+
+      tramp_aix = (struct ffi_aix_trampoline_struct *) (closure->tramp);
+      fd = (aix_fd *)(void *)ffi_closure_ASM;
+
+      FFI_ASSERT (cif->abi == FFI_AIX);
+
+      tramp_aix->code_pointer = fd->code_pointer;
+      tramp_aix->toc = fd->toc;
+      tramp_aix->static_chain = codeloc;
+      closure->cif = cif;
+      closure->fun = fun;
+      closure->user_data = user_data;
+      break;
+
+    default:
+      return FFI_BAD_ABI;
+      break;
+    }
+  return FFI_OK;
+}
+
+#if defined (FFI_GO_CLOSURES)
+ffi_status
+ffi_prep_go_closure (ffi_go_closure* closure,
+		     ffi_cif* cif,
+		     void (*fun)(ffi_cif*, void*, void**, void*))
+{
+  switch (cif->abi)
+    {
+      case FFI_AIX:
+
+        FFI_ASSERT (cif->abi == FFI_AIX);
+
+        closure->tramp = (void *)ffi_go_closure_ASM;
+        closure->cif = cif;
+        closure->fun = fun;
+        return FFI_OK;
+      
+      // For now, ffi_prep_go_closure is only implemented for AIX, not for Darwin
+      default:
+        return FFI_BAD_ABI;
+        break;
+    }
+  return FFI_OK;
+}
+#endif
+
+static void
+flush_icache(char *addr)
+{
+#ifndef _AIX
+  __asm__ volatile (
+		"dcbf 0,%0\n"
+		"\tsync\n"
+		"\ticbi 0,%0\n"
+		"\tsync\n"
+		"\tisync"
+		: : "r"(addr) : "memory");
+#endif
+}
+
+static void
+flush_range(char * addr1, int size)
+{
+#define MIN_LINE_SIZE 32
+  int i;
+  for (i = 0; i < size; i += MIN_LINE_SIZE)
+    flush_icache(addr1+i);
+  flush_icache(addr1+size-1);
+}
+
+typedef union
+{
+  float f;
+  double d;
+} ffi_dblfl;
+
+ffi_type *
+ffi_closure_helper_DARWIN (ffi_closure *, void *,
+			   unsigned long *, ffi_dblfl *);
+
+#if defined (FFI_GO_CLOSURES)
+ffi_type *
+ffi_go_closure_helper_DARWIN (ffi_go_closure*, void *,
+			      unsigned long *, ffi_dblfl *);
+#endif
+
+/* Basically the trampoline invokes ffi_closure_ASM, and on
+   entry, r11 holds the address of the closure.
+   After storing the registers that could possibly contain
+   parameters to be passed into the stack frame and setting
+   up space for a return value, ffi_closure_ASM invokes the
+   following helper function to do most of the work.  */
+
+static ffi_type *
+ffi_closure_helper_common (ffi_cif* cif,
+			   void (*fun)(ffi_cif*, void*, void**, void*),
+			   void *user_data, void *rvalue,
+			   unsigned long *pgr, ffi_dblfl *pfr)
+{
+  /* rvalue is the pointer to space for return value in closure assembly
+     pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM
+     pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM.  */
+
+  typedef double ldbits[2];
+
+  union ldu
+  {
+    ldbits lb;
+    long double ld;
+  };
+
+  void **          avalue;
+  ffi_type **      arg_types;
+  long             i, avn;
+  ffi_dblfl *      end_pfr = pfr + NUM_FPR_ARG_REGISTERS;
+  unsigned         size_al;
+#if defined(POWERPC_DARWIN64)
+  unsigned 	   fpsused = 0;
+#endif
+
+  avalue = alloca (cif->nargs * sizeof(void *));
+
+  if (cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+#if defined(POWERPC_DARWIN64)
+      if (!darwin64_struct_ret_by_value_p (cif->rtype))
+	{
+    	  /* Won't fit into the regs - return by ref.  */
+	  rvalue = (void *) *pgr;
+	  pgr++;
+	}
+#elif defined(DARWIN_PPC)
+      if (cif->rtype->size > 4)
+	{
+	  rvalue = (void *) *pgr;
+	  pgr++;
+	}
+#else /* assume we return by ref.  */
+      rvalue = (void *) *pgr;
+      pgr++;
+#endif
+    }
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  while (i < avn)
+    {
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+#if  defined(POWERPC64)
+	  avalue[i] = (char *) pgr + 7;
+#else
+	  avalue[i] = (char *) pgr + 3;
+#endif
+	  pgr++;
+	  break;
+
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+#if  defined(POWERPC64)
+	  avalue[i] = (char *) pgr + 6;
+#else
+	  avalue[i] = (char *) pgr + 2;
+#endif
+	  pgr++;
+	  break;
+
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+#if  defined(POWERPC64)
+	  avalue[i] = (char *) pgr + 4;
+#else
+	case FFI_TYPE_POINTER:
+	  avalue[i] = pgr;
+#endif
+	  pgr++;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  size_al = arg_types[i]->size;
+#if defined(POWERPC_DARWIN64)
+	  pgr = (unsigned long *)FFI_ALIGN((char *)pgr, arg_types[i]->alignment);
+	  if (size_al < 3 || size_al == 4)
+	    {
+	      avalue[i] = ((char *)pgr)+8-size_al;
+	      if (arg_types[i]->elements[0]->type == FFI_TYPE_FLOAT
+		  && fpsused < NUM_FPR_ARG_REGISTERS)
+		{
+		  *(float *)pgr = (float) *(double *)pfr;
+		  pfr++;
+		  fpsused++;
+		}
+	    }
+	  else 
+	    {
+	      if (size_al != 16)
+		pfr = (ffi_dblfl *) 
+		    darwin64_struct_floats_to_mem (arg_types[i], (char *)pgr,
+						   (double *)pfr, &fpsused);
+	      avalue[i] = pgr;
+	    }
+	  pgr += (size_al + 7) / 8;
+#else
+	  /* If the first member of the struct is a double, then align
+	     the struct to double-word.  */
+	  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)
+	    size_al = FFI_ALIGN(arg_types[i]->size, 8);
+#  if defined(POWERPC64)
+	  FFI_ASSERT (cif->abi != FFI_DARWIN);
+	  avalue[i] = pgr;
+	  pgr += (size_al + 7) / 8;
+#  else
+	  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,
+	     SI 4 bytes) are aligned as if they were those modes.  */
+	  if (size_al < 3 && cif->abi == FFI_DARWIN)
+	    avalue[i] = (char*) pgr + 4 - size_al;
+	  else
+	    avalue[i] = pgr;
+	  pgr += (size_al + 3) / 4;
+#  endif
+#endif
+	  break;
+
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+#if  defined(POWERPC64)
+	case FFI_TYPE_POINTER:
+	  avalue[i] = pgr;
+	  pgr++;
+	  break;
+#else
+	  /* Long long ints are passed in two gpr's.  */
+	  avalue[i] = pgr;
+	  pgr += 2;
+	  break;
+#endif
+
+	case FFI_TYPE_FLOAT:
+	  /* A float value consumes a GPR.
+	     There are 13 64bit floating point registers.  */
+	  if (pfr < end_pfr)
+	    {
+	      double temp = pfr->d;
+	      pfr->f = (float) temp;
+	      avalue[i] = pfr;
+	      pfr++;
+	    }
+	  else
+	    {
+	      avalue[i] = pgr;
+	    }
+	  pgr++;
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  /* A double value consumes two GPRs.
+	     There are 13 64bit floating point registers.  */
+	  if (pfr < end_pfr)
+	    {
+	      avalue[i] = pfr;
+	      pfr++;
+	    }
+	  else
+	    {
+	      avalue[i] = pgr;
+	    }
+#ifdef POWERPC64
+	  pgr++;
+#else
+	  pgr += 2;
+#endif
+	  break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+
+	case FFI_TYPE_LONGDOUBLE:
+#ifdef POWERPC64
+	  if (pfr + 1 < end_pfr)
+	    {
+	      avalue[i] = pfr;
+	      pfr += 2;
+	    }
+	  else
+	    {
+	      if (pfr < end_pfr)
+		{
+		  *pgr = *(unsigned long *) pfr;
+		  pfr++;
+		}
+	      avalue[i] = pgr;
+	    }
+	  pgr += 2;
+#else  /* POWERPC64 */
+	  /* A long double value consumes four GPRs and two FPRs.
+	     There are 13 64bit floating point registers.  */
+	  if (pfr + 1 < end_pfr)
+	    {
+	      avalue[i] = pfr;
+	      pfr += 2;
+	    }
+	  /* Here we have the situation where one part of the long double
+	     is stored in fpr13 and the other part is already on the stack.
+	     We use a union to pass the long double to avalue[i].  */
+	  else if (pfr + 1 == end_pfr)
+	    {
+	      union ldu temp_ld;
+	      memcpy (&temp_ld.lb[0], pfr, sizeof(ldbits));
+	      memcpy (&temp_ld.lb[1], pgr + 2, sizeof(ldbits));
+	      avalue[i] = &temp_ld.ld;
+	      pfr++;
+	    }
+	  else
+	    {
+	      avalue[i] = pgr;
+	    }
+	  pgr += 4;
+#endif  /* POWERPC64 */
+	  break;
+#endif
+	default:
+	  FFI_ASSERT(0);
+	}
+      i++;
+    }
+
+  (fun) (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_ASM to perform return type promotions.  */
+  return cif->rtype;
+}
+
+ffi_type *
+ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,
+			   unsigned long *pgr, ffi_dblfl *pfr)
+{
+  return ffi_closure_helper_common (closure->cif, closure->fun,
+				    closure->user_data, rvalue, pgr, pfr);
+}
+
+#if defined (FFI_GO_CLOSURES)
+ffi_type *
+ffi_go_closure_helper_DARWIN (ffi_go_closure *closure, void *rvalue,
+			      unsigned long *pgr, ffi_dblfl *pfr)
+{
+  return ffi_closure_helper_common (closure->cif, closure->fun,
+				    closure, rvalue, pgr, pfr);
+}
+#endif
Index: libffi-3.4.6/src/powerpc/aix_closure.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/aix_closure.S b/libffi-3.4.6/src/powerpc/aix_closure.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/aix_closure.S	
@@ -0,0 +1,694 @@
+/* -----------------------------------------------------------------------
+   aix_closure.S - Copyright (c) 2002, 2003, 2009 Free Software Foundation, Inc.
+   based on darwin_closure.S
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+	.set r0,0
+	.set r1,1
+	.set r2,2
+	.set r3,3
+	.set r4,4
+	.set r5,5
+	.set r6,6
+	.set r7,7
+	.set r8,8
+	.set r9,9
+	.set r10,10
+	.set r11,11
+	.set r12,12
+	.set r13,13
+	.set r14,14
+	.set r15,15
+	.set r16,16
+	.set r17,17
+	.set r18,18
+	.set r19,19
+	.set r20,20
+	.set r21,21
+	.set r22,22
+	.set r23,23
+	.set r24,24
+	.set r25,25
+	.set r26,26
+	.set r27,27
+	.set r28,28
+	.set r29,29
+	.set r30,30
+	.set r31,31
+	.set f0,0
+	.set f1,1
+	.set f2,2
+	.set f3,3
+	.set f4,4
+	.set f5,5
+	.set f6,6
+	.set f7,7
+	.set f8,8
+	.set f9,9
+	.set f10,10
+	.set f11,11
+	.set f12,12
+	.set f13,13
+	.set f14,14
+	.set f15,15
+	.set f16,16
+	.set f17,17
+	.set f18,18
+	.set f19,19
+	.set f20,20
+	.set f21,21
+
+	.extern .ffi_closure_helper_DARWIN
+	.extern .ffi_go_closure_helper_DARWIN
+
+#define LIBFFI_ASM
+#define JUMPTARGET(name) name
+#define L(x) x
+	.file "aix_closure.S"
+	.toc
+LC..60:
+	.tc L..60[TC],L..60
+	.csect .text[PR]
+	.align 2
+
+.csect .text[PR]
+	.align 2
+	.globl ffi_closure_ASM
+	.globl .ffi_closure_ASM
+.csect ffi_closure_ASM[DS]
+ffi_closure_ASM:
+#ifdef __64BIT__
+	.llong .ffi_closure_ASM, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_closure_ASM:
+	.function .ffi_closure_ASM,.ffi_closure_ASM,16,044,LFE..0-LFB..0
+	.bf __LINE__
+	.line 1
+LFB..0:
+/* we want to build up an area for the parameters passed */
+/* in registers (both floating point and integer) */
+
+	/* we store gpr 3 to gpr 10 (aligned to 4)
+	in the parents outgoing area  */
+	std   r3, 48+(0*8)(r1)
+	std   r4, 48+(1*8)(r1)
+	std   r5, 48+(2*8)(r1)
+	std   r6, 48+(3*8)(r1)
+	mflr  r0
+
+	std   r7, 48+(4*8)(r1)
+	std   r8, 48+(5*8)(r1)
+	std   r9, 48+(6*8)(r1)
+	std   r10, 48+(7*8)(r1)
+	std   r0, 16(r1)	/* save the return address */
+LCFI..0:
+	/* 48  Bytes (Linkage Area) */
+	/* 64  Bytes (params) */
+	/* 16  Bytes (result) */
+	/* 104 Bytes (13*8 from FPR) */
+	/* 8   Bytes (alignment) */
+	/* 240 Bytes */
+
+	stdu  r1, -240(r1)	/* skip over caller save area
+				   keep stack aligned to 16  */
+LCFI..1:
+
+	/* next save fpr 1 to fpr 13 (aligned to 8) */
+	stfd  f1, 128+(0*8)(r1)
+	stfd  f2, 128+(1*8)(r1)
+	stfd  f3, 128+(2*8)(r1)
+	stfd  f4, 128+(3*8)(r1)
+	stfd  f5, 128+(4*8)(r1)
+	stfd  f6, 128+(5*8)(r1)
+	stfd  f7, 128+(6*8)(r1)
+	stfd  f8, 128+(7*8)(r1)
+	stfd  f9, 128+(8*8)(r1)
+	stfd  f10, 128+(9*8)(r1)
+	stfd  f11, 128+(10*8)(r1)
+	stfd  f12, 128+(11*8)(r1)
+	stfd  f13, 128+(12*8)(r1)
+
+	/* set up registers for the routine that actually does the work */
+	/* get the context pointer from the trampoline */
+	mr r3, r11
+
+	/* now load up the pointer to the result storage */
+	addi r4, r1, 112
+
+	/* now load up the pointer to the saved gpr registers */
+	addi r5, r1, 288
+
+	/* now load up the pointer to the saved fpr registers */
+	addi r6, r1, 128
+
+	/* make the call */
+	bl .ffi_closure_helper_DARWIN
+	nop
+
+.Ldoneclosure:
+
+	/* now r3 contains the return type */
+	/* so use it to look up in a table */
+	/* so we know how to deal with each type */
+
+	/* look up the proper starting point in table  */
+	/* by using return type as offset */
+	lhz	r3, 10(r3)	/* load type from return type */
+	ld	r4, LC..60(2)	/* get address of jump table */
+	sldi	r3, r3, 4	/* now multiply return type by 16 */
+	ld	r0, 240+16(r1)	/* load return address */
+	add	r3, r3, r4	/* add contents of table to table address */
+	mtctr	r3
+	bctr			/* jump to it */
+
+/* Each fragment must be exactly 16 bytes long (4 instructions).
+   Align to 16 byte boundary for cache and dispatch efficiency.  */
+	.align 4
+
+L..60:
+/* case FFI_TYPE_VOID */
+	mtlr r0
+	addi r1, r1, 240
+	blr
+	nop
+
+/* case FFI_TYPE_INT */
+	lwa r3, 112+4(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_FLOAT */
+	lfs f1, 112+0(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_DOUBLE */
+	lfd f1, 112+0(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_LONGDOUBLE */
+	lfd f1, 112+0(r1)
+	mtlr r0
+	lfd f2, 112+8(r1)
+	b L..finish
+
+/* case FFI_TYPE_UINT8 */
+	lbz r3, 112+7(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_SINT8 */
+	lbz r3, 112+7(r1)
+	mtlr r0
+	extsb r3, r3
+	b L..finish
+
+/* case FFI_TYPE_UINT16 */
+	lhz r3, 112+6(r1)
+	mtlr r0
+L..finish:
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_SINT16 */
+	lha r3, 112+6(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_UINT32 */
+	lwz r3, 112+4(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_SINT32 */
+	lwa r3, 112+4(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_UINT64 */
+	ld r3, 112+0(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_SINT64 */
+	ld r3, 112+0(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+
+/* case FFI_TYPE_STRUCT */
+	mtlr r0
+	addi r1, r1, 240
+	blr
+	nop
+
+/* case FFI_TYPE_POINTER */
+	ld r3, 112+0(r1)
+	mtlr r0
+	addi r1, r1, 240
+	blr
+LFE..0:
+
+#else /* ! __64BIT__ */
+	
+	.long .ffi_closure_ASM, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_closure_ASM:
+	.function .ffi_closure_ASM,.ffi_closure_ASM,16,044,LFE..0-LFB..0
+	.bf __LINE__
+	.line 1
+LFB..0:
+/* we want to build up an area for the parameters passed */
+/* in registers (both floating point and integer) */
+
+	/* we store gpr 3 to gpr 10 (aligned to 4)
+	in the parents outgoing area  */
+	stw   r3, 24+(0*4)(r1)
+	stw   r4, 24+(1*4)(r1)
+	stw   r5, 24+(2*4)(r1)
+	stw   r6, 24+(3*4)(r1)
+	mflr  r0
+
+	stw   r7, 24+(4*4)(r1)
+	stw   r8, 24+(5*4)(r1)
+	stw   r9, 24+(6*4)(r1)
+	stw   r10, 24+(7*4)(r1)
+	stw   r0, 8(r1)
+LCFI..0:
+	/* 24 Bytes (Linkage Area) */
+	/* 32 Bytes (params) */
+	/* 16  Bytes (result) */
+	/* 104 Bytes (13*8 from FPR) */
+	/* 176 Bytes */
+
+	stwu  r1, -176(r1)	/* skip over caller save area
+				   keep stack aligned to 16  */
+LCFI..1:
+
+	/* next save fpr 1 to fpr 13 (aligned to 8) */
+	stfd  f1, 72+(0*8)(r1)
+	stfd  f2, 72+(1*8)(r1)
+	stfd  f3, 72+(2*8)(r1)
+	stfd  f4, 72+(3*8)(r1)
+	stfd  f5, 72+(4*8)(r1)
+	stfd  f6, 72+(5*8)(r1)
+	stfd  f7, 72+(6*8)(r1)
+	stfd  f8, 72+(7*8)(r1)
+	stfd  f9, 72+(8*8)(r1)
+	stfd  f10, 72+(9*8)(r1)
+	stfd  f11, 72+(10*8)(r1)
+	stfd  f12, 72+(11*8)(r1)
+	stfd  f13, 72+(12*8)(r1)
+
+	/* set up registers for the routine that actually does the work */
+	/* get the context pointer from the trampoline */
+	mr r3, r11
+
+	/* now load up the pointer to the result storage */
+	addi r4, r1, 56
+
+	/* now load up the pointer to the saved gpr registers */
+	addi r5, r1, 200
+
+	/* now load up the pointer to the saved fpr registers */
+	addi r6, r1, 72
+
+	/* make the call */
+	bl .ffi_closure_helper_DARWIN
+	nop
+
+.Ldoneclosure:
+
+	/* now r3 contains the return type */
+	/* so use it to look up in a table */
+	/* so we know how to deal with each type */
+
+	/* look up the proper starting point in table  */
+	/* by using return type as offset */
+	lhz	r3, 6(r3)	/* load type from return type */
+	lwz	r4, LC..60(2)	/* get address of jump table */
+	slwi	r3, r3, 4	/* now multiply return type by 16 */
+	lwz	r0, 176+8(r1)	/* load return address */
+	add	r3, r3, r4	/* add contents of table to table address */
+	mtctr	r3
+	bctr			/* jump to it */
+
+/* Each fragment must be exactly 16 bytes long (4 instructions).
+   Align to 16 byte boundary for cache and dispatch efficiency.  */
+	.align 4
+
+L..60:
+/* case FFI_TYPE_VOID */
+	mtlr r0
+	addi r1, r1, 176
+	blr
+	nop
+
+/* case FFI_TYPE_INT */
+	lwz r3, 56+0(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_FLOAT */
+	lfs f1, 56+0(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_DOUBLE */
+	lfd f1, 56+0(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_LONGDOUBLE */
+	lfd f1, 56+0(r1)
+	mtlr r0
+	lfd f2, 56+8(r1)
+	b L..finish
+
+/* case FFI_TYPE_UINT8 */
+	lbz r3, 56+3(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_SINT8 */
+	lbz r3, 56+3(r1)
+	mtlr r0
+	extsb r3, r3
+	b L..finish
+
+/* case FFI_TYPE_UINT16 */
+	lhz r3, 56+2(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_SINT16 */
+	lha r3, 56+2(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_UINT32 */
+	lwz r3, 56+0(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_SINT32 */
+	lwz r3, 56+0(r1)
+	mtlr r0
+	addi r1, r1, 176
+	blr
+
+/* case FFI_TYPE_UINT64 */
+	lwz r3, 56+0(r1)
+	mtlr r0
+	lwz r4, 56+4(r1)
+	b L..finish
+
+/* case FFI_TYPE_SINT64 */
+	lwz r3, 56+0(r1)
+	mtlr r0
+	lwz r4, 56+4(r1)
+	b L..finish
+
+/* case FFI_TYPE_STRUCT */
+	mtlr r0
+	addi r1, r1, 176
+	blr
+	nop
+
+/* case FFI_TYPE_POINTER */
+	lwz r3, 56+0(r1)
+	mtlr r0
+L..finish:
+	addi r1, r1, 176
+	blr
+LFE..0:
+#endif
+	.ef __LINE__
+/* END(ffi_closure_ASM) */
+
+
+.csect .text[PR]
+	.align 2
+	.globl ffi_go_closure_ASM
+	.globl .ffi_go_closure_ASM
+.csect ffi_go_closure_ASM[DS]
+ffi_go_closure_ASM:
+#ifdef __64BIT__
+	.llong .ffi_go_closure_ASM, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_go_closure_ASM:
+	.function .ffi_go_closure_ASM,.ffi_go_closure_ASM,16,044,LFE..1-LFB..1
+	.bf __LINE__
+	.line 1
+LFB..1:
+/* we want to build up an area for the parameters passed */
+/* in registers (both floating point and integer) */
+
+	/* we store gpr 3 to gpr 10 (aligned to 4)
+	in the parents outgoing area  */
+	std   r3, 48+(0*8)(r1)
+	std   r4, 48+(1*8)(r1)
+	std   r5, 48+(2*8)(r1)
+	std   r6, 48+(3*8)(r1)
+	mflr  r0
+
+	std   r7, 48+(4*8)(r1)
+	std   r8, 48+(5*8)(r1)
+	std   r9, 48+(6*8)(r1)
+	std   r10, 48+(7*8)(r1)
+	std   r0, 16(r1)	/* save the return address */
+LCFI..2:
+	/* 48  Bytes (Linkage Area) */
+	/* 64  Bytes (params) */
+	/* 16  Bytes (result) */
+	/* 104 Bytes (13*8 from FPR) */
+	/* 8   Bytes (alignment) */
+	/* 240 Bytes */
+
+	stdu  r1, -240(r1)	/* skip over caller save area
+				   keep stack aligned to 16  */
+LCFI..3:
+
+	/* next save fpr 1 to fpr 13 (aligned to 8) */
+	stfd  f1, 128+(0*8)(r1)
+	stfd  f2, 128+(1*8)(r1)
+	stfd  f3, 128+(2*8)(r1)
+	stfd  f4, 128+(3*8)(r1)
+	stfd  f5, 128+(4*8)(r1)
+	stfd  f6, 128+(5*8)(r1)
+	stfd  f7, 128+(6*8)(r1)
+	stfd  f8, 128+(7*8)(r1)
+	stfd  f9, 128+(8*8)(r1)
+	stfd  f10, 128+(9*8)(r1)
+	stfd  f11, 128+(10*8)(r1)
+	stfd  f12, 128+(11*8)(r1)
+	stfd  f13, 128+(12*8)(r1)
+
+	/* set up registers for the routine that actually does the work */
+	mr r3, r11	/* go closure */
+
+	/* now load up the pointer to the result storage */
+	addi r4, r1, 112
+
+	/* now load up the pointer to the saved gpr registers */
+	addi r5, r1, 288
+
+	/* now load up the pointer to the saved fpr registers */
+	addi r6, r1, 128
+
+	/* make the call */
+	bl .ffi_go_closure_helper_DARWIN
+	nop
+
+	b .Ldoneclosure
+LFE..1:
+
+#else /* ! __64BIT__ */
+	
+	.long .ffi_go_closure_ASM, TOC[tc0], 0
+	.csect .text[PR]
+.ffi_go_closure_ASM:
+	.function .ffi_go_closure_ASM,.ffi_go_closure_ASM,16,044,LFE..1-LFB..1
+	.bf __LINE__
+	.line 1
+LFB..1:
+/* we want to build up an area for the parameters passed */
+/* in registers (both floating point and integer) */
+
+	/* we store gpr 3 to gpr 10 (aligned to 4)
+	in the parents outgoing area  */
+	stw   r3, 24+(0*4)(r1)
+	stw   r4, 24+(1*4)(r1)
+	stw   r5, 24+(2*4)(r1)
+	stw   r6, 24+(3*4)(r1)
+	mflr  r0
+
+	stw   r7, 24+(4*4)(r1)
+	stw   r8, 24+(5*4)(r1)
+	stw   r9, 24+(6*4)(r1)
+	stw   r10, 24+(7*4)(r1)
+	stw   r0, 8(r1)
+LCFI..2:
+	/* 24 Bytes (Linkage Area) */
+	/* 32 Bytes (params) */
+	/* 16  Bytes (result) */
+	/* 104 Bytes (13*8 from FPR) */
+	/* 176 Bytes */
+
+	stwu  r1, -176(r1)	/* skip over caller save area
+				   keep stack aligned to 16  */
+LCFI..3:
+
+	/* next save fpr 1 to fpr 13 (aligned to 8) */
+	stfd  f1, 72+(0*8)(r1)
+	stfd  f2, 72+(1*8)(r1)
+	stfd  f3, 72+(2*8)(r1)
+	stfd  f4, 72+(3*8)(r1)
+	stfd  f5, 72+(4*8)(r1)
+	stfd  f6, 72+(5*8)(r1)
+	stfd  f7, 72+(6*8)(r1)
+	stfd  f8, 72+(7*8)(r1)
+	stfd  f9, 72+(8*8)(r1)
+	stfd  f10, 72+(9*8)(r1)
+	stfd  f11, 72+(10*8)(r1)
+	stfd  f12, 72+(11*8)(r1)
+	stfd  f13, 72+(12*8)(r1)
+
+	/* set up registers for the routine that actually does the work */
+	mr   r3, 11	/* go closure */
+
+	/* now load up the pointer to the result storage */
+	addi r4, r1, 56
+
+	/* now load up the pointer to the saved gpr registers */
+	addi r5, r1, 200
+
+	/* now load up the pointer to the saved fpr registers */
+	addi r6, r1, 72
+
+	/* make the call */
+	bl .ffi_go_closure_helper_DARWIN
+	nop
+
+	b    .Ldoneclosure
+LFE..1:
+#endif
+	.ef __LINE__
+/* END(ffi_go_closure_ASM) */
+
+/* EH frame stuff.  */
+
+#define LR_REGNO		0x41		/* Link Register (65), see rs6000.md */
+#ifdef __64BIT__
+#define PTRSIZE			8
+#define LOG2_PTRSIZE		3
+#define CFA_OFFSET		0xf0,0x01	/* LEB128 240 */
+#define FDE_ENCODING		0x1c		/* DW_EH_PE_pcrel|DW_EH_PE_sdata8 */
+#define EH_DATA_ALIGN_FACT	0x78		/* LEB128 -8 */
+#else
+#define PTRSIZE			4
+#define LOG2_PTRSIZE		2
+#define CFA_OFFSET		0xb0,0x01	/* LEB128 176 */
+#define FDE_ENCODING		0x1b		/* DW_EH_PE_pcrel|DW_EH_PE_sdata4 */
+#define EH_DATA_ALIGN_FACT	0x7c		/* LEB128 -4 */
+#endif
+
+	.csect	_unwind.ro_[RO],4
+	.align	LOG2_PTRSIZE
+	.globl	_GLOBAL__F_libffi_src_powerpc_aix_closure
+_GLOBAL__F_libffi_src_powerpc_aix_closure:
+Lframe..1:
+	.vbyte	4,LECIE..1-LSCIE..1	/* CIE Length */
+LSCIE..1:
+	.vbyte	4,0			/* CIE Identifier Tag */
+	.byte	0x3			/* CIE Version */
+	.byte	"zR"			/* CIE Augmentation */
+	.byte	0
+	.byte	0x1			/* uleb128 0x1; CIE Code Alignment Factor */
+	.byte	EH_DATA_ALIGN_FACT	/* leb128 -4/-8; CIE Data Alignment Factor */
+	.byte	LR_REGNO		/* CIE RA Column */
+	.byte	0x1			/* uleb128 0x1; Augmentation size */
+	.byte	FDE_ENCODING		/* FDE Encoding (pcrel|sdata4/8) */
+	.byte	0xc			/* DW_CFA_def_cfa */
+	.byte	0x1			/*     uleb128 0x1; Register r1 */
+	.byte	0			/*     uleb128 0x0; Offset 0 */
+	.align	LOG2_PTRSIZE
+LECIE..1:
+LSFDE..1:
+	.vbyte	4,LEFDE..1-LASFDE..1	/* FDE Length */
+LASFDE..1:
+	.vbyte	4,LASFDE..1-Lframe..1	/* FDE CIE offset */
+	.vbyte	PTRSIZE,LFB..0-$	/* FDE initial location */
+	.vbyte	PTRSIZE,LFE..0-LFB..0	/* FDE address range */
+	.byte	0			/* uleb128 0x0; Augmentation size */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..1-LCFI..0
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	CFA_OFFSET		/*     uleb128 176/240 */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..0-LFB..0
+	.byte	0x11			/* DW_CFA_offset_extended_sf */
+	.byte	LR_REGNO		/*     uleb128 LR_REGNO; Register LR */
+	.byte	0x7e			/*     leb128 -2; Offset -2 (8/16) */
+	.align	LOG2_PTRSIZE
+LEFDE..1:
+LSFDE..2:
+	.vbyte	4,LEFDE..2-LASFDE..2	/* FDE Length */
+LASFDE..2:
+	.vbyte	4,LASFDE..2-Lframe..1	/* FDE CIE offset */
+	.vbyte	PTRSIZE,LFB..1-$	/* FDE initial location */
+	.vbyte	PTRSIZE,LFE..1-LFB..1	/* FDE address range */
+	.byte	0			/* uleb128 0x0; Augmentation size */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..3-LCFI..2
+	.byte	0xe			/* DW_CFA_def_cfa_offset */
+	.byte	CFA_OFFSET		/*     uleb128 176/240 */
+	.byte	0x4			/* DW_CFA_advance_loc4 */
+	.vbyte	4,LCFI..2-LFB..1
+	.byte	0x11			/* DW_CFA_offset_extended_sf */
+	.byte	LR_REGNO		/*     uleb128 LR_REGNO; Register LR */
+	.byte	0x7e			/*     leb128 -2; Offset -2 (8/16) */
+	.align	LOG2_PTRSIZE
+LEFDE..2:
+	.vbyte	4,0			/* End of FDEs */
+
+	.csect	.text[PR]
+	.ref	_GLOBAL__F_libffi_src_powerpc_aix_closure	/* Prevents garbage collection by AIX linker */
+
Index: libffi-3.4.6/src/powerpc/ffi_linux64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffi_linux64.c b/libffi-3.4.6/src/powerpc/ffi_linux64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffi_linux64.c	
@@ -0,0 +1,1153 @@
+/* -----------------------------------------------------------------------
+   ffi_linux64.c - Copyright (C) 2013 IBM
+                   Copyright (C) 2011 Anthony Green
+                   Copyright (C) 2011 Kyle Moffett
+                   Copyright (C) 2008 Red Hat, Inc
+                   Copyright (C) 2007, 2008 Free Software Foundation, Inc
+                   Copyright (c) 1998 Geoffrey Keating
+
+   PowerPC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include "ffi.h"
+
+#ifdef POWERPC64
+#include "ffi_common.h"
+#include "ffi_powerpc.h"
+
+
+/* About the LINUX64 ABI.  */
+enum {
+  NUM_GPR_ARG_REGISTERS64 = 8,
+  NUM_FPR_ARG_REGISTERS64 = 13,
+  NUM_VEC_ARG_REGISTERS64 = 12,
+};
+enum { ASM_NEEDS_REGISTERS64 = 4 };
+
+
+#if HAVE_LONG_DOUBLE_VARIANT && FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+/* Adjust size of ffi_type_longdouble.  */
+void FFI_HIDDEN
+ffi_prep_types_linux64 (ffi_abi abi)
+{
+  if ((abi & (FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128)) == FFI_LINUX)
+    {
+      ffi_type_longdouble.size = 8;
+      ffi_type_longdouble.alignment = 8;
+    }
+  else
+    {
+      ffi_type_longdouble.size = 16;
+      ffi_type_longdouble.alignment = 16;
+    }
+}
+#endif
+
+
+static unsigned int
+discover_homogeneous_aggregate (ffi_abi abi,
+                                const ffi_type *t,
+                                unsigned int *elnum)
+{
+  switch (t->type)
+    {
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      /* 64-bit long doubles are equivalent to doubles. */
+      if ((abi & FFI_LINUX_LONG_DOUBLE_128) == 0)
+        {
+          *elnum = 1;
+          return FFI_TYPE_DOUBLE;
+        }
+      /* IBM extended precision values use unaligned pairs
+         of FPRs, but according to the ABI must be considered
+         distinct from doubles. They are also limited to a
+         maximum of four members in a homogeneous aggregate. */
+      else if ((abi & FFI_LINUX_LONG_DOUBLE_IEEE128) == 0)
+        {
+          *elnum = 2;
+          return FFI_TYPE_LONGDOUBLE;
+        }
+      /* Fall through. */
+#endif
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      *elnum = 1;
+      return (int) t->type;
+
+    case FFI_TYPE_STRUCT:;
+      {
+	unsigned int base_elt = 0, total_elnum = 0;
+	ffi_type **el = t->elements;
+	while (*el)
+	  {
+	    unsigned int el_elt, el_elnum = 0;
+	    el_elt = discover_homogeneous_aggregate (abi, *el, &el_elnum);
+	    if (el_elt == 0
+		|| (base_elt && base_elt != el_elt))
+	      return 0;
+	    base_elt = el_elt;
+	    total_elnum += el_elnum;
+#if _CALL_ELF == 2
+	    if (total_elnum > 8)
+	      return 0;
+#else
+	    if (total_elnum > 1)
+	      return 0;
+#endif
+	    el++;
+	  }
+	*elnum = total_elnum;
+	return base_elt;
+      }
+
+    default:
+      return 0;
+    }
+}
+
+
+/* Perform machine dependent cif processing */
+static ffi_status
+ffi_prep_cif_linux64_core (ffi_cif *cif)
+{
+  ffi_type **ptr;
+  unsigned bytes;
+  unsigned i, fparg_count = 0, intarg_count = 0, vecarg_count = 0;
+  unsigned flags = cif->flags;
+  unsigned elt, elnum, rtype;
+
+#if FFI_TYPE_LONGDOUBLE == FFI_TYPE_DOUBLE
+  /* If compiled without long double support... */
+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0 ||
+      (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+    return FFI_BAD_ABI;
+#elif !defined(__VEC__)
+  /* If compiled without vector register support (used by assembly)... */
+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+    return FFI_BAD_ABI;
+#else
+  /* If the IEEE128 flag is set, but long double is only 64 bits wide... */
+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) == 0 &&
+      (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+    return FFI_BAD_ABI;
+#endif
+
+  /* The machine-independent calculation of cif->bytes doesn't work
+     for us.  Redo the calculation.  */
+#if _CALL_ELF == 2
+  /* Space for backchain, CR, LR, TOC and the asm's temp regs.  */
+  bytes = (4 + ASM_NEEDS_REGISTERS64) * sizeof (long);
+
+  /* Space for the general registers.  */
+  bytes += NUM_GPR_ARG_REGISTERS64 * sizeof (long);
+#else
+  /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp
+     regs.  */
+  bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);
+
+  /* Space for the mandatory parm save area and general registers.  */
+  bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);
+#endif
+
+  /* Return value handling.  */
+  rtype = cif->rtype->type;
+#if _CALL_ELF == 2
+homogeneous:
+#endif
+  switch (rtype)
+    {
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+        {
+          flags |= FLAG_RETURNS_VEC;
+          break;
+        }
+      if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)
+	flags |= FLAG_RETURNS_128BITS;
+      /* Fall through.  */
+#endif
+    case FFI_TYPE_DOUBLE:
+      flags |= FLAG_RETURNS_64BITS;
+      /* Fall through.  */
+    case FFI_TYPE_FLOAT:
+      flags |= FLAG_RETURNS_FP;
+      break;
+
+    case FFI_TYPE_UINT128:
+      flags |= FLAG_RETURNS_128BITS;
+      /* Fall through.  */
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_POINTER:
+      flags |= FLAG_RETURNS_64BITS;
+      break;
+
+    case FFI_TYPE_STRUCT:
+#if _CALL_ELF == 2
+      elt = discover_homogeneous_aggregate (cif->abi, cif->rtype, &elnum);
+      if (elt)
+        {
+          flags |= FLAG_RETURNS_SMST;
+          rtype = elt;
+          goto homogeneous;
+        }
+      if (cif->rtype->size <= 16)
+        {
+          flags |= FLAG_RETURNS_SMST;
+          break;
+        }
+#endif
+      intarg_count++;
+      flags |= FLAG_RETVAL_REFERENCE;
+      /* Fall through.  */
+    case FFI_TYPE_VOID:
+      flags |= FLAG_RETURNS_NOTHING;
+      break;
+
+    default:
+      /* Returns 32-bit integer, or similar.  Nothing to do here.  */
+      break;
+    }
+
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+      unsigned int align;
+
+      switch ((*ptr)->type)
+	{
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+          if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+            {
+              vecarg_count++;
+              /* Align to 16 bytes, plus the 16-byte argument. */
+              intarg_count = (intarg_count + 3) & ~0x1;
+              if (vecarg_count > NUM_VEC_ARG_REGISTERS64)
+                flags |= FLAG_ARG_NEEDS_PSAVE;
+              break;
+            }
+	  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)
+	    {
+	      fparg_count++;
+	      intarg_count++;
+	    }
+	  /* Fall through.  */
+#endif
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_FLOAT:
+	  fparg_count++;
+	  intarg_count++;
+	  if (fparg_count > NUM_FPR_ARG_REGISTERS64)
+	    flags |= FLAG_ARG_NEEDS_PSAVE;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  if ((cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)
+	    {
+	      align = (*ptr)->alignment;
+	      if (align > 16)
+		align = 16;
+	      align = align / 8;
+	      if (align > 1)
+		intarg_count = FFI_ALIGN (intarg_count, align);
+	    }
+	  intarg_count += ((*ptr)->size + 7) / 8;
+	  elt = discover_homogeneous_aggregate (cif->abi, *ptr, &elnum);
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+          if (elt == FFI_TYPE_LONGDOUBLE &&
+              (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+            {
+              vecarg_count += elnum;
+              if (vecarg_count > NUM_VEC_ARG_REGISTERS64)
+                flags |= FLAG_ARG_NEEDS_PSAVE;
+              break;
+            }
+	  else
+#endif
+	  if (elt)
+	    {
+	      fparg_count += elnum;
+	      if (fparg_count > NUM_FPR_ARG_REGISTERS64)
+		flags |= FLAG_ARG_NEEDS_PSAVE;
+	    }
+	  else
+	    {
+	      if (intarg_count > NUM_GPR_ARG_REGISTERS64)
+		flags |= FLAG_ARG_NEEDS_PSAVE;
+	    }
+	  break;
+
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	  /* Everything else is passed as a 8-byte word in a GPR, either
+	     the object itself or a pointer to it.  */
+	  intarg_count++;
+	  if (intarg_count > NUM_GPR_ARG_REGISTERS64)
+	    flags |= FLAG_ARG_NEEDS_PSAVE;
+	  break;
+	default:
+	  FFI_ASSERT (0);
+	}
+    }
+
+  if (fparg_count != 0)
+    flags |= FLAG_FP_ARGUMENTS;
+  if (intarg_count > 4)
+    flags |= FLAG_4_GPR_ARGUMENTS;
+  if (vecarg_count != 0)
+    flags |= FLAG_VEC_ARGUMENTS;
+
+  /* Space for the FPR registers, if needed.  */
+  if (fparg_count != 0)
+    bytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);
+  /* Space for the vector registers, if needed, aligned to 16 bytes. */
+  if (vecarg_count != 0) {
+    bytes = (bytes + 15) & ~0xF;
+    bytes += NUM_VEC_ARG_REGISTERS64 * sizeof (float128);
+  }
+
+  /* Stack space.  */
+#if _CALL_ELF == 2
+  if ((flags & FLAG_ARG_NEEDS_PSAVE) != 0)
+    bytes += intarg_count * sizeof (long);
+#else
+  if (intarg_count > NUM_GPR_ARG_REGISTERS64)
+    bytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);
+#endif
+
+  /* The stack space allocated needs to be a multiple of 16 bytes.  */
+  bytes = (bytes + 15) & ~0xF;
+
+  cif->flags = flags;
+  cif->bytes = bytes;
+
+  return FFI_OK;
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_linux64 (ffi_cif *cif)
+{
+  if ((cif->abi & FFI_LINUX) != 0)
+    cif->nfixedargs = cif->nargs;
+#if _CALL_ELF != 2
+  else if (cif->abi == FFI_COMPAT_LINUX64)
+    {
+      /* This call is from old code.  Don't touch cif->nfixedargs
+	 since old code will be using a smaller cif.  */
+      cif->flags |= FLAG_COMPAT;
+      /* Translate to new abi value.  */
+      cif->abi = FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128;
+    }
+#endif
+  else
+    return FFI_BAD_ABI;
+  return ffi_prep_cif_linux64_core (cif);
+}
+
+ffi_status FFI_HIDDEN
+ffi_prep_cif_linux64_var (ffi_cif *cif,
+			  unsigned int nfixedargs,
+			  unsigned int ntotalargs MAYBE_UNUSED)
+{
+  if ((cif->abi & FFI_LINUX) != 0)
+    cif->nfixedargs = nfixedargs;
+#if _CALL_ELF != 2
+  else if (cif->abi == FFI_COMPAT_LINUX64)
+    {
+      /* This call is from old code.  Don't touch cif->nfixedargs
+	 since old code will be using a smaller cif.  */
+      cif->flags |= FLAG_COMPAT;
+      /* Translate to new abi value.  */
+      cif->abi = FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128;
+    }
+#endif
+  else
+    return FFI_BAD_ABI;
+#if _CALL_ELF == 2
+  cif->flags |= FLAG_ARG_NEEDS_PSAVE;
+#endif
+  return ffi_prep_cif_linux64_core (cif);
+}
+
+
+/* ffi_prep_args64 is called by the assembly routine once stack space
+   has been allocated for the function's arguments.
+
+   The stack layout we want looks like this:
+
+   |   Ret addr from ffi_call_LINUX64	8bytes	|	higher addresses
+   |--------------------------------------------|
+   |   CR save area			8bytes	|
+   |--------------------------------------------|
+   |   Previous backchain pointer	8	|	stack pointer here
+   |--------------------------------------------|<+ <<<	on entry to
+   |   Saved r28-r31			4*8	| |	ffi_call_LINUX64
+   |--------------------------------------------| |
+   |   GPR registers r3-r10		8*8	| |
+   |--------------------------------------------| |
+   |   FPR registers f1-f13 (optional)	13*8	| |
+   |--------------------------------------------| |
+   |   VEC registers v2-v13 (optional)  12*16   | |
+   |--------------------------------------------| |
+   |   Parameter save area		        | |
+   |--------------------------------------------| |
+   |   TOC save area			8	| |
+   |--------------------------------------------| |	stack	|
+   |   Linker doubleword		8	| |	grows	|
+   |--------------------------------------------| |	down	V
+   |   Compiler doubleword		8	| |
+   |--------------------------------------------| |	lower addresses
+   |   Space for callee's LR		8	| |
+   |--------------------------------------------| |
+   |   CR save area			8	| |
+   |--------------------------------------------| |	stack pointer here
+   |   Current backchain pointer	8	|-/	during
+   |--------------------------------------------|   <<<	ffi_call_LINUX64
+
+*/
+
+void FFI_HIDDEN
+ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)
+{
+  const unsigned long bytes = ecif->cif->bytes;
+  const unsigned long flags = ecif->cif->flags;
+
+  typedef union
+  {
+    char *c;
+    unsigned long *ul;
+    float *f;
+    double *d;
+    float128 *f128;
+    size_t p;
+  } valp;
+
+  /* 'stacktop' points at the previous backchain pointer.  */
+  valp stacktop;
+
+  /* 'next_arg' points at the space for gpr3, and grows upwards as
+     we use GPR registers, then continues at rest.  */
+  valp gpr_base;
+  valp gpr_end;
+  valp rest;
+  valp next_arg;
+
+  /* 'fpr_base' points at the space for f1, and grows upwards as
+     we use FPR registers.  */
+  valp fpr_base;
+  unsigned int fparg_count;
+
+  /* 'vec_base' points at the space for v2, and grows upwards as
+     we use vector registers.  */
+  valp vec_base;
+  unsigned int vecarg_count;
+
+  unsigned int i, words, nargs, nfixedargs;
+  ffi_type **ptr;
+  double double_tmp;
+  union
+  {
+    void **v;
+    char **c;
+    signed char **sc;
+    unsigned char **uc;
+    signed short **ss;
+    unsigned short **us;
+    signed int **si;
+    unsigned int **ui;
+    unsigned long **ul;
+    float **f;
+    double **d;
+    float128 **f128;
+  } p_argv;
+  unsigned long gprvalue;
+  unsigned long align;
+
+  stacktop.c = (char *) stack + bytes;
+  gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;
+  gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;
+#if _CALL_ELF == 2
+  rest.ul = stack + 4 + NUM_GPR_ARG_REGISTERS64;
+#else
+  rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;
+#endif
+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;
+  fparg_count = 0;
+  /* Place the vector args below the FPRs, if used, else the GPRs. */
+  if (ecif->cif->flags & FLAG_FP_ARGUMENTS)
+    vec_base.p = fpr_base.p & ~0xF;
+  else
+    vec_base.p = gpr_base.p;
+  vec_base.f128 -= NUM_VEC_ARG_REGISTERS64;
+  vecarg_count = 0;
+  next_arg.ul = gpr_base.ul;
+
+  /* Check that everything starts aligned properly.  */
+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) gpr_base.c & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) gpr_end.c  & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) vec_base.c & 0xF) == 0);
+  FFI_ASSERT ((bytes & 0xF) == 0);
+
+  /* Deal with return values that are actually pass-by-reference.  */
+  if (flags & FLAG_RETVAL_REFERENCE)
+    *next_arg.ul++ = (unsigned long) (char *) ecif->rvalue;
+
+  /* Now for the arguments.  */
+  p_argv.v = ecif->avalue;
+  nargs = ecif->cif->nargs;
+#if _CALL_ELF != 2
+  nfixedargs = (unsigned) -1;
+  if ((flags & FLAG_COMPAT) == 0)
+#endif
+    nfixedargs = ecif->cif->nfixedargs;
+  for (ptr = ecif->cif->arg_types, i = 0;
+       i < nargs;
+       i++, ptr++, p_argv.v++)
+    {
+      unsigned int elt, elnum;
+
+      switch ((*ptr)->type)
+	{
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+          if ((ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+            {
+              next_arg.p = FFI_ALIGN (next_arg.p, 16);
+              if (next_arg.ul == gpr_end.ul)
+                next_arg.ul = rest.ul;
+              if (vecarg_count < NUM_VEC_ARG_REGISTERS64 && i < nfixedargs)
+		memcpy (vec_base.f128++, *p_argv.f128, sizeof (float128));
+              else
+		memcpy (next_arg.f128, *p_argv.f128, sizeof (float128));
+              if (++next_arg.f128 == gpr_end.f128)
+                next_arg.f128 = rest.f128;
+              vecarg_count++;
+              FFI_ASSERT (__LDBL_MANT_DIG__ == 113);
+              FFI_ASSERT (flags & FLAG_VEC_ARGUMENTS);
+              break;
+            }
+	  if ((ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)
+	    {
+	      double_tmp = (*p_argv.d)[0];
+	      if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)
+		{
+		  *fpr_base.d++ = double_tmp;
+# if _CALL_ELF != 2
+		  if ((flags & FLAG_COMPAT) != 0)
+		    *next_arg.d = double_tmp;
+# endif
+		}
+	      else
+		*next_arg.d = double_tmp;
+	      if (++next_arg.ul == gpr_end.ul)
+		next_arg.ul = rest.ul;
+	      fparg_count++;
+	      double_tmp = (*p_argv.d)[1];
+	      if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)
+		{
+		  *fpr_base.d++ = double_tmp;
+# if _CALL_ELF != 2
+		  if ((flags & FLAG_COMPAT) != 0)
+		    *next_arg.d = double_tmp;
+# endif
+		}
+	      else
+		*next_arg.d = double_tmp;
+	      if (++next_arg.ul == gpr_end.ul)
+		next_arg.ul = rest.ul;
+	      fparg_count++;
+	      FFI_ASSERT (__LDBL_MANT_DIG__ == 106);
+	      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	      break;
+	    }
+	  /* Fall through.  */
+#endif
+	case FFI_TYPE_DOUBLE:
+#if _CALL_ELF != 2
+	do_double:
+#endif
+	  double_tmp = **p_argv.d;
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)
+	    {
+	      *fpr_base.d++ = double_tmp;
+#if _CALL_ELF != 2
+	      if ((flags & FLAG_COMPAT) != 0)
+		*next_arg.d = double_tmp;
+#endif
+	    }
+	  else
+	    *next_arg.d = double_tmp;
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
+	  fparg_count++;
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+#if _CALL_ELF != 2
+	do_float:
+#endif
+	  double_tmp = **p_argv.f;
+	  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)
+	    {
+	      *fpr_base.d++ = double_tmp;
+#if _CALL_ELF != 2
+	      if ((flags & FLAG_COMPAT) != 0)
+		{
+# ifndef __LITTLE_ENDIAN__
+		  next_arg.f[1] = (float) double_tmp;
+# else
+		  next_arg.f[0] = (float) double_tmp;
+# endif
+		}
+#endif
+	    }
+	  else
+	    {
+# ifndef __LITTLE_ENDIAN__
+	      next_arg.f[1] = (float) double_tmp;
+# else
+	      next_arg.f[0] = (float) double_tmp;
+# endif
+	    }
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
+	  fparg_count++;
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  if ((ecif->cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)
+	    {
+	      align = (*ptr)->alignment;
+	      if (align > 16)
+		align = 16;
+	      if (align > 1)
+                {
+                  next_arg.p = FFI_ALIGN (next_arg.p, align);
+                  if (next_arg.ul == gpr_end.ul)
+                    next_arg.ul = rest.ul;
+                }
+	    }
+	  elt = discover_homogeneous_aggregate (ecif->cif->abi, *ptr, &elnum);
+	  if (elt)
+	    {
+#if _CALL_ELF == 2
+	      union {
+		void *v;
+		float *f;
+		double *d;
+		float128 *f128;
+	      } arg;
+
+	      arg.v = *p_argv.v;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+              if (elt == FFI_TYPE_LONGDOUBLE &&
+                  (ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+                {
+                  do
+                    {
+                      if (vecarg_count < NUM_VEC_ARG_REGISTERS64
+                          && i < nfixedargs)
+		        memcpy (vec_base.f128++, arg.f128++, sizeof (float128));
+                      else
+		        memcpy (next_arg.f128, arg.f128++, sizeof (float128));
+                      if (++next_arg.f128 == gpr_end.f128)
+                        next_arg.f128 = rest.f128;
+                      vecarg_count++;
+                    }
+                  while (--elnum != 0);
+                }
+              else
+#endif
+	      if (elt == FFI_TYPE_FLOAT)
+		{
+		  do
+		    {
+		      double_tmp = *arg.f++;
+		      if (fparg_count < NUM_FPR_ARG_REGISTERS64
+			  && i < nfixedargs)
+			*fpr_base.d++ = double_tmp;
+		      else
+			*next_arg.f = (float) double_tmp;
+		      if (++next_arg.f == gpr_end.f)
+			next_arg.f = rest.f;
+		      fparg_count++;
+		    }
+		  while (--elnum != 0);
+		  if ((next_arg.p & 7) != 0)
+                    if (++next_arg.f == gpr_end.f)
+                      next_arg.f = rest.f;
+		}
+	      else
+		do
+		  {
+		    double_tmp = *arg.d++;
+		    if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)
+		      *fpr_base.d++ = double_tmp;
+		    else
+		      *next_arg.d = double_tmp;
+		    if (++next_arg.d == gpr_end.d)
+		      next_arg.d = rest.d;
+		    fparg_count++;
+		  }
+		while (--elnum != 0);
+#else
+	      if (elt == FFI_TYPE_FLOAT)
+		goto do_float;
+	      else
+		goto do_double;
+#endif
+	    }
+	  else
+	    {
+	      words = ((*ptr)->size + 7) / 8;
+	      if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)
+		{
+		  size_t first = gpr_end.c - next_arg.c;
+		  memcpy (next_arg.c, *p_argv.c, first);
+		  memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);
+		  next_arg.c = rest.c + words * 8 - first;
+		}
+	      else
+		{
+		  char *where = next_arg.c;
+
+#ifndef __LITTLE_ENDIAN__
+		  /* Structures with size less than eight bytes are passed
+		     left-padded.  */
+		  if ((*ptr)->size < 8)
+		    where += 8 - (*ptr)->size;
+#endif
+		  memcpy (where, *p_argv.c, (*ptr)->size);
+		  next_arg.ul += words;
+		  if (next_arg.ul == gpr_end.ul)
+		    next_arg.ul = rest.ul;
+		}
+	    }
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  gprvalue = **p_argv.uc;
+	  goto putgpr;
+	case FFI_TYPE_SINT8:
+	  gprvalue = **p_argv.sc;
+	  goto putgpr;
+	case FFI_TYPE_UINT16:
+	  gprvalue = **p_argv.us;
+	  goto putgpr;
+	case FFI_TYPE_SINT16:
+	  gprvalue = **p_argv.ss;
+	  goto putgpr;
+	case FFI_TYPE_UINT32:
+	  gprvalue = **p_argv.ui;
+	  goto putgpr;
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	  gprvalue = **p_argv.si;
+	  goto putgpr;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_POINTER:
+	  gprvalue = **p_argv.ul;
+	putgpr:
+	  *next_arg.ul++ = gprvalue;
+	  if (next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
+	  break;
+	}
+    }
+
+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS
+	      || (next_arg.ul >= gpr_base.ul
+		  && next_arg.ul <= gpr_base.ul + 4));
+}
+
+
+#if _CALL_ELF == 2
+#define MIN_CACHE_LINE_SIZE 8
+
+static void
+flush_icache (char *wraddr, char *xaddr, int size)
+{
+  int i;
+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)
+    __asm__ volatile ("icbi 0,%0;" "dcbf 0,%1;"
+		      : : "r" (xaddr + i), "r" (wraddr + i) : "memory");
+  __asm__ volatile ("icbi 0,%0;" "dcbf 0,%1;" "sync;" "isync;"
+		    : : "r"(xaddr + size - 1), "r"(wraddr + size - 1)
+		    : "memory");
+}
+#endif
+
+
+ffi_status FFI_HIDDEN
+ffi_prep_closure_loc_linux64 (ffi_closure *closure,
+			      ffi_cif *cif,
+			      void (*fun) (ffi_cif *, void *, void **, void *),
+			      void *user_data,
+			      void *codeloc)
+{
+#if _CALL_ELF == 2
+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+
+  if (cif->abi < FFI_LINUX || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  tramp[0] = 0xe96c0018;	/* 0:	ld	11,2f-0b(12)	*/
+  tramp[1] = 0xe98c0010;	/*	ld	12,1f-0b(12)	*/
+  tramp[2] = 0x7d8903a6;	/*	mtctr	12		*/
+  tramp[3] = 0x4e800420;	/*	bctr			*/
+				/* 1:	.quad	function_addr	*/
+				/* 2:	.quad	context		*/
+  *(void **) &tramp[4] = (void *) ffi_closure_LINUX64;
+  *(void **) &tramp[6] = codeloc;
+  flush_icache ((char *) tramp, (char *) codeloc, 4 * 4);
+#else
+  void **tramp = (void **) &closure->tramp[0];
+
+  if (cif->abi < FFI_LINUX || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  /* Copy function address and TOC from ffi_closure_LINUX64 OPD.  */
+  memcpy (&tramp[0], (void **) ffi_closure_LINUX64, sizeof (void *));
+  tramp[1] = codeloc;
+  memcpy (&tramp[2], (void **) ffi_closure_LINUX64 + 1, sizeof (void *));
+#endif
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+
+int FFI_HIDDEN
+ffi_closure_helper_LINUX64 (ffi_cif *cif,
+			    void (*fun) (ffi_cif *, void *, void **, void *),
+			    void *user_data,
+			    void *rvalue,
+			    unsigned long *pst,
+                            ffi_dblfl *pfr,
+                            float128 *pvec)
+{
+  /* rvalue is the pointer to space for return value in closure assembly */
+  /* pst is the pointer to parameter save area
+     (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */
+  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */
+  /* pvec is the pointer to where v2-v13 are stored in ffi_closure_LINUX64 */
+
+  void **avalue;
+  ffi_type **arg_types;
+  unsigned long i, avn, nfixedargs;
+  ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;
+  float128 *end_pvec = pvec + NUM_VEC_ARG_REGISTERS64;
+  unsigned long align;
+
+  avalue = alloca (cif->nargs * sizeof (void *));
+
+  /* Copy the caller's structure return value address so that the
+     closure returns the data directly to the caller.  */
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+      && (cif->flags & FLAG_RETURNS_SMST) == 0)
+    {
+      rvalue = (void *) *pst;
+      pst++;
+    }
+
+  i = 0;
+  avn = cif->nargs;
+#if _CALL_ELF != 2
+  nfixedargs = (unsigned) -1;
+  if ((cif->flags & FLAG_COMPAT) == 0)
+#endif
+    nfixedargs = cif->nfixedargs;
+  arg_types = cif->arg_types;
+
+  /* Grab the addresses of the arguments from the stack frame.  */
+  while (i < avn)
+    {
+      unsigned int elt, elnum;
+
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+#ifndef __LITTLE_ENDIAN__
+	  avalue[i] = (char *) pst + 7;
+	  pst++;
+	  break;
+#endif
+
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+#ifndef __LITTLE_ENDIAN__
+	  avalue[i] = (char *) pst + 6;
+	  pst++;
+	  break;
+#endif
+
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+#ifndef __LITTLE_ENDIAN__
+	  avalue[i] = (char *) pst + 4;
+	  pst++;
+	  break;
+#endif
+
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  avalue[i] = pst;
+	  pst++;
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  if ((cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)
+	    {
+	      align = arg_types[i]->alignment;
+	      if (align > 16)
+		align = 16;
+	      if (align > 1)
+		pst = (unsigned long *) FFI_ALIGN ((size_t) pst, align);
+	    }
+	  elt = discover_homogeneous_aggregate (cif->abi, arg_types[i], &elnum);
+	  if (elt)
+	    {
+#if _CALL_ELF == 2
+	      union {
+		void *v;
+		unsigned long *ul;
+		float *f;
+		double *d;
+		float128 *f128;
+		size_t p;
+	      } to, from;
+
+	      /* Repackage the aggregate from its parts.  The
+		 aggregate size is not greater than the space taken by
+		 the registers so store back to the register/parameter
+		 save arrays.  */
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+              if (elt == FFI_TYPE_LONGDOUBLE &&
+                  (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+                {
+                  if (pvec + elnum <= end_pvec)
+                    to.v = pvec;
+                  else
+                    to.v = pst;
+                }
+              else
+#endif
+	      if (pfr + elnum <= end_pfr)
+		to.v = pfr;
+	      else
+		to.v = pst;
+
+	      avalue[i] = to.v;
+	      from.ul = pst;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+              if (elt == FFI_TYPE_LONGDOUBLE &&
+                  (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+                {
+                  do
+                    {
+                      if (pvec < end_pvec && i < nfixedargs)
+		        memcpy (to.f128, pvec++, sizeof (float128));
+                      else
+		        memcpy (to.f128, from.f128, sizeof (float128));
+                      to.f128++;
+                      from.f128++;
+                    }
+                  while (--elnum != 0);
+                }
+              else
+#endif
+	      if (elt == FFI_TYPE_FLOAT)
+		{
+		  do
+		    {
+		      if (pfr < end_pfr && i < nfixedargs)
+			{
+			  *to.f = (float) pfr->d;
+			  pfr++;
+			}
+		      else
+			*to.f = *from.f;
+		      to.f++;
+		      from.f++;
+		    }
+		  while (--elnum != 0);
+		}
+	      else
+		{
+		  do
+		    {
+		      if (pfr < end_pfr && i < nfixedargs)
+			{
+			  *to.d = pfr->d;
+			  pfr++;
+			}
+		      else
+			*to.d = *from.d;
+		      to.d++;
+		      from.d++;
+		    }
+		  while (--elnum != 0);
+		}
+#else
+	      if (elt == FFI_TYPE_FLOAT)
+		goto do_float;
+	      else
+		goto do_double;
+#endif
+	    }
+	  else
+	    {
+#ifndef __LITTLE_ENDIAN__
+	      /* Structures with size less than eight bytes are passed
+		 left-padded.  */
+	      if (arg_types[i]->size < 8)
+		avalue[i] = (char *) pst + 8 - arg_types[i]->size;
+	      else
+#endif
+		avalue[i] = pst;
+	    }
+	  pst += (arg_types[i]->size + 7) / 8;
+	  break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+          if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)
+            {
+              if (((unsigned long) pst & 0xF) != 0)
+                ++pst;
+              if (pvec < end_pvec && i < nfixedargs)
+                avalue[i] = pvec++;
+              else
+                avalue[i] = pst;
+              pst += 2;
+              break;
+            }
+          else if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)
+	    {
+	      if (pfr + 1 < end_pfr && i + 1 < nfixedargs)
+		{
+		  avalue[i] = pfr;
+		  pfr += 2;
+		}
+	      else
+		{
+		  if (pfr < end_pfr && i < nfixedargs)
+		    {
+		      /* Passed partly in f13 and partly on the stack.
+			 Move it all to the stack.  */
+		      *pst = *(unsigned long *) pfr;
+		      pfr++;
+		    }
+		  avalue[i] = pst;
+		}
+	      pst += 2;
+	      break;
+	    }
+	  /* Fall through.  */
+#endif
+	case FFI_TYPE_DOUBLE:
+#if _CALL_ELF != 2
+	do_double:
+#endif
+	  /* On the outgoing stack all values are aligned to 8 */
+	  /* there are 13 64bit floating point registers */
+
+	  if (pfr < end_pfr && i < nfixedargs)
+	    {
+	      avalue[i] = pfr;
+	      pfr++;
+	    }
+	  else
+	    avalue[i] = pst;
+	  pst++;
+	  break;
+
+	case FFI_TYPE_FLOAT:
+#if _CALL_ELF != 2
+	do_float:
+#endif
+	  if (pfr < end_pfr && i < nfixedargs)
+	    {
+	      /* Float values are stored as doubles in the
+		 ffi_closure_LINUX64 code.  Fix them here.  */
+	      pfr->f = (float) pfr->d;
+	      avalue[i] = pfr;
+	      pfr++;
+	    }
+	  else
+	    {
+#ifndef __LITTLE_ENDIAN__
+	      avalue[i] = (char *) pst + 4;
+#else
+	      avalue[i] = pst;
+#endif
+	    }
+	  pst++;
+	  break;
+
+	default:
+	  FFI_ASSERT (0);
+	}
+
+      i++;
+    }
+
+  (*fun) (cif, rvalue, avalue, user_data);
+
+  /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */
+  if ((cif->flags & FLAG_RETURNS_SMST) != 0)
+    {
+      if ((cif->flags & (FLAG_RETURNS_FP | FLAG_RETURNS_VEC)) == 0)
+	return FFI_V2_TYPE_SMALL_STRUCT + cif->rtype->size - 1;
+      else if ((cif->flags & FLAG_RETURNS_VEC) != 0)
+        return FFI_V2_TYPE_VECTOR_HOMOG;
+      else if ((cif->flags & FLAG_RETURNS_64BITS) != 0)
+	return FFI_V2_TYPE_DOUBLE_HOMOG;
+      else
+	return FFI_V2_TYPE_FLOAT_HOMOG;
+    }
+  if ((cif->flags & FLAG_RETURNS_VEC) != 0)
+    return FFI_V2_TYPE_VECTOR;
+  return cif->rtype->type;
+}
+#endif
Index: libffi-3.4.6/src/powerpc/ffi_powerpc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ffi_powerpc.h b/libffi-3.4.6/src/powerpc/ffi_powerpc.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ffi_powerpc.h	
@@ -0,0 +1,105 @@
+/* -----------------------------------------------------------------------
+   ffi_powerpc.h - Copyright (C) 2013 IBM
+                   Copyright (C) 2011 Anthony Green
+                   Copyright (C) 2011 Kyle Moffett
+                   Copyright (C) 2008 Red Hat, Inc
+                   Copyright (C) 2007, 2008 Free Software Foundation, Inc
+                   Copyright (c) 1998 Geoffrey Keating
+
+   PowerPC Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+enum {
+  /* The assembly depends on these exact flags.  */
+  /* These go in cr7 */
+  FLAG_RETURNS_SMST     = 1 << (31-31), /* Used for FFI_SYSV small structs.  */
+  FLAG_RETURNS_NOTHING  = 1 << (31-30),
+  FLAG_RETURNS_FP       = 1 << (31-29),
+  FLAG_RETURNS_VEC      = 1 << (31-28),
+
+  /* These go in cr6 */
+  FLAG_RETURNS_64BITS   = 1 << (31-27),
+  FLAG_RETURNS_128BITS  = 1 << (31-26),
+
+  FLAG_COMPAT           = 1 << (31- 8), /* Not used by assembly */
+
+  /* These go in cr1 */
+  FLAG_ARG_NEEDS_COPY   = 1 << (31- 7), /* Used by sysv code */
+  FLAG_ARG_NEEDS_PSAVE  = FLAG_ARG_NEEDS_COPY, /* Used by linux64 code */
+  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */
+  FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),
+  FLAG_RETVAL_REFERENCE = 1 << (31- 4),
+  FLAG_VEC_ARGUMENTS    = 1 << (31- 3),
+};
+
+typedef union
+{
+  float f;
+  double d;
+} ffi_dblfl;
+
+#if defined(__FLOAT128_TYPE__) && defined(__HAVE_FLOAT128)
+typedef _Float128 float128;
+#elif defined(__FLOAT128__)
+typedef __float128 float128;
+#else
+typedef char float128[16] __attribute__((aligned(16)));
+#endif
+
+void FFI_HIDDEN ffi_closure_SYSV (void);
+void FFI_HIDDEN ffi_go_closure_sysv (void);
+void FFI_HIDDEN ffi_call_SYSV(extended_cif *, void (*)(void), void *,
+			      unsigned, void *, int);
+
+void FFI_HIDDEN ffi_prep_types_sysv (ffi_abi);
+ffi_status FFI_HIDDEN ffi_prep_cif_sysv (ffi_cif *);
+ffi_status FFI_HIDDEN ffi_prep_closure_loc_sysv (ffi_closure *,
+						 ffi_cif *,
+						 void (*) (ffi_cif *, void *,
+							   void **, void *),
+						 void *, void *);
+int FFI_HIDDEN ffi_closure_helper_SYSV (ffi_cif *,
+					void (*) (ffi_cif *, void *,
+						  void **, void *),
+					void *, void *, unsigned long *,
+					ffi_dblfl *, unsigned long *);
+
+void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, void (*) (void), void *,
+				 unsigned long, void *, long);
+void FFI_HIDDEN ffi_closure_LINUX64 (void);
+void FFI_HIDDEN ffi_go_closure_linux64 (void);
+
+void FFI_HIDDEN ffi_prep_types_linux64 (ffi_abi);
+ffi_status FFI_HIDDEN ffi_prep_cif_linux64 (ffi_cif *);
+ffi_status FFI_HIDDEN ffi_prep_cif_linux64_var (ffi_cif *, unsigned int,
+						unsigned int);
+void FFI_HIDDEN ffi_prep_args64 (extended_cif *, unsigned long *const);
+ffi_status FFI_HIDDEN ffi_prep_closure_loc_linux64 (ffi_closure *, ffi_cif *,
+						    void (*) (ffi_cif *, void *,
+							      void **, void *),
+						    void *, void *);
+int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_cif *,
+					   void (*) (ffi_cif *, void *,
+						     void **, void *),
+					   void *, void *,
+					   unsigned long *, ffi_dblfl *,
+					   float128 *);
Index: libffi-3.4.6/src/powerpc/ppc_closure.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/ppc_closure.S b/libffi-3.4.6/src/powerpc/ppc_closure.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/ppc_closure.S	
@@ -0,0 +1,397 @@
+/* -----------------------------------------------------------------------
+   sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>
+	    Copyright (c) 2008 Red Hat, Inc.
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+#include <powerpc/asm.h>
+
+	.file   "ppc_closure.S"
+
+#ifndef POWERPC64
+
+FFI_HIDDEN(ffi_closure_SYSV)
+ENTRY(ffi_closure_SYSV)
+	.cfi_startproc
+	stwu %r1,-144(%r1)
+	.cfi_def_cfa_offset 144
+	mflr %r0
+	stw %r0,148(%r1)
+	.cfi_offset 65, 4
+
+# we want to build up an areas for the parameters passed
+# in registers (both floating point and integer)
+
+	# so first save gpr 3 to gpr 10 (aligned to 4)
+	stw   %r3, 16(%r1)
+	stw   %r4, 20(%r1)
+	stw   %r5, 24(%r1)
+
+	# set up registers for the routine that does the work
+
+	# closure->cif
+	lwz %r3,FFI_TRAMPOLINE_SIZE(%r11)
+	# closure->fun
+	lwz %r4,FFI_TRAMPOLINE_SIZE+4(%r11)
+	# closure->user_data
+	lwz %r5,FFI_TRAMPOLINE_SIZE+8(%r11)
+
+.Ldoclosure:
+	stw   %r6, 28(%r1)
+	stw   %r7, 32(%r1)
+	stw   %r8, 36(%r1)
+	stw   %r9, 40(%r1)
+	stw   %r10,44(%r1)
+
+#ifndef __NO_FPRS__
+	# next save fpr 1 to fpr 8 (aligned to 8)
+	stfd  %f1, 48(%r1)
+	stfd  %f2, 56(%r1)
+	stfd  %f3, 64(%r1)
+	stfd  %f4, 72(%r1)
+	stfd  %f5, 80(%r1)
+	stfd  %f6, 88(%r1)
+	stfd  %f7, 96(%r1)
+	stfd  %f8, 104(%r1)
+#endif
+
+	# pointer to the result storage
+	addi %r6,%r1,112
+
+	# pointer to the saved gpr registers
+	addi %r7,%r1,16
+
+	# pointer to the saved fpr registers
+	addi %r8,%r1,48
+
+	# pointer to the outgoing parameter save area in the previous frame
+	# i.e. the previous frame pointer + 8
+	addi %r9,%r1,152
+
+	# make the call
+	bl ffi_closure_helper_SYSV@local
+.Lret:
+	# now r3 contains the return type
+	# so use it to look up in a table
+	# so we know how to deal with each type
+
+	# look up the proper starting point in table
+	# by using return type as offset
+
+	mflr %r4		# move address of .Lret to r4
+	slwi %r3,%r3,4		# now multiply return type by 16
+	addi %r4, %r4, .Lret_type0 - .Lret
+	lwz %r0,148(%r1)
+	add %r3,%r3,%r4		# add contents of table to table address
+	mtctr %r3
+	bctr			# jump to it
+
+# Each of the ret_typeX code fragments has to be exactly 16 bytes long
+# (4 instructions). For cache effectiveness we align to a 16 byte boundary
+# first.
+	.align 4
+# case FFI_TYPE_VOID
+.Lret_type0:
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+	nop
+
+# case FFI_TYPE_INT
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+.Lfinish:
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_FLOAT
+#ifndef __NO_FPRS__
+	lfs %f1,112+0(%r1)
+#else
+	nop
+#endif
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_DOUBLE
+#ifndef __NO_FPRS__
+	lfd %f1,112+0(%r1)
+#else
+	nop
+#endif
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_LONGDOUBLE
+#ifndef __NO_FPRS__
+	lfd %f1,112+0(%r1)
+	lfd %f2,112+8(%r1)
+	mtlr %r0
+	b .Lfinish
+#else
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+	nop
+#endif
+
+# case FFI_TYPE_UINT8
+#ifdef __LITTLE_ENDIAN__
+	lbz %r3,112+0(%r1)
+#else
+	lbz %r3,112+3(%r1)
+#endif
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_SINT8
+#ifdef __LITTLE_ENDIAN__
+	lbz %r3,112+0(%r1)
+#else
+	lbz %r3,112+3(%r1)
+#endif
+	extsb %r3,%r3
+	mtlr %r0
+	b .Lfinish
+
+# case FFI_TYPE_UINT16
+#ifdef __LITTLE_ENDIAN__
+	lhz %r3,112+0(%r1)
+#else
+	lhz %r3,112+2(%r1)
+#endif
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_SINT16
+#ifdef __LITTLE_ENDIAN__
+	lha %r3,112+0(%r1)
+#else
+	lha %r3,112+2(%r1)
+#endif
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_UINT32
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_SINT32
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_UINT64
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
+	b .Lfinish
+
+# case FFI_TYPE_SINT64
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
+	b .Lfinish
+
+# case FFI_TYPE_STRUCT
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+	nop
+
+# case FFI_TYPE_POINTER
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_TYPE_UINT128
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	lwz %r5,112+8(%r1)
+	b .Luint128
+
+# The return types below are only used when the ABI type is FFI_SYSV.
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 1. One byte struct.
+	lbz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 2. Two byte struct.
+	lhz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 3. Three byte struct.
+	lwz %r3,112+0(%r1)
+#ifdef __LITTLE_ENDIAN__
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+#else
+	srwi %r3,%r3,8
+	mtlr %r0
+	b .Lfinish
+#endif
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 4. Four byte struct.
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 5. Five byte struct.
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+#ifdef __LITTLE_ENDIAN__
+	mtlr %r0
+	b .Lfinish
+#else
+	li %r5,24
+	b .Lstruct567
+#endif
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 6. Six byte struct.
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+#ifdef __LITTLE_ENDIAN__
+	mtlr %r0
+	b .Lfinish
+#else
+	li %r5,16
+	b .Lstruct567
+#endif
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 7. Seven byte struct.
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+#ifdef __LITTLE_ENDIAN__
+	mtlr %r0
+	b .Lfinish
+#else
+	li %r5,8
+	b .Lstruct567
+#endif
+
+# case FFI_SYSV_TYPE_SMALL_STRUCT + 8. Eight byte struct.
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
+	b .Lfinish
+
+#ifndef __LITTLE_ENDIAN__
+.Lstruct567:
+	subfic %r6,%r5,32
+	srw %r4,%r4,%r5
+	slw %r6,%r3,%r6
+	srw %r3,%r3,%r5
+	or %r4,%r6,%r4
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset 144
+#endif
+
+.Luint128:
+	lwz %r6,112+12(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_endproc
+END(ffi_closure_SYSV)
+
+
+FFI_HIDDEN(ffi_go_closure_sysv)
+ENTRY(ffi_go_closure_sysv)
+	.cfi_startproc
+	stwu %r1,-144(%r1)
+	.cfi_def_cfa_offset 144
+	mflr %r0
+	stw %r0,148(%r1)
+	.cfi_offset 65, 4
+
+	stw   %r3, 16(%r1)
+	stw   %r4, 20(%r1)
+	stw   %r5, 24(%r1)
+
+	# closure->cif
+	lwz %r3,4(%r11)
+	# closure->fun
+	lwz %r4,8(%r11)
+	# user_data
+	mr %r5,%r11
+	b .Ldoclosure
+	.cfi_endproc
+END(ffi_go_closure_sysv)
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
+#endif
Index: libffi-3.4.6/src/powerpc/darwin_closure.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/darwin_closure.S b/libffi-3.4.6/src/powerpc/darwin_closure.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/darwin_closure.S	
@@ -0,0 +1,571 @@
+/* -----------------------------------------------------------------------
+   darwin_closure.S - Copyright (c) 2002, 2003, 2004, 2010, 
+   Free Software Foundation, Inc. 
+   based on ppc_closure.S
+
+   PowerPC Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#define L(x) x
+
+#if defined(__ppc64__)
+#define MODE_CHOICE(x, y) y
+#else
+#define MODE_CHOICE(x, y) x
+#endif
+
+#define machine_choice	MODE_CHOICE(ppc7400,ppc64)
+
+; Define some pseudo-opcodes for size-independent load & store of GPRs ...
+#define lgu		MODE_CHOICE(lwzu, ldu)
+#define lg		MODE_CHOICE(lwz,ld)
+#define sg		MODE_CHOICE(stw,std)
+#define sgu		MODE_CHOICE(stwu,stdu)
+
+; ... and the size of GPRs and their storage indicator.
+#define GPR_BYTES	MODE_CHOICE(4,8)
+#define LOG2_GPR_BYTES	MODE_CHOICE(2,3)	/* log2(GPR_BYTES) */
+#define g_long		MODE_CHOICE(long, quad)	/* usage is ".g_long" */
+
+; From the ABI doc: "Mac OS X ABI Function Call Guide" Version 2009-02-04.
+#define LINKAGE_SIZE	MODE_CHOICE(24,48)
+#define PARAM_AREA	MODE_CHOICE(32,64)
+
+#define SAVED_CR_OFFSET	MODE_CHOICE(4,8)	/* save position for CR */
+#define SAVED_LR_OFFSET	MODE_CHOICE(8,16)	/* save position for lr */
+
+/* WARNING: if ffi_type is changed... here be monsters.  
+   Offsets of items within the result type.  */
+#define FFI_TYPE_TYPE	MODE_CHOICE(6,10)
+#define FFI_TYPE_ELEM	MODE_CHOICE(8,16)
+
+#define SAVED_FPR_COUNT 13
+#define FPR_SIZE	8
+/* biggest m64 struct ret is 8GPRS + 13FPRS = 168 bytes - rounded to 16bytes = 176. */
+#define RESULT_BYTES	MODE_CHOICE(16,176)
+
+; The whole stack frame **MUST** be 16byte-aligned.
+#define SAVE_SIZE (((LINKAGE_SIZE+PARAM_AREA+SAVED_FPR_COUNT*FPR_SIZE+RESULT_BYTES)+15) & -16LL)
+#define PAD_SIZE (SAVE_SIZE-(LINKAGE_SIZE+PARAM_AREA+SAVED_FPR_COUNT*FPR_SIZE+RESULT_BYTES))
+
+#define PARENT_PARM_BASE (SAVE_SIZE+LINKAGE_SIZE)
+#define FP_SAVE_BASE (LINKAGE_SIZE+PARAM_AREA)
+
+#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050
+; We no longer need the pic symbol stub for Darwin >= 9.
+#define BLCLS_HELP _ffi_closure_helper_DARWIN
+#define STRUCT_RETVALUE_P _darwin64_struct_ret_by_value_p
+#define PASS_STR_FLOATS _darwin64_pass_struct_floats
+#undef WANT_STUB
+#else
+#define BLCLS_HELP L_ffi_closure_helper_DARWIN$stub
+#define STRUCT_RETVALUE_P L_darwin64_struct_ret_by_value_p$stub
+#define PASS_STR_FLOATS L_darwin64_pass_struct_floats$stub
+#define WANT_STUB
+#endif
+
+/* m32/m64
+
+   The stack layout looks like this:
+
+   |   Additional params...			| |     Higher address
+   ~						~ ~
+   |   Parameters      (at least 8*4/8=32/64)	| | NUM_GPR_ARG_REGISTERS
+   |--------------------------------------------| |
+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8	| |
+   |--------------------------------------------| |
+   |   Reserved                       2*4/8	| |
+   |--------------------------------------------| |
+   |   Space for callee`s LR		4/8	| |
+   |--------------------------------------------| |
+   |   Saved CR [low word for m64]      4/8	| |
+   |--------------------------------------------| |
+   |   Current backchain pointer	4/8	|-/ Parent`s frame.
+   |--------------------------------------------| <+ <<< on entry to
+   |   Result Bytes		       16/176	| |
+   |--------------------------------------------| |
+   ~   padding to 16-byte alignment		~ ~
+   |--------------------------------------------| |
+   |   NUM_FPR_ARG_REGISTERS slots		| |
+   |   here fp13 .. fp1		       13*8	| |
+   |--------------------------------------------| |
+   |   R3..R10			  8*4/8=32/64	| | NUM_GPR_ARG_REGISTERS
+   |--------------------------------------------| |
+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8	| |
+   |--------------------------------------------| |	stack	|
+   |   Reserved [compiler,binder]     2*4/8	| |	grows	|
+   |--------------------------------------------| |	down	V
+   |   Space for callees LR		4/8	| |
+   |--------------------------------------------| |	lower addresses
+   |   Saved CR [low word for m64]      4/8	| |
+   |--------------------------------------------| |     stack pointer here
+   |   Current backchain pointer	4/8	|-/	during
+   |--------------------------------------------|   <<<	call.
+
+*/
+
+	.file	"darwin_closure.S"
+
+	.machine machine_choice
+
+	.text
+	.globl _ffi_closure_ASM
+	.align LOG2_GPR_BYTES
+_ffi_closure_ASM:
+LFB1:
+Lstartcode:
+	mflr	r0			/* extract return address  */
+	sg	r0,SAVED_LR_OFFSET(r1)	/* save the return address  */
+LCFI0:
+	sgu	r1,-SAVE_SIZE(r1)	/* skip over caller save area
+					keep stack aligned to 16.  */
+LCFI1:
+	/* We want to build up an area for the parameters passed
+	   in registers. (both floating point and integer)  */
+
+	/* Put gpr 3 to gpr 10 in the parents outgoing area...
+	   ... the remainder of any params that overflowed the regs will
+	   follow here.  */
+	sg	r3, (PARENT_PARM_BASE                )(r1)
+	sg	r4, (PARENT_PARM_BASE + GPR_BYTES    )(r1)
+	sg	r5, (PARENT_PARM_BASE + GPR_BYTES * 2)(r1)
+	sg	r6, (PARENT_PARM_BASE + GPR_BYTES * 3)(r1)
+	sg	r7, (PARENT_PARM_BASE + GPR_BYTES * 4)(r1)
+	sg	r8, (PARENT_PARM_BASE + GPR_BYTES * 5)(r1)
+	sg	r9, (PARENT_PARM_BASE + GPR_BYTES * 6)(r1)
+	sg	r10,(PARENT_PARM_BASE + GPR_BYTES * 7)(r1)
+
+	/* We save fpr 1 to fpr 14 in our own save frame.  */
+	stfd	f1, (FP_SAVE_BASE                 )(r1)
+	stfd	f2, (FP_SAVE_BASE +  FPR_SIZE     )(r1)
+	stfd	f3, (FP_SAVE_BASE +  FPR_SIZE * 2 )(r1)
+	stfd	f4, (FP_SAVE_BASE +  FPR_SIZE * 3 )(r1)
+	stfd	f5, (FP_SAVE_BASE +  FPR_SIZE * 4 )(r1)
+	stfd	f6, (FP_SAVE_BASE +  FPR_SIZE * 5 )(r1)
+	stfd	f7, (FP_SAVE_BASE +  FPR_SIZE * 6 )(r1)
+	stfd	f8, (FP_SAVE_BASE +  FPR_SIZE * 7 )(r1)
+	stfd	f9, (FP_SAVE_BASE +  FPR_SIZE * 8 )(r1)
+	stfd	f10,(FP_SAVE_BASE +  FPR_SIZE * 9 )(r1)
+	stfd	f11,(FP_SAVE_BASE +  FPR_SIZE * 10)(r1)
+	stfd	f12,(FP_SAVE_BASE +  FPR_SIZE * 11)(r1)
+	stfd	f13,(FP_SAVE_BASE +  FPR_SIZE * 12)(r1)
+
+	/* Set up registers for the routine that actually does the work
+	   get the context pointer from the trampoline.  */
+	mr	r3,r11
+
+	/* Now load up the pointer to the result storage.  */
+	addi	r4,r1,(SAVE_SIZE-RESULT_BYTES)
+
+	/* Now load up the pointer to the saved gpr registers.  */
+	addi	r5,r1,PARENT_PARM_BASE
+
+	/* Now load up the pointer to the saved fpr registers.  */
+	addi	r6,r1,FP_SAVE_BASE
+
+	/* Make the call.  */
+	bl	BLCLS_HELP
+
+	/* r3 contains the rtype pointer... save it since we will need
+	   it later.  */
+	sg	r3,LINKAGE_SIZE(r1)	; ffi_type * result_type
+	lg	r0,0(r3)		; size => r0
+	lhz	r3,FFI_TYPE_TYPE(r3)	; type => r3
+
+	/* The helper will have intercepted structure returns and inserted
+	   the caller`s destination address for structs returned by ref.  */
+
+	/* r3 contains the return type  so use it to look up in a table
+	   so we know how to deal with each type.  */
+
+	addi	r5,r1,(SAVE_SIZE-RESULT_BYTES) /* Otherwise, our return is here.  */
+	bl	Lget_ret_type0_addr	/* Get pointer to Lret_type0 into LR.  */
+	mflr	r4			/* Move to r4.  */
+	slwi	r3,r3,4			/* Now multiply return type by 16.  */
+	add	r3,r3,r4		/* Add contents of table to table address.  */
+	mtctr	r3
+	bctr			 	 /* Jump to it.  */
+LFE1:
+/* Each of the ret_typeX code fragments has to be exactly 16 bytes long
+   (4 instructions). For cache effectiveness we align to a 16 byte boundary
+   first.  */
+
+	.align 4
+
+	nop
+	nop
+	nop
+Lget_ret_type0_addr:
+	blrl
+
+/* case FFI_TYPE_VOID  */
+Lret_type0:
+	b	Lfinish
+	nop
+	nop
+	nop
+
+/* case FFI_TYPE_INT  */
+Lret_type1:
+	lg	r3,0(r5)
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_FLOAT  */
+Lret_type2:
+	lfs	f1,0(r5)
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_DOUBLE  */
+Lret_type3:
+	lfd	f1,0(r5)
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_LONGDOUBLE  */
+Lret_type4:
+	lfd	f1,0(r5)
+	lfd	f2,8(r5)
+	b	Lfinish
+	nop
+
+/* case FFI_TYPE_UINT8  */
+Lret_type5:
+#if defined(__ppc64__)
+	lbz	r3,7(r5)
+#else
+	lbz	r3,3(r5)
+#endif
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_SINT8  */
+Lret_type6:
+#if defined(__ppc64__)
+	lbz	r3,7(r5)
+#else
+	lbz	r3,3(r5)
+#endif
+	extsb	r3,r3
+	b	Lfinish
+	nop
+
+/* case FFI_TYPE_UINT16  */
+Lret_type7:
+#if defined(__ppc64__)
+	lhz	r3,6(r5)
+#else
+	lhz	r3,2(r5)
+#endif
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_SINT16  */
+Lret_type8:
+#if defined(__ppc64__)
+	lha	r3,6(r5)
+#else
+	lha	r3,2(r5)
+#endif
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_UINT32  */
+Lret_type9:
+#if defined(__ppc64__)
+	lwz	r3,4(r5)
+#else
+	lwz	r3,0(r5)
+#endif
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_SINT32  */
+Lret_type10:
+#if defined(__ppc64__)
+	lwz	r3,4(r5)
+#else
+	lwz	r3,0(r5)
+#endif
+	b	Lfinish
+	nop
+	nop
+
+/* case FFI_TYPE_UINT64  */
+Lret_type11:
+#if defined(__ppc64__)
+	lg	r3,0(r5)
+	b	Lfinish
+	nop
+#else
+	lwz	r3,0(r5)
+	lwz	r4,4(r5)
+	b	Lfinish
+#endif
+	nop
+
+/* case FFI_TYPE_SINT64  */
+Lret_type12:
+#if defined(__ppc64__)
+	lg	r3,0(r5)
+	b	Lfinish
+	nop
+#else
+	lwz	r3,0(r5)
+	lwz	r4,4(r5)
+	b	Lfinish
+#endif
+	nop
+
+/* case FFI_TYPE_STRUCT  */
+Lret_type13:
+#if defined(__ppc64__)
+	lg	r3,0(r5)		; we need at least this...
+	cmpi	0,r0,4
+	bgt	Lstructend		; not a special small case
+	b	Lsmallstruct		; see if we need more.
+#else
+	cmpwi	0,r0,4
+	bgt	Lfinish		; not by value
+	lg	r3,0(r5)
+	b	Lfinish
+#endif
+/* case FFI_TYPE_POINTER  */
+Lret_type14:
+	lg	r3,0(r5)
+	b	Lfinish
+	nop
+	nop
+
+#if defined(__ppc64__)
+Lsmallstruct:
+	beq	Lfour			; continuation of Lret13.
+	cmpi	0,r0,3
+	beq	Lfinish			; don`t adjust this - can`t be any floats here...
+	srdi	r3,r3,48
+	cmpi	0,r0,2
+	beq	Lfinish			; .. or here ..
+	srdi	r3,r3,8
+	b 	Lfinish			; .. or here.
+
+Lfour:
+	lg	r6,LINKAGE_SIZE(r1)	; get the result type
+	lg	r6,FFI_TYPE_ELEM(r6)	; elements array pointer
+	lg	r6,0(r6)		; first element
+	lhz	r0,FFI_TYPE_TYPE(r6)	; OK go the type
+	cmpi	0,r0,2			; FFI_TYPE_FLOAT
+	bne	Lfourint
+	lfs	f1,0(r5)		; just one float in the struct.
+	b 	Lfinish
+
+Lfourint:
+	srdi	r3,r3,32		; four bytes.
+	b 	Lfinish
+
+Lstructend:
+	lg	r3,LINKAGE_SIZE(r1)	; get the result type
+	bl	STRUCT_RETVALUE_P
+	cmpi	0,r3,0
+	beq	Lfinish			; nope.
+	/* Recover a pointer to the results.  */
+	addi	r11,r1,(SAVE_SIZE-RESULT_BYTES)
+	lg	r3,0(r11)		; we need at least this...
+	lg	r4,8(r11)
+	cmpi	0,r0,16
+	beq	Lfinish		; special case 16 bytes we don't consider floats.
+
+	/* OK, frustratingly, the process of saving the struct to mem might have
+	   messed with the FPRs, so we have to re-load them :(.
+	   We`ll use our FPRs space again - calling: 
+	   void darwin64_pass_struct_floats (ffi_type *s, char *src, 
+					     unsigned *nfpr, double **fprs) 
+	   We`ll temporarily pinch the first two slots of the param area for local
+	   vars used by the routine.  */
+	xor	r6,r6,r6
+	addi	r5,r1,PARENT_PARM_BASE		; some space
+	sg	r6,0(r5)			; *nfpr zeroed.
+	addi	r6,r5,8				; **fprs
+	addi	r3,r1,FP_SAVE_BASE		; pointer to FPRs space
+	sg	r3,0(r6)
+	mr	r4,r11				; the struct is here...
+	lg	r3,LINKAGE_SIZE(r1)		; ffi_type * result_type.
+	bl	PASS_STR_FLOATS			; get struct floats into FPR save space.
+	/* See if we used any floats  */
+	lwz	r0,(SAVE_SIZE-RESULT_BYTES)(r1)	
+	cmpi	0,r0,0
+	beq	Lstructints			; nope.
+	/* OK load `em up... */
+	lfd	f1, (FP_SAVE_BASE                 )(r1)
+	lfd	f2, (FP_SAVE_BASE +  FPR_SIZE     )(r1)
+	lfd	f3, (FP_SAVE_BASE +  FPR_SIZE * 2 )(r1)
+	lfd	f4, (FP_SAVE_BASE +  FPR_SIZE * 3 )(r1)
+	lfd	f5, (FP_SAVE_BASE +  FPR_SIZE * 4 )(r1)
+	lfd	f6, (FP_SAVE_BASE +  FPR_SIZE * 5 )(r1)
+	lfd	f7, (FP_SAVE_BASE +  FPR_SIZE * 6 )(r1)
+	lfd	f8, (FP_SAVE_BASE +  FPR_SIZE * 7 )(r1)
+	lfd	f9, (FP_SAVE_BASE +  FPR_SIZE * 8 )(r1)
+	lfd	f10,(FP_SAVE_BASE +  FPR_SIZE * 9 )(r1)
+	lfd	f11,(FP_SAVE_BASE +  FPR_SIZE * 10)(r1)
+	lfd	f12,(FP_SAVE_BASE +  FPR_SIZE * 11)(r1)
+	lfd	f13,(FP_SAVE_BASE +  FPR_SIZE * 12)(r1)
+
+	/* point back at our saved struct.  */
+Lstructints:
+	addi	r11,r1,(SAVE_SIZE-RESULT_BYTES)
+	lg	r3,0(r11)			; we end up picking the
+	lg	r4,8(r11)			; first two again.
+	lg	r5,16(r11)
+	lg	r6,24(r11)
+	lg	r7,32(r11)
+	lg	r8,40(r11)
+	lg	r9,48(r11)
+	lg	r10,56(r11)
+#endif
+
+/* case done  */
+Lfinish:
+	addi	r1,r1,SAVE_SIZE		/* Restore stack pointer.  */
+	lg	r0,SAVED_LR_OFFSET(r1)	/* Get return address.  */
+	mtlr	r0			/* Reset link register.  */
+	blr
+Lendcode:
+	.align 1
+	
+/* END(ffi_closure_ASM)  */
+
+/* EH frame stuff.  */
+#define EH_DATA_ALIGN_FACT MODE_CHOICE(0x7c,0x78)
+/* 176, 400 */
+#define EH_FRAME_OFFSETA MODE_CHOICE(176,0x90)
+#define EH_FRAME_OFFSETB MODE_CHOICE(1,3)
+
+	.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
+EH_frame1:
+	.set	L$set$0,LECIE1-LSCIE1
+	.long	L$set$0	; Length of Common Information Entry
+LSCIE1:
+	.long	0x0	; CIE Identifier Tag
+	.byte	0x1	; CIE Version
+	.ascii	"zR\0"	; CIE Augmentation
+	.byte	0x1	; uleb128 0x1; CIE Code Alignment Factor
+	.byte	EH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor
+	.byte	0x41	; CIE RA Column
+	.byte	0x1	; uleb128 0x1; Augmentation size
+	.byte	0x10	; FDE Encoding (pcrel)
+	.byte	0xc	; DW_CFA_def_cfa
+	.byte	0x1	; uleb128 0x1
+	.byte	0x0	; uleb128 0x0
+	.align	LOG2_GPR_BYTES
+LECIE1:
+	.globl _ffi_closure_ASM.eh
+_ffi_closure_ASM.eh:
+LSFDE1:
+	.set	L$set$1,LEFDE1-LASFDE1
+	.long	L$set$1	; FDE Length
+
+LASFDE1:
+	.long	LASFDE1-EH_frame1	; FDE CIE offset
+	.g_long	Lstartcode-.	; FDE initial location
+	.set	L$set$2,LFE1-Lstartcode
+	.g_long	L$set$2	; FDE address range
+	.byte   0x0     ; uleb128 0x0; Augmentation size
+	.byte	0x4	; DW_CFA_advance_loc4
+	.set	L$set$3,LCFI1-LCFI0
+	.long	L$set$3
+	.byte	0xe	; DW_CFA_def_cfa_offset
+	.byte	EH_FRAME_OFFSETA,EH_FRAME_OFFSETB	; uleb128 176,1/190,3
+	.byte	0x4	; DW_CFA_advance_loc4
+	.set	L$set$4,LCFI0-Lstartcode
+	.long	L$set$4
+	.byte   0x11    ; DW_CFA_offset_extended_sf
+	.byte	0x41	; uleb128 0x41
+	.byte   0x7e    ; sleb128 -2
+	.align	LOG2_GPR_BYTES
+LEFDE1:
+	.align 	1
+
+#ifdef WANT_STUB
+	.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
+	.align 5
+L_ffi_closure_helper_DARWIN$stub:
+	.indirect_symbol _ffi_closure_helper_DARWIN
+	mflr r0
+	bcl 20,31,"L1$spb"
+"L1$spb":
+	mflr r11
+	addis r11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr-"L1$spb")
+	mtlr r0
+	lwzu r12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr-"L1$spb")(r11)
+	mtctr r12
+	bctr
+	.lazy_symbol_pointer
+L_ffi_closure_helper_DARWIN$lazy_ptr:
+	.indirect_symbol _ffi_closure_helper_DARWIN
+	.g_long	dyld_stub_binding_helper
+
+#if defined(__ppc64__)
+	.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
+	.align 5
+L_darwin64_struct_ret_by_value_p$stub:
+	.indirect_symbol _darwin64_struct_ret_by_value_p
+	mflr r0
+	bcl 20,31,"L2$spb"
+"L2$spb":
+	mflr r11
+	addis r11,r11,ha16(L_darwin64_struct_ret_by_value_p$lazy_ptr-"L2$spb")
+	mtlr r0
+	lwzu r12,lo16(L_darwin64_struct_ret_by_value_p$lazy_ptr-"L2$spb")(r11)
+	mtctr r12
+	bctr
+	.lazy_symbol_pointer
+L_darwin64_struct_ret_by_value_p$lazy_ptr:
+	.indirect_symbol _darwin64_struct_ret_by_value_p
+	.g_long	dyld_stub_binding_helper
+
+	.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32
+	.align 5
+L_darwin64_pass_struct_floats$stub:
+	.indirect_symbol _darwin64_pass_struct_floats
+	mflr r0
+	bcl 20,31,"L3$spb"
+"L3$spb":
+	mflr r11
+	addis r11,r11,ha16(L_darwin64_pass_struct_floats$lazy_ptr-"L3$spb")
+	mtlr r0
+	lwzu r12,lo16(L_darwin64_pass_struct_floats$lazy_ptr-"L3$spb")(r11)
+	mtctr r12
+	bctr
+	.lazy_symbol_pointer
+L_darwin64_pass_struct_floats$lazy_ptr:
+	.indirect_symbol _darwin64_pass_struct_floats
+	.g_long	dyld_stub_binding_helper
+#  endif
+#endif
Index: libffi-3.4.6/src/powerpc/linux64_closure.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/powerpc/linux64_closure.S b/libffi-3.4.6/src/powerpc/linux64_closure.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/powerpc/linux64_closure.S	
@@ -0,0 +1,566 @@
+/* -----------------------------------------------------------------------
+   sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>
+	    Copyright (c) 2008 Red Hat, Inc.
+
+   PowerPC64 Assembly glue.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.file	"linux64_closure.S"
+
+	.machine altivec
+
+#ifdef POWERPC64
+	FFI_HIDDEN (ffi_closure_LINUX64)
+	.globl  ffi_closure_LINUX64
+	.text
+	.cfi_startproc
+# if _CALL_ELF == 2
+ffi_closure_LINUX64:
+#  ifndef __PCREL__
+	addis	%r2, %r12, .TOC.-ffi_closure_LINUX64@ha
+	addi	%r2, %r2, .TOC.-ffi_closure_LINUX64@l
+#  endif
+	.localentry ffi_closure_LINUX64, . - ffi_closure_LINUX64
+# else
+	.section        ".opd","aw"
+	.align  3
+ffi_closure_LINUX64:
+#  ifdef _CALL_LINUX
+	.quad   .L.ffi_closure_LINUX64,.TOC.@tocbase,0
+	.type   ffi_closure_LINUX64,@function
+	.text
+.L.ffi_closure_LINUX64:
+#  else
+	FFI_HIDDEN (.ffi_closure_LINUX64)
+	.globl  .ffi_closure_LINUX64
+	.quad   .ffi_closure_LINUX64,.TOC.@tocbase,0
+	.size   ffi_closure_LINUX64,24
+	.type   .ffi_closure_LINUX64,@function
+	.text
+.ffi_closure_LINUX64:
+#  endif
+# endif
+
+# if _CALL_ELF == 2
+#  ifdef __VEC__
+#   32 byte special reg save area + 64 byte parm save area
+#   + 128 byte retval area + 13*8 fpr save area + 12*16 vec save area + round to 16
+#   define STACKFRAME 528
+#  else
+#   32 byte special reg save area + 64 byte parm save area
+#   + 64 byte retval area + 13*8 fpr save area + round to 16
+#   define STACKFRAME 272
+#  endif
+#  define PARMSAVE 32
+#  define RETVAL PARMSAVE+64
+# else
+#  48 bytes special reg save area + 64 bytes parm save area
+#  + 16 bytes retval area + 13*8 bytes fpr save area + round to 16
+#  define STACKFRAME 240
+#  define PARMSAVE 48
+#  define RETVAL PARMSAVE+64
+# endif
+
+# if _CALL_ELF == 2
+	ld	%r12, FFI_TRAMPOLINE_SIZE(%r11)		# closure->cif
+	mflr	%r0
+	lwz	%r12, 28(%r12)				# cif->flags
+	mtcrf	0x40, %r12
+	addi	%r12, %r1, PARMSAVE
+	bt	7, 0f
+	# Our caller has not allocated a parameter save area.
+	# We need to allocate one here and use it to pass gprs to
+	# ffi_closure_helper_LINUX64.
+	addi	%r12, %r1, -STACKFRAME+PARMSAVE
+0:
+	# Save general regs into parm save area
+	std	%r3, 0(%r12)
+	std	%r4, 8(%r12)
+	std	%r5, 16(%r12)
+	std	%r6, 24(%r12)
+	std	%r7, 32(%r12)
+	std	%r8, 40(%r12)
+	std	%r9, 48(%r12)
+	std	%r10, 56(%r12)
+
+	# load up the pointer to the parm save area
+	mr	%r7, %r12
+# else
+	# copy r2 to r11 and load TOC into r2
+	mr	%r11, %r2
+	ld	%r2, 16(%r2)
+
+	mflr	%r0
+	# Save general regs into parm save area
+	# This is the parameter save area set up by our caller.
+	std	%r3, PARMSAVE+0(%r1)
+	std	%r4, PARMSAVE+8(%r1)
+	std	%r5, PARMSAVE+16(%r1)
+	std	%r6, PARMSAVE+24(%r1)
+	std	%r7, PARMSAVE+32(%r1)
+	std	%r8, PARMSAVE+40(%r1)
+	std	%r9, PARMSAVE+48(%r1)
+	std	%r10, PARMSAVE+56(%r1)
+
+	# load up the pointer to the parm save area
+	addi	%r7, %r1, PARMSAVE
+# endif
+	std	%r0, 16(%r1)
+
+	# closure->cif
+	ld	%r3, FFI_TRAMPOLINE_SIZE(%r11)
+	# closure->fun
+	ld	%r4, FFI_TRAMPOLINE_SIZE+8(%r11)
+	# closure->user_data
+	ld	%r5, FFI_TRAMPOLINE_SIZE+16(%r11)
+
+.Ldoclosure:
+	# next save fpr 1 to fpr 13
+	stfd	%f1, -104+(0*8)(%r1)
+	stfd	%f2, -104+(1*8)(%r1)
+	stfd	%f3, -104+(2*8)(%r1)
+	stfd	%f4, -104+(3*8)(%r1)
+	stfd	%f5, -104+(4*8)(%r1)
+	stfd	%f6, -104+(5*8)(%r1)
+	stfd	%f7, -104+(6*8)(%r1)
+	stfd	%f8, -104+(7*8)(%r1)
+	stfd	%f9, -104+(8*8)(%r1)
+	stfd	%f10, -104+(9*8)(%r1)
+	stfd	%f11, -104+(10*8)(%r1)
+	stfd	%f12, -104+(11*8)(%r1)
+	stfd	%f13, -104+(12*8)(%r1)
+
+	# load up the pointer to the saved fpr registers
+	addi	%r8, %r1, -104
+
+# ifdef __VEC__
+	# load up the pointer to the saved vector registers
+	# 8 bytes padding for 16-byte alignment at -112(%r1)
+	addi	%r9, %r8, -24
+	stvx	%v13, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v12, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v11, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v10, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v9, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v8, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v7, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v6, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v5, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v4, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v3, 0, %r9
+	addi	%r9, %r9, -16
+	stvx	%v2, 0, %r9
+# endif
+
+	# load up the pointer to the result storage
+	addi	%r6, %r1, -STACKFRAME+RETVAL
+
+	stdu	%r1, -STACKFRAME(%r1)
+	.cfi_def_cfa_offset STACKFRAME
+	.cfi_offset 65, 16
+
+	# make the call
+# if defined _CALL_LINUX || _CALL_ELF == 2
+#  ifdef __PCREL__
+	bl ffi_closure_helper_LINUX64@notoc
+.Lret:
+#  else
+	bl ffi_closure_helper_LINUX64
+.Lret:
+	nop
+#  endif
+# else
+	bl .ffi_closure_helper_LINUX64
+.Lret:
+	nop
+# endif
+
+	# now r3 contains the return type
+	# so use it to look up in a table
+	# so we know how to deal with each type
+
+	# look up the proper starting point in table
+	# by using return type as offset
+	ld %r0, STACKFRAME+16(%r1)
+	cmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT
+	bge .Lsmall
+	mflr %r4		# move address of .Lret to r4
+	sldi %r3, %r3, 4	# now multiply return type by 16
+	addi %r4, %r4, .Lret_type0 - .Lret
+	add %r3, %r3, %r4	# add contents of table to table address
+	mtctr %r3
+	bctr			# jump to it
+
+# Each of the ret_typeX code fragments has to be exactly 16 bytes long
+# (4 instructions). For cache effectiveness we align to a 16 byte boundary
+# first.
+	.align 4
+
+.Lret_type0:
+# case FFI_TYPE_VOID
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+	nop
+# case FFI_TYPE_INT
+# ifdef __LITTLE_ENDIAN__
+	lwa %r3, RETVAL+0(%r1)
+# else
+	lwa %r3, RETVAL+4(%r1)
+# endif
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_FLOAT
+	lfs %f1, RETVAL+0(%r1)
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_DOUBLE
+	lfd %f1, RETVAL+0(%r1)
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_LONGDOUBLE
+	lfd %f1, RETVAL+0(%r1)
+	mtlr %r0
+	lfd %f2, RETVAL+8(%r1)
+	b .Lfinish
+# case FFI_TYPE_UINT8
+# ifdef __LITTLE_ENDIAN__
+	lbz %r3, RETVAL+0(%r1)
+# else
+	lbz %r3, RETVAL+7(%r1)
+# endif
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_SINT8
+# ifdef __LITTLE_ENDIAN__
+	lbz %r3, RETVAL+0(%r1)
+# else
+	lbz %r3, RETVAL+7(%r1)
+# endif
+	extsb %r3,%r3
+	mtlr %r0
+	b .Lfinish
+# case FFI_TYPE_UINT16
+# ifdef __LITTLE_ENDIAN__
+	lhz %r3, RETVAL+0(%r1)
+# else
+	lhz %r3, RETVAL+6(%r1)
+# endif
+	mtlr %r0
+.Lfinish:
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_SINT16
+# ifdef __LITTLE_ENDIAN__
+	lha %r3, RETVAL+0(%r1)
+# else
+	lha %r3, RETVAL+6(%r1)
+# endif
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_UINT32
+# ifdef __LITTLE_ENDIAN__
+	lwz %r3, RETVAL+0(%r1)
+# else
+	lwz %r3, RETVAL+4(%r1)
+# endif
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_SINT32
+# ifdef __LITTLE_ENDIAN__
+	lwa %r3, RETVAL+0(%r1)
+# else
+	lwa %r3, RETVAL+4(%r1)
+# endif
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_UINT64
+	ld %r3, RETVAL+0(%r1)
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_SINT64
+	ld %r3, RETVAL+0(%r1)
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_TYPE_STRUCT
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+	nop
+# case FFI_TYPE_POINTER
+	ld %r3, RETVAL+0(%r1)
+	mtlr %r0
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+# case FFI_V2_TYPE_VECTOR
+	addi %r3, %r1, RETVAL
+	lvx %v2, 0, %r3
+	mtlr %r0
+	b .Lfinish
+# case FFI_V2_TYPE_VECTOR_HOMOG
+	addi %r3, %r1, RETVAL
+	lvx %v2, 0, %r3
+	addi %r3, %r3, 16
+	b .Lmorevector
+# case FFI_V2_TYPE_FLOAT_HOMOG
+	lfs %f1, RETVAL+0(%r1)
+	lfs %f2, RETVAL+4(%r1)
+	lfs %f3, RETVAL+8(%r1)
+	b .Lmorefloat
+# case FFI_V2_TYPE_DOUBLE_HOMOG
+	lfd %f1, RETVAL+0(%r1)
+	lfd %f2, RETVAL+8(%r1)
+	lfd %f3, RETVAL+16(%r1)
+	lfd %f4, RETVAL+24(%r1)
+	mtlr %r0
+	lfd %f5, RETVAL+32(%r1)
+	lfd %f6, RETVAL+40(%r1)
+	lfd %f7, RETVAL+48(%r1)
+	lfd %f8, RETVAL+56(%r1)
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+.Lmorevector:
+	lvx %v3, 0, %r3
+	addi %r3, %r3, 16
+	lvx %v4, 0, %r3
+	addi %r3, %r3, 16
+	lvx %v5, 0, %r3
+	mtlr %r0
+	addi %r3, %r3, 16
+	lvx %v6, 0, %r3
+	addi %r3, %r3, 16
+	lvx %v7, 0, %r3
+	addi %r3, %r3, 16
+	lvx %v8, 0, %r3
+	addi %r3, %r3, 16
+	lvx %v9, 0, %r3
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+.Lmorefloat:
+	lfs %f4, RETVAL+12(%r1)
+	mtlr %r0
+	lfs %f5, RETVAL+16(%r1)
+	lfs %f6, RETVAL+20(%r1)
+	lfs %f7, RETVAL+24(%r1)
+	lfs %f8, RETVAL+28(%r1)
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+.Lsmall:
+# ifdef __LITTLE_ENDIAN__
+	ld %r3,RETVAL+0(%r1)
+	mtlr %r0
+	ld %r4,RETVAL+8(%r1)
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+# else
+	# A struct smaller than a dword is returned in the low bits of r3
+	# ie. right justified.  Larger structs are passed left justified
+	# in r3 and r4.  The return value area on the stack will have
+	# the structs as they are usually stored in memory.
+	cmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT + 7 # size 8 bytes?
+	neg %r5, %r3
+	ld %r3,RETVAL+0(%r1)
+	blt .Lsmalldown
+	mtlr %r0
+	ld %r4,RETVAL+8(%r1)
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	blr
+	.cfi_def_cfa_offset STACKFRAME
+.Lsmalldown:
+	addi %r5, %r5, FFI_V2_TYPE_SMALL_STRUCT + 7
+	mtlr %r0
+	sldi %r5, %r5, 3
+	addi %r1, %r1, STACKFRAME
+	.cfi_def_cfa_offset 0
+	srd %r3, %r3, %r5
+	blr
+# endif
+
+	.cfi_endproc
+# if _CALL_ELF == 2
+	.size	ffi_closure_LINUX64,.-ffi_closure_LINUX64
+# else
+#  ifdef _CALL_LINUX
+	.size	ffi_closure_LINUX64,.-.L.ffi_closure_LINUX64
+#  else
+	.long	0
+	.byte	0,12,0,1,128,0,0,0
+	.size	.ffi_closure_LINUX64,.-.ffi_closure_LINUX64
+#  endif
+# endif
+
+
+	FFI_HIDDEN (ffi_go_closure_linux64)
+	.globl  ffi_go_closure_linux64
+	.text
+	.cfi_startproc
+# if _CALL_ELF == 2
+ffi_go_closure_linux64:
+#  ifndef __PCREL__
+	addis	%r2, %r12, .TOC.-ffi_go_closure_linux64@ha
+	addi	%r2, %r2, .TOC.-ffi_go_closure_linux64@l
+#  endif
+	.localentry ffi_go_closure_linux64, . - ffi_go_closure_linux64
+# else
+	.section        ".opd","aw"
+	.align  3
+ffi_go_closure_linux64:
+#  ifdef _CALL_LINUX
+	.quad   .L.ffi_go_closure_linux64,.TOC.@tocbase,0
+	.type   ffi_go_closure_linux64,@function
+	.text
+.L.ffi_go_closure_linux64:
+#  else
+	FFI_HIDDEN (.ffi_go_closure_linux64)
+	.globl  .ffi_go_closure_linux64
+	.quad   .ffi_go_closure_linux64,.TOC.@tocbase,0
+	.size   ffi_go_closure_linux64,24
+	.type   .ffi_go_closure_linux64,@function
+	.text
+.ffi_go_closure_linux64:
+#  endif
+# endif
+
+# if _CALL_ELF == 2
+	ld	%r12, 8(%r11)				# closure->cif
+	mflr	%r0
+	lwz	%r12, 28(%r12)				# cif->flags
+	mtcrf	0x40, %r12
+	addi	%r12, %r1, PARMSAVE
+	bt	7, 0f
+	# Our caller has not allocated a parameter save area.
+	# We need to allocate one here and use it to pass gprs to
+	# ffi_closure_helper_LINUX64.
+	addi	%r12, %r1, -STACKFRAME+PARMSAVE
+0:
+	# Save general regs into parm save area
+	std	%r3, 0(%r12)
+	std	%r4, 8(%r12)
+	std	%r5, 16(%r12)
+	std	%r6, 24(%r12)
+	std	%r7, 32(%r12)
+	std	%r8, 40(%r12)
+	std	%r9, 48(%r12)
+	std	%r10, 56(%r12)
+
+	# load up the pointer to the parm save area
+	mr	%r7, %r12
+# else
+	mflr	%r0
+	# Save general regs into parm save area
+	# This is the parameter save area set up by our caller.
+	std	%r3, PARMSAVE+0(%r1)
+	std	%r4, PARMSAVE+8(%r1)
+	std	%r5, PARMSAVE+16(%r1)
+	std	%r6, PARMSAVE+24(%r1)
+	std	%r7, PARMSAVE+32(%r1)
+	std	%r8, PARMSAVE+40(%r1)
+	std	%r9, PARMSAVE+48(%r1)
+	std	%r10, PARMSAVE+56(%r1)
+
+	# load up the pointer to the parm save area
+	addi	%r7, %r1, PARMSAVE
+# endif
+	std	%r0, 16(%r1)
+
+	# closure->cif
+	ld	%r3, 8(%r11)
+	# closure->fun
+	ld	%r4, 16(%r11)
+	# user_data
+	mr	%r5, %r11
+	b	.Ldoclosure
+
+	.cfi_endproc
+# if _CALL_ELF == 2
+	.size	ffi_go_closure_linux64,.-ffi_go_closure_linux64
+# else
+#  ifdef _CALL_LINUX
+	.size	ffi_go_closure_linux64,.-.L.ffi_go_closure_linux64
+#  else
+	.long	0
+	.byte	0,12,0,1,128,0,0,0
+	.size	.ffi_go_closure_linux64,.-.ffi_go_closure_linux64
+#  endif
+# endif
+#endif
+
+#if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2
+	.section	.note.GNU-stack,"",@progbits
+#endif
Index: libffi-3.4.6/src/tramp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/tramp.c b/libffi-3.4.6/src/tramp.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/tramp.c	
@@ -0,0 +1,716 @@
+/* -----------------------------------------------------------------------
+   tramp.c - Copyright (c) 2020 Madhavan T. Venkataraman
+             Copyright (c) 2022 Anthony Green
+
+   API and support functions for managing statically defined closure
+   trampolines.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <fficonfig.h>
+
+#ifdef FFI_EXEC_STATIC_TRAMP
+
+/* -------------------------- Headers and Definitions ---------------------*/
+/*
+ * Add support for other OSes later. For now, it is just Linux and Cygwin.
+ */
+
+#if defined (__linux__) || defined (__CYGWIN__)
+#ifdef __linux__
+#define _GNU_SOURCE 1
+#endif
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <sys/mman.h>
+#include <tramp.h>
+#ifdef __linux__
+#include <linux/limits.h>
+#include <linux/types.h>
+#endif
+#ifdef __CYGWIN__
+#include <limits.h>
+#endif
+#endif
+
+/*
+ * Each architecture defines static code for a trampoline code table. The
+ * trampoline code table is mapped into the address space of a process.
+ *
+ * The following architecture specific function returns:
+ *
+ *	- the address of the trampoline code table in the text segment
+ *	- the size of each trampoline in the trampoline code table
+ *	- the size of the mapping for the whole trampoline code table
+ */
+void __attribute__((weak)) *ffi_tramp_arch (size_t *tramp_size,
+  size_t *map_size);
+
+/* ------------------------- Trampoline Data Structures --------------------*/
+
+struct tramp;
+
+/*
+ * Trampoline table. Manages one trampoline code table and one trampoline
+ * parameter table.
+ *
+ * prev, next	Links in the global trampoline table list.
+ * code_table	Trampoline code table mapping.
+ * parm_table	Trampoline parameter table mapping.
+ * array	Array of trampolines malloced.
+ * free		List of free trampolines.
+ * nfree	Number of free trampolines.
+ */
+struct tramp_table
+{
+  struct tramp_table *prev;
+  struct tramp_table *next;
+  void *code_table;
+  void *parm_table;
+  struct tramp *array;
+  struct tramp *free;
+  int nfree;
+};
+
+/*
+ * Parameters for each trampoline.
+ *
+ * data
+ *	Data for the target code that the trampoline jumps to.
+ * target
+ *	Target code that the trampoline jumps to.
+ */
+struct tramp_parm
+{
+  void *data;
+  void *target;
+};
+
+/*
+ * Trampoline structure for each trampoline.
+ *
+ * prev, next	Links in the trampoline free list of a trampoline table.
+ * table	Trampoline table to which this trampoline belongs.
+ * code		Address of this trampoline in the code table mapping.
+ * parm		Address of this trampoline's parameters in the parameter
+ *		table mapping.
+ */
+struct tramp
+{
+  struct tramp *prev;
+  struct tramp *next;
+  struct tramp_table *table;
+  void *code;
+  struct tramp_parm *parm;
+};
+
+enum tramp_globals_status {
+	TRAMP_GLOBALS_UNINITIALIZED = 0,
+	TRAMP_GLOBALS_PASSED,
+	TRAMP_GLOBALS_FAILED,
+};
+
+/*
+ * Trampoline globals.
+ *
+ * fd
+ *	File descriptor of binary file that contains the trampoline code table.
+ * offset
+ *	Offset of the trampoline code table in that file.
+ * text
+ *	Address of the trampoline code table in the text segment.
+ * map_size
+ *	Size of the trampoline code table mapping.
+ * size
+ *	Size of one trampoline in the trampoline code table.
+ * ntramp
+ *	Total number of trampolines in the trampoline code table.
+ * free_tables
+ *	List of trampoline tables that contain free trampolines.
+ * nfree_tables
+ *	Number of trampoline tables that contain free trampolines.
+ * status
+ *	Initialization status.
+ */
+struct tramp_globals
+{
+  int fd;
+  off_t offset;
+  void *text;
+  size_t map_size;
+  size_t size;
+  int ntramp;
+  struct tramp_table *free_tables;
+  int nfree_tables;
+  enum tramp_globals_status status;
+};
+
+static struct tramp_globals tramp_globals;
+
+/* --------------------- Trampoline File Initialization --------------------*/
+
+/*
+ * The trampoline file is the file used to map the trampoline code table into
+ * the address space of a process. There are two ways to get this file:
+ *
+ * - From the OS. E.g., on Linux, /proc/<pid>/maps lists all the memory
+ *   mappings for <pid>. For file-backed mappings, maps supplies the file name
+ *   and the file offset. Using this, we can locate the mapping that maps
+ *   libffi and get the path to the libffi binary. And, we can compute the
+ *   offset of the trampoline code table within that binary.
+ *
+ * - Else, if we can create a temporary file, we can write the trampoline code
+ *   table from the text segment into the temporary file.
+ *
+ * The first method is the preferred one. If the OS security subsystem
+ * disallows mapping unsigned files with PROT_EXEC, then the second method
+ * will fail.
+ *
+ * If an OS allows the trampoline code table in the text segment to be
+ * directly remapped (e.g., MACH vm_remap ()), then we don't need the
+ * trampoline file.
+ */
+static int tramp_table_alloc (void);
+
+#if defined (__linux__) || defined (__CYGWIN__)
+
+static int
+ffi_tramp_get_libffi (void)
+{
+  FILE *fp;
+  char file[PATH_MAX], line[PATH_MAX+100], perm[10], dev[10];
+  unsigned long start, end, offset, inode;
+  uintptr_t addr = (uintptr_t) tramp_globals.text;
+  int nfields, found;
+
+  snprintf (file, PATH_MAX, "/proc/%d/maps", getpid());
+  fp = fopen (file, "r");
+  if (fp == NULL)
+    return 0;
+
+  found = 0;
+  while (feof (fp) == 0) {
+    if (fgets (line, sizeof (line), fp) == 0)
+      break;
+
+    nfields = sscanf (line, "%lx-%lx %9s %lx %9s %ld %s",
+      &start, &end, perm, &offset, dev, &inode, file);
+    if (nfields != 7)
+      continue;
+
+    if (addr >= start && addr < end) {
+      tramp_globals.offset = offset + (addr - start);
+      found = 1;
+      break;
+    }
+  }
+  fclose (fp);
+
+  if (!found)
+    return 0;
+
+  tramp_globals.fd = open (file, O_RDONLY);
+  if (tramp_globals.fd == -1)
+    return 0;
+
+  /*
+   * Allocate a trampoline table just to make sure that the trampoline code
+   * table can be mapped.
+   */
+  if (!tramp_table_alloc ())
+    {
+      close (tramp_globals.fd);
+      tramp_globals.fd = -1;
+      return 0;
+    }
+  return 1;
+}
+
+#endif /* defined (__linux__) || defined (__CYGWIN__) */
+
+#if defined (__linux__) || defined (__CYGWIN__)
+
+static int
+ffi_tramp_get_temp_file (void)
+{
+  ssize_t count;
+
+  tramp_globals.offset = 0;
+  tramp_globals.fd = open_temp_exec_file ();
+
+  /*
+   * Write the trampoline code table into the temporary file and allocate a
+   * trampoline table to make sure that the temporary file can be mapped.
+   */
+  count = write(tramp_globals.fd, tramp_globals.text, tramp_globals.map_size);
+  if (count >=0 && (size_t)count == tramp_globals.map_size && tramp_table_alloc ())
+    return 1;
+
+  close (tramp_globals.fd);
+  tramp_globals.fd = -1;
+  return 0;
+}
+
+#endif /* defined (__linux__) || defined (__CYGWIN__) */
+
+/* ------------------------ OS-specific Initialization ----------------------*/
+
+#if defined (__linux__) || defined (__CYGWIN__)
+
+static int
+ffi_tramp_init_os (void)
+{
+  if (ffi_tramp_get_libffi ())
+    return 1;
+  return ffi_tramp_get_temp_file ();
+}
+
+#endif /* defined (__linux__) || defined (__CYGWIN__) */
+
+/* --------------------------- OS-specific Locking -------------------------*/
+
+#if defined (__linux__) || defined (__CYGWIN__)
+
+static pthread_mutex_t tramp_globals_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void
+ffi_tramp_lock(void)
+{
+  pthread_mutex_lock (&tramp_globals_mutex);
+}
+
+static void
+ffi_tramp_unlock(void)
+{
+  pthread_mutex_unlock (&tramp_globals_mutex);
+}
+
+#endif /* defined (__linux__) || defined (__CYGWIN__) */
+
+/* ------------------------ OS-specific Memory Mapping ----------------------*/
+
+/*
+ * Create a trampoline code table mapping and a trampoline parameter table
+ * mapping. The two mappings must be adjacent to each other for PC-relative
+ * access.
+ *
+ * For each trampoline in the code table, there is a corresponding parameter
+ * block in the parameter table. The size of the parameter block is the same
+ * as the size of the trampoline. This means that the parameter block is at
+ * a fixed offset from its trampoline making it easy for a trampoline to find
+ * its parameters using PC-relative access.
+ *
+ * The parameter block will contain a struct tramp_parm. This means that
+ * sizeof (struct tramp_parm) cannot exceed the size of a parameter block.
+ */
+
+#if defined (__linux__) || defined (__CYGWIN__)
+
+static int
+tramp_table_map (struct tramp_table *table)
+{
+  char *addr;
+
+  /*
+   * Create an anonymous mapping twice the map size. The top half will be used
+   * for the code table. The bottom half will be used for the parameter table.
+   */
+  addr = mmap (NULL, tramp_globals.map_size * 2, PROT_READ | PROT_WRITE,
+    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (addr == MAP_FAILED)
+    return 0;
+
+  /*
+   * Replace the top half of the anonymous mapping with the code table mapping.
+   */
+  table->code_table = mmap (addr, tramp_globals.map_size, PROT_READ | PROT_EXEC,
+    MAP_PRIVATE | MAP_FIXED, tramp_globals.fd, tramp_globals.offset);
+  if (table->code_table == MAP_FAILED)
+    {
+      (void) munmap (addr, tramp_globals.map_size * 2);
+      return 0;
+    }
+  table->parm_table = table->code_table + tramp_globals.map_size;
+  return 1;
+}
+
+static void
+tramp_table_unmap (struct tramp_table *table)
+{
+  (void) munmap (table->code_table, tramp_globals.map_size);
+  (void) munmap (table->parm_table, tramp_globals.map_size);
+}
+
+#endif /* defined (__linux__) || defined (__CYGWIN__) */
+
+/* ------------------------ Trampoline Initialization ----------------------*/
+
+/*
+ * Initialize the static trampoline feature.
+ */
+static int
+ffi_tramp_init (void)
+{
+  long page_size;
+
+  if (tramp_globals.status == TRAMP_GLOBALS_PASSED)
+    return 1;
+
+  if (tramp_globals.status == TRAMP_GLOBALS_FAILED)
+    return 0;
+
+  if (ffi_tramp_arch == NULL)
+    {
+      tramp_globals.status = TRAMP_GLOBALS_FAILED;
+      return 0;
+    }
+
+  tramp_globals.free_tables = NULL;
+  tramp_globals.nfree_tables = 0;
+
+  /*
+   * Get trampoline code table information from the architecture.
+   */
+  tramp_globals.text = ffi_tramp_arch (&tramp_globals.size,
+    &tramp_globals.map_size);
+  tramp_globals.ntramp = tramp_globals.map_size / tramp_globals.size;
+
+  page_size = sysconf (_SC_PAGESIZE);
+  if (page_size >= 0 && (size_t)page_size > tramp_globals.map_size)
+    return 0;
+
+  if (ffi_tramp_init_os ())
+    {
+      tramp_globals.status = TRAMP_GLOBALS_PASSED;
+      return 1;
+    }
+
+  tramp_globals.status = TRAMP_GLOBALS_FAILED;
+  return 0;
+}
+
+/* ---------------------- Trampoline Table functions ---------------------- */
+
+/* This code assumes that malloc () is available on all OSes. */
+
+static void tramp_add (struct tramp *tramp);
+
+/*
+ * Allocate and initialize a trampoline table.
+ */
+static int
+tramp_table_alloc (void)
+{
+  struct tramp_table *table;
+  struct tramp *tramp_array, *tramp;
+  size_t size;
+  char *code, *parm;
+  int i;
+
+  /*
+   * If we already have tables with free trampolines, there is no need to
+   * allocate a new table.
+   */
+  if (tramp_globals.nfree_tables > 0)
+    return 1;
+
+  /*
+   * Allocate a new trampoline table structure.
+   */
+  table = malloc (sizeof (*table));
+  if (table == NULL)
+    return 0;
+
+  /*
+   * Allocate new trampoline structures.
+   */
+  tramp_array = malloc (sizeof (*tramp) * tramp_globals.ntramp);
+  if (tramp_array == NULL)
+    goto free_table;
+
+  /*
+   * Map a code table and a parameter table into the caller's address space.
+   */
+  if (!tramp_table_map (table))
+    {
+      /*
+       * Failed to map the code and parameter tables.
+       */
+      goto free_tramp_array;
+    }
+
+  /*
+   * Initialize the trampoline table.
+   */
+  table->array = tramp_array;
+  table->free = NULL;
+  table->nfree = 0;
+
+  /*
+   * Populate the trampoline table free list. This will also add the trampoline
+   * table to the global list of trampoline tables.
+   */
+  size = tramp_globals.size;
+  code = table->code_table;
+  parm = table->parm_table;
+  for (i = 0; i < tramp_globals.ntramp; i++)
+    {
+      tramp = &tramp_array[i];
+      tramp->table = table;
+      tramp->code = code;
+      tramp->parm = (struct tramp_parm *) parm;
+      tramp_add (tramp);
+
+      code += size;
+      parm += size;
+    }
+  /* Success */
+  return 1;
+
+/* Failure */
+free_tramp_array:
+  free (tramp_array);
+free_table:
+  free (table);
+  return 0;
+}
+
+/*
+ * Free a trampoline table.
+ */
+static void
+tramp_table_free (struct tramp_table *table)
+{
+  tramp_table_unmap (table);
+  free (table->array);
+  free (table);
+}
+
+/*
+ * Add a new trampoline table to the global table list.
+ */
+static void
+tramp_table_add (struct tramp_table *table)
+{
+  table->next = tramp_globals.free_tables;
+  table->prev = NULL;
+  if (tramp_globals.free_tables != NULL)
+    tramp_globals.free_tables->prev = table;
+  tramp_globals.free_tables = table;
+  tramp_globals.nfree_tables++;
+}
+
+/*
+ * Delete a trampoline table from the global table list.
+ */
+static void
+tramp_table_del (struct tramp_table *table)
+{
+  tramp_globals.nfree_tables--;
+  if (table->prev != NULL)
+    table->prev->next = table->next;
+  if (table->next != NULL)
+    table->next->prev = table->prev;
+  if (tramp_globals.free_tables == table)
+    tramp_globals.free_tables = table->next;
+}
+
+/* ------------------------- Trampoline functions ------------------------- */
+
+/*
+ * Add a trampoline to its trampoline table.
+ */
+static void
+tramp_add (struct tramp *tramp)
+{
+  struct tramp_table *table = tramp->table;
+
+  tramp->next = table->free;
+  tramp->prev = NULL;
+  if (table->free != NULL)
+    table->free->prev = tramp;
+  table->free = tramp;
+  table->nfree++;
+
+  if (table->nfree == 1)
+    tramp_table_add (table);
+
+  /*
+   * We don't want to keep too many free trampoline tables lying around.
+   */
+  if (table->nfree == tramp_globals.ntramp &&
+    tramp_globals.nfree_tables > 1)
+    {
+      tramp_table_del (table);
+      tramp_table_free (table);
+    }
+}
+
+/*
+ * Remove a trampoline from its trampoline table.
+ */
+static void
+tramp_del (struct tramp *tramp)
+{
+  struct tramp_table *table = tramp->table;
+
+  table->nfree--;
+  if (tramp->prev != NULL)
+    tramp->prev->next = tramp->next;
+  if (tramp->next != NULL)
+    tramp->next->prev = tramp->prev;
+  if (table->free == tramp)
+    table->free = tramp->next;
+
+  if (table->nfree == 0)
+    tramp_table_del (table);
+}
+
+/* ------------------------ Trampoline API functions ------------------------ */
+
+int
+ffi_tramp_is_supported(void)
+{
+  int ret;
+
+  ffi_tramp_lock();
+  ret = ffi_tramp_init ();
+  ffi_tramp_unlock();
+  return ret;
+}
+
+/*
+ * Allocate a trampoline and return its opaque address.
+ */
+void *
+ffi_tramp_alloc (int flags)
+{
+  struct tramp *tramp;
+
+  ffi_tramp_lock();
+
+  if (!ffi_tramp_init () || flags != 0)
+    {
+      ffi_tramp_unlock();
+      return NULL;
+    }
+
+  if (!tramp_table_alloc ())
+    {
+      ffi_tramp_unlock();
+      return NULL;
+    }
+
+  tramp = tramp_globals.free_tables->free;
+  tramp_del (tramp);
+
+  ffi_tramp_unlock();
+
+  return tramp;
+}
+
+/*
+ * Set the parameters for a trampoline.
+ */
+void
+ffi_tramp_set_parms (void *arg, void *target, void *data)
+{
+  struct tramp *tramp = arg;
+
+  ffi_tramp_lock();
+  tramp->parm->target = target;
+  tramp->parm->data = data;
+  ffi_tramp_unlock();
+}
+
+/*
+ * Get the invocation address of a trampoline.
+ */
+void *
+ffi_tramp_get_addr (void *arg)
+{
+  struct tramp *tramp = arg;
+  void *addr;
+
+  ffi_tramp_lock();
+  addr = tramp->code;
+  ffi_tramp_unlock();
+
+  return addr;
+}
+
+/*
+ * Free a trampoline.
+ */
+void
+ffi_tramp_free (void *arg)
+{
+  struct tramp *tramp = arg;
+
+  ffi_tramp_lock();
+  tramp_add (tramp);
+  ffi_tramp_unlock();
+}
+
+/* ------------------------------------------------------------------------- */
+
+#else /* !FFI_EXEC_STATIC_TRAMP */
+
+#include <stddef.h>
+
+int
+ffi_tramp_is_supported(void)
+{
+  return 0;
+}
+
+void *
+ffi_tramp_alloc (int flags)
+{
+  return NULL;
+}
+
+void
+ffi_tramp_set_parms (void *arg, void *target, void *data)
+{
+}
+
+void *
+ffi_tramp_get_addr (void *arg)
+{
+  return NULL;
+}
+
+void
+ffi_tramp_free (void *arg)
+{
+}
+
+#endif /* FFI_EXEC_STATIC_TRAMP */
Index: libffi-3.4.6/src/types.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/types.c b/libffi-3.4.6/src/types.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/types.c	
@@ -0,0 +1,106 @@
+/* -----------------------------------------------------------------------
+   types.c - Copyright (c) 1996, 1998, 2024  Red Hat, Inc.
+
+   Predefined ffi_types needed by libffi.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+/* Hide the basic type definitions from the header file, so that we
+   can redefine them here as "const".  */
+#define LIBFFI_HIDE_BASIC_TYPES
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+/* Type definitions */
+
+#define FFI_TYPEDEF(name, type, id, maybe_const)\
+struct struct_align_##name {			\
+  char c;					\
+  type x;					\
+};						\
+FFI_EXTERN					\
+maybe_const ffi_type ffi_type_##name = {	\
+  sizeof(type),					\
+  offsetof(struct struct_align_##name, x),	\
+  id, NULL					\
+}
+
+#define FFI_COMPLEX_TYPEDEF(name, type, maybe_const)	\
+static ffi_type *ffi_elements_complex_##name [2] = {	\
+	(ffi_type *)(&ffi_type_##name), NULL		\
+};							\
+struct struct_align_complex_##name {			\
+  char c;						\
+  _Complex type x;					\
+};							\
+FFI_EXTERN						\
+maybe_const ffi_type ffi_type_complex_##name = {	\
+  sizeof(_Complex type),				\
+  offsetof(struct struct_align_complex_##name, x),	\
+  FFI_TYPE_COMPLEX,					\
+  (ffi_type **)ffi_elements_complex_##name		\
+}
+
+/* Size and alignment are fake here. They must not be 0. */
+FFI_EXTERN const ffi_type ffi_type_void = {
+  1, 1, FFI_TYPE_VOID, NULL
+};
+
+FFI_TYPEDEF(uint8, UINT8, FFI_TYPE_UINT8, const);
+FFI_TYPEDEF(sint8, SINT8, FFI_TYPE_SINT8, const);
+FFI_TYPEDEF(uint16, UINT16, FFI_TYPE_UINT16, const);
+FFI_TYPEDEF(sint16, SINT16, FFI_TYPE_SINT16, const);
+FFI_TYPEDEF(uint32, UINT32, FFI_TYPE_UINT32, const);
+FFI_TYPEDEF(sint32, SINT32, FFI_TYPE_SINT32, const);
+FFI_TYPEDEF(uint64, UINT64, FFI_TYPE_UINT64, const);
+FFI_TYPEDEF(sint64, SINT64, FFI_TYPE_SINT64, const);
+
+FFI_TYPEDEF(pointer, void*, FFI_TYPE_POINTER, const);
+
+FFI_TYPEDEF(float, float, FFI_TYPE_FLOAT, const);
+FFI_TYPEDEF(double, double, FFI_TYPE_DOUBLE, const);
+
+#if !defined HAVE_LONG_DOUBLE_VARIANT || defined __alpha__
+#define FFI_LDBL_CONST const
+#else
+#define FFI_LDBL_CONST
+#endif
+
+#ifdef __alpha__
+/* Even if we're not configured to default to 128-bit long double,
+   maintain binary compatibility, as -mlong-double-128 can be used
+   at any time.  */
+/* Validate the hard-coded number below.  */
+# if defined(__LONG_DOUBLE_128__) && FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+const ffi_type ffi_type_longdouble = { 16, 16, 4, NULL };
+#else
+FFI_TYPEDEF(longdouble, long double, FFI_TYPE_LONGDOUBLE, FFI_LDBL_CONST);
+#endif
+
+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
+FFI_COMPLEX_TYPEDEF(float, float, const);
+FFI_COMPLEX_TYPEDEF(double, double, const);
+FFI_COMPLEX_TYPEDEF(longdouble, long double, FFI_LDBL_CONST);
+#endif
Index: libffi-3.4.6/src/raw_api.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/raw_api.c b/libffi-3.4.6/src/raw_api.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/raw_api.c	
@@ -0,0 +1,267 @@
+/* -----------------------------------------------------------------------
+   raw_api.c - Copyright (c) 1999, 2008  Red Hat, Inc.
+
+   Author: Kresten Krab Thorup <krab@gnu.org>
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+/* This file defines generic functions for use with the raw api. */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#if !FFI_NO_RAW_API
+
+size_t
+ffi_raw_size (ffi_cif *cif)
+{
+  size_t result = 0;
+  int i;
+
+  ffi_type **at = cif->arg_types;
+
+  for (i = cif->nargs-1; i >= 0; i--, at++)
+    {
+#if !FFI_NO_STRUCTS
+      if ((*at)->type == FFI_TYPE_STRUCT)
+	result += FFI_ALIGN (sizeof (void*), FFI_SIZEOF_ARG);
+      else
+#endif
+	result += FFI_ALIGN ((*at)->size, FFI_SIZEOF_ARG);
+    }
+
+  return result;
+}
+
+
+void
+ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)
+{
+  unsigned i;
+  ffi_type **tp = cif->arg_types;
+
+#if WORDS_BIGENDIAN
+
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {	  
+      switch ((*tp)->type)
+	{
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	  *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 1);
+	  break;
+	  
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	  *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 2);
+	  break;
+
+#if FFI_SIZEOF_ARG >= 4	  
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	  *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 4);
+	  break;
+#endif
+	
+#if !FFI_NO_STRUCTS  
+	case FFI_TYPE_STRUCT:
+	  *args = (raw++)->ptr;
+	  break;
+#endif
+
+	case FFI_TYPE_COMPLEX:
+	  *args = (raw++)->ptr;
+	  break;
+
+	case FFI_TYPE_POINTER:
+	  *args = (void*) &(raw++)->ptr;
+	  break;
+	  
+	default:
+	  *args = raw;
+	  raw += FFI_ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+	}
+    }
+
+#else /* WORDS_BIGENDIAN */
+
+#if !PDP
+
+  /* then assume little endian */
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {	  
+#if !FFI_NO_STRUCTS
+      if ((*tp)->type == FFI_TYPE_STRUCT)
+	{
+	  *args = (raw++)->ptr;
+	}
+      else
+#endif
+      if ((*tp)->type == FFI_TYPE_COMPLEX)
+	{
+	  *args = (raw++)->ptr;
+	}
+      else
+	{
+	  *args = (void*) raw;
+	  raw += FFI_ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);
+	}
+    }
+
+#else
+#error "pdp endian not supported"
+#endif /* ! PDP */
+
+#endif /* WORDS_BIGENDIAN */
+}
+
+void
+ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)
+{
+  unsigned i;
+  ffi_type **tp = cif->arg_types;
+
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {	  
+      switch ((*tp)->type)
+	{
+	case FFI_TYPE_UINT8:
+	  (raw++)->uint = *(UINT8*) (*args);
+	  break;
+
+	case FFI_TYPE_SINT8:
+	  (raw++)->sint = *(SINT8*) (*args);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  (raw++)->uint = *(UINT16*) (*args);
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  (raw++)->sint = *(SINT16*) (*args);
+	  break;
+
+#if FFI_SIZEOF_ARG >= 4
+	case FFI_TYPE_UINT32:
+	  (raw++)->uint = *(UINT32*) (*args);
+	  break;
+
+	case FFI_TYPE_SINT32:
+	  (raw++)->sint = *(SINT32*) (*args);
+	  break;
+#endif
+
+#if !FFI_NO_STRUCTS
+	case FFI_TYPE_STRUCT:
+	  (raw++)->ptr = *args;
+	  break;
+#endif
+
+	case FFI_TYPE_COMPLEX:
+	  (raw++)->ptr = *args;
+	  break;
+
+	case FFI_TYPE_POINTER:
+	  (raw++)->ptr = **(void***) args;
+	  break;
+
+	default:
+	  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);
+	  raw += FFI_ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+	}
+    }
+}
+
+#if !FFI_NATIVE_RAW_API
+
+
+/* This is a generic definition of ffi_raw_call, to be used if the
+ * native system does not provide a machine-specific implementation.
+ * Having this, allows code to be written for the raw API, without
+ * the need for system-specific code to handle input in that format;
+ * these following couple of functions will handle the translation forth
+ * and back automatically. */
+
+void ffi_raw_call (ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *raw)
+{
+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
+  ffi_raw_to_ptrarray (cif, raw, avalue);
+  ffi_call (cif, fn, rvalue, avalue);
+}
+
+#if FFI_CLOSURES		/* base system provides closures */
+
+static void
+ffi_translate_args (ffi_cif *cif, void *rvalue,
+		    void **avalue, void *user_data)
+{
+  ffi_raw *raw = (ffi_raw*)alloca (ffi_raw_size (cif));
+  ffi_raw_closure *cl = (ffi_raw_closure*)user_data;
+
+  ffi_ptrarray_to_raw (cif, avalue, raw);
+  (*cl->fun) (cif, rvalue, raw, cl->user_data);
+}
+
+ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure* cl,
+			  ffi_cif *cif,
+			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+			  void *user_data,
+			  void *codeloc)
+{
+  ffi_status status;
+
+  status = ffi_prep_closure_loc ((ffi_closure*) cl,
+				 cif,
+				 &ffi_translate_args,
+				 codeloc,
+				 codeloc);
+  if (status == FFI_OK)
+    {
+      cl->fun       = fun;
+      cl->user_data = user_data;
+    }
+
+  return status;
+}
+
+#endif /* FFI_CLOSURES */
+#endif /* !FFI_NATIVE_RAW_API */
+
+#if FFI_CLOSURES
+
+/* Again, here is the generic version of ffi_prep_raw_closure, which
+ * will install an intermediate "hub" for translation of arguments from
+ * the pointer-array format, to the raw format */
+
+ffi_status
+ffi_prep_raw_closure (ffi_raw_closure* cl,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+		      void *user_data)
+{
+  return ffi_prep_raw_closure_loc (cl, cif, fun, user_data, cl);
+}
+
+#endif /* FFI_CLOSURES */
+
+#endif /* !FFI_NO_RAW_API */
Index: libffi-3.4.6/src/closures.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/closures.c b/libffi-3.4.6/src/closures.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/closures.c	
@@ -0,0 +1,1107 @@
+/* -----------------------------------------------------------------------
+   closures.c - Copyright (c) 2019, 2022 Anthony Green
+                Copyright (c) 2007, 2009, 2010 Red Hat, Inc.
+                Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc
+                Copyright (c) 2011 Plausible Labs Cooperative, Inc.
+
+   Code to allocate and deallocate memory for closures.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#if (defined __linux__ || defined __CYGWIN__) && !defined _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#ifndef __EMSCRIPTEN__
+
+#include <fficonfig.h>
+#include <ffi.h>
+#include <ffi_common.h>
+#include <tramp.h>
+
+#ifdef __NetBSD__
+#include <sys/param.h>
+#endif
+
+#if __NetBSD_Version__ - 0 >= 799007200
+/* NetBSD with PROT_MPROTECT */
+#include <sys/mman.h>
+
+#include <stddef.h>
+#include <unistd.h>
+#ifdef  HAVE_SYS_MEMFD_H
+#include <sys/memfd.h>
+#endif
+
+static const size_t overhead =
+  (sizeof(max_align_t) > sizeof(void *) + sizeof(size_t)) ?
+    sizeof(max_align_t)
+    : sizeof(void *) + sizeof(size_t);
+
+#define ADD_TO_POINTER(p, d) ((void *)((uintptr_t)(p) + (d)))
+
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  static size_t page_size;
+  size_t rounded_size;
+  void *codeseg, *dataseg;
+  int prot;
+
+  /* Expect that PAX mprotect is active and a separate code mapping is necessary. */
+  if (!code)
+    return NULL;
+
+  /* Obtain system page size. */
+  if (!page_size)
+    page_size = sysconf(_SC_PAGESIZE);
+
+  /* Round allocation size up to the next page, keeping in mind the size field and pointer to code map. */
+  rounded_size = (size + overhead + page_size - 1) & ~(page_size - 1);
+
+  /* Primary mapping is RW, but request permission to switch to PROT_EXEC later. */
+  prot = PROT_READ | PROT_WRITE | PROT_MPROTECT(PROT_EXEC);
+  dataseg = mmap(NULL, rounded_size, prot, MAP_ANON | MAP_PRIVATE, -1, 0);
+  if (dataseg == MAP_FAILED)
+    return NULL;
+
+  /* Create secondary mapping and switch it to RX. */
+  codeseg = mremap(dataseg, rounded_size, NULL, rounded_size, MAP_REMAPDUP);
+  if (codeseg == MAP_FAILED) {
+    munmap(dataseg, rounded_size);
+    return NULL;
+  }
+  if (mprotect(codeseg, rounded_size, PROT_READ | PROT_EXEC) == -1) {
+    munmap(codeseg, rounded_size);
+    munmap(dataseg, rounded_size);
+    return NULL;
+  }
+
+  /* Remember allocation size and location of the secondary mapping for ffi_closure_free. */
+  memcpy(dataseg, &rounded_size, sizeof(rounded_size));
+  memcpy(ADD_TO_POINTER(dataseg, sizeof(size_t)), &codeseg, sizeof(void *));
+  *code = ADD_TO_POINTER(codeseg, overhead);
+  return ADD_TO_POINTER(dataseg, overhead);
+}
+
+void
+ffi_closure_free (void *ptr)
+{
+  void *codeseg, *dataseg;
+  size_t rounded_size;
+
+  dataseg = ADD_TO_POINTER(ptr, -overhead);
+  memcpy(&rounded_size, dataseg, sizeof(rounded_size));
+  memcpy(&codeseg, ADD_TO_POINTER(dataseg, sizeof(size_t)), sizeof(void *));
+  munmap(dataseg, rounded_size);
+  munmap(codeseg, rounded_size);
+}
+
+int
+ffi_tramp_is_present (__attribute__((unused)) void *ptr)
+{
+  return 0;
+}
+#else /* !NetBSD with PROT_MPROTECT */
+
+#if !FFI_MMAP_EXEC_WRIT && !FFI_EXEC_TRAMPOLINE_TABLE
+# if __linux__ && !defined(__ANDROID__)
+/* This macro indicates it may be forbidden to map anonymous memory
+   with both write and execute permission.  Code compiled when this
+   option is defined will attempt to map such pages once, but if it
+   fails, it falls back to creating a temporary file in a writable and
+   executable filesystem and mapping pages from it into separate
+   locations in the virtual memory space, one location writable and
+   another executable.  */
+#  define FFI_MMAP_EXEC_WRIT 1
+#  define HAVE_MNTENT 1
+# endif
+# if defined(__CYGWIN__) || defined(_WIN32) || defined(__OS2__)
+/* Windows systems may have Data Execution Protection (DEP) enabled,
+   which requires the use of VirtualMalloc/VirtualFree to alloc/free
+   executable memory. */
+#  define FFI_MMAP_EXEC_WRIT 1
+# endif
+#endif
+
+#if FFI_MMAP_EXEC_WRIT && defined(__linux__) && !defined(__ANDROID__)
+# if !defined FFI_MMAP_EXEC_SELINUX
+/* When defined to 1 check for SELinux and if SELinux is active,
+   don't attempt PROT_EXEC|PROT_WRITE mapping at all, as that
+   might cause audit messages.  */
+#  define FFI_MMAP_EXEC_SELINUX 1
+# endif /* !defined FFI_MMAP_EXEC_SELINUX */
+# if !defined FFI_MMAP_PAX
+/* Also check for PaX MPROTECT */
+#  define FFI_MMAP_PAX 1
+# endif /* !defined FFI_MMAP_PAX */
+#endif /* FFI_MMAP_EXEC_WRIT && defined(__linux__) && !defined(__ANDROID__) */
+
+#if FFI_CLOSURES
+
+#if FFI_EXEC_TRAMPOLINE_TABLE
+
+#ifdef __MACH__
+
+#include <mach/mach.h>
+#include <pthread.h>
+#ifdef HAVE_PTRAUTH
+#include <ptrauth.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+
+extern void *ffi_closure_trampoline_table_page;
+
+typedef struct ffi_trampoline_table ffi_trampoline_table;
+typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;
+
+struct ffi_trampoline_table
+{
+  /* contiguous writable and executable pages */
+  vm_address_t config_page;
+
+  /* free list tracking */
+  uint16_t free_count;
+  ffi_trampoline_table_entry *free_list;
+  ffi_trampoline_table_entry *free_list_pool;
+
+  ffi_trampoline_table *prev;
+  ffi_trampoline_table *next;
+};
+
+struct ffi_trampoline_table_entry
+{
+  void *(*trampoline) (void);
+  ffi_trampoline_table_entry *next;
+};
+
+/* Total number of trampolines that fit in one trampoline table */
+#define FFI_TRAMPOLINE_COUNT (PAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE)
+
+static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;
+static ffi_trampoline_table *ffi_trampoline_tables = NULL;
+
+static ffi_trampoline_table *
+ffi_trampoline_table_alloc (void)
+{
+  ffi_trampoline_table *table;
+  vm_address_t config_page;
+  vm_address_t trampoline_page;
+  vm_address_t trampoline_page_template;
+  vm_prot_t cur_prot;
+  vm_prot_t max_prot;
+  kern_return_t kt;
+  uint16_t i;
+
+  /* Allocate two pages -- a config page and a placeholder page */
+  config_page = 0x0;
+  kt = vm_allocate (mach_task_self (), &config_page, PAGE_MAX_SIZE * 2,
+		    VM_FLAGS_ANYWHERE);
+  if (kt != KERN_SUCCESS)
+    return NULL;
+
+  /* Remap the trampoline table on top of the placeholder page */
+  trampoline_page = config_page + PAGE_MAX_SIZE;
+
+#ifdef HAVE_PTRAUTH
+  trampoline_page_template = (vm_address_t)(uintptr_t)ptrauth_auth_data((void *)&ffi_closure_trampoline_table_page, ptrauth_key_function_pointer, 0);
+#else
+  trampoline_page_template = (vm_address_t)&ffi_closure_trampoline_table_page;
+#endif
+
+#ifdef __arm__
+  /* ffi_closure_trampoline_table_page can be thumb-biased on some ARM archs */
+  trampoline_page_template &= ~1UL;
+#endif
+  kt = vm_remap (mach_task_self (), &trampoline_page, PAGE_MAX_SIZE, 0x0,
+		 VM_FLAGS_OVERWRITE, mach_task_self (), trampoline_page_template,
+		 FALSE, &cur_prot, &max_prot, VM_INHERIT_SHARE);
+  if (kt != KERN_SUCCESS)
+    {
+      vm_deallocate (mach_task_self (), config_page, PAGE_MAX_SIZE * 2);
+      return NULL;
+    }
+
+  if (!(cur_prot & VM_PROT_EXECUTE))
+    {
+      /* If VM_PROT_EXECUTE isn't set on the remapped trampoline page, set it */
+      kt = vm_protect (mach_task_self (), trampoline_page, PAGE_MAX_SIZE,
+         FALSE, cur_prot | VM_PROT_EXECUTE);
+      if (kt != KERN_SUCCESS)
+        {
+          vm_deallocate (mach_task_self (), config_page, PAGE_MAX_SIZE * 2);
+          return NULL;
+        }
+    }
+
+  /* We have valid trampoline and config pages */
+  table = calloc (1, sizeof (ffi_trampoline_table));
+  table->free_count = FFI_TRAMPOLINE_COUNT;
+  table->config_page = config_page;
+
+  /* Create and initialize the free list */
+  table->free_list_pool =
+    calloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));
+
+  for (i = 0; i < table->free_count; i++)
+    {
+      ffi_trampoline_table_entry *entry = &table->free_list_pool[i];
+      entry->trampoline =
+	(void *) (trampoline_page + (i * FFI_TRAMPOLINE_SIZE));
+#ifdef HAVE_PTRAUTH
+      entry->trampoline = ptrauth_sign_unauthenticated(entry->trampoline, ptrauth_key_function_pointer, 0);
+#endif
+
+      if (i < table->free_count - 1)
+	entry->next = &table->free_list_pool[i + 1];
+    }
+
+  table->free_list = table->free_list_pool;
+
+  return table;
+}
+
+static void
+ffi_trampoline_table_free (ffi_trampoline_table *table)
+{
+  /* Remove from the list */
+  if (table->prev != NULL)
+    table->prev->next = table->next;
+
+  if (table->next != NULL)
+    table->next->prev = table->prev;
+
+  /* Deallocate pages */
+  vm_deallocate (mach_task_self (), table->config_page, PAGE_MAX_SIZE * 2);
+
+  /* Deallocate free list */
+  free (table->free_list_pool);
+  free (table);
+}
+
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  /* Create the closure */
+  ffi_closure *closure = malloc (size);
+  if (closure == NULL)
+    return NULL;
+
+  pthread_mutex_lock (&ffi_trampoline_lock);
+
+  /* Check for an active trampoline table with available entries. */
+  ffi_trampoline_table *table = ffi_trampoline_tables;
+  if (table == NULL || table->free_list == NULL)
+    {
+      table = ffi_trampoline_table_alloc ();
+      if (table == NULL)
+	{
+	  pthread_mutex_unlock (&ffi_trampoline_lock);
+	  free (closure);
+	  return NULL;
+	}
+
+      /* Insert the new table at the top of the list */
+      table->next = ffi_trampoline_tables;
+      if (table->next != NULL)
+	table->next->prev = table;
+
+      ffi_trampoline_tables = table;
+    }
+
+  /* Claim the free entry */
+  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;
+  ffi_trampoline_tables->free_list = entry->next;
+  ffi_trampoline_tables->free_count--;
+  entry->next = NULL;
+
+  pthread_mutex_unlock (&ffi_trampoline_lock);
+
+  /* Initialize the return values */
+  *code = entry->trampoline;
+  closure->trampoline_table = table;
+  closure->trampoline_table_entry = entry;
+
+  return closure;
+}
+
+void
+ffi_closure_free (void *ptr)
+{
+  ffi_closure *closure = ptr;
+
+  pthread_mutex_lock (&ffi_trampoline_lock);
+
+  /* Fetch the table and entry references */
+  ffi_trampoline_table *table = closure->trampoline_table;
+  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;
+
+  /* Return the entry to the free list */
+  entry->next = table->free_list;
+  table->free_list = entry;
+  table->free_count++;
+
+  /* If all trampolines within this table are free, and at least one other table exists, deallocate
+   * the table */
+  if (table->free_count == FFI_TRAMPOLINE_COUNT
+      && ffi_trampoline_tables != table)
+    {
+      ffi_trampoline_table_free (table);
+    }
+  else if (ffi_trampoline_tables != table)
+    {
+      /* Otherwise, bump this table to the top of the list */
+      table->prev = NULL;
+      table->next = ffi_trampoline_tables;
+      if (ffi_trampoline_tables != NULL)
+	ffi_trampoline_tables->prev = table;
+
+      ffi_trampoline_tables = table;
+    }
+
+  pthread_mutex_unlock (&ffi_trampoline_lock);
+
+  /* Free the closure */
+  free (closure);
+}
+
+#endif
+
+// Per-target implementation; It's unclear what can reasonable be shared between two OS/architecture implementations.
+
+#elif FFI_MMAP_EXEC_WRIT /* !FFI_EXEC_TRAMPOLINE_TABLE */
+
+#define USE_LOCKS 1
+#define USE_DL_PREFIX 1
+#ifdef __GNUC__
+#ifndef USE_BUILTIN_FFS
+#define USE_BUILTIN_FFS 1
+#endif
+#endif
+
+/* We need to use mmap, not sbrk.  */
+#define HAVE_MORECORE 0
+
+/* We could, in theory, support mremap, but it wouldn't buy us anything.  */
+#define HAVE_MREMAP 0
+
+/* We have no use for this, so save some code and data.  */
+#define NO_MALLINFO 1
+
+/* We need all allocations to be in regular segments, otherwise we
+   lose track of the corresponding code address.  */
+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
+
+/* Don't allocate more than a page unless needed.  */
+#define DEFAULT_GRANULARITY ((size_t)malloc_getpagesize)
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#ifndef _MSC_VER
+#include <unistd.h>
+#endif
+#include <string.h>
+#include <stdio.h>
+#if !defined(_WIN32)
+#ifdef HAVE_MNTENT
+#include <mntent.h>
+#endif /* HAVE_MNTENT */
+#include <sys/param.h>
+#include <pthread.h>
+
+/* We don't want sys/mman.h to be included after we redefine mmap and
+   dlmunmap.  */
+#include <sys/mman.h>
+#define LACKS_SYS_MMAN_H 1
+
+#if FFI_MMAP_EXEC_SELINUX
+#include <sys/statfs.h>
+#include <stdlib.h>
+
+static int selinux_enabled = -1;
+
+static int
+selinux_enabled_check (void)
+{
+  struct statfs sfs;
+  FILE *f;
+  char *buf = NULL;
+  size_t len = 0;
+
+  if (statfs ("/selinux", &sfs) >= 0
+      && (unsigned int) sfs.f_type == 0xf97cff8cU)
+    return 1;
+  f = fopen ("/proc/mounts", "r");
+  if (f == NULL)
+    return 0;
+  while (getline (&buf, &len, f) >= 0)
+    {
+      char *p = strchr (buf, ' ');
+      if (p == NULL)
+        break;
+      p = strchr (p + 1, ' ');
+      if (p == NULL)
+        break;
+      if (strncmp (p + 1, "selinuxfs ", 10) == 0)
+        {
+          free (buf);
+          fclose (f);
+          return 1;
+        }
+    }
+  free (buf);
+  fclose (f);
+  return 0;
+}
+
+#define is_selinux_enabled() (selinux_enabled >= 0 ? selinux_enabled \
+			      : (selinux_enabled = selinux_enabled_check ()))
+
+#else
+
+#define is_selinux_enabled() 0
+
+#endif /* !FFI_MMAP_EXEC_SELINUX */
+
+/* On PaX enable kernels that have MPROTECT enabled we can't use PROT_EXEC. */
+#if defined FFI_MMAP_PAX
+#include <stdlib.h>
+
+enum {
+  PAX_MPROTECT = (1 << 0),
+  PAX_EMUTRAMP = (1 << 1),
+};
+static int cached_pax_flags = -1;
+
+static int
+pax_flags_check (void)
+{
+  char *buf = NULL;
+  size_t len = 0;
+  FILE *f;
+  int ret;
+  f = fopen ("/proc/self/status", "r");
+  if (f == NULL)
+    return 0;
+  ret = 0;
+
+  while (getline (&buf, &len, f) != -1)
+    if (!strncmp (buf, "PaX:", 4))
+      {
+        if (NULL != strchr (buf + 4, 'M'))
+          ret |= PAX_MPROTECT;
+        if (NULL != strchr (buf + 4, 'E'))
+          ret |= PAX_EMUTRAMP;
+        break;
+      }
+  free (buf);
+  fclose (f);
+  return ret;
+}
+
+#define get_pax_flags() (cached_pax_flags >= 0 ? cached_pax_flags \
+                               : (cached_pax_flags = pax_flags_check ()))
+#define has_pax_flags(flags) ((flags) == ((flags) & get_pax_flags ()))
+#define is_mprotect_enabled() (has_pax_flags (PAX_MPROTECT))
+#define is_emutramp_enabled() (has_pax_flags (PAX_EMUTRAMP))
+
+#endif /* defined FFI_MMAP_PAX */
+
+#elif defined (__CYGWIN__) || defined(__INTERIX)
+
+#include <sys/mman.h>
+
+/* Cygwin is Linux-like, but not quite that Linux-like.  */
+#define is_selinux_enabled() 0
+
+#endif /* !defined(X86_WIN32) && !defined(X86_WIN64) */
+
+#if !defined FFI_MMAP_PAX
+# define is_mprotect_enabled() 0
+# define is_emutramp_enabled() 0
+#endif /* !defined FFI_MMAP_PAX */
+
+/* Declare all functions defined in dlmalloc.c as static.  */
+static void *dlmalloc(size_t);
+static void dlfree(void*);
+static void *dlcalloc(size_t, size_t) MAYBE_UNUSED;
+static void *dlrealloc(void *, size_t) MAYBE_UNUSED;
+static void *dlmemalign(size_t, size_t) MAYBE_UNUSED;
+static void *dlvalloc(size_t) MAYBE_UNUSED;
+static int dlmallopt(int, int) MAYBE_UNUSED;
+static size_t dlmalloc_footprint(void) MAYBE_UNUSED;
+static size_t dlmalloc_max_footprint(void) MAYBE_UNUSED;
+static void** dlindependent_calloc(size_t, size_t, void**) MAYBE_UNUSED;
+static void** dlindependent_comalloc(size_t, size_t*, void**) MAYBE_UNUSED;
+static void *dlpvalloc(size_t) MAYBE_UNUSED;
+static int dlmalloc_trim(size_t) MAYBE_UNUSED;
+static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;
+static void dlmalloc_stats(void) MAYBE_UNUSED;
+
+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
+/* Use these for mmap and munmap within dlmalloc.c.  */
+static void *dlmmap(void *, size_t, int, int, int, off_t);
+static int dlmunmap(void *, size_t);
+#endif /* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */
+
+#define mmap dlmmap
+#define munmap dlmunmap
+
+#include "dlmalloc.c"
+
+#undef mmap
+#undef munmap
+
+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)
+
+/* A mutex used to synchronize access to *exec* variables in this file.  */
+static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/* A file descriptor of a temporary file from which we'll map
+   executable pages.  */
+static int execfd = -1;
+
+/* The amount of space already allocated from the temporary file.  */
+static size_t execsize = 0;
+
+#ifdef HAVE_MEMFD_CREATE
+/* Open a temporary file name, and immediately unlink it.  */
+static int
+open_temp_exec_file_memfd (const char *name)
+{
+  int fd;
+  fd = memfd_create (name, MFD_CLOEXEC);
+  return fd;
+}
+#endif
+
+/* Open a temporary file name, and immediately unlink it.  */
+static int
+open_temp_exec_file_name (char *name, int flags MAYBE_UNUSED)
+{
+  int fd;
+
+#ifdef HAVE_MKOSTEMP
+  fd = mkostemp (name, flags);
+#else
+  fd = mkstemp (name);
+#endif
+
+  if (fd != -1)
+    unlink (name);
+
+  return fd;
+}
+
+/* Open a temporary file in the named directory.  */
+static int
+open_temp_exec_file_dir (const char *dir)
+{
+  static const char suffix[] = "/ffiXXXXXX";
+  int lendir, flags;
+  char *tempname;
+#ifdef O_TMPFILE
+  int fd;
+#endif
+
+#ifdef O_CLOEXEC
+  flags = O_CLOEXEC;
+#else
+  flags = 0;
+#endif
+
+#ifdef O_TMPFILE
+  fd = open (dir, flags | O_RDWR | O_EXCL | O_TMPFILE, 0700);
+  /* If the running system does not support the O_TMPFILE flag then retry without it. */
+  if (fd != -1 || (errno != EINVAL && errno != EISDIR && errno != EOPNOTSUPP)) {
+    return fd;
+  } else {
+    errno = 0;
+  }
+#endif
+
+  lendir = (int) strlen (dir);
+  tempname = __builtin_alloca (lendir + sizeof (suffix));
+
+  if (!tempname)
+    return -1;
+
+  memcpy (tempname, dir, lendir);
+  memcpy (tempname + lendir, suffix, sizeof (suffix));
+
+  return open_temp_exec_file_name (tempname, flags);
+}
+
+/* Open a temporary file in the directory in the named environment
+   variable.  */
+static int
+open_temp_exec_file_env (const char *envvar)
+{
+  const char *value = getenv (envvar);
+
+  if (!value)
+    return -1;
+
+  return open_temp_exec_file_dir (value);
+}
+
+#ifdef HAVE_MNTENT
+/* Open a temporary file in an executable and writable mount point
+   listed in the mounts file.  Subsequent calls with the same mounts
+   keep searching for mount points in the same file.  Providing NULL
+   as the mounts file closes the file.  */
+static int
+open_temp_exec_file_mnt (const char *mounts)
+{
+  static const char *last_mounts;
+  static FILE *last_mntent;
+
+  if (mounts != last_mounts)
+    {
+      if (last_mntent)
+	endmntent (last_mntent);
+
+      last_mounts = mounts;
+
+      if (mounts)
+	last_mntent = setmntent (mounts, "r");
+      else
+	last_mntent = NULL;
+    }
+
+  if (!last_mntent)
+    return -1;
+
+  for (;;)
+    {
+      int fd;
+      struct mntent mnt;
+      char buf[MAXPATHLEN * 3];
+
+      if (getmntent_r (last_mntent, &mnt, buf, sizeof (buf)) == NULL)
+	return -1;
+
+      if (hasmntopt (&mnt, "ro")
+	  || hasmntopt (&mnt, "noexec")
+	  || access (mnt.mnt_dir, W_OK))
+	continue;
+
+      fd = open_temp_exec_file_dir (mnt.mnt_dir);
+
+      if (fd != -1)
+	return fd;
+    }
+}
+#endif /* HAVE_MNTENT */
+
+/* Instructions to look for a location to hold a temporary file that
+   can be mapped in for execution.  */
+static struct
+{
+  int (*func)(const char *);
+  const char *arg;
+  int repeat;
+} open_temp_exec_file_opts[] = {
+#ifdef HAVE_MEMFD_CREATE
+  { open_temp_exec_file_memfd, "libffi", 0 },
+#endif
+  { open_temp_exec_file_env, "LIBFFI_TMPDIR", 0 },
+  { open_temp_exec_file_env, "TMPDIR", 0 },
+  { open_temp_exec_file_dir, "/tmp", 0 },
+  { open_temp_exec_file_dir, "/var/tmp", 0 },
+  { open_temp_exec_file_dir, "/dev/shm", 0 },
+  { open_temp_exec_file_env, "HOME", 0 },
+#ifdef HAVE_MNTENT
+  { open_temp_exec_file_mnt, "/etc/mtab", 1 },
+  { open_temp_exec_file_mnt, "/proc/mounts", 1 },
+#endif /* HAVE_MNTENT */
+};
+
+/* Current index into open_temp_exec_file_opts.  */
+static int open_temp_exec_file_opts_idx = 0;
+
+/* Reset a current multi-call func, then advances to the next entry.
+   If we're at the last, go back to the first and return nonzero,
+   otherwise return zero.  */
+static int
+open_temp_exec_file_opts_next (void)
+{
+  if (open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat)
+    open_temp_exec_file_opts[open_temp_exec_file_opts_idx].func (NULL);
+
+  open_temp_exec_file_opts_idx++;
+  if (open_temp_exec_file_opts_idx
+      == (sizeof (open_temp_exec_file_opts)
+	  / sizeof (*open_temp_exec_file_opts)))
+    {
+      open_temp_exec_file_opts_idx = 0;
+      return 1;
+    }
+
+  return 0;
+}
+
+/* Return a file descriptor of a temporary zero-sized file in a
+   writable and executable filesystem.  */
+int
+open_temp_exec_file (void)
+{
+  int fd;
+
+  do
+    {
+      fd = open_temp_exec_file_opts[open_temp_exec_file_opts_idx].func
+	(open_temp_exec_file_opts[open_temp_exec_file_opts_idx].arg);
+
+      if (!open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat
+	  || fd == -1)
+	{
+	  if (open_temp_exec_file_opts_next ())
+	    break;
+	}
+    }
+  while (fd == -1);
+
+  return fd;
+}
+
+/* We need to allocate space in a file that will be backing a writable
+   mapping.  Several problems exist with the usual approaches:
+   - fallocate() is Linux-only
+   - posix_fallocate() is not available on all platforms
+   - ftruncate() does not allocate space on filesystems with sparse files
+   Failure to allocate the space will cause SIGBUS to be thrown when
+   the mapping is subsequently written to.  */
+static int
+allocate_space (int fd, off_t len)
+{
+  static long page_size;
+
+  /* Obtain system page size. */
+  if (!page_size)
+    page_size = sysconf(_SC_PAGESIZE);
+
+  unsigned char buf[page_size];
+  memset (buf, 0, page_size);
+
+  while (len > 0)
+    {
+      off_t to_write = (len < page_size) ? len : page_size;
+      if (write (fd, buf, to_write) < to_write)
+        return -1;
+      len -= to_write;
+    }
+
+  return 0;
+}
+
+/* Map in a chunk of memory from the temporary exec file into separate
+   locations in the virtual memory address space, one writable and one
+   executable.  Returns the address of the writable portion, after
+   storing an offset to the corresponding executable portion at the
+   last word of the requested chunk.  */
+static void *
+dlmmap_locked (void *start, size_t length, int prot, int flags, off_t offset)
+{
+  void *ptr;
+
+  if (execfd == -1)
+    {
+      open_temp_exec_file_opts_idx = 0;
+    retry_open:
+      execfd = open_temp_exec_file ();
+      if (execfd == -1)
+	return MFAIL;
+    }
+
+  offset = execsize;
+
+  if (allocate_space (execfd, length))
+    return MFAIL;
+
+  flags &= ~(MAP_PRIVATE | MAP_ANONYMOUS);
+  flags |= MAP_SHARED;
+
+  ptr = mmap (NULL, length, (prot & ~PROT_WRITE) | PROT_EXEC,
+	      flags, execfd, offset);
+  if (ptr == MFAIL)
+    {
+      if (!offset)
+	{
+	  close (execfd);
+	  goto retry_open;
+	}
+      if (ftruncate (execfd, offset) != 0)
+      {
+        /* Fixme : Error logs can be added here. Returning an error for
+         * ftruncte() will not add any advantage as it is being
+         * validating in the error case. */
+      }
+
+      return MFAIL;
+    }
+  else if (!offset
+	   && open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat)
+    open_temp_exec_file_opts_next ();
+
+  start = mmap (start, length, prot, flags, execfd, offset);
+
+  if (start == MFAIL)
+    {
+      munmap (ptr, length);
+      if (ftruncate (execfd, offset) != 0)
+      {
+        /* Fixme : Error logs can be added here. Returning an error for
+         * ftruncte() will not add any advantage as it is being
+         * validating in the error case. */
+      }
+      return start;
+    }
+
+  mmap_exec_offset ((char *)start, length) = (char*)ptr - (char*)start;
+
+  execsize += length;
+
+  return start;
+}
+
+/* Map in a writable and executable chunk of memory if possible.
+   Failing that, fall back to dlmmap_locked.  */
+static void *
+dlmmap (void *start, size_t length, int prot,
+	int flags, int fd, off_t offset)
+{
+  void *ptr;
+
+  assert (start == NULL && length % malloc_getpagesize == 0
+	  && prot == (PROT_READ | PROT_WRITE)
+	  && flags == (MAP_PRIVATE | MAP_ANONYMOUS)
+	  && fd == -1 && offset == 0);
+
+  if (execfd == -1 && ffi_tramp_is_supported ())
+    {
+      ptr = mmap (start, length, prot & ~PROT_EXEC, flags, fd, offset);
+      return ptr;
+    }
+
+  /* -1 != execfd hints that we already decided to use dlmmap_locked
+     last time.  */
+  if (execfd == -1 && is_mprotect_enabled ())
+    {
+#ifdef FFI_MMAP_EXEC_EMUTRAMP_PAX
+      if (is_emutramp_enabled ())
+        {
+          /* emutramp requires the kernel recognizing the trampoline pattern
+             generated by ffi_prep_closure_loc; there is no way to test
+             in advance whether this will work, so this is experimental.  */
+          ptr = mmap (start, length, prot & ~PROT_EXEC, flags, fd, offset);
+          return ptr;
+        }
+#endif
+      /* fallback to dlmmap_locked.  */
+    }
+  else if (execfd == -1 && !is_selinux_enabled ())
+    {
+      ptr = mmap (start, length, prot | PROT_EXEC, flags, fd, offset);
+
+      if (ptr != MFAIL || (errno != EPERM && errno != EACCES))
+	/* Cool, no need to mess with separate segments.  */
+	return ptr;
+
+      /* If MREMAP_DUP is ever introduced and implemented, try mmap
+	 with ((prot & ~PROT_WRITE) | PROT_EXEC) and mremap with
+	 MREMAP_DUP and prot at this point.  */
+    }
+
+  pthread_mutex_lock (&open_temp_exec_file_mutex);
+  ptr = dlmmap_locked (start, length, prot, flags, offset);
+  pthread_mutex_unlock (&open_temp_exec_file_mutex);
+
+  return ptr;
+}
+
+/* Release memory at the given address, as well as the corresponding
+   executable page if it's separate.  */
+static int
+dlmunmap (void *start, size_t length)
+{
+  /* We don't bother decreasing execsize or truncating the file, since
+     we can't quite tell whether we're unmapping the end of the file.
+     We don't expect frequent deallocation anyway.  If we did, we
+     could locate pages in the file by writing to the pages being
+     deallocated and checking that the file contents change.
+     Yuck.  */
+  msegmentptr seg = segment_holding (gm, start);
+  void *code;
+
+  if (seg && (code = add_segment_exec_offset (start, seg)) != start)
+    {
+      int ret = munmap (code, length);
+      if (ret)
+	return ret;
+    }
+
+  return munmap (start, length);
+}
+
+#if FFI_CLOSURE_FREE_CODE
+/* Return segment holding given code address.  */
+static msegmentptr
+segment_holding_code (mstate m, char* addr)
+{
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if (addr >= add_segment_exec_offset (sp->base, sp)
+	&& addr < add_segment_exec_offset (sp->base, sp) + sp->size)
+      return sp;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+#endif
+
+#endif /* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */
+
+/* Allocate a chunk of memory with the given size.  Returns a pointer
+   to the writable address, and sets *CODE to the executable
+   corresponding virtual address.  */
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  void *ptr, *ftramp;
+
+  if (!code)
+    return NULL;
+
+  ptr = dlmalloc (size);
+
+  if (ptr)
+    {
+      msegmentptr seg = segment_holding (gm, ptr);
+
+      *code = FFI_FN (add_segment_exec_offset (ptr, seg));
+      if (!ffi_tramp_is_supported ())
+        return ptr;
+
+      ftramp = ffi_tramp_alloc (0);
+      if (ftramp == NULL)
+      {
+        dlfree (ptr);
+        return NULL;
+      }
+      *code = FFI_FN (ffi_tramp_get_addr (ftramp));
+      ((ffi_closure *) ptr)->ftramp = ftramp;
+    }
+
+  return ptr;
+}
+
+void *
+ffi_data_to_code_pointer (void *data)
+{
+  msegmentptr seg = segment_holding (gm, data);
+  /* We expect closures to be allocated with ffi_closure_alloc(), in
+     which case seg will be non-NULL.  However, some users take on the
+     burden of managing this memory themselves, in which case this
+     we'll just return data. */
+  if (seg)
+    {
+      if (!ffi_tramp_is_supported ())
+        return add_segment_exec_offset (data, seg);
+      return ffi_tramp_get_addr (((ffi_closure *) data)->ftramp);
+    }
+  else
+    return data;
+}
+
+/* Release a chunk of memory allocated with ffi_closure_alloc.  If
+   FFI_CLOSURE_FREE_CODE is nonzero, the given address can be the
+   writable or the executable address given.  Otherwise, only the
+   writable address can be provided here.  */
+void
+ffi_closure_free (void *ptr)
+{
+#if FFI_CLOSURE_FREE_CODE
+  msegmentptr seg = segment_holding_code (gm, ptr);
+
+  if (seg)
+    ptr = sub_segment_exec_offset (ptr, seg);
+#endif
+  if (ffi_tramp_is_supported ())
+    ffi_tramp_free (((ffi_closure *) ptr)->ftramp);
+
+  dlfree (ptr);
+}
+
+int
+ffi_tramp_is_present (void *ptr)
+{
+  msegmentptr seg = segment_holding (gm, ptr);
+  return seg != NULL && ffi_tramp_is_supported();
+}
+
+# else /* ! FFI_MMAP_EXEC_WRIT */
+
+/* On many systems, memory returned by malloc is writable and
+   executable, so just use it.  */
+
+#include <stdlib.h>
+
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  void *c;
+
+  if (!code)
+    return NULL;
+
+  c = malloc (size);
+  *code = FFI_FN (c);
+  return c;
+}
+
+void
+ffi_closure_free (void *ptr)
+{
+  free (ptr);
+}
+
+void *
+ffi_data_to_code_pointer (void *data)
+{
+  return data;
+}
+
+int
+ffi_tramp_is_present (__attribute__((unused)) void *ptr)
+{
+  return 0;
+}
+
+# endif /* ! FFI_MMAP_EXEC_WRIT */
+#endif /* FFI_CLOSURES */
+
+#endif /* NetBSD with PROT_MPROTECT */
+#endif /* __EMSCRIPTEN__ */
Index: libffi-3.4.6/src/dlmalloc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/dlmalloc.c b/libffi-3.4.6/src/dlmalloc.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/dlmalloc.c	
@@ -0,0 +1,5171 @@
+/*
+  This is a version (aka dlmalloc) of malloc/free/realloc written by
+  Doug Lea and released to the public domain, as explained at
+  http://creativecommons.org/licenses/publicdomain.  Send questions,
+  comments, complaints, performance data, etc to dl@cs.oswego.edu
+
+* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)
+
+   Note: There may be an updated version of this malloc obtainable at
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+         Check before installing!
+
+* Quickstart
+
+  This library is all in one file to simplify the most common usage:
+  ftp it, compile it (-O3), and link it into another program. All of
+  the compile-time options default to reasonable values for use on
+  most platforms.  You might later want to step through various
+  compile-time and dynamic tuning options.
+
+  For convenience, an include file for code using this malloc is at:
+     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h
+  You don't really need this .h file unless you call functions not
+  defined in your system include files.  The .h file contains only the
+  excerpts from this file needed for using this malloc on ANSI C/C++
+  systems, so long as you haven't changed compile-time options about
+  naming and tuning parameters.  If you do, then you can create your
+  own malloc.h that does include all settings by cutting at the point
+  indicated below. Note that you may already by default be using a C
+  library containing a malloc that is based on some version of this
+  malloc (for example in linux). You might still want to use the one
+  in this file to customize settings or to avoid overheads associated
+  with library versions.
+
+* Vital statistics:
+
+  Supported pointer/size_t representation:       4 or 8 bytes
+       size_t MUST be an unsigned type of the same width as
+       pointers. (If you are using an ancient system that declares
+       size_t as a signed type, or need it to be a different width
+       than pointers, you can use a previous release of this malloc
+       (e.g. 2.7.2) supporting these.)
+
+  Alignment:                                     8 bytes (default)
+       This suffices for nearly all current machines and C compilers.
+       However, you can define MALLOC_ALIGNMENT to be wider than this
+       if necessary (up to 128bytes), at the expense of using more space.
+
+  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
+                                          8 or 16 bytes (if 8byte sizes)
+       Each malloced chunk has a hidden word of overhead holding size
+       and status information, and additional cross-check word
+       if FOOTERS is defined.
+
+  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
+                          8-byte ptrs:  32 bytes    (including overhead)
+
+       Even a request for zero bytes (i.e., malloc(0)) returns a
+       pointer to something of the minimum allocatable size.
+       The maximum overhead wastage (i.e., number of extra bytes
+       allocated than were requested in malloc) is less than or equal
+       to the minimum size, except for requests >= mmap_threshold that
+       are serviced via mmap(), where the worst case wastage is about
+       32 bytes plus the remainder from a system page (the minimal
+       mmap unit); typically 4096 or 8192 bytes.
+
+  Security: static-safe; optionally more or less
+       The "security" of malloc refers to the ability of malicious
+       code to accentuate the effects of errors (for example, freeing
+       space that is not currently malloc'ed or overwriting past the
+       ends of chunks) in code that calls malloc.  This malloc
+       guarantees not to modify any memory locations below the base of
+       heap, i.e., static variables, even in the presence of usage
+       errors.  The routines additionally detect most improper frees
+       and reallocs.  All this holds as long as the static bookkeeping
+       for malloc itself is not corrupted by some other means.  This
+       is only one aspect of security -- these checks do not, and
+       cannot, detect all possible programming errors.
+
+       If FOOTERS is defined nonzero, then each allocated chunk
+       carries an additional check word to verify that it was malloced
+       from its space.  These check words are the same within each
+       execution of a program using malloc, but differ across
+       executions, so externally crafted fake chunks cannot be
+       freed. This improves security by rejecting frees/reallocs that
+       could corrupt heap memory, in addition to the checks preventing
+       writes to statics that are always on.  This may further improve
+       security at the expense of time and space overhead.  (Note that
+       FOOTERS may also be worth using with MSPACES.)
+
+       By default detected errors cause the program to abort (calling
+       "abort()"). You can override this to instead proceed past
+       errors by defining PROCEED_ON_ERROR.  In this case, a bad free
+       has no effect, and a malloc that encounters a bad address
+       caused by user overwrites will ignore the bad address by
+       dropping pointers and indices to all known memory. This may
+       be appropriate for programs that should continue if at all
+       possible in the face of programming errors, although they may
+       run out of memory because dropped memory is never reclaimed.
+
+       If you don't like either of these options, you can define
+       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
+       else. And if if you are sure that your program using malloc has
+       no errors or vulnerabilities, you can define INSECURE to 1,
+       which might (or might not) provide a small performance improvement.
+
+  Thread-safety: NOT thread-safe unless USE_LOCKS defined
+       When USE_LOCKS is defined, each public call to malloc, free,
+       etc is surrounded with either a pthread mutex or a win32
+       spinlock (depending on WIN32). This is not especially fast, and
+       can be a major bottleneck.  It is designed only to provide
+       minimal protection in concurrent environments, and to provide a
+       basis for extensions.  If you are using malloc in a concurrent
+       program, consider instead using ptmalloc, which is derived from
+       a version of this malloc. (See http://www.malloc.de).
+
+  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
+       This malloc can use unix sbrk or any emulation (invoked using
+       the CALL_MORECORE macro) and/or mmap/munmap or any emulation
+       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
+       memory.  On most unix systems, it tends to work best if both
+       MORECORE and MMAP are enabled.  On Win32, it uses emulations
+       based on VirtualAlloc. It also uses common C library functions
+       like memset.
+
+  Compliance: I believe it is compliant with the Single Unix Specification
+       (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
+       others as well.
+
+* Overview of algorithms
+
+  This is not the fastest, most space-conserving, most portable, or
+  most tunable malloc ever written. However it is among the fastest
+  while also being among the most space-conserving, portable and
+  tunable.  Consistent balance across these factors results in a good
+  general-purpose allocator for malloc-intensive programs.
+
+  In most ways, this malloc is a best-fit allocator. Generally, it
+  chooses the best-fitting existing chunk for a request, with ties
+  broken in approximately least-recently-used order. (This strategy
+  normally maintains low fragmentation.) However, for requests less
+  than 256bytes, it deviates from best-fit when there is not an
+  exactly fitting available chunk by preferring to use space adjacent
+  to that used for the previous small request, as well as by breaking
+  ties in approximately most-recently-used order. (These enhance
+  locality of series of small allocations.)  And for very large requests
+  (>= 256Kb by default), it relies on system memory mapping
+  facilities, if supported.  (This helps avoid carrying around and
+  possibly fragmenting memory used only for large chunks.)
+
+  All operations (except malloc_stats and mallinfo) have execution
+  times that are bounded by a constant factor of the number of bits in
+  a size_t, not counting any clearing in calloc or copying in realloc,
+  or actions surrounding MORECORE and MMAP that have times
+  proportional to the number of non-contiguous regions returned by
+  system allocation routines, which is often just 1.
+
+  The implementation is not very modular and seriously overuses
+  macros. Perhaps someday all C compilers will do as good a job
+  inlining modular code as can now be done by brute-force expansion,
+  but now, enough of them seem not to.
+
+  Some compilers issue a lot of warnings about code that is
+  dead/unreachable only on some platforms, and also about intentional
+  uses of negation on unsigned types. All known cases of each can be
+  ignored.
+
+  For a longer but out of date high-level description, see
+     http://gee.cs.oswego.edu/dl/html/malloc.html
+
+* MSPACES
+  If MSPACES is defined, then in addition to malloc, free, etc.,
+  this file also defines mspace_malloc, mspace_free, etc. These
+  are versions of malloc routines that take an "mspace" argument
+  obtained using create_mspace, to control all internal bookkeeping.
+  If ONLY_MSPACES is defined, only these versions are compiled.
+  So if you would like to use this allocator for only some allocations,
+  and your system malloc for others, you can compile with
+  ONLY_MSPACES and then do something like...
+    static mspace mymspace = create_mspace(0,0); // for example
+    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)
+
+  (Note: If you only need one instance of an mspace, you can instead
+  use "USE_DL_PREFIX" to relabel the global malloc.)
+
+  You can similarly create thread-local allocators by storing
+  mspaces as thread-locals. For example:
+    static __thread mspace tlms = 0;
+    void*  tlmalloc(size_t bytes) {
+      if (tlms == 0) tlms = create_mspace(0, 0);
+      return mspace_malloc(tlms, bytes);
+    }
+    void  tlfree(void* mem) { mspace_free(tlms, mem); }
+
+  Unless FOOTERS is defined, each mspace is completely independent.
+  You cannot allocate from one and free to another (although
+  conformance is only weakly checked, so usage errors are not always
+  caught). If FOOTERS is defined, then each chunk carries around a tag
+  indicating its originating mspace, and frees are directed to their
+  originating spaces.
+
+ -------------------------  Compile-time options ---------------------------
+
+Be careful in setting #define values for numerical constants of type
+size_t. On some systems, literal values are not automatically extended
+to size_t precision unless they are explicitly casted.
+
+WIN32                    default: defined if _WIN32 defined
+  Defining WIN32 sets up defaults for MS environment and compilers.
+  Otherwise defaults are for unix.
+
+MALLOC_ALIGNMENT         default: (size_t)8
+  Controls the minimum alignment for malloc'ed chunks.  It must be a
+  power of two and at least 8, even on machines for which smaller
+  alignments would suffice. It may be defined as larger than this
+  though. Note however that code and data structures are optimized for
+  the case of 8-byte alignment.
+
+MSPACES                  default: 0 (false)
+  If true, compile in support for independent allocation spaces.
+  This is only supported if HAVE_MMAP is true.
+
+ONLY_MSPACES             default: 0 (false)
+  If true, only compile in mspace versions, not regular versions.
+
+USE_LOCKS                default: 0 (false)
+  Causes each call to each public routine to be surrounded with
+  pthread or WIN32 mutex lock/unlock. (If set true, this can be
+  overridden on a per-mspace basis for mspace versions.)
+
+FOOTERS                  default: 0
+  If true, provide extra checking and dispatching by placing
+  information in the footers of allocated chunks. This adds
+  space and time overhead.
+
+INSECURE                 default: 0
+  If true, omit checks for usage errors and heap space overwrites.
+
+USE_DL_PREFIX            default: NOT defined
+  Causes compiler to prefix all public routines with the string 'dl'.
+  This can be useful when you only want to use this malloc in one part
+  of a program, using your regular system malloc elsewhere.
+
+ABORT                    default: defined as abort()
+  Defines how to abort on failed checks.  On most systems, a failed
+  check cannot die with an "assert" or even print an informative
+  message, because the underlying print routines in turn call malloc,
+  which will fail again.  Generally, the best policy is to simply call
+  abort(). It's not very useful to do more than this because many
+  errors due to overwriting will show up as address faults (null, odd
+  addresses etc) rather than malloc-triggered checks, so will also
+  abort.  Also, most compilers know that abort() does not return, so
+  can better optimize code conditionally calling it.
+
+PROCEED_ON_ERROR           default: defined as 0 (false)
+  Controls whether detected bad addresses cause them to bypassed
+  rather than aborting. If set, detected bad arguments to free and
+  realloc are ignored. And all bookkeeping information is zeroed out
+  upon a detected overwrite of freed heap space, thus losing the
+  ability to ever return it from malloc again, but enabling the
+  application to proceed. If PROCEED_ON_ERROR is defined, the
+  static variable malloc_corruption_error_count is compiled in
+  and can be examined to see if errors have occurred. This option
+  generates slower code than the default abort policy.
+
+DEBUG                    default: NOT defined
+  The DEBUG setting is mainly intended for people trying to modify
+  this code or diagnose problems when porting to new platforms.
+  However, it may also be able to better isolate user errors than just
+  using runtime checks.  The assertions in the check routines spell
+  out in more detail the assumptions and invariants underlying the
+  algorithms.  The checking is fairly extensive, and will slow down
+  execution noticeably. Calling malloc_stats or mallinfo with DEBUG
+  set will attempt to check every non-mmapped allocated and free chunk
+  in the course of computing the summaries.
+
+ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
+  Debugging assertion failures can be nearly impossible if your
+  version of the assert macro causes malloc to be called, which will
+  lead to a cascade of further failures, blowing the runtime stack.
+  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
+  which will usually make debugging easier.
+
+MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
+  The action to take before "return 0" when malloc fails to be able to
+  return memory because there is none available.
+
+HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
+  True if this system supports sbrk or an emulation of it.
+
+MORECORE                  default: sbrk
+  The name of the sbrk-style system routine to call to obtain more
+  memory.  See below for guidance on writing custom MORECORE
+  functions. The type of the argument to sbrk/MORECORE varies across
+  systems.  It cannot be size_t, because it supports negative
+  arguments, so it is normally the signed type of the same width as
+  size_t (sometimes declared as "intptr_t").  It doesn't much matter
+  though. Internally, we only call it with arguments less than half
+  the max value of a size_t, which should work across all reasonable
+  possibilities, although sometimes generating compiler warnings.  See
+  near the end of this file for guidelines for creating a custom
+  version of MORECORE.
+
+MORECORE_CONTIGUOUS       default: 1 (true)
+  If true, take advantage of fact that consecutive calls to MORECORE
+  with positive arguments always return contiguous increasing
+  addresses.  This is true of unix sbrk. It does not hurt too much to
+  set it true anyway, since malloc copes with non-contiguities.
+  Setting it false when definitely non-contiguous saves time
+  and possibly wasted space it would take to discover this though.
+
+MORECORE_CANNOT_TRIM      default: NOT defined
+  True if MORECORE cannot release space back to the system when given
+  negative arguments. This is generally necessary only if you are
+  using a hand-crafted MORECORE function that cannot handle negative
+  arguments.
+
+HAVE_MMAP                 default: 1 (true)
+  True if this system supports mmap or an emulation of it.  If so, and
+  HAVE_MORECORE is not true, MMAP is used for all system
+  allocation. If set and HAVE_MORECORE is true as well, MMAP is
+  primarily used to directly allocate very large blocks. It is also
+  used as a backup strategy in cases where MORECORE fails to provide
+  space from system. Note: A single call to MUNMAP is assumed to be
+  able to unmap memory that may have be allocated using multiple calls
+  to MMAP, so long as they are adjacent.
+
+HAVE_MREMAP               default: 1 on linux, else 0
+  If true realloc() uses mremap() to re-allocate large blocks and
+  extend or shrink allocation spaces.
+
+MMAP_CLEARS               default: 1 on unix
+  True if mmap clears memory so calloc doesn't need to. This is true
+  for standard unix mmap using /dev/zero.
+
+USE_BUILTIN_FFS            default: 0 (i.e., not used)
+  Causes malloc to use the builtin ffs() function to compute indices.
+  Some compilers may recognize and intrinsify ffs to be faster than the
+  supplied C version. Also, the case of x86 using gcc is special-cased
+  to an asm instruction, so is already as fast as it can be, and so
+  this setting has no effect. (On most x86s, the asm version is only
+  slightly faster than the C version.)
+
+malloc_getpagesize         default: derive from system includes, or 4096.
+  The system page size. To the extent possible, this malloc manages
+  memory from the system in page-size units.  This may be (and
+  usually is) a function rather than a constant. This is ignored
+  if WIN32, where page size is determined using getSystemInfo during
+  initialization.
+
+USE_DEV_RANDOM             default: 0 (i.e., not used)
+  Causes malloc to use /dev/random to initialize secure magic seed for
+  stamping footers. Otherwise, the current time is used.
+
+NO_MALLINFO                default: 0
+  If defined, don't compile "mallinfo". This can be a simple way
+  of dealing with mismatches between system declarations and
+  those in this file.
+
+MALLINFO_FIELD_TYPE        default: size_t
+  The type of the fields in the mallinfo struct. This was originally
+  defined as "int" in SVID etc, but is more usefully defined as
+  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set
+
+REALLOC_ZERO_BYTES_FREES    default: not defined
+  This should be set if a call to realloc with zero bytes should 
+  be the same as a call to free. Some people think it should. Otherwise, 
+  since this malloc returns a unique pointer for malloc(0), so does 
+  realloc(p, 0).
+
+LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
+LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
+LACKS_STDLIB_H                default: NOT defined unless on WIN32
+  Define these if your system does not have these header files.
+  You might need to manually insert some of the declarations they provide.
+
+DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
+                                system_info.dwAllocationGranularity in WIN32,
+                                otherwise 64K.
+      Also settable using mallopt(M_GRANULARITY, x)
+  The unit for allocating and deallocating memory from the system.  On
+  most systems with contiguous MORECORE, there is no reason to
+  make this more than a page. However, systems with MMAP tend to
+  either require or encourage larger granularities.  You can increase
+  this value to prevent system allocation functions to be called so
+  often, especially if they are slow.  The value must be at least one
+  page and must be a power of two.  Setting to 0 causes initialization
+  to either page size or win32 region size.  (Note: In previous
+  versions of malloc, the equivalent of this option was called
+  "TOP_PAD")
+
+DEFAULT_TRIM_THRESHOLD    default: 2MB
+      Also settable using mallopt(M_TRIM_THRESHOLD, x)
+  The maximum amount of unused top-most memory to keep before
+  releasing via malloc_trim in free().  Automatic trimming is mainly
+  useful in long-lived programs using contiguous MORECORE.  Because
+  trimming via sbrk can be slow on some systems, and can sometimes be
+  wasteful (in cases where programs immediately afterward allocate
+  more large chunks) the value should be high enough so that your
+  overall system performance would improve by releasing this much
+  memory.  As a rough guide, you might set to a value close to the
+  average size of a process (program) running on your system.
+  Releasing this much memory would allow such a process to run in
+  memory.  Generally, it is worth tuning trim thresholds when a
+  program undergoes phases where several large chunks are allocated
+  and released in ways that can reuse each other's storage, perhaps
+  mixed with phases where there are no such chunks at all. The trim
+  value must be greater than page size to have any useful effect.  To
+  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
+  some people use of mallocing a huge space and then freeing it at
+  program startup, in an attempt to reserve system memory, doesn't
+  have the intended effect under automatic trimming, since that memory
+  will immediately be returned to the system.
+
+DEFAULT_MMAP_THRESHOLD       default: 256K
+      Also settable using mallopt(M_MMAP_THRESHOLD, x)
+  The request size threshold for using MMAP to directly service a
+  request. Requests of at least this size that cannot be allocated
+  using already-existing space will be serviced via mmap.  (If enough
+  normal freed space already exists it is used instead.)  Using mmap
+  segregates relatively large chunks of memory so that they can be
+  individually obtained and released from the host system. A request
+  serviced through mmap is never reused by any other request (at least
+  not directly; the system may just so happen to remap successive
+  requests to the same locations).  Segregating space in this way has
+  the benefits that: Mmapped space can always be individually released
+  back to the system, which helps keep the system level memory demands
+  of a long-lived program low.  Also, mapped memory doesn't become
+  `locked' between other chunks, as can happen with normally allocated
+  chunks, which means that even trimming via malloc_trim would not
+  release them.  However, it has the disadvantage that the space
+  cannot be reclaimed, consolidated, and then used to service later
+  requests, as happens with normal chunks.  The advantages of mmap
+  nearly always outweigh disadvantages for "large" chunks, but the
+  value of "large" may vary across systems.  The default is an
+  empirically derived value that works well in most systems. You can
+  disable mmap by setting to MAX_SIZE_T.
+
+*/
+
+#if defined __linux__ && !defined _GNU_SOURCE
+/* mremap() on Linux requires this via sys/mman.h */
+#define _GNU_SOURCE 1
+#endif
+
+#ifndef WIN32
+#ifdef _WIN32
+#define WIN32 1
+#endif  /* _WIN32 */
+#endif  /* WIN32 */
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#define HAVE_MMAP 1
+#define HAVE_MORECORE 0
+#define LACKS_UNISTD_H
+#define LACKS_SYS_PARAM_H
+#define LACKS_SYS_MMAN_H
+#define LACKS_STRING_H
+#define LACKS_STRINGS_H
+#define LACKS_SYS_TYPES_H
+#define LACKS_ERRNO_H
+#define MALLOC_FAILURE_ACTION
+#define MMAP_CLEARS 0 /* WINCE and some others apparently don't clear */
+#endif  /* WIN32 */
+
+#ifdef __OS2__
+#define INCL_DOS
+#include <os2.h>
+#define HAVE_MMAP 1
+#define HAVE_MORECORE 0
+#define LACKS_SYS_MMAN_H
+#endif  /* __OS2__ */
+
+#if defined(DARWIN) || defined(_DARWIN)
+/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
+#ifndef HAVE_MORECORE
+#define HAVE_MORECORE 0
+#define HAVE_MMAP 1
+#endif  /* HAVE_MORECORE */
+#endif  /* DARWIN */
+
+#ifndef LACKS_SYS_TYPES_H
+#include <sys/types.h>  /* For size_t */
+#endif  /* LACKS_SYS_TYPES_H */
+
+/* The maximum possible size_t value has all bits set */
+#define MAX_SIZE_T           (~(size_t)0)
+
+#ifndef ONLY_MSPACES
+#define ONLY_MSPACES 0
+#endif  /* ONLY_MSPACES */
+#ifndef MSPACES
+#if ONLY_MSPACES
+#define MSPACES 1
+#else   /* ONLY_MSPACES */
+#define MSPACES 0
+#endif  /* ONLY_MSPACES */
+#endif  /* MSPACES */
+#ifndef MALLOC_ALIGNMENT
+#define MALLOC_ALIGNMENT ((size_t)8U)
+#endif  /* MALLOC_ALIGNMENT */
+#ifndef FOOTERS
+#define FOOTERS 0
+#endif  /* FOOTERS */
+#ifndef ABORT
+#define ABORT  abort()
+#endif  /* ABORT */
+#ifndef ABORT_ON_ASSERT_FAILURE
+#define ABORT_ON_ASSERT_FAILURE 1
+#endif  /* ABORT_ON_ASSERT_FAILURE */
+#ifndef PROCEED_ON_ERROR
+#define PROCEED_ON_ERROR 0
+#endif  /* PROCEED_ON_ERROR */
+#ifndef USE_LOCKS
+#define USE_LOCKS 0
+#endif  /* USE_LOCKS */
+#ifndef INSECURE
+#define INSECURE 0
+#endif  /* INSECURE */
+#ifndef HAVE_MMAP
+#define HAVE_MMAP 1
+#endif  /* HAVE_MMAP */
+#ifndef MMAP_CLEARS
+#define MMAP_CLEARS 1
+#endif  /* MMAP_CLEARS */
+#ifndef HAVE_MREMAP
+#ifdef linux
+#define HAVE_MREMAP 1
+#else   /* linux */
+#define HAVE_MREMAP 0
+#endif  /* linux */
+#endif  /* HAVE_MREMAP */
+#ifndef MALLOC_FAILURE_ACTION
+#define MALLOC_FAILURE_ACTION  errno = ENOMEM;
+#endif  /* MALLOC_FAILURE_ACTION */
+#ifndef HAVE_MORECORE
+#if ONLY_MSPACES
+#define HAVE_MORECORE 0
+#else   /* ONLY_MSPACES */
+#define HAVE_MORECORE 1
+#endif  /* ONLY_MSPACES */
+#endif  /* HAVE_MORECORE */
+#if !HAVE_MORECORE
+#define MORECORE_CONTIGUOUS 0
+#else   /* !HAVE_MORECORE */
+#ifndef MORECORE
+#define MORECORE sbrk
+#endif  /* MORECORE */
+#ifndef MORECORE_CONTIGUOUS
+#define MORECORE_CONTIGUOUS 1
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* HAVE_MORECORE */
+#ifndef DEFAULT_GRANULARITY
+#if MORECORE_CONTIGUOUS
+#define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
+#else   /* MORECORE_CONTIGUOUS */
+#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* DEFAULT_GRANULARITY */
+#ifndef DEFAULT_TRIM_THRESHOLD
+#ifndef MORECORE_CANNOT_TRIM
+#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
+#else   /* MORECORE_CANNOT_TRIM */
+#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
+#endif  /* MORECORE_CANNOT_TRIM */
+#endif  /* DEFAULT_TRIM_THRESHOLD */
+#ifndef DEFAULT_MMAP_THRESHOLD
+#if HAVE_MMAP
+#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
+#else   /* HAVE_MMAP */
+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
+#endif  /* HAVE_MMAP */
+#endif  /* DEFAULT_MMAP_THRESHOLD */
+#ifndef USE_BUILTIN_FFS
+#define USE_BUILTIN_FFS 0
+#endif  /* USE_BUILTIN_FFS */
+#ifndef USE_DEV_RANDOM
+#define USE_DEV_RANDOM 0
+#endif  /* USE_DEV_RANDOM */
+#ifndef NO_MALLINFO
+#define NO_MALLINFO 0
+#endif  /* NO_MALLINFO */
+#ifndef MALLINFO_FIELD_TYPE
+#define MALLINFO_FIELD_TYPE size_t
+#endif  /* MALLINFO_FIELD_TYPE */
+
+/*
+  mallopt tuning options.  SVID/XPG defines four standard parameter
+  numbers for mallopt, normally defined in malloc.h.  None of these
+  are used in this malloc, so setting them has no effect. But this
+  malloc does support the following options.
+*/
+
+/* The system's malloc.h may have conflicting defines. */
+#undef M_TRIM_THRESHOLD
+#undef M_GRANULARITY
+#undef M_MMAP_THRESHOLD
+
+#define M_TRIM_THRESHOLD     (-1)
+#define M_GRANULARITY        (-2)
+#define M_MMAP_THRESHOLD     (-3)
+
+/* ------------------------ Mallinfo declarations ------------------------ */
+
+#if !NO_MALLINFO
+/*
+  This version of malloc supports the standard SVID/XPG mallinfo
+  routine that returns a struct containing usage properties and
+  statistics. It should work on any system that has a
+  /usr/include/malloc.h defining struct mallinfo.  The main
+  declaration needed is the mallinfo struct that is returned (by-copy)
+  by mallinfo().  The malloinfo struct contains a bunch of fields that
+  are not even meaningful in this version of malloc.  These fields are
+  are instead filled by mallinfo() with other numbers that might be of
+  interest.
+
+  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
+  /usr/include/malloc.h file that includes a declaration of struct
+  mallinfo.  If so, it is included; else a compliant version is
+  declared below.  These must be precisely the same for mallinfo() to
+  work.  The original SVID version of this struct, defined on most
+  systems with mallinfo, declares all fields as ints. But some others
+  define as unsigned long. If your system defines the fields using a
+  type of different width than listed here, you MUST #include your
+  system version and #define HAVE_USR_INCLUDE_MALLOC_H.
+*/
+
+/* #define HAVE_USR_INCLUDE_MALLOC_H */
+
+#ifdef HAVE_USR_INCLUDE_MALLOC_H
+#include "/usr/include/malloc.h"
+#else /* HAVE_USR_INCLUDE_MALLOC_H */
+
+/* HP-UX's stdlib.h redefines mallinfo unless _STRUCT_MALLINFO is defined */
+#define _STRUCT_MALLINFO
+
+struct mallinfo {
+  MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
+  MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
+  MALLINFO_FIELD_TYPE smblks;   /* always 0 */
+  MALLINFO_FIELD_TYPE hblks;    /* always 0 */
+  MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
+  MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
+  MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
+  MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
+  MALLINFO_FIELD_TYPE fordblks; /* total free space */
+  MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
+};
+
+#endif /* HAVE_USR_INCLUDE_MALLOC_H */
+#endif /* NO_MALLINFO */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#if !ONLY_MSPACES
+
+/* ------------------- Declarations of public routines ------------------- */
+
+#ifndef USE_DL_PREFIX
+#define dlcalloc               calloc
+#define dlfree                 free
+#define dlmalloc               malloc
+#define dlmemalign             memalign
+#define dlrealloc              realloc
+#define dlvalloc               valloc
+#define dlpvalloc              pvalloc
+#define dlmallinfo             mallinfo
+#define dlmallopt              mallopt
+#define dlmalloc_trim          malloc_trim
+#define dlmalloc_stats         malloc_stats
+#define dlmalloc_usable_size   malloc_usable_size
+#define dlmalloc_footprint     malloc_footprint
+#define dlmalloc_max_footprint malloc_max_footprint
+#define dlindependent_calloc   independent_calloc
+#define dlindependent_comalloc independent_comalloc
+#endif /* USE_DL_PREFIX */
+
+
+/*
+  malloc(size_t n)
+  Returns a pointer to a newly allocated chunk of at least n bytes, or
+  null if no space is available, in which case errno is set to ENOMEM
+  on ANSI C systems.
+
+  If n is zero, malloc returns a minimum-sized chunk. (The minimum
+  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
+  systems.)  Note that size_t is an unsigned type, so calls with
+  arguments that would be negative if signed are interpreted as
+  requests for huge amounts of space, which will often fail. The
+  maximum supported value of n differs across systems, but is in all
+  cases less than the maximum representable value of a size_t.
+*/
+void* dlmalloc(size_t);
+
+/*
+  free(void* p)
+  Releases the chunk of memory pointed to by p, that had been previously
+  allocated using malloc or a related routine such as realloc.
+  It has no effect if p is null. If p was not malloced or already
+  freed, free(p) will by default cause the current program to abort.
+*/
+void  dlfree(void*);
+
+/*
+  calloc(size_t n_elements, size_t element_size);
+  Returns a pointer to n_elements * element_size bytes, with all locations
+  set to zero.
+*/
+void* dlcalloc(size_t, size_t);
+
+/*
+  realloc(void* p, size_t n)
+  Returns a pointer to a chunk of size n that contains the same data
+  as does chunk p up to the minimum of (n, p's size) bytes, or null
+  if no space is available.
+
+  The returned pointer may or may not be the same as p. The algorithm
+  prefers extending p in most cases when possible, otherwise it
+  employs the equivalent of a malloc-copy-free sequence.
+
+  If p is null, realloc is equivalent to malloc.
+
+  If space is not available, realloc returns null, errno is set (if on
+  ANSI) and p is NOT freed.
+
+  if n is for fewer bytes than already held by p, the newly unused
+  space is lopped off and freed if possible.  realloc with a size
+  argument of zero (re)allocates a minimum-sized chunk.
+
+  The old unix realloc convention of allowing the last-free'd chunk
+  to be used as an argument to realloc is not supported.
+*/
+
+void* dlrealloc(void*, size_t);
+
+/*
+  memalign(size_t alignment, size_t n);
+  Returns a pointer to a newly allocated chunk of n bytes, aligned
+  in accord with the alignment argument.
+
+  The alignment argument should be a power of two. If the argument is
+  not a power of two, the nearest greater power is used.
+  8-byte alignment is guaranteed by normal malloc calls, so don't
+  bother calling memalign with an argument of 8 or less.
+
+  Overreliance on memalign is a sure way to fragment space.
+*/
+void* dlmemalign(size_t, size_t);
+
+/*
+  valloc(size_t n);
+  Equivalent to memalign(pagesize, n), where pagesize is the page
+  size of the system. If the pagesize is unknown, 4096 is used.
+*/
+void* dlvalloc(size_t);
+
+/*
+  mallopt(int parameter_number, int parameter_value)
+  Sets tunable parameters The format is to provide a
+  (parameter-number, parameter-value) pair.  mallopt then sets the
+  corresponding parameter to the argument value if it can (i.e., so
+  long as the value is meaningful), and returns 1 if successful else
+  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,
+  normally defined in malloc.h.  None of these are use in this malloc,
+  so setting them has no effect. But this malloc also supports other
+  options in mallopt. See below for details.  Briefly, supported
+  parameters are as follows (listed defaults are for "typical"
+  configurations).
+
+  Symbol            param #  default    allowed param values
+  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)
+  M_GRANULARITY        -2     page size   any power of 2 >= page size
+  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
+*/
+int dlmallopt(int, int);
+
+/*
+  malloc_footprint();
+  Returns the number of bytes obtained from the system.  The total
+  number of bytes allocated by malloc, realloc etc., is less than this
+  value. Unlike mallinfo, this function returns only a precomputed
+  result, so can be called frequently to monitor memory consumption.
+  Even if locks are otherwise defined, this function does not use them,
+  so results might not be up to date.
+*/
+size_t dlmalloc_footprint(void);
+
+/*
+  malloc_max_footprint();
+  Returns the maximum number of bytes obtained from the system. This
+  value will be greater than current footprint if deallocated space
+  has been reclaimed by the system. The peak number of bytes allocated
+  by malloc, realloc etc., is less than this value. Unlike mallinfo,
+  this function returns only a precomputed result, so can be called
+  frequently to monitor memory consumption.  Even if locks are
+  otherwise defined, this function does not use them, so results might
+  not be up to date.
+*/
+size_t dlmalloc_max_footprint(void);
+
+#if !NO_MALLINFO
+/*
+  mallinfo()
+  Returns (by copy) a struct containing various summary statistics:
+
+  arena:     current total non-mmapped bytes allocated from system
+  ordblks:   the number of free chunks
+  smblks:    always zero.
+  hblks:     current number of mmapped regions
+  hblkhd:    total bytes held in mmapped regions
+  usmblks:   the maximum total allocated space. This will be greater
+                than current total if trimming has occurred.
+  fsmblks:   always zero
+  uordblks:  current total allocated space (normal or mmapped)
+  fordblks:  total free space
+  keepcost:  the maximum number of bytes that could ideally be released
+               back to system via malloc_trim. ("ideally" means that
+               it ignores page restrictions etc.)
+
+  Because these fields are ints, but internal bookkeeping may
+  be kept as longs, the reported values may wrap around zero and
+  thus be inaccurate.
+*/
+struct mallinfo dlmallinfo(void);
+#endif /* NO_MALLINFO */
+
+/*
+  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);
+
+  independent_calloc is similar to calloc, but instead of returning a
+  single cleared space, it returns an array of pointers to n_elements
+  independent elements that can hold contents of size elem_size, each
+  of which starts out cleared, and can be independently freed,
+  realloc'ed etc. The elements are guaranteed to be adjacently
+  allocated (this is not guaranteed to occur with multiple callocs or
+  mallocs), which may also improve cache locality in some
+  applications.
+
+  The "chunks" argument is optional (i.e., may be null, which is
+  probably the most typical usage). If it is null, the returned array
+  is itself dynamically allocated and should also be freed when it is
+  no longer needed. Otherwise, the chunks array must be of at least
+  n_elements in length. It is filled in with the pointers to the
+  chunks.
+
+  In either case, independent_calloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and "chunks"
+  is null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be individually freed when it is no longer
+  needed. If you'd like to instead be able to free all at once, you
+  should instead use regular calloc and assign pointers into this
+  space to represent elements.  (In this case though, you cannot
+  independently free elements.)
+
+  independent_calloc simplifies and speeds up implementations of many
+  kinds of pools.  It may also be useful when constructing large data
+  structures that initially have a fixed number of fixed-sized nodes,
+  but the number is not known at compile time, and some of the nodes
+  may later need to be freed. For example:
+
+  struct Node { int item; struct Node* next; };
+
+  struct Node* build_list() {
+    struct Node** pool;
+    int n = read_number_of_nodes_needed();
+    if (n <= 0) return 0;
+    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
+    if (pool == 0) die();
+    // organize into a linked list...
+    struct Node* first = pool[0];
+    for (i = 0; i < n-1; ++i)
+      pool[i]->next = pool[i+1];
+    free(pool);     // Can now free the array (or not, if it is needed later)
+    return first;
+  }
+*/
+void** dlindependent_calloc(size_t, size_t, void**);
+
+/*
+  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);
+
+  independent_comalloc allocates, all at once, a set of n_elements
+  chunks with sizes indicated in the "sizes" array.    It returns
+  an array of pointers to these elements, each of which can be
+  independently freed, realloc'ed etc. The elements are guaranteed to
+  be adjacently allocated (this is not guaranteed to occur with
+  multiple callocs or mallocs), which may also improve cache locality
+  in some applications.
+
+  The "chunks" argument is optional (i.e., may be null). If it is null
+  the returned array is itself dynamically allocated and should also
+  be freed when it is no longer needed. Otherwise, the chunks array
+  must be of at least n_elements in length. It is filled in with the
+  pointers to the chunks.
+
+  In either case, independent_comalloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and chunks is
+  null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be individually freed when it is no longer
+  needed. If you'd like to instead be able to free all at once, you
+  should instead use a single regular malloc, and assign pointers at
+  particular offsets in the aggregate space. (In this case though, you
+  cannot independently free elements.)
+
+  independent_comallac differs from independent_calloc in that each
+  element may have a different size, and also that it does not
+  automatically clear elements.
+
+  independent_comalloc can be used to speed up allocation in cases
+  where several structs or objects must always be allocated at the
+  same time.  For example:
+
+  struct Head { ... }
+  struct Foot { ... }
+
+  void send_message(char* msg) {
+    int msglen = strlen(msg);
+    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
+    void* chunks[3];
+    if (independent_comalloc(3, sizes, chunks) == 0)
+      die();
+    struct Head* head = (struct Head*)(chunks[0]);
+    char*        body = (char*)(chunks[1]);
+    struct Foot* foot = (struct Foot*)(chunks[2]);
+    // ...
+  }
+
+  In general though, independent_comalloc is worth using only for
+  larger values of n_elements. For small values, you probably won't
+  detect enough difference from series of malloc calls to bother.
+
+  Overuse of independent_comalloc can increase overall memory usage,
+  since it cannot reuse existing noncontiguous small chunks that
+  might be available for some of the elements.
+*/
+void** dlindependent_comalloc(size_t, size_t*, void**);
+
+
+/*
+  pvalloc(size_t n);
+  Equivalent to valloc(minimum-page-that-holds(n)), that is,
+  round up n to nearest pagesize.
+ */
+void*  dlpvalloc(size_t);
+
+/*
+  malloc_trim(size_t pad);
+
+  If possible, gives memory back to the system (via negative arguments
+  to sbrk) if there is unused memory at the `high' end of the malloc
+  pool or in unused MMAP segments. You can call this after freeing
+  large blocks of memory to potentially reduce the system-level memory
+  requirements of a program. However, it cannot guarantee to reduce
+  memory. Under some allocation patterns, some large free blocks of
+  memory will be locked between two used chunks, so they cannot be
+  given back to the system.
+
+  The `pad' argument to malloc_trim represents the amount of free
+  trailing space to leave untrimmed. If this argument is zero, only
+  the minimum amount of memory to maintain internal data structures
+  will be left. Non-zero arguments can be supplied to maintain enough
+  trailing space to service future expected allocations without having
+  to re-obtain memory from the system.
+
+  Malloc_trim returns 1 if it actually released any memory, else 0.
+*/
+int  dlmalloc_trim(size_t);
+
+/*
+  malloc_usable_size(void* p);
+
+  Returns the number of bytes you can actually use in
+  an allocated chunk, which may be more than you requested (although
+  often not) due to alignment and minimum size constraints.
+  You can use this many bytes without worrying about
+  overwriting other allocated objects. This is not a particularly great
+  programming practice. malloc_usable_size can be more useful in
+  debugging and assertions, for example:
+
+  p = malloc(n);
+  assert(malloc_usable_size(p) >= 256);
+*/
+size_t dlmalloc_usable_size(void*);
+
+/*
+  malloc_stats();
+  Prints on stderr the amount of space obtained from the system (both
+  via sbrk and mmap), the maximum amount (which may be more than
+  current if malloc_trim and/or munmap got called), and the current
+  number of bytes allocated via malloc (or realloc, etc) but not yet
+  freed. Note that this is the number of bytes allocated, not the
+  number requested. It will be larger than the number requested
+  because of alignment and bookkeeping overhead. Because it includes
+  alignment wastage as being in use, this figure may be greater than
+  zero even when no user-level chunks are allocated.
+
+  The reported current and maximum system memory can be inaccurate if
+  a program makes other calls to system memory allocation functions
+  (normally sbrk) outside of malloc.
+
+  malloc_stats prints only the most commonly interesting statistics.
+  More information can be obtained by calling mallinfo.
+*/
+void  dlmalloc_stats(void);
+
+#endif /* ONLY_MSPACES */
+
+#if MSPACES
+
+/*
+  mspace is an opaque type representing an independent
+  region of space that supports mspace_malloc, etc.
+*/
+typedef void* mspace;
+
+/*
+  create_mspace creates and returns a new independent space with the
+  given initial capacity, or, if 0, the default granularity size.  It
+  returns null if there is no system memory available to create the
+  space.  If argument locked is non-zero, the space uses a separate
+  lock to control access. The capacity of the space will grow
+  dynamically as needed to service mspace_malloc requests.  You can
+  control the sizes of incremental increases of this space by
+  compiling with a different DEFAULT_GRANULARITY or dynamically
+  setting with mallopt(M_GRANULARITY, value).
+*/
+mspace create_mspace(size_t capacity, int locked);
+
+/*
+  destroy_mspace destroys the given space, and attempts to return all
+  of its memory back to the system, returning the total number of
+  bytes freed. After destruction, the results of access to all memory
+  used by the space become undefined.
+*/
+size_t destroy_mspace(mspace msp);
+
+/*
+  create_mspace_with_base uses the memory supplied as the initial base
+  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
+  space is used for bookkeeping, so the capacity must be at least this
+  large. (Otherwise 0 is returned.) When this initial space is
+  exhausted, additional memory will be obtained from the system.
+  Destroying this space will deallocate all additionally allocated
+  space (if possible) but not the initial base.
+*/
+mspace create_mspace_with_base(void* base, size_t capacity, int locked);
+
+/*
+  mspace_malloc behaves as malloc, but operates within
+  the given space.
+*/
+void* mspace_malloc(mspace msp, size_t bytes);
+
+/*
+  mspace_free behaves as free, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_free is not actually needed.
+  free may be called instead of mspace_free because freed chunks from
+  any space are handled by their originating spaces.
+*/
+void mspace_free(mspace msp, void* mem);
+
+/*
+  mspace_realloc behaves as realloc, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_realloc is not actually
+  needed.  realloc may be called instead of mspace_realloc because
+  realloced chunks from any space are handled by their originating
+  spaces.
+*/
+void* mspace_realloc(mspace msp, void* mem, size_t newsize);
+
+/*
+  mspace_calloc behaves as calloc, but operates within
+  the given space.
+*/
+void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
+
+/*
+  mspace_memalign behaves as memalign, but operates within
+  the given space.
+*/
+void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
+
+/*
+  mspace_independent_calloc behaves as independent_calloc, but
+  operates within the given space.
+*/
+void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]);
+
+/*
+  mspace_independent_comalloc behaves as independent_comalloc, but
+  operates within the given space.
+*/
+void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]);
+
+/*
+  mspace_footprint() returns the number of bytes obtained from the
+  system for this space.
+*/
+size_t mspace_footprint(mspace msp);
+
+/*
+  mspace_max_footprint() returns the peak number of bytes obtained from the
+  system for this space.
+*/
+size_t mspace_max_footprint(mspace msp);
+
+
+#if !NO_MALLINFO
+/*
+  mspace_mallinfo behaves as mallinfo, but reports properties of
+  the given space.
+*/
+struct mallinfo mspace_mallinfo(mspace msp);
+#endif /* NO_MALLINFO */
+
+/*
+  mspace_malloc_stats behaves as malloc_stats, but reports
+  properties of the given space.
+*/
+void mspace_malloc_stats(mspace msp);
+
+/*
+  mspace_trim behaves as malloc_trim, but
+  operates within the given space.
+*/
+int mspace_trim(mspace msp, size_t pad);
+
+/*
+  An alias for mallopt.
+*/
+int mspace_mallopt(int, int);
+
+#endif /* MSPACES */
+
+#ifdef __cplusplus
+};  /* end of extern "C" */
+#endif /* __cplusplus */
+
+/*
+  ========================================================================
+  To make a fully customizable malloc.h header file, cut everything
+  above this line, put into file malloc.h, edit to suit, and #include it
+  on the next line, as well as in programs that use this malloc.
+  ========================================================================
+*/
+
+/* #include "malloc.h" */
+
+/*------------------------------ internal #includes ---------------------- */
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4146 ) /* no "unsigned" warnings */
+#endif /* _MSC_VER */
+
+#include <stdio.h>       /* for printing in malloc_stats */
+
+#ifndef LACKS_ERRNO_H
+#include <errno.h>       /* for MALLOC_FAILURE_ACTION */
+#endif /* LACKS_ERRNO_H */
+#if FOOTERS
+#include <time.h>        /* for magic initialization */
+#endif /* FOOTERS */
+#ifndef LACKS_STDLIB_H
+#include <stdlib.h>      /* for abort() */
+#endif /* LACKS_STDLIB_H */
+#ifdef DEBUG
+#if ABORT_ON_ASSERT_FAILURE
+#define assert(x) if(!(x)) ABORT
+#else /* ABORT_ON_ASSERT_FAILURE */
+#include <assert.h>
+#endif /* ABORT_ON_ASSERT_FAILURE */
+#else  /* DEBUG */
+#define assert(x)
+#endif /* DEBUG */
+#ifndef LACKS_STRING_H
+#include <string.h>      /* for memset etc */
+#endif  /* LACKS_STRING_H */
+#if USE_BUILTIN_FFS
+#ifndef LACKS_STRINGS_H
+#include <strings.h>     /* for ffs */
+#endif /* LACKS_STRINGS_H */
+#endif /* USE_BUILTIN_FFS */
+#if HAVE_MMAP
+#ifndef LACKS_SYS_MMAN_H
+#include <sys/mman.h>    /* for mmap */
+#endif /* LACKS_SYS_MMAN_H */
+#ifndef LACKS_FCNTL_H
+#include <fcntl.h>
+#endif /* LACKS_FCNTL_H */
+#endif /* HAVE_MMAP */
+#if HAVE_MORECORE
+#ifndef LACKS_UNISTD_H
+#include <unistd.h>     /* for sbrk */
+#else /* LACKS_UNISTD_H */
+#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
+extern void*     sbrk(ptrdiff_t);
+#endif /* FreeBSD etc */
+#endif /* LACKS_UNISTD_H */
+#endif /* HAVE_MMAP */
+
+#ifndef WIN32
+#ifndef malloc_getpagesize
+#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
+#    ifndef _SC_PAGE_SIZE
+#      define _SC_PAGE_SIZE _SC_PAGESIZE
+#    endif
+#  endif
+#  ifdef _SC_PAGE_SIZE
+#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
+#  else
+#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
+       extern size_t getpagesize();
+#      define malloc_getpagesize getpagesize()
+#    else
+#      ifdef WIN32 /* use supplied emulation of getpagesize */
+#        define malloc_getpagesize getpagesize()
+#      else
+#        ifndef LACKS_SYS_PARAM_H
+#          include <sys/param.h>
+#        endif
+#        ifdef EXEC_PAGESIZE
+#          define malloc_getpagesize EXEC_PAGESIZE
+#        else
+#          ifdef NBPG
+#            ifndef CLSIZE
+#              define malloc_getpagesize NBPG
+#            else
+#              define malloc_getpagesize (NBPG * CLSIZE)
+#            endif
+#          else
+#            ifdef NBPC
+#              define malloc_getpagesize NBPC
+#            else
+#              ifdef PAGESIZE
+#                define malloc_getpagesize PAGESIZE
+#              else /* just guess */
+#                define malloc_getpagesize ((size_t)4096U)
+#              endif
+#            endif
+#          endif
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+#endif
+
+/* ------------------- size_t and alignment properties -------------------- */
+
+/* The byte and bit size of a size_t */
+#define SIZE_T_SIZE         (sizeof(size_t))
+#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)
+
+/* Some constants coerced to size_t */
+/* Annoying but necessary to avoid errors on some platforms */
+#define SIZE_T_ZERO         ((size_t)0)
+#define SIZE_T_ONE          ((size_t)1)
+#define SIZE_T_TWO          ((size_t)2)
+#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
+#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
+#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
+#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
+
+/* The bit mask value corresponding to MALLOC_ALIGNMENT */
+#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
+
+/* True if address a has acceptable alignment */
+#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)
+
+/* the number of bytes to offset an address to align it */
+#define align_offset(A)\
+ ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\
+  ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
+
+/* -------------------------- MMAP preliminaries ------------------------- */
+
+/*
+   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
+   checks to fail so compiler optimizer can delete code rather than
+   using so many "#if"s.
+*/
+
+
+/* MORECORE and MMAP must return MFAIL on failure */
+#define MFAIL                ((void*)(MAX_SIZE_T))
+#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
+
+#if !HAVE_MMAP
+#define IS_MMAPPED_BIT       (SIZE_T_ZERO)
+#define USE_MMAP_BIT         (SIZE_T_ZERO)
+#define CALL_MMAP(s)         MFAIL
+#define CALL_MUNMAP(a, s)    (-1)
+#define DIRECT_MMAP(s)       MFAIL
+
+#else /* HAVE_MMAP */
+#define IS_MMAPPED_BIT       (SIZE_T_ONE)
+#define USE_MMAP_BIT         (SIZE_T_ONE)
+
+#if !defined(WIN32) && !defined (__OS2__)
+#define CALL_MUNMAP(a, s)    munmap((a), (s))
+#define MMAP_PROT            (PROT_READ|PROT_WRITE)
+#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
+#define MAP_ANONYMOUS        MAP_ANON
+#endif /* MAP_ANON */
+#ifdef MAP_ANONYMOUS
+#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
+#define CALL_MMAP(s)         mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
+#else /* MAP_ANONYMOUS */
+/*
+   Nearly all versions of mmap support MAP_ANONYMOUS, so the following
+   is unlikely to be needed, but is supplied just in case.
+*/
+#define MMAP_FLAGS           (MAP_PRIVATE)
+static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
+#define CALL_MMAP(s) ((dev_zero_fd < 0) ? \
+           (dev_zero_fd = open("/dev/zero", O_RDWR), \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
+#endif /* MAP_ANONYMOUS */
+
+#define DIRECT_MMAP(s)       CALL_MMAP(s)
+
+#elif defined(__OS2__)
+
+/* OS/2 MMAP via DosAllocMem */
+static void* os2mmap(size_t size) {
+  void* ptr;
+  if (DosAllocMem(&ptr, size, OBJ_ANY|PAG_COMMIT|PAG_READ|PAG_WRITE) &&
+      DosAllocMem(&ptr, size, PAG_COMMIT|PAG_READ|PAG_WRITE))
+    return MFAIL;
+  return ptr;
+}
+
+#define os2direct_mmap(n)     os2mmap(n)
+
+/* This function supports releasing coalesed segments */
+static int os2munmap(void* ptr, size_t size) {
+  while (size) {
+    ULONG ulSize = size;
+    ULONG ulFlags = 0;
+    if (DosQueryMem(ptr, &ulSize, &ulFlags) != 0)
+      return -1;
+    if ((ulFlags & PAG_BASE) == 0 ||(ulFlags & PAG_COMMIT) == 0 ||
+        ulSize > size)
+      return -1;
+    if (DosFreeMem(ptr) != 0)
+      return -1;
+    ptr = ( void * ) ( ( char * ) ptr + ulSize );
+    size -= ulSize;
+  }
+  return 0;
+}
+
+#define CALL_MMAP(s)         os2mmap(s)
+#define CALL_MUNMAP(a, s)    os2munmap((a), (s))
+#define DIRECT_MMAP(s)       os2direct_mmap(s)
+
+#else /* WIN32 */
+
+/* Win32 MMAP via VirtualAlloc */
+static void* win32mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
+static void* win32direct_mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
+                           PAGE_EXECUTE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* This function supports releasing coalesed segments */
+static int win32munmap(void* ptr, size_t size) {
+  MEMORY_BASIC_INFORMATION minfo;
+  char* cptr = ptr;
+  while (size) {
+    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)
+      return -1;
+    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
+        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
+      return -1;
+    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
+      return -1;
+    cptr += minfo.RegionSize;
+    size -= minfo.RegionSize;
+  }
+  return 0;
+}
+
+#define CALL_MMAP(s)         win32mmap(s)
+#define CALL_MUNMAP(a, s)    win32munmap((a), (s))
+#define DIRECT_MMAP(s)       win32direct_mmap(s)
+#endif /* WIN32 */
+#endif /* HAVE_MMAP */
+
+#if HAVE_MMAP && HAVE_MREMAP
+#define CALL_MREMAP(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
+#else  /* HAVE_MMAP && HAVE_MREMAP */
+#define CALL_MREMAP(addr, osz, nsz, mv) MFAIL
+#endif /* HAVE_MMAP && HAVE_MREMAP */
+
+#if HAVE_MORECORE
+#define CALL_MORECORE(S)     MORECORE(S)
+#else  /* HAVE_MORECORE */
+#define CALL_MORECORE(S)     MFAIL
+#endif /* HAVE_MORECORE */
+
+/* mstate bit set if contiguous morecore disabled or failed */
+#define USE_NONCONTIGUOUS_BIT (4U)
+
+/* segment bit set in create_mspace_with_base */
+#define EXTERN_BIT            (8U)
+
+
+/* --------------------------- Lock preliminaries ------------------------ */
+
+#if USE_LOCKS
+
+/*
+  When locks are defined, there are up to two global locks:
+
+  * If HAVE_MORECORE, morecore_mutex protects sequences of calls to
+    MORECORE.  In many cases sys_alloc requires two calls, that should
+    not be interleaved with calls by other threads.  This does not
+    protect against direct calls to MORECORE by other threads not
+    using this lock, so there is still code to cope the best we can on
+    interference.
+
+  * magic_init_mutex ensures that mparams.magic and other
+    unique mparams values are initialized only once.
+*/
+
+#if !defined(WIN32) && !defined(__OS2__)
+/* By default use posix locks */
+#include <pthread.h>
+#define MLOCK_T pthread_mutex_t
+#define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
+#define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)
+#define RELEASE_LOCK(l)      pthread_mutex_unlock(l)
+
+#if HAVE_MORECORE
+static MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif /* HAVE_MORECORE */
+
+static MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+#elif defined(__OS2__)
+#define MLOCK_T HMTX
+#define INITIAL_LOCK(l)      DosCreateMutexSem(0, l, 0, FALSE)
+#define ACQUIRE_LOCK(l)      DosRequestMutexSem(*l, SEM_INDEFINITE_WAIT)
+#define RELEASE_LOCK(l)      DosReleaseMutexSem(*l)
+#if HAVE_MORECORE
+static MLOCK_T morecore_mutex;
+#endif /* HAVE_MORECORE */
+static MLOCK_T magic_init_mutex;
+
+#else /* WIN32 */
+/*
+   Because lock-protected regions have bounded times, and there
+   are no recursive lock calls, we can use simple spinlocks.
+*/
+
+#define MLOCK_T long
+static int win32_acquire_lock (MLOCK_T *sl) {
+  for (;;) {
+#ifdef InterlockedCompareExchangePointer
+    if (!InterlockedCompareExchange(sl, 1, 0))
+      return 0;
+#else  /* Use older void* version */
+    if (!InterlockedCompareExchange((void**)sl, (void*)1, (void*)0))
+      return 0;
+#endif /* InterlockedCompareExchangePointer */
+    Sleep (0);
+  }
+}
+
+static void win32_release_lock (MLOCK_T *sl) {
+  InterlockedExchange (sl, 0);
+}
+
+#define INITIAL_LOCK(l)      *(l)=0
+#define ACQUIRE_LOCK(l)      win32_acquire_lock(l)
+#define RELEASE_LOCK(l)      win32_release_lock(l)
+#if HAVE_MORECORE
+static MLOCK_T morecore_mutex;
+#endif /* HAVE_MORECORE */
+static MLOCK_T magic_init_mutex;
+#endif /* WIN32 */
+
+#define USE_LOCK_BIT               (2U)
+#else  /* USE_LOCKS */
+#define USE_LOCK_BIT               (0U)
+#define INITIAL_LOCK(l)
+#endif /* USE_LOCKS */
+
+#if USE_LOCKS && HAVE_MORECORE
+#define ACQUIRE_MORECORE_LOCK()    ACQUIRE_LOCK(&morecore_mutex);
+#define RELEASE_MORECORE_LOCK()    RELEASE_LOCK(&morecore_mutex);
+#else /* USE_LOCKS && HAVE_MORECORE */
+#define ACQUIRE_MORECORE_LOCK()
+#define RELEASE_MORECORE_LOCK()
+#endif /* USE_LOCKS && HAVE_MORECORE */
+
+#if USE_LOCKS
+#define ACQUIRE_MAGIC_INIT_LOCK()  ACQUIRE_LOCK(&magic_init_mutex);
+#define RELEASE_MAGIC_INIT_LOCK()  RELEASE_LOCK(&magic_init_mutex);
+#else  /* USE_LOCKS */
+#define ACQUIRE_MAGIC_INIT_LOCK()
+#define RELEASE_MAGIC_INIT_LOCK()
+#endif /* USE_LOCKS */
+
+
+/* -----------------------  Chunk representations ------------------------ */
+
+/*
+  (The following includes lightly edited explanations by Colin Plumb.)
+
+  The malloc_chunk declaration below is misleading (but accurate and
+  necessary).  It declares a "view" into memory allowing access to
+  necessary fields at known offsets from a given base.
+
+  Chunks of memory are maintained using a `boundary tag' method as
+  originally described by Knuth.  (See the paper by Paul Wilson
+  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
+  techniques.)  Sizes of free chunks are stored both in the front of
+  each chunk and at the end.  This makes consolidating fragmented
+  chunks into bigger chunks fast.  The head fields also hold bits
+  representing whether chunks are free or in use.
+
+  Here are some pictures to make it clearer.  They are "exploded" to
+  show that the state of a chunk can be thought of as extending from
+  the high 31 bits of the head field of its header through the
+  prev_foot and PINUSE_BIT bit of the following chunk header.
+
+  A chunk that's in use looks like:
+
+   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+           | Size of previous chunk (if P = 1)                             |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         1| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               |
+         +-                                                             -+
+         |                                                               |
+         +-                                                             -+
+         |                                                               :
+         +-      size - sizeof(size_t) available payload bytes          -+
+         :                                                               |
+ chunk-> +-                                                             -+
+         |                                                               |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
+       | Size of next chunk (may or may not be in use)               | +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    And if it's free, it looks like this:
+
+   chunk-> +-                                                             -+
+           | User payload (must be in use, or we would have merged!)       |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         0| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Next pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Prev pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               :
+         +-      size - sizeof(struct chunk) unused bytes               -+
+         :                                                               |
+ chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Size of this chunk                                            |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
+       | Size of next chunk (must be in use, or we would have merged)| +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                                                               :
+       +- User payload                                                -+
+       :                                                               |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                                     |0|
+                                                                     +-+
+  Note that since we always merge adjacent free chunks, the chunks
+  adjacent to a free chunk must be in use.
+
+  Given a pointer to a chunk (which can be derived trivially from the
+  payload pointer) we can, in O(1) time, find out whether the adjacent
+  chunks are free, and if so, unlink them from the lists that they
+  are on and merge them with the current chunk.
+
+  Chunks always begin on even word boundaries, so the mem portion
+  (which is returned to the user) is also on an even word boundary, and
+  thus at least double-word aligned.
+
+  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
+  chunk size (which is always a multiple of two words), is an in-use
+  bit for the *previous* chunk.  If that bit is *clear*, then the
+  word before the current chunk size contains the previous chunk
+  size, and can be used to find the front of the previous chunk.
+  The very first chunk allocated always has this bit set, preventing
+  access to non-existent (or non-owned) memory. If pinuse is set for
+  any given chunk, then you CANNOT determine the size of the
+  previous chunk, and might even get a memory addressing fault when
+  trying to do so.
+
+  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
+  the chunk size redundantly records whether the current chunk is
+  inuse. This redundancy enables usage checks within free and realloc,
+  and reduces indirection when freeing and consolidating chunks.
+
+  Each freshly allocated chunk must have both cinuse and pinuse set.
+  That is, each allocated chunk borders either a previously allocated
+  and still in-use chunk, or the base of its memory arena. This is
+  ensured by making all allocations from the the `lowest' part of any
+  found chunk.  Further, no free chunk physically borders another one,
+  so each free chunk is known to be preceded and followed by either
+  inuse chunks or the ends of memory.
+
+  Note that the `foot' of the current chunk is actually represented
+  as the prev_foot of the NEXT chunk. This makes it easier to
+  deal with alignments etc but can be very confusing when trying
+  to extend or adapt this code.
+
+  The exceptions to all this are
+
+     1. The special chunk `top' is the top-most available chunk (i.e.,
+        the one bordering the end of available memory). It is treated
+        specially.  Top is never included in any bin, is used only if
+        no other chunk is available, and is released back to the
+        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
+        the top chunk is treated as larger (and thus less well
+        fitting) than any other available chunk.  The top chunk
+        doesn't update its trailing size field since there is no next
+        contiguous chunk that would have to index off it. However,
+        space is still allocated for it (TOP_FOOT_SIZE) to enable
+        separation or merging when space is extended.
+
+     3. Chunks allocated via mmap, which have the lowest-order bit
+        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
+        PINUSE_BIT in their head fields.  Because they are allocated
+        one-by-one, each must carry its own prev_foot field, which is
+        also used to hold the offset this chunk has within its mmapped
+        region, which is needed to preserve alignment. Each mmapped
+        chunk is trailed by the first two fields of a fake next-chunk
+        for sake of usage checks.
+
+*/
+
+struct malloc_chunk {
+  size_t               prev_foot;  /* Size of previous chunk (if free).  */
+  size_t               head;       /* Size and inuse bits. */
+  struct malloc_chunk* fd;         /* double links -- used only if free. */
+  struct malloc_chunk* bk;
+};
+
+typedef struct malloc_chunk  mchunk;
+typedef struct malloc_chunk* mchunkptr;
+typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
+typedef size_t bindex_t;               /* Described below */
+typedef unsigned int binmap_t;         /* Described below */
+typedef unsigned int flag_t;           /* The type of various bit flag sets */
+
+/* ------------------- Chunks sizes and alignments ----------------------- */
+
+#define MCHUNK_SIZE         (sizeof(mchunk))
+
+#if FOOTERS
+#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
+#else /* FOOTERS */
+#define CHUNK_OVERHEAD      (SIZE_T_SIZE)
+#endif /* FOOTERS */
+
+/* MMapped chunks need a second word of overhead ... */
+#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
+/* ... and additional padding for fake next-chunk at foot */
+#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
+
+/* The smallest size we can malloc is an aligned minimal chunk */
+#define MIN_CHUNK_SIZE\
+  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* conversion from malloc headers to user pointers, and back */
+#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
+#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
+/* chunk associated with aligned address A */
+#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
+
+/* Bounds on request (not chunk) sizes. */
+#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)
+#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
+
+/* pad request bytes into a usable size */
+#define pad_request(req) \
+   (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* pad request, checking for minimum (but not maximum) */
+#define request2size(req) \
+  (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
+
+
+/* ------------------ Operations on head and foot fields ----------------- */
+
+/*
+  The head field of a chunk is or'ed with PINUSE_BIT when previous
+  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
+  use. If the chunk was obtained with mmap, the prev_foot field has
+  IS_MMAPPED_BIT set, otherwise holding the offset of the base of the
+  mmapped region to the base of the chunk.
+*/
+
+#define PINUSE_BIT          (SIZE_T_ONE)
+#define CINUSE_BIT          (SIZE_T_TWO)
+#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
+
+/* Head value for fenceposts */
+#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)
+
+/* extraction of fields from head words */
+#define cinuse(p)           ((p)->head & CINUSE_BIT)
+#define pinuse(p)           ((p)->head & PINUSE_BIT)
+#define chunksize(p)        ((p)->head & ~(INUSE_BITS))
+
+#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
+#define clear_cinuse(p)     ((p)->head &= ~CINUSE_BIT)
+
+/* Treat space at ptr +/- offset as a chunk */
+#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
+#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
+
+/* Ptr to next or previous physical malloc_chunk. */
+#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~INUSE_BITS)))
+#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
+
+/* extract next chunk's pinuse bit */
+#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
+
+/* Get/set size at footer */
+#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
+#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
+
+/* Set size, pinuse bit, and foot */
+#define set_size_and_pinuse_of_free_chunk(p, s)\
+  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
+
+/* Set size, pinuse bit, foot, and clear next pinuse */
+#define set_free_with_pinuse(p, s, n)\
+  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
+
+#define is_mmapped(p)\
+  (!((p)->head & PINUSE_BIT) && ((p)->prev_foot & IS_MMAPPED_BIT))
+
+/* Get the internal overhead associated with chunk p */
+#define overhead_for(p)\
+ (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
+
+/* Return true if malloced space is not necessarily cleared */
+#if MMAP_CLEARS
+#define calloc_must_clear(p) (!is_mmapped(p))
+#else /* MMAP_CLEARS */
+#define calloc_must_clear(p) (1)
+#endif /* MMAP_CLEARS */
+
+/* ---------------------- Overlaid data structures ----------------------- */
+
+/*
+  When chunks are not in use, they are treated as nodes of either
+  lists or trees.
+
+  "Small"  chunks are stored in circular doubly-linked lists, and look
+  like this:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk in list             |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk in list            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space (may be 0 bytes long)                .
+            .                                                               .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Larger chunks are kept in a form of bitwise digital trees (aka
+  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
+  free chunks greater than 256 bytes, their size doesn't impose any
+  constraints on user chunk sizes.  Each node looks like:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk of same size        |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk of same size       |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to left child (child[0])                  |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to right child (child[1])                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to parent                                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             bin index of this chunk                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space                                      .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
+  of the same size are arranged in a circularly-linked list, with only
+  the oldest chunk (the next to be used, in our FIFO ordering)
+  actually in the tree.  (Tree members are distinguished by a non-null
+  parent pointer.)  If a chunk with the same size an an existing node
+  is inserted, it is linked off the existing node using pointers that
+  work in the same way as fd/bk pointers of small chunks.
+
+  Each tree contains a power of 2 sized range of chunk sizes (the
+  smallest is 0x100 <= x < 0x180), which is is divided in half at each
+  tree level, with the chunks in the smaller half of the range (0x100
+  <= x < 0x140 for the top nose) in the left subtree and the larger
+  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
+  done by inspecting individual bits.
+
+  Using these rules, each node's left subtree contains all smaller
+  sizes than its right subtree.  However, the node at the root of each
+  subtree has no particular ordering relationship to either.  (The
+  dividing line between the subtree sizes is based on trie relation.)
+  If we remove the last chunk of a given size from the interior of the
+  tree, we need to replace it with a leaf node.  The tree ordering
+  rules permit a node to be replaced by any leaf below it.
+
+  The smallest chunk in a tree (a common operation in a best-fit
+  allocator) can be found by walking a path to the leftmost leaf in
+  the tree.  Unlike a usual binary tree, where we follow left child
+  pointers until we reach a null, here we follow the right child
+  pointer any time the left one is null, until we reach a leaf with
+  both child pointers null. The smallest chunk in the tree will be
+  somewhere along that path.
+
+  The worst case number of steps to add, find, or remove a node is
+  bounded by the number of bits differentiating chunks within
+  bins. Under current bin calculations, this ranges from 6 up to 21
+  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
+  is of course much better.
+*/
+
+struct malloc_tree_chunk {
+  /* The first four fields must be compatible with malloc_chunk */
+  size_t                    prev_foot;
+  size_t                    head;
+  struct malloc_tree_chunk* fd;
+  struct malloc_tree_chunk* bk;
+
+  struct malloc_tree_chunk* child[2];
+  struct malloc_tree_chunk* parent;
+  bindex_t                  index;
+};
+
+typedef struct malloc_tree_chunk  tchunk;
+typedef struct malloc_tree_chunk* tchunkptr;
+typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */
+
+/* A little helper macro for trees */
+#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
+
+/* ----------------------------- Segments -------------------------------- */
+
+/*
+  Each malloc space may include non-contiguous segments, held in a
+  list headed by an embedded malloc_segment record representing the
+  top-most space. Segments also include flags holding properties of
+  the space. Large chunks that are directly allocated by mmap are not
+  included in this list. They are instead independently created and
+  destroyed without otherwise keeping track of them.
+
+  Segment management mainly comes into play for spaces allocated by
+  MMAP.  Any call to MMAP might or might not return memory that is
+  adjacent to an existing segment.  MORECORE normally contiguously
+  extends the current space, so this space is almost always adjacent,
+  which is simpler and faster to deal with. (This is why MORECORE is
+  used preferentially to MMAP when both are available -- see
+  sys_alloc.)  When allocating using MMAP, we don't use any of the
+  hinting mechanisms (inconsistently) supported in various
+  implementations of unix mmap, or distinguish reserving from
+  committing memory. Instead, we just ask for space, and exploit
+  contiguity when we get it.  It is probably possible to do
+  better than this on some systems, but no general scheme seems
+  to be significantly better.
+
+  Management entails a simpler variant of the consolidation scheme
+  used for chunks to reduce fragmentation -- new adjacent memory is
+  normally prepended or appended to an existing segment. However,
+  there are limitations compared to chunk consolidation that mostly
+  reflect the fact that segment processing is relatively infrequent
+  (occurring only when getting memory from system) and that we
+  don't expect to have huge numbers of segments:
+
+  * Segments are not indexed, so traversal requires linear scans.  (It
+    would be possible to index these, but is not worth the extra
+    overhead and complexity for most programs on most platforms.)
+  * New segments are only appended to old ones when holding top-most
+    memory; if they cannot be prepended to others, they are held in
+    different segments.
+
+  Except for the top-most segment of an mstate, each segment record
+  is kept at the tail of its segment. Segments are added by pushing
+  segment records onto the list headed by &mstate.seg for the
+  containing mstate.
+
+  Segment flags control allocation/merge/deallocation policies:
+  * If EXTERN_BIT set, then we did not allocate this segment,
+    and so should not try to deallocate or merge with others.
+    (This currently holds only for the initial segment passed
+    into create_mspace_with_base.)
+  * If IS_MMAPPED_BIT set, the segment may be merged with
+    other surrounding mmapped segments and trimmed/de-allocated
+    using munmap.
+  * If neither bit is set, then the segment was obtained using
+    MORECORE so can be merged with surrounding MORECORE'd segments
+    and deallocated/trimmed using MORECORE with negative arguments.
+*/
+
+struct malloc_segment {
+  char*        base;             /* base address */
+  size_t       size;             /* allocated size */
+  struct malloc_segment* next;   /* ptr to next segment */
+#if FFI_MMAP_EXEC_WRIT
+  /* The mmap magic is supposed to store the address of the executable
+     segment at the very end of the requested block.  */
+
+# define mmap_exec_offset(b,s) (*(ptrdiff_t*)((b)+(s)-sizeof(ptrdiff_t)))
+
+  /* We can only merge segments if their corresponding executable
+     segments are at identical offsets.  */
+# define check_segment_merge(S,b,s) \
+  (mmap_exec_offset((b),(s)) == (S)->exec_offset)
+
+# define add_segment_exec_offset(p,S) ((char*)(p) + (S)->exec_offset)
+# define sub_segment_exec_offset(p,S) ((char*)(p) - (S)->exec_offset)
+
+  /* The removal of sflags only works with HAVE_MORECORE == 0.  */
+
+# define get_segment_flags(S)   (IS_MMAPPED_BIT)
+# define set_segment_flags(S,v) \
+  (((v) != IS_MMAPPED_BIT) ? (ABORT, (v)) :				\
+   (((S)->exec_offset =							\
+     mmap_exec_offset((S)->base, (S)->size)),				\
+    (mmap_exec_offset((S)->base + (S)->exec_offset, (S)->size) !=	\
+     (S)->exec_offset) ? (ABORT, (v)) :					\
+   (mmap_exec_offset((S)->base, (S)->size) = 0), (v)))
+
+  /* We use an offset here, instead of a pointer, because then, when
+     base changes, we don't have to modify this.  On architectures
+     with segmented addresses, this might not work.  */
+  ptrdiff_t    exec_offset;
+#else
+
+# define get_segment_flags(S)   ((S)->sflags)
+# define set_segment_flags(S,v) ((S)->sflags = (v))
+# define check_segment_merge(S,b,s) (1)
+
+  flag_t       sflags;           /* mmap and extern flag */
+#endif
+};
+
+#define is_mmapped_segment(S)  (get_segment_flags(S) & IS_MMAPPED_BIT)
+#define is_extern_segment(S)   (get_segment_flags(S) & EXTERN_BIT)
+
+typedef struct malloc_segment  msegment;
+typedef struct malloc_segment* msegmentptr;
+
+/* ---------------------------- malloc_state ----------------------------- */
+
+/*
+   A malloc_state holds all of the bookkeeping for a space.
+   The main fields are:
+
+  Top
+    The topmost chunk of the currently active segment. Its size is
+    cached in topsize.  The actual size of topmost space is
+    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
+    fenceposts and segment records if necessary when getting more
+    space from the system.  The size at which to autotrim top is
+    cached from mparams in trim_check, except that it is disabled if
+    an autotrim fails.
+
+  Designated victim (dv)
+    This is the preferred chunk for servicing small requests that
+    don't have exact fits.  It is normally the chunk split off most
+    recently to service another small request.  Its size is cached in
+    dvsize. The link fields of this chunk are not maintained since it
+    is not kept in a bin.
+
+  SmallBins
+    An array of bin headers for free chunks.  These bins hold chunks
+    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
+    chunks of all the same size, spaced 8 bytes apart.  To simplify
+    use in double-linked lists, each bin header acts as a malloc_chunk
+    pointing to the real first node, if it exists (else pointing to
+    itself).  This avoids special-casing for headers.  But to avoid
+    waste, we allocate only the fd/bk pointers of bins, and then use
+    repositioning tricks to treat these as the fields of a chunk.
+
+  TreeBins
+    Treebins are pointers to the roots of trees holding a range of
+    sizes. There are 2 equally spaced treebins for each power of two
+    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
+    larger.
+
+  Bin maps
+    There is one bit map for small bins ("smallmap") and one for
+    treebins ("treemap).  Each bin sets its bit when non-empty, and
+    clears the bit when empty.  Bit operations are then used to avoid
+    bin-by-bin searching -- nearly all "search" is done without ever
+    looking at bins that won't be selected.  The bit maps
+    conservatively use 32 bits per map word, even if on 64bit system.
+    For a good description of some of the bit-based techniques used
+    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
+    supplement at http://hackersdelight.org/). Many of these are
+    intended to reduce the branchiness of paths through malloc etc, as
+    well as to reduce the number of memory locations read or written.
+
+  Segments
+    A list of segments headed by an embedded malloc_segment record
+    representing the initial space.
+
+  Address check support
+    The least_addr field is the least address ever obtained from
+    MORECORE or MMAP. Attempted frees and reallocs of any address less
+    than this are trapped (unless INSECURE is defined).
+
+  Magic tag
+    A cross-check field that should always hold same value as mparams.magic.
+
+  Flags
+    Bits recording whether to use MMAP, locks, or contiguous MORECORE
+
+  Statistics
+    Each space keeps track of current and maximum system memory
+    obtained via MORECORE or MMAP.
+
+  Locking
+    If USE_LOCKS is defined, the "mutex" lock is acquired and released
+    around every public call using this mspace.
+*/
+
+/* Bin types, widths and sizes */
+#define NSMALLBINS        (32U)
+#define NTREEBINS         (32U)
+#define SMALLBIN_SHIFT    (3U)
+#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
+#define TREEBIN_SHIFT     (8U)
+#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
+#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
+#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
+
+struct malloc_state {
+  binmap_t   smallmap;
+  binmap_t   treemap;
+  size_t     dvsize;
+  size_t     topsize;
+  char*      least_addr;
+  mchunkptr  dv;
+  mchunkptr  top;
+  size_t     trim_check;
+  size_t     magic;
+  mchunkptr  smallbins[(NSMALLBINS+1)*2];
+  tbinptr    treebins[NTREEBINS];
+  size_t     footprint;
+  size_t     max_footprint;
+  flag_t     mflags;
+#if USE_LOCKS
+  MLOCK_T    mutex;     /* locate lock among fields that rarely change */
+#endif /* USE_LOCKS */
+  msegment   seg;
+};
+
+typedef struct malloc_state*    mstate;
+
+/* ------------- Global malloc_state and malloc_params ------------------- */
+
+/*
+  malloc_params holds global properties, including those that can be
+  dynamically set using mallopt. There is a single instance, mparams,
+  initialized in init_mparams.
+*/
+
+struct malloc_params {
+  size_t magic;
+  size_t page_size;
+  size_t granularity;
+  size_t mmap_threshold;
+  size_t trim_threshold;
+  flag_t default_mflags;
+};
+
+static struct malloc_params mparams;
+
+/* The global malloc_state used for all non-"mspace" calls */
+static struct malloc_state _gm_;
+#define gm                 (&_gm_)
+#define is_global(M)       ((M) == &_gm_)
+#define is_initialized(M)  ((M)->top != 0)
+
+/* -------------------------- system alloc setup ------------------------- */
+
+/* Operations on mflags */
+
+#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)
+#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)
+#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)
+
+#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)
+#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)
+#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)
+
+#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)
+#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)
+
+#define set_lock(M,L)\
+ ((M)->mflags = (L)?\
+  ((M)->mflags | USE_LOCK_BIT) :\
+  ((M)->mflags & ~USE_LOCK_BIT))
+
+/* page-align a size */
+#define page_align(S)\
+ (((S) + (mparams.page_size)) & ~(mparams.page_size - SIZE_T_ONE))
+
+/* granularity-align a size */
+#define granularity_align(S)\
+  (((S) + (mparams.granularity)) & ~(mparams.granularity - SIZE_T_ONE))
+
+#define is_page_aligned(S)\
+   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
+#define is_granularity_aligned(S)\
+   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
+
+/*  True if segment S holds address A */
+#define segment_holds(S, A)\
+  ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
+
+/* Return segment holding given address */
+static msegmentptr segment_holding(mstate m, char* addr) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if (addr >= sp->base && addr < sp->base + sp->size)
+      return sp;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+/* Return true if segment contains a segment link */
+static int has_segment_link(mstate m, msegmentptr ss) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
+      return 1;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+#ifndef MORECORE_CANNOT_TRIM
+#define should_trim(M,s)  ((s) > (M)->trim_check)
+#else  /* MORECORE_CANNOT_TRIM */
+#define should_trim(M,s)  (0)
+#endif /* MORECORE_CANNOT_TRIM */
+
+/*
+  TOP_FOOT_SIZE is padding at the end of a segment, including space
+  that may be needed to place segment records and fenceposts when new
+  noncontiguous segments are added.
+*/
+#define TOP_FOOT_SIZE\
+  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
+
+
+/* -------------------------------  Hooks -------------------------------- */
+
+/*
+  PREACTION should be defined to return 0 on success, and nonzero on
+  failure. If you are not using locking, you can redefine these to do
+  anything you like.
+*/
+
+#if USE_LOCKS
+
+/* Ensure locks are initialized */
+#define GLOBALLY_INITIALIZE() (mparams.page_size == 0 && init_mparams())
+
+#define PREACTION(M)  ((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
+#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
+#else /* USE_LOCKS */
+
+#ifndef PREACTION
+#define PREACTION(M) (0)
+#endif  /* PREACTION */
+
+#ifndef POSTACTION
+#define POSTACTION(M)
+#endif  /* POSTACTION */
+
+#endif /* USE_LOCKS */
+
+/*
+  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
+  USAGE_ERROR_ACTION is triggered on detected bad frees and
+  reallocs. The argument p is an address that might have triggered the
+  fault. It is ignored by the two predefined actions, but might be
+  useful in custom actions that try to help diagnose errors.
+*/
+
+#if PROCEED_ON_ERROR
+
+/* A count of the number of corruption errors causing resets */
+int malloc_corruption_error_count;
+
+/* default corruption action */
+static void reset_on_error(mstate m);
+
+#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
+#define USAGE_ERROR_ACTION(m, p)
+
+#else /* PROCEED_ON_ERROR */
+
+#ifndef CORRUPTION_ERROR_ACTION
+#define CORRUPTION_ERROR_ACTION(m) ABORT
+#endif /* CORRUPTION_ERROR_ACTION */
+
+#ifndef USAGE_ERROR_ACTION
+#define USAGE_ERROR_ACTION(m,p) ABORT
+#endif /* USAGE_ERROR_ACTION */
+
+#endif /* PROCEED_ON_ERROR */
+
+/* -------------------------- Debugging setup ---------------------------- */
+
+#if ! DEBUG
+
+#define check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)
+#define check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)
+#define check_malloc_state(M)
+#define check_top_chunk(M,P)
+
+#else /* DEBUG */
+#define check_free_chunk(M,P)       do_check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
+#define check_top_chunk(M,P)        do_check_top_chunk(M,P)
+#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
+#define check_malloc_state(M)       do_check_malloc_state(M)
+
+static void   do_check_any_chunk(mstate m, mchunkptr p);
+static void   do_check_top_chunk(mstate m, mchunkptr p);
+static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
+static void   do_check_inuse_chunk(mstate m, mchunkptr p);
+static void   do_check_free_chunk(mstate m, mchunkptr p);
+static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
+static void   do_check_tree(mstate m, tchunkptr t);
+static void   do_check_treebin(mstate m, bindex_t i);
+static void   do_check_smallbin(mstate m, bindex_t i);
+static void   do_check_malloc_state(mstate m);
+static int    bin_find(mstate m, mchunkptr x);
+static size_t traverse_and_check(mstate m);
+#endif /* DEBUG */
+
+/* ---------------------------- Indexing Bins ---------------------------- */
+
+#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
+#define small_index(s)      ((s)  >> SMALLBIN_SHIFT)
+#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
+#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
+
+/* addressing by index. See above about smallbin repositioning */
+#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
+#define treebin_at(M,i)     (&((M)->treebins[i]))
+
+/* assign tree index for size S to variable I */
+#if defined(__GNUC__) && defined(__i386__)
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K;\
+    __asm__("bsrl %1,%0\n\t" : "=r" (K) : "rm"  (X));\
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+#else /* GNUC */
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int Y = (unsigned int)X;\
+    unsigned int N = ((Y - 0x100) >> 16) & 8;\
+    unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\
+    N += K;\
+    N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\
+    K = 14 - N + ((Y <<= K) >> 15);\
+    I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\
+  }\
+}
+#endif /* GNUC */
+
+/* Bit representing maximum resolved size in a treebin at i */
+#define bit_for_tree_index(i) \
+   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)
+
+/* Shift placing maximum resolved bit in a treebin at i as sign bit */
+#define leftshift_for_tree_index(i) \
+   ((i == NTREEBINS-1)? 0 : \
+    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
+
+/* The size of the smallest chunk held in bin with index i */
+#define minsize_for_tree_index(i) \
+   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
+   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))
+
+
+/* ------------------------ Operations on bin maps ----------------------- */
+
+/* bit corresponding to given index */
+#define idx2bit(i)              ((binmap_t)(1) << (i))
+
+/* Mark/Clear bits with given index */
+#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
+#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
+#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))
+
+#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
+#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
+#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))
+
+/* index corresponding to given bit */
+
+#if defined(__GNUC__) && defined(__i386__)
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  __asm__("bsfl %1,%0\n\t" : "=r" (J) : "rm" (X));\
+  I = (bindex_t)J;\
+}
+
+#else /* GNUC */
+#if  USE_BUILTIN_FFS
+#define compute_bit2idx(X, I) I = __builtin_ffs(X)-1
+
+#else /* USE_BUILTIN_FFS */
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int Y = X - 1;\
+  unsigned int K = Y >> (16-4) & 16;\
+  unsigned int N = K;        Y >>= K;\
+  N += K = Y >> (8-3) &  8;  Y >>= K;\
+  N += K = Y >> (4-2) &  4;  Y >>= K;\
+  N += K = Y >> (2-1) &  2;  Y >>= K;\
+  N += K = Y >> (1-0) &  1;  Y >>= K;\
+  I = (bindex_t)(N + Y);\
+}
+#endif /* USE_BUILTIN_FFS */
+#endif /* GNUC */
+
+/* isolate the least set bit of a bitmap */
+#define least_bit(x)         ((x) & -(x))
+
+/* mask with all bits to left of least bit of x on */
+#define left_bits(x)         ((x<<1) | -(x<<1))
+
+/* mask with all bits to left of or equal to least bit of x on */
+#define same_or_left_bits(x) ((x) | -(x))
+
+
+/* ----------------------- Runtime Check Support ------------------------- */
+
+/*
+  For security, the main invariant is that malloc/free/etc never
+  writes to a static address other than malloc_state, unless static
+  malloc_state itself has been corrupted, which cannot occur via
+  malloc (because of these checks). In essence this means that we
+  believe all pointers, sizes, maps etc held in malloc_state, but
+  check all of those linked or offsetted from other embedded data
+  structures.  These checks are interspersed with main code in a way
+  that tends to minimize their run-time cost.
+
+  When FOOTERS is defined, in addition to range checking, we also
+  verify footer fields of inuse chunks, which can be used guarantee
+  that the mstate controlling malloc/free is intact.  This is a
+  streamlined version of the approach described by William Robertson
+  et al in "Run-time Detection of Heap-based Overflows" LISA'03
+  http://www.usenix.org/events/lisa03/tech/robertson.html The footer
+  of an inuse chunk holds the xor of its mstate and a random seed,
+  that is checked upon calls to free() and realloc().  This is
+  (probablistically) unguessable from outside the program, but can be
+  computed by any code successfully malloc'ing any chunk, so does not
+  itself provide protection against code that has already broken
+  security through some other means.  Unlike Robertson et al, we
+  always dynamically check addresses of all offset chunks (previous,
+  next, etc). This turns out to be cheaper than relying on hashes.
+*/
+
+#if !INSECURE
+/* Check if address a is at least as high as any from MORECORE or MMAP */
+#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
+/* Check if address of next chunk n is higher than base chunk p */
+#define ok_next(p, n)    ((char*)(p) < (char*)(n))
+/* Check if p has its cinuse bit on */
+#define ok_cinuse(p)     cinuse(p)
+/* Check if p has its pinuse bit on */
+#define ok_pinuse(p)     pinuse(p)
+
+#else /* !INSECURE */
+#define ok_address(M, a) (1)
+#define ok_next(b, n)    (1)
+#define ok_cinuse(p)     (1)
+#define ok_pinuse(p)     (1)
+#endif /* !INSECURE */
+
+#if (FOOTERS && !INSECURE)
+/* Check if (alleged) mstate m has expected magic field */
+#define ok_magic(M)      ((M)->magic == mparams.magic)
+#else  /* (FOOTERS && !INSECURE) */
+#define ok_magic(M)      (1)
+#endif /* (FOOTERS && !INSECURE) */
+
+
+/* In gcc, use __builtin_expect to minimize impact of checks */
+#if !INSECURE
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define RTCHECK(e)  __builtin_expect(e, 1)
+#else /* GNUC */
+#define RTCHECK(e)  (e)
+#endif /* GNUC */
+#else /* !INSECURE */
+#define RTCHECK(e)  (1)
+#endif /* !INSECURE */
+
+/* macros to set up inuse chunks with or without footers */
+
+#if !FOOTERS
+
+#define mark_inuse_foot(M,p,s)
+
+/* Set cinuse bit and pinuse bit of next chunk */
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set size, cinuse and pinuse bit of this chunk */
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
+
+#else /* FOOTERS */
+
+/* Set foot of inuse chunk to be xor of mstate and seed */
+#define mark_inuse_foot(M,p,s)\
+  (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))
+
+#define get_mstate_for(p)\
+  ((mstate)(((mchunkptr)((char*)(p) +\
+    (chunksize(p))))->prev_foot ^ mparams.magic))
+
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \
+  mark_inuse_foot(M,p,s))
+
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\
+ mark_inuse_foot(M,p,s))
+
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  mark_inuse_foot(M, p, s))
+
+#endif /* !FOOTERS */
+
+/* ---------------------------- setting mparams -------------------------- */
+
+/* Initialize mparams */
+static int init_mparams(void) {
+  if (mparams.page_size == 0) {
+    size_t s;
+
+    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
+    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
+#if MORECORE_CONTIGUOUS
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
+#else  /* MORECORE_CONTIGUOUS */
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
+#endif /* MORECORE_CONTIGUOUS */
+
+#if (FOOTERS && !INSECURE)
+    {
+#if USE_DEV_RANDOM
+      int fd;
+      unsigned char buf[sizeof(size_t)];
+      /* Try to use /dev/urandom, else fall back on using time */
+      if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
+          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
+        s = *((size_t *) buf);
+        close(fd);
+      }
+      else
+#endif /* USE_DEV_RANDOM */
+        s = (size_t)(time(0) ^ (size_t)0x55555555U);
+
+      s |= (size_t)8U;    /* ensure nonzero */
+      s &= ~(size_t)7U;   /* improve chances of fault for bad values */
+
+    }
+#else /* (FOOTERS && !INSECURE) */
+    s = (size_t)0x58585858U;
+#endif /* (FOOTERS && !INSECURE) */
+    ACQUIRE_MAGIC_INIT_LOCK();
+    if (mparams.magic == 0) {
+      mparams.magic = s;
+      /* Set up lock for main malloc area */
+      INITIAL_LOCK(&gm->mutex);
+      gm->mflags = mparams.default_mflags;
+    }
+    RELEASE_MAGIC_INIT_LOCK();
+
+#if !defined(WIN32) && !defined(__OS2__)
+    mparams.page_size = malloc_getpagesize;
+    mparams.granularity = ((DEFAULT_GRANULARITY != 0)?
+                           DEFAULT_GRANULARITY : mparams.page_size);
+#elif defined (__OS2__)
+ /* if low-memory is used, os2munmap() would break
+    if it were anything other than 64k */
+    mparams.page_size = 4096u;
+    mparams.granularity = 65536u;
+#else /* WIN32 */
+    {
+      SYSTEM_INFO system_info;
+      GetSystemInfo(&system_info);
+      mparams.page_size = system_info.dwPageSize;
+      mparams.granularity = system_info.dwAllocationGranularity;
+    }
+#endif /* WIN32 */
+
+    /* Sanity-check configuration:
+       size_t must be unsigned and as wide as pointer type.
+       ints must be at least 4 bytes.
+       alignment must be at least 8.
+       Alignment, min chunk size, and page size must all be powers of 2.
+    */
+    if ((sizeof(size_t) != sizeof(char*)) ||
+        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
+        (sizeof(int) < 4)  ||
+        (MALLOC_ALIGNMENT < (size_t)8U) ||
+        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
+        ((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
+        ((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||
+        ((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))
+      ABORT;
+  }
+  return 0;
+}
+
+/* support for mallopt */
+static int change_mparam(int param_number, int value) {
+  size_t val = (size_t)value;
+  init_mparams();
+  switch(param_number) {
+  case M_TRIM_THRESHOLD:
+    mparams.trim_threshold = val;
+    return 1;
+  case M_GRANULARITY:
+    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
+      mparams.granularity = val;
+      return 1;
+    }
+    else
+      return 0;
+  case M_MMAP_THRESHOLD:
+    mparams.mmap_threshold = val;
+    return 1;
+  default:
+    return 0;
+  }
+}
+
+#if DEBUG
+/* ------------------------- Debugging Support --------------------------- */
+
+/* Check properties of any chunk, whether free, inuse, mmapped etc  */
+static void do_check_any_chunk(mstate m, mchunkptr p) {
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+}
+
+/* Check properties of top chunk */
+static void do_check_top_chunk(mstate m, mchunkptr p) {
+  msegmentptr sp = segment_holding(m, (char*)p);
+  size_t  sz = chunksize(p);
+  assert(sp != 0);
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(sz == m->topsize);
+  assert(sz > 0);
+  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);
+  assert(pinuse(p));
+  assert(!next_pinuse(p));
+}
+
+/* Check properties of (inuse) mmapped chunks */
+static void do_check_mmapped_chunk(mstate m, mchunkptr p) {
+  size_t  sz = chunksize(p);
+  size_t len = (sz + (p->prev_foot & ~IS_MMAPPED_BIT) + MMAP_FOOT_PAD);
+  assert(is_mmapped(p));
+  assert(use_mmap(m));
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(!is_small(sz));
+  assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
+  assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);
+  assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);
+}
+
+/* Check properties of inuse chunks */
+static void do_check_inuse_chunk(mstate m, mchunkptr p) {
+  do_check_any_chunk(m, p);
+  assert(cinuse(p));
+  assert(next_pinuse(p));
+  /* If not pinuse and not mmapped, previous chunk has OK offset */
+  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);
+  if (is_mmapped(p))
+    do_check_mmapped_chunk(m, p);
+}
+
+/* Check properties of free chunks */
+static void do_check_free_chunk(mstate m, mchunkptr p) {
+  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
+  mchunkptr next = chunk_plus_offset(p, sz);
+  do_check_any_chunk(m, p);
+  assert(!cinuse(p));
+  assert(!next_pinuse(p));
+  assert (!is_mmapped(p));
+  if (p != m->dv && p != m->top) {
+    if (sz >= MIN_CHUNK_SIZE) {
+      assert((sz & CHUNK_ALIGN_MASK) == 0);
+      assert(is_aligned(chunk2mem(p)));
+      assert(next->prev_foot == sz);
+      assert(pinuse(p));
+      assert (next == m->top || cinuse(next));
+      assert(p->fd->bk == p);
+      assert(p->bk->fd == p);
+    }
+    else  /* markers are always of size SIZE_T_SIZE */
+      assert(sz == SIZE_T_SIZE);
+  }
+}
+
+/* Check properties of malloced chunks at the point they are malloced */
+static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);
+    do_check_inuse_chunk(m, p);
+    assert((sz & CHUNK_ALIGN_MASK) == 0);
+    assert(sz >= MIN_CHUNK_SIZE);
+    assert(sz >= s);
+    /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
+    assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));
+  }
+}
+
+/* Check a tree and its subtrees.  */
+static void do_check_tree(mstate m, tchunkptr t) {
+  tchunkptr head = 0;
+  tchunkptr u = t;
+  bindex_t tindex = t->index;
+  size_t tsize = chunksize(t);
+  bindex_t idx;
+  compute_tree_index(tsize, idx);
+  assert(tindex == idx);
+  assert(tsize >= MIN_LARGE_SIZE);
+  assert(tsize >= minsize_for_tree_index(idx));
+  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));
+
+  do { /* traverse through chain of same-sized nodes */
+    do_check_any_chunk(m, ((mchunkptr)u));
+    assert(u->index == tindex);
+    assert(chunksize(u) == tsize);
+    assert(!cinuse(u));
+    assert(!next_pinuse(u));
+    assert(u->fd->bk == u);
+    assert(u->bk->fd == u);
+    if (u->parent == 0) {
+      assert(u->child[0] == 0);
+      assert(u->child[1] == 0);
+    }
+    else {
+      assert(head == 0); /* only one node on chain has parent */
+      head = u;
+      assert(u->parent != u);
+      assert (u->parent->child[0] == u ||
+              u->parent->child[1] == u ||
+              *((tbinptr*)(u->parent)) == u);
+      if (u->child[0] != 0) {
+        assert(u->child[0]->parent == u);
+        assert(u->child[0] != u);
+        do_check_tree(m, u->child[0]);
+      }
+      if (u->child[1] != 0) {
+        assert(u->child[1]->parent == u);
+        assert(u->child[1] != u);
+        do_check_tree(m, u->child[1]);
+      }
+      if (u->child[0] != 0 && u->child[1] != 0) {
+        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
+      }
+    }
+    u = u->fd;
+  } while (u != t);
+  assert(head != 0);
+}
+
+/*  Check all the chunks in a treebin.  */
+static void do_check_treebin(mstate m, bindex_t i) {
+  tbinptr* tb = treebin_at(m, i);
+  tchunkptr t = *tb;
+  int empty = (m->treemap & (1U << i)) == 0;
+  if (t == 0)
+    assert(empty);
+  if (!empty)
+    do_check_tree(m, t);
+}
+
+/*  Check all the chunks in a smallbin.  */
+static void do_check_smallbin(mstate m, bindex_t i) {
+  sbinptr b = smallbin_at(m, i);
+  mchunkptr p = b->bk;
+  unsigned int empty = (m->smallmap & (1U << i)) == 0;
+  if (p == b)
+    assert(empty);
+  if (!empty) {
+    for (; p != b; p = p->bk) {
+      size_t size = chunksize(p);
+      mchunkptr q;
+      /* each chunk claims to be free */
+      do_check_free_chunk(m, p);
+      /* chunk belongs in bin */
+      assert(small_index(size) == i);
+      assert(p->bk == b || chunksize(p->bk) == chunksize(p));
+      /* chunk is followed by an inuse chunk */
+      q = next_chunk(p);
+      if (q->head != FENCEPOST_HEAD)
+        do_check_inuse_chunk(m, q);
+    }
+  }
+}
+
+/* Find x in a bin. Used in other check functions. */
+static int bin_find(mstate m, mchunkptr x) {
+  size_t size = chunksize(x);
+  if (is_small(size)) {
+    bindex_t sidx = small_index(size);
+    sbinptr b = smallbin_at(m, sidx);
+    if (smallmap_is_marked(m, sidx)) {
+      mchunkptr p = b;
+      do {
+        if (p == x)
+          return 1;
+      } while ((p = p->fd) != b);
+    }
+  }
+  else {
+    bindex_t tidx;
+    compute_tree_index(size, tidx);
+    if (treemap_is_marked(m, tidx)) {
+      tchunkptr t = *treebin_at(m, tidx);
+      size_t sizebits = size << leftshift_for_tree_index(tidx);
+      while (t != 0 && chunksize(t) != size) {
+        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+        sizebits <<= 1;
+      }
+      if (t != 0) {
+        tchunkptr u = t;
+        do {
+          if (u == (tchunkptr)x)
+            return 1;
+        } while ((u = u->fd) != t);
+      }
+    }
+  }
+  return 0;
+}
+
+/* Traverse each chunk and check it; return total */
+static size_t traverse_and_check(mstate m) {
+  size_t sum = 0;
+  if (is_initialized(m)) {
+    msegmentptr s = &m->seg;
+    sum += m->topsize + TOP_FOOT_SIZE;
+    while (s != 0) {
+      mchunkptr q = align_as_chunk(s->base);
+      mchunkptr lastq = 0;
+      assert(pinuse(q));
+      while (segment_holds(s, q) &&
+             q != m->top && q->head != FENCEPOST_HEAD) {
+        sum += chunksize(q);
+        if (cinuse(q)) {
+          assert(!bin_find(m, q));
+          do_check_inuse_chunk(m, q);
+        }
+        else {
+          assert(q == m->dv || bin_find(m, q));
+          assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */
+          do_check_free_chunk(m, q);
+        }
+        lastq = q;
+        q = next_chunk(q);
+      }
+      s = s->next;
+    }
+  }
+  return sum;
+}
+
+/* Check all properties of malloc_state. */
+static void do_check_malloc_state(mstate m) {
+  bindex_t i;
+  size_t total;
+  /* check bins */
+  for (i = 0; i < NSMALLBINS; ++i)
+    do_check_smallbin(m, i);
+  for (i = 0; i < NTREEBINS; ++i)
+    do_check_treebin(m, i);
+
+  if (m->dvsize != 0) { /* check dv chunk */
+    do_check_any_chunk(m, m->dv);
+    assert(m->dvsize == chunksize(m->dv));
+    assert(m->dvsize >= MIN_CHUNK_SIZE);
+    assert(bin_find(m, m->dv) == 0);
+  }
+
+  if (m->top != 0) {   /* check top chunk */
+    do_check_top_chunk(m, m->top);
+    assert(m->topsize == chunksize(m->top));
+    assert(m->topsize > 0);
+    assert(bin_find(m, m->top) == 0);
+  }
+
+  total = traverse_and_check(m);
+  assert(total <= m->footprint);
+  assert(m->footprint <= m->max_footprint);
+}
+#endif /* DEBUG */
+
+/* ----------------------------- statistics ------------------------------ */
+
+#if !NO_MALLINFO
+static struct mallinfo internal_mallinfo(mstate m) {
+  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  if (!PREACTION(m)) {
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      size_t nfree = SIZE_T_ONE; /* top always free */
+      size_t mfree = m->topsize + TOP_FOOT_SIZE;
+      size_t sum = mfree;
+      msegmentptr s = &m->seg;
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          size_t sz = chunksize(q);
+          sum += sz;
+          if (!cinuse(q)) {
+            mfree += sz;
+            ++nfree;
+          }
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+
+      nm.arena    = sum;
+      nm.ordblks  = nfree;
+      nm.hblkhd   = m->footprint - sum;
+      nm.usmblks  = m->max_footprint;
+      nm.uordblks = m->footprint - mfree;
+      nm.fordblks = mfree;
+      nm.keepcost = m->topsize;
+    }
+
+    POSTACTION(m);
+  }
+  return nm;
+}
+#endif /* !NO_MALLINFO */
+
+static void internal_malloc_stats(mstate m) {
+  if (!PREACTION(m)) {
+    size_t maxfp = 0;
+    size_t fp = 0;
+    size_t used = 0;
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      msegmentptr s = &m->seg;
+      maxfp = m->max_footprint;
+      fp = m->footprint;
+      used = fp - (m->topsize + TOP_FOOT_SIZE);
+
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          if (!cinuse(q))
+            used -= chunksize(q);
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+    }
+
+    fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
+    fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
+    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
+
+    POSTACTION(m);
+  }
+}
+
+/* ----------------------- Operations on smallbins ----------------------- */
+
+/*
+  Various forms of linking and unlinking are defined as macros.  Even
+  the ones for trees, which are very long but have very short typical
+  paths.  This is ugly but reduces reliance on inlining support of
+  compilers.
+*/
+
+/* Link a free chunk into a smallbin  */
+#define insert_small_chunk(M, P, S) {\
+  bindex_t I  = small_index(S);\
+  mchunkptr B = smallbin_at(M, I);\
+  mchunkptr F = B;\
+  assert(S >= MIN_CHUNK_SIZE);\
+  if (!smallmap_is_marked(M, I))\
+    mark_smallmap(M, I);\
+  else if (RTCHECK(ok_address(M, B->fd)))\
+    F = B->fd;\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+  B->fd = P;\
+  F->bk = P;\
+  P->fd = F;\
+  P->bk = B;\
+}
+
+/* Unlink a chunk from a smallbin  */
+#define unlink_small_chunk(M, P, S) {\
+  mchunkptr F = P->fd;\
+  mchunkptr B = P->bk;\
+  bindex_t I = small_index(S);\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (F == B)\
+    clear_smallmap(M, I);\
+  else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &&\
+                   (B == smallbin_at(M,I) || ok_address(M, B)))) {\
+    F->bk = B;\
+    B->fd = F;\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Unlink the first chunk from a smallbin */
+#define unlink_first_small_chunk(M, B, P, I) {\
+  mchunkptr F = P->fd;\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (B == F)\
+    clear_smallmap(M, I);\
+  else if (RTCHECK(ok_address(M, F))) {\
+    B->fd = F;\
+    F->bk = B;\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Replace dv node, binning the old one */
+/* Used only when dvsize known to be small */
+#define replace_dv(M, P, S) {\
+  size_t DVS = M->dvsize;\
+  if (DVS != 0) {\
+    mchunkptr DV = M->dv;\
+    assert(is_small(DVS));\
+    insert_small_chunk(M, DV, DVS);\
+  }\
+  M->dvsize = S;\
+  M->dv = P;\
+}
+
+/* ------------------------- Operations on trees ------------------------- */
+
+/* Insert chunk into tree */
+#define insert_large_chunk(M, X, S) {\
+  tbinptr* H;\
+  bindex_t I;\
+  compute_tree_index(S, I);\
+  H = treebin_at(M, I);\
+  X->index = I;\
+  X->child[0] = X->child[1] = 0;\
+  if (!treemap_is_marked(M, I)) {\
+    mark_treemap(M, I);\
+    *H = X;\
+    X->parent = (tchunkptr)H;\
+    X->fd = X->bk = X;\
+  }\
+  else {\
+    tchunkptr T = *H;\
+    size_t K = S << leftshift_for_tree_index(I);\
+    for (;;) {\
+      if (chunksize(T) != S) {\
+        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
+        K <<= 1;\
+        if (*C != 0)\
+          T = *C;\
+        else if (RTCHECK(ok_address(M, C))) {\
+          *C = X;\
+          X->parent = T;\
+          X->fd = X->bk = X;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+      else {\
+        tchunkptr F = T->fd;\
+        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
+          T->fd = F->bk = X;\
+          X->fd = F;\
+          X->bk = T;\
+          X->parent = 0;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+    }\
+  }\
+}
+
+/*
+  Unlink steps:
+
+  1. If x is a chained node, unlink it from its same-sized fd/bk links
+     and choose its bk node as its replacement.
+  2. If x was the last node of its size, but not a leaf node, it must
+     be replaced with a leaf node (not merely one with an open left or
+     right), to make sure that lefts and rights of descendants
+     correspond properly to bit masks.  We use the rightmost descendant
+     of x.  We could use any other leaf, but this is easy to locate and
+     tends to counteract removal of leftmosts elsewhere, and so keeps
+     paths shorter than minimally guaranteed.  This doesn't loop much
+     because on average a node in a tree is near the bottom.
+  3. If x is the base of a chain (i.e., has parent links) relink
+     x's parent and children to x's replacement (or null if none).
+*/
+
+#define unlink_large_chunk(M, X) {\
+  tchunkptr XP = X->parent;\
+  tchunkptr R;\
+  if (X->bk != X) {\
+    tchunkptr F = X->fd;\
+    R = X->bk;\
+    if (RTCHECK(ok_address(M, F))) {\
+      F->bk = R;\
+      R->fd = F;\
+    }\
+    else {\
+      CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+  else {\
+    tchunkptr* RP;\
+    if (((R = *(RP = &(X->child[1]))) != 0) ||\
+        ((R = *(RP = &(X->child[0]))) != 0)) {\
+      tchunkptr* CP;\
+      while ((*(CP = &(R->child[1])) != 0) ||\
+             (*(CP = &(R->child[0])) != 0)) {\
+        R = *(RP = CP);\
+      }\
+      if (RTCHECK(ok_address(M, RP)))\
+        *RP = 0;\
+      else {\
+        CORRUPTION_ERROR_ACTION(M);\
+      }\
+    }\
+  }\
+  if (XP != 0) {\
+    tbinptr* H = treebin_at(M, X->index);\
+    if (X == *H) {\
+      if ((*H = R) == 0) \
+        clear_treemap(M, X->index);\
+    }\
+    else if (RTCHECK(ok_address(M, XP))) {\
+      if (XP->child[0] == X) \
+        XP->child[0] = R;\
+      else \
+        XP->child[1] = R;\
+    }\
+    else\
+      CORRUPTION_ERROR_ACTION(M);\
+    if (R != 0) {\
+      if (RTCHECK(ok_address(M, R))) {\
+        tchunkptr C0, C1;\
+        R->parent = XP;\
+        if ((C0 = X->child[0]) != 0) {\
+          if (RTCHECK(ok_address(M, C0))) {\
+            R->child[0] = C0;\
+            C0->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+        if ((C1 = X->child[1]) != 0) {\
+          if (RTCHECK(ok_address(M, C1))) {\
+            R->child[1] = C1;\
+            C1->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+      }\
+      else\
+        CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+}
+
+/* Relays to large vs small bin operations */
+
+#define insert_chunk(M, P, S)\
+  if (is_small(S)) insert_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
+
+#define unlink_chunk(M, P, S)\
+  if (is_small(S)) unlink_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
+
+
+/* Relays to internal calls to malloc/free from realloc, memalign etc */
+
+#if ONLY_MSPACES
+#define internal_malloc(m, b) mspace_malloc(m, b)
+#define internal_free(m, mem) mspace_free(m,mem);
+#else /* ONLY_MSPACES */
+#if MSPACES
+#define internal_malloc(m, b)\
+   (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
+#define internal_free(m, mem)\
+   if (m == gm) dlfree(mem); else mspace_free(m,mem);
+#else /* MSPACES */
+#define internal_malloc(m, b) dlmalloc(b)
+#define internal_free(m, mem) dlfree(mem)
+#endif /* MSPACES */
+#endif /* ONLY_MSPACES */
+
+/* -----------------------  Direct-mmapping chunks ----------------------- */
+
+/*
+  Directly mmapped chunks are set up with an offset to the start of
+  the mmapped region stored in the prev_foot field of the chunk. This
+  allows reconstruction of the required argument to MUNMAP when freed,
+  and also allows adjustment of the returned chunk to meet alignment
+  requirements (especially in memalign).  There is also enough space
+  allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain
+  the PINUSE bit so frees can be checked.
+*/
+
+/* Malloc using mmap */
+static void* mmap_alloc(mstate m, size_t nb) {
+  size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  if (mmsize > nb) {     /* Check for wrap around 0 */
+    char* mm = (char*)(DIRECT_MMAP(mmsize));
+    if (mm != CMFAIL) {
+      size_t offset = align_offset(chunk2mem(mm));
+      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
+      mchunkptr p = (mchunkptr)(mm + offset);
+      p->prev_foot = offset | IS_MMAPPED_BIT;
+      (p)->head = (psize|CINUSE_BIT);
+      mark_inuse_foot(m, p, psize);
+      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;
+
+      if (mm < m->least_addr)
+        m->least_addr = mm;
+      if ((m->footprint += mmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      assert(is_aligned(chunk2mem(p)));
+      check_mmapped_chunk(m, p);
+      return chunk2mem(p);
+    }
+  }
+  return 0;
+}
+
+/* Realloc using mmap */
+static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb) {
+  size_t oldsize = chunksize(oldp);
+  if (is_small(nb)) /* Can't shrink mmap regions below small size */
+    return 0;
+  /* Keep old chunk if big enough but not too big */
+  if (oldsize >= nb + SIZE_T_SIZE &&
+      (oldsize - nb) <= (mparams.granularity << 1))
+    return oldp;
+  else {
+    size_t offset = oldp->prev_foot & ~IS_MMAPPED_BIT;
+    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;
+    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +
+                                         CHUNK_ALIGN_MASK);
+    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
+                                  oldmmsize, newmmsize, 1);
+    if (cp != CMFAIL) {
+      mchunkptr newp = (mchunkptr)(cp + offset);
+      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;
+      newp->head = (psize|CINUSE_BIT);
+      mark_inuse_foot(m, newp, psize);
+      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;
+
+      if (cp < m->least_addr)
+        m->least_addr = cp;
+      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      check_mmapped_chunk(m, newp);
+      return newp;
+    }
+  }
+  return 0;
+}
+
+/* -------------------------- mspace management -------------------------- */
+
+/* Initialize top chunk and its size */
+static void init_top(mstate m, mchunkptr p, size_t psize) {
+  /* Ensure alignment */
+  size_t offset = align_offset(chunk2mem(p));
+  p = (mchunkptr)((char*)p + offset);
+  psize -= offset;
+
+  m->top = p;
+  m->topsize = psize;
+  p->head = psize | PINUSE_BIT;
+  /* set size of fake trailing chunk holding overhead space only once */
+  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
+  m->trim_check = mparams.trim_threshold; /* reset on each update */
+}
+
+/* Initialize bins for a new mstate that is otherwise zeroed out */
+static void init_bins(mstate m) {
+  /* Establish circular links for smallbins */
+  bindex_t i;
+  for (i = 0; i < NSMALLBINS; ++i) {
+    sbinptr bin = smallbin_at(m,i);
+    bin->fd = bin->bk = bin;
+  }
+}
+
+#if PROCEED_ON_ERROR
+
+/* default corruption action */
+static void reset_on_error(mstate m) {
+  int i;
+  ++malloc_corruption_error_count;
+  /* Reinitialize fields to forget about all memory */
+  m->smallbins = m->treebins = 0;
+  m->dvsize = m->topsize = 0;
+  m->seg.base = 0;
+  m->seg.size = 0;
+  m->seg.next = 0;
+  m->top = m->dv = 0;
+  for (i = 0; i < NTREEBINS; ++i)
+    *treebin_at(m, i) = 0;
+  init_bins(m);
+}
+#endif /* PROCEED_ON_ERROR */
+
+/* Allocate chunk and prepend remainder with chunk in successor base. */
+static void* prepend_alloc(mstate m, char* newbase, char* oldbase,
+                           size_t nb) {
+  mchunkptr p = align_as_chunk(newbase);
+  mchunkptr oldfirst = align_as_chunk(oldbase);
+  size_t psize = (char*)oldfirst - (char*)p;
+  mchunkptr q = chunk_plus_offset(p, nb);
+  size_t qsize = psize - nb;
+  set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+
+  assert((char*)oldfirst > (char*)q);
+  assert(pinuse(oldfirst));
+  assert(qsize >= MIN_CHUNK_SIZE);
+
+  /* consolidate remainder with first chunk of old base */
+  if (oldfirst == m->top) {
+    size_t tsize = m->topsize += qsize;
+    m->top = q;
+    q->head = tsize | PINUSE_BIT;
+    check_top_chunk(m, q);
+  }
+  else if (oldfirst == m->dv) {
+    size_t dsize = m->dvsize += qsize;
+    m->dv = q;
+    set_size_and_pinuse_of_free_chunk(q, dsize);
+  }
+  else {
+    if (!cinuse(oldfirst)) {
+      size_t nsize = chunksize(oldfirst);
+      unlink_chunk(m, oldfirst, nsize);
+      oldfirst = chunk_plus_offset(oldfirst, nsize);
+      qsize += nsize;
+    }
+    set_free_with_pinuse(q, qsize, oldfirst);
+    insert_chunk(m, q, qsize);
+    check_free_chunk(m, q);
+  }
+
+  check_malloced_chunk(m, chunk2mem(p), nb);
+  return chunk2mem(p);
+}
+
+
+/* Add a segment to hold a new noncontiguous region */
+static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {
+  /* Determine locations and sizes of segment, fenceposts, old top */
+  char* old_top = (char*)m->top;
+  msegmentptr oldsp = segment_holding(m, old_top);
+  char* old_end = oldsp->base + oldsp->size;
+  size_t ssize = pad_request(sizeof(struct malloc_segment));
+  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  size_t offset = align_offset(chunk2mem(rawsp));
+  char* asp = rawsp + offset;
+  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
+  mchunkptr sp = (mchunkptr)csp;
+  msegmentptr ss = (msegmentptr)(chunk2mem(sp));
+  mchunkptr tnext = chunk_plus_offset(sp, ssize);
+  mchunkptr p = tnext;
+  int nfences = 0;
+
+  /* reset top to new space */
+  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+
+  /* Set up segment record */
+  assert(is_aligned(ss));
+  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
+  *ss = m->seg; /* Push current record */
+  m->seg.base = tbase;
+  m->seg.size = tsize;
+  (void)set_segment_flags(&m->seg, mmapped);
+  m->seg.next = ss;
+
+  /* Insert trailing fenceposts */
+  for (;;) {
+    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);
+    p->head = FENCEPOST_HEAD;
+    ++nfences;
+    if ((char*)(&(nextp->head)) < old_end)
+      p = nextp;
+    else
+      break;
+  }
+  assert(nfences >= 2);
+
+  /* Insert the rest of old top into a bin as an ordinary free chunk */
+  if (csp != old_top) {
+    mchunkptr q = (mchunkptr)old_top;
+    size_t psize = csp - old_top;
+    mchunkptr tn = chunk_plus_offset(q, psize);
+    set_free_with_pinuse(q, psize, tn);
+    insert_chunk(m, q, psize);
+  }
+
+  check_top_chunk(m, m->top);
+}
+
+/* -------------------------- System allocation -------------------------- */
+
+/* Get memory from system using MORECORE or MMAP */
+static void* sys_alloc(mstate m, size_t nb) {
+  char* tbase = CMFAIL;
+  size_t tsize = 0;
+  flag_t mmap_flag = 0;
+
+  init_mparams();
+
+  /* Directly map large chunks */
+  if (use_mmap(m) && nb >= mparams.mmap_threshold) {
+    void* mem = mmap_alloc(m, nb);
+    if (mem != 0)
+      return mem;
+  }
+
+  /*
+    Try getting memory in any of three ways (in most-preferred to
+    least-preferred order):
+    1. A call to MORECORE that can normally contiguously extend memory.
+       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
+       or main space is mmapped or a previous contiguous call failed)
+    2. A call to MMAP new space (disabled if not HAVE_MMAP).
+       Note that under the default settings, if MORECORE is unable to
+       fulfill a request, and HAVE_MMAP is true, then mmap is
+       used as a noncontiguous system allocator. This is a useful backup
+       strategy for systems with holes in address spaces -- in this case
+       sbrk cannot contiguously expand the heap, but mmap may be able to
+       find space.
+    3. A call to MORECORE that cannot usually contiguously extend memory.
+       (disabled if not HAVE_MORECORE)
+  */
+
+  if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {
+    char* br = CMFAIL;
+    msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
+    size_t asize = 0;
+    ACQUIRE_MORECORE_LOCK();
+
+    if (ss == 0) {  /* First time through or recovery */
+      char* base = (char*)CALL_MORECORE(0);
+      if (base != CMFAIL) {
+        asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
+        /* Adjust to end on a page boundary */
+        if (!is_page_aligned(base))
+          asize += (page_align((size_t)base) - (size_t)base);
+        /* Can't call MORECORE if size is negative when treated as signed */
+        if (asize < HALF_MAX_SIZE_T &&
+            (br = (char*)(CALL_MORECORE(asize))) == base) {
+          tbase = base;
+          tsize = asize;
+        }
+      }
+    }
+    else {
+      /* Subtract out existing available top space from MORECORE request. */
+      asize = granularity_align(nb - m->topsize + TOP_FOOT_SIZE + SIZE_T_ONE);
+      /* Use mem here only if it did continuously extend old space */
+      if (asize < HALF_MAX_SIZE_T &&
+          (br = (char*)(CALL_MORECORE(asize))) == ss->base+ss->size) {
+        tbase = br;
+        tsize = asize;
+      }
+    }
+
+    if (tbase == CMFAIL) {    /* Cope with partial failure */
+      if (br != CMFAIL) {    /* Try to use/extend the space we did get */
+        if (asize < HALF_MAX_SIZE_T &&
+            asize < nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
+          size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
+          if (esize < HALF_MAX_SIZE_T) {
+            char* end = (char*)CALL_MORECORE(esize);
+            if (end != CMFAIL)
+              asize += esize;
+            else {            /* Can't use; try to release */
+              (void)CALL_MORECORE(-asize);
+              br = CMFAIL;
+            }
+          }
+        }
+      }
+      if (br != CMFAIL) {    /* Use the space we did get */
+        tbase = br;
+        tsize = asize;
+      }
+      else
+        disable_contiguous(m); /* Don't try contiguous path in the future */
+    }
+
+    RELEASE_MORECORE_LOCK();
+  }
+
+  if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */
+    size_t req = nb + TOP_FOOT_SIZE + SIZE_T_ONE;
+    size_t rsize = granularity_align(req);
+    if (rsize > nb) { /* Fail if wraps around zero */
+      char* mp = (char*)(CALL_MMAP(rsize));
+      if (mp != CMFAIL) {
+        tbase = mp;
+        tsize = rsize;
+        mmap_flag = IS_MMAPPED_BIT;
+      }
+    }
+  }
+
+  if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */
+    size_t asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
+    if (asize < HALF_MAX_SIZE_T) {
+      char* br = CMFAIL;
+      char* end = CMFAIL;
+      ACQUIRE_MORECORE_LOCK();
+      br = (char*)(CALL_MORECORE(asize));
+      end = (char*)(CALL_MORECORE(0));
+      RELEASE_MORECORE_LOCK();
+      if (br != CMFAIL && end != CMFAIL && br < end) {
+        size_t ssize = end - br;
+        if (ssize > nb + TOP_FOOT_SIZE) {
+          tbase = br;
+          tsize = ssize;
+        }
+      }
+    }
+  }
+
+  if (tbase != CMFAIL) {
+
+    if ((m->footprint += tsize) > m->max_footprint)
+      m->max_footprint = m->footprint;
+
+    if (!is_initialized(m)) { /* first-time initialization */
+      m->seg.base = m->least_addr = tbase;
+      m->seg.size = tsize;
+      (void)set_segment_flags(&m->seg, mmap_flag);
+      m->magic = mparams.magic;
+      init_bins(m);
+      if (is_global(m)) 
+        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+      else {
+        /* Offset top by embedded malloc_state */
+        mchunkptr mn = next_chunk(mem2chunk(m));
+        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
+      }
+    }
+
+    else {
+      /* Try to merge with an existing segment */
+      msegmentptr sp = &m->seg;
+      while (sp != 0 && tbase != sp->base + sp->size)
+        sp = sp->next;
+      if (sp != 0 &&
+          !is_extern_segment(sp) &&
+	  check_segment_merge(sp, tbase, tsize) &&
+          (get_segment_flags(sp) & IS_MMAPPED_BIT) == mmap_flag &&
+          segment_holds(sp, m->top)) { /* append */
+        sp->size += tsize;
+        init_top(m, m->top, m->topsize + tsize);
+      }
+      else {
+        if (tbase < m->least_addr)
+          m->least_addr = tbase;
+        sp = &m->seg;
+        while (sp != 0 && sp->base != tbase + tsize)
+          sp = sp->next;
+        if (sp != 0 &&
+            !is_extern_segment(sp) &&
+	    check_segment_merge(sp, tbase, tsize) &&
+            (get_segment_flags(sp) & IS_MMAPPED_BIT) == mmap_flag) {
+          char* oldbase = sp->base;
+          sp->base = tbase;
+          sp->size += tsize;
+          return prepend_alloc(m, tbase, oldbase, nb);
+        }
+        else
+          add_segment(m, tbase, tsize, mmap_flag);
+      }
+    }
+
+    if (nb < m->topsize) { /* Allocate from new or extended top space */
+      size_t rsize = m->topsize -= nb;
+      mchunkptr p = m->top;
+      mchunkptr r = m->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+      check_top_chunk(m, m->top);
+      check_malloced_chunk(m, chunk2mem(p), nb);
+      return chunk2mem(p);
+    }
+  }
+
+  MALLOC_FAILURE_ACTION;
+  return 0;
+}
+
+/* -----------------------  system deallocation -------------------------- */
+
+/* Unmap and unlink any mmapped segments that don't contain used chunks */
+static size_t release_unused_segments(mstate m) {
+  size_t released = 0;
+  msegmentptr pred = &m->seg;
+  msegmentptr sp = pred->next;
+  while (sp != 0) {
+    char* base = sp->base;
+    size_t size = sp->size;
+    msegmentptr next = sp->next;
+    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
+      mchunkptr p = align_as_chunk(base);
+      size_t psize = chunksize(p);
+      /* Can unmap if first chunk holds entire segment and not pinned */
+      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
+        tchunkptr tp = (tchunkptr)p;
+        assert(segment_holds(sp, (char*)sp));
+        if (p == m->dv) {
+          m->dv = 0;
+          m->dvsize = 0;
+        }
+        else {
+          unlink_large_chunk(m, tp);
+        }
+        if (CALL_MUNMAP(base, size) == 0) {
+          released += size;
+          m->footprint -= size;
+          /* unlink obsoleted record */
+          sp = pred;
+          sp->next = next;
+        }
+        else { /* back out if cannot unmap */
+          insert_large_chunk(m, tp, psize);
+        }
+      }
+    }
+    pred = sp;
+    sp = next;
+  }
+  return released;
+}
+
+static int sys_trim(mstate m, size_t pad) {
+  size_t released = 0;
+  if (pad < MAX_REQUEST && is_initialized(m)) {
+    pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */
+
+    if (m->topsize > pad) {
+      /* Shrink top space in granularity-size units, keeping at least one */
+      size_t unit = mparams.granularity;
+      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
+                      SIZE_T_ONE) * unit;
+      msegmentptr sp = segment_holding(m, (char*)m->top);
+
+      if (!is_extern_segment(sp)) {
+        if (is_mmapped_segment(sp)) {
+          if (HAVE_MMAP &&
+              sp->size >= extra &&
+              !has_segment_link(m, sp)) { /* can't shrink if pinned */
+            size_t newsize = sp->size - extra;
+            /* Prefer mremap, fall back to munmap */
+            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
+                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
+              released = extra;
+            }
+          }
+        }
+        else if (HAVE_MORECORE) {
+          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
+            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
+          ACQUIRE_MORECORE_LOCK();
+          {
+            /* Make sure end of memory is where we last set it. */
+            char* old_br = (char*)(CALL_MORECORE(0));
+            if (old_br == sp->base + sp->size) {
+              char* rel_br = (char*)(CALL_MORECORE(-extra));
+              char* new_br = (char*)(CALL_MORECORE(0));
+              if (rel_br != CMFAIL && new_br < old_br)
+                released = old_br - new_br;
+            }
+          }
+          RELEASE_MORECORE_LOCK();
+        }
+      }
+
+      if (released != 0) {
+        sp->size -= released;
+        m->footprint -= released;
+        init_top(m, m->top, m->topsize - released);
+        check_top_chunk(m, m->top);
+      }
+    }
+
+    /* Unmap any unused mmapped segments */
+    if (HAVE_MMAP) 
+      released += release_unused_segments(m);
+
+    /* On failure, disable autotrim to avoid repeated failed future calls */
+    if (released == 0)
+      m->trim_check = MAX_SIZE_T;
+  }
+
+  return (released != 0)? 1 : 0;
+}
+
+/* ---------------------------- malloc support --------------------------- */
+
+/* allocate a large request from the best fitting chunk in a treebin */
+static void* tmalloc_large(mstate m, size_t nb) {
+  tchunkptr v = 0;
+  size_t rsize = -nb; /* Unsigned negation */
+  tchunkptr t;
+  bindex_t idx;
+  compute_tree_index(nb, idx);
+
+  if ((t = *treebin_at(m, idx)) != 0) {
+    /* Traverse tree for this bin looking for node with size == nb */
+    size_t sizebits = nb << leftshift_for_tree_index(idx);
+    tchunkptr rst = 0;  /* The deepest untaken right subtree */
+    for (;;) {
+      tchunkptr rt;
+      size_t trem = chunksize(t) - nb;
+      if (trem < rsize) {
+        v = t;
+        if ((rsize = trem) == 0)
+          break;
+      }
+      rt = t->child[1];
+      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+      if (rt != 0 && rt != t)
+        rst = rt;
+      if (t == 0) {
+        t = rst; /* set t to least subtree holding sizes > nb */
+        break;
+      }
+      sizebits <<= 1;
+    }
+  }
+
+  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
+    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
+    if (leftbits != 0) {
+      bindex_t i;
+      binmap_t leastbit = least_bit(leftbits);
+      compute_bit2idx(leastbit, i);
+      t = *treebin_at(m, i);
+    }
+  }
+
+  while (t != 0) { /* find smallest of tree or subtree */
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+    t = leftmost_child(t);
+  }
+
+  /*  If dv is a better fit, return 0 so malloc will use it */
+  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
+    if (RTCHECK(ok_address(m, v))) { /* split */
+      mchunkptr r = chunk_plus_offset(v, nb);
+      assert(chunksize(v) == rsize + nb);
+      if (RTCHECK(ok_next(v, r))) {
+        unlink_large_chunk(m, v);
+        if (rsize < MIN_CHUNK_SIZE)
+          set_inuse_and_pinuse(m, v, (rsize + nb));
+        else {
+          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+          set_size_and_pinuse_of_free_chunk(r, rsize);
+          insert_chunk(m, r, rsize);
+        }
+        return chunk2mem(v);
+      }
+    }
+    CORRUPTION_ERROR_ACTION(m);
+  }
+  return 0;
+}
+
+/* allocate a small request from the best fitting chunk in a treebin */
+static void* tmalloc_small(mstate m, size_t nb) {
+  tchunkptr t, v;
+  size_t rsize;
+  bindex_t i;
+  binmap_t leastbit = least_bit(m->treemap);
+  compute_bit2idx(leastbit, i);
+
+  v = t = *treebin_at(m, i);
+  rsize = chunksize(t) - nb;
+
+  while ((t = leftmost_child(t)) != 0) {
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+  }
+
+  if (RTCHECK(ok_address(m, v))) {
+    mchunkptr r = chunk_plus_offset(v, nb);
+    assert(chunksize(v) == rsize + nb);
+    if (RTCHECK(ok_next(v, r))) {
+      unlink_large_chunk(m, v);
+      if (rsize < MIN_CHUNK_SIZE)
+        set_inuse_and_pinuse(m, v, (rsize + nb));
+      else {
+        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        replace_dv(m, r, rsize);
+      }
+      return chunk2mem(v);
+    }
+  }
+
+  CORRUPTION_ERROR_ACTION(m);
+  return 0;
+}
+
+/* --------------------------- realloc support --------------------------- */
+
+static void* internal_realloc(mstate m, void* oldmem, size_t bytes) {
+  if (bytes >= MAX_REQUEST) {
+    MALLOC_FAILURE_ACTION;
+    return 0;
+  }
+  if (!PREACTION(m)) {
+    mchunkptr oldp = mem2chunk(oldmem);
+    size_t oldsize = chunksize(oldp);
+    mchunkptr next = chunk_plus_offset(oldp, oldsize);
+    mchunkptr newp = 0;
+    void* extra = 0;
+
+    /* Try to either shrink or extend into top. Else malloc-copy-free */
+
+    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&
+                ok_next(oldp, next) && ok_pinuse(next))) {
+      size_t nb = request2size(bytes);
+      if (is_mmapped(oldp))
+        newp = mmap_resize(m, oldp, nb);
+      else if (oldsize >= nb) { /* already big enough */
+        size_t rsize = oldsize - nb;
+        newp = oldp;
+        if (rsize >= MIN_CHUNK_SIZE) {
+          mchunkptr remainder = chunk_plus_offset(newp, nb);
+          set_inuse(m, newp, nb);
+          set_inuse(m, remainder, rsize);
+          extra = chunk2mem(remainder);
+        }
+      }
+      else if (next == m->top && oldsize + m->topsize > nb) {
+        /* Expand into top */
+        size_t newsize = oldsize + m->topsize;
+        size_t newtopsize = newsize - nb;
+        mchunkptr newtop = chunk_plus_offset(oldp, nb);
+        set_inuse(m, oldp, nb);
+        newtop->head = newtopsize |PINUSE_BIT;
+        m->top = newtop;
+        m->topsize = newtopsize;
+        newp = oldp;
+      }
+    }
+    else {
+      USAGE_ERROR_ACTION(m, oldmem);
+      POSTACTION(m);
+      return 0;
+    }
+
+    POSTACTION(m);
+
+    if (newp != 0) {
+      if (extra != 0) {
+        internal_free(m, extra);
+      }
+      check_inuse_chunk(m, newp);
+      return chunk2mem(newp);
+    }
+    else {
+      void* newmem = internal_malloc(m, bytes);
+      if (newmem != 0) {
+        size_t oc = oldsize - overhead_for(oldp);
+        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);
+        internal_free(m, oldmem);
+      }
+      return newmem;
+    }
+  }
+  return 0;
+}
+
+/* --------------------------- memalign support -------------------------- */
+
+static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
+  if (alignment <= MALLOC_ALIGNMENT)    /* Can just use malloc */
+    return internal_malloc(m, bytes);
+  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
+    alignment = MIN_CHUNK_SIZE;
+  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
+    size_t a = MALLOC_ALIGNMENT << 1;
+    while (a < alignment) a <<= 1;
+    alignment = a;
+  }
+  
+  if (bytes >= MAX_REQUEST - alignment) {
+    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
+      MALLOC_FAILURE_ACTION;
+    }
+  }
+  else {
+    size_t nb = request2size(bytes);
+    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
+    char* mem = (char*)internal_malloc(m, req);
+    if (mem != 0) {
+      void* leader = 0;
+      void* trailer = 0;
+      mchunkptr p = mem2chunk(mem);
+
+      if (PREACTION(m)) return 0;
+      if ((((size_t)(mem)) % alignment) != 0) { /* misaligned */
+        /*
+          Find an aligned spot inside chunk.  Since we need to give
+          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
+          the first calculation places us at a spot with less than
+          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
+          We've allocated enough total room so that this is always
+          possible.
+        */
+        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +
+                                                       alignment -
+                                                       SIZE_T_ONE)) &
+                                             -alignment));
+        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
+          br : br+alignment;
+        mchunkptr newp = (mchunkptr)pos;
+        size_t leadsize = pos - (char*)(p);
+        size_t newsize = chunksize(p) - leadsize;
+
+        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
+          newp->prev_foot = p->prev_foot + leadsize;
+          newp->head = (newsize|CINUSE_BIT);
+        }
+        else { /* Otherwise, give back leader, use the rest */
+          set_inuse(m, newp, newsize);
+          set_inuse(m, p, leadsize);
+          leader = chunk2mem(p);
+        }
+        p = newp;
+      }
+
+      /* Give back spare room at the end */
+      if (!is_mmapped(p)) {
+        size_t size = chunksize(p);
+        if (size > nb + MIN_CHUNK_SIZE) {
+          size_t remainder_size = size - nb;
+          mchunkptr remainder = chunk_plus_offset(p, nb);
+          set_inuse(m, p, nb);
+          set_inuse(m, remainder, remainder_size);
+          trailer = chunk2mem(remainder);
+        }
+      }
+
+      assert (chunksize(p) >= nb);
+      assert((((size_t)(chunk2mem(p))) % alignment) == 0);
+      check_inuse_chunk(m, p);
+      POSTACTION(m);
+      if (leader != 0) {
+        internal_free(m, leader);
+      }
+      if (trailer != 0) {
+        internal_free(m, trailer);
+      }
+      return chunk2mem(p);
+    }
+  }
+  return 0;
+}
+
+/* ------------------------ comalloc/coalloc support --------------------- */
+
+static void** ialloc(mstate m,
+                     size_t n_elements,
+                     size_t* sizes,
+                     int opts,
+                     void* chunks[]) {
+  /*
+    This provides common support for independent_X routines, handling
+    all of the combinations that can result.
+
+    The opts arg has:
+    bit 0 set if all elements are same size (using sizes[0])
+    bit 1 set if elements should be zeroed
+  */
+
+  size_t    element_size;   /* chunksize of each element, if all same */
+  size_t    contents_size;  /* total size of elements */
+  size_t    array_size;     /* request size of pointer array */
+  void*     mem;            /* malloced aggregate space */
+  mchunkptr p;              /* corresponding chunk */
+  size_t    remainder_size; /* remaining bytes while splitting */
+  void**    marray;         /* either "chunks" or malloced ptr array */
+  mchunkptr array_chunk;    /* chunk for malloced ptr array */
+  flag_t    was_enabled;    /* to disable mmap */
+  size_t    size;
+  size_t    i;
+
+  /* compute array length, if needed */
+  if (chunks != 0) {
+    if (n_elements == 0)
+      return chunks; /* nothing to do */
+    marray = chunks;
+    array_size = 0;
+  }
+  else {
+    /* if empty req, must still return chunk representing empty array */
+    if (n_elements == 0)
+      return (void**)internal_malloc(m, 0);
+    marray = 0;
+    array_size = request2size(n_elements * (sizeof(void*)));
+  }
+
+  /* compute total element size */
+  if (opts & 0x1) { /* all-same-size */
+    element_size = request2size(*sizes);
+    contents_size = n_elements * element_size;
+  }
+  else { /* add up all the sizes */
+    element_size = 0;
+    contents_size = 0;
+    for (i = 0; i != n_elements; ++i)
+      contents_size += request2size(sizes[i]);
+  }
+
+  size = contents_size + array_size;
+
+  /*
+     Allocate the aggregate chunk.  First disable direct-mmapping so
+     malloc won't use it, since we would not be able to later
+     free/realloc space internal to a segregated mmap region.
+  */
+  was_enabled = use_mmap(m);
+  disable_mmap(m);
+  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
+  if (was_enabled)
+    enable_mmap(m);
+  if (mem == 0)
+    return 0;
+
+  if (PREACTION(m)) return 0;
+  p = mem2chunk(mem);
+  remainder_size = chunksize(p);
+
+  assert(!is_mmapped(p));
+
+  if (opts & 0x2) {       /* optionally clear the elements */
+    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
+  }
+
+  /* If not provided, allocate the pointer array as final part of chunk */
+  if (marray == 0) {
+    size_t  array_chunk_size;
+    array_chunk = chunk_plus_offset(p, contents_size);
+    array_chunk_size = remainder_size - contents_size;
+    marray = (void**) (chunk2mem(array_chunk));
+    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
+    remainder_size = contents_size;
+  }
+
+  /* split out elements */
+  for (i = 0; ; ++i) {
+    marray[i] = chunk2mem(p);
+    if (i != n_elements-1) {
+      if (element_size != 0)
+        size = element_size;
+      else
+        size = request2size(sizes[i]);
+      remainder_size -= size;
+      set_size_and_pinuse_of_inuse_chunk(m, p, size);
+      p = chunk_plus_offset(p, size);
+    }
+    else { /* the final element absorbs any overallocation slop */
+      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
+      break;
+    }
+  }
+
+#if DEBUG
+  if (marray != chunks) {
+    /* final element must have exactly exhausted chunk */
+    if (element_size != 0) {
+      assert(remainder_size == element_size);
+    }
+    else {
+      assert(remainder_size == request2size(sizes[i]));
+    }
+    check_inuse_chunk(m, mem2chunk(marray));
+  }
+  for (i = 0; i != n_elements; ++i)
+    check_inuse_chunk(m, mem2chunk(marray[i]));
+
+#endif /* DEBUG */
+
+  POSTACTION(m);
+  return marray;
+}
+
+
+/* -------------------------- public routines ---------------------------- */
+
+#if !ONLY_MSPACES
+
+void* dlmalloc(size_t bytes) {
+  /*
+     Basic algorithm:
+     If a small request (< 256 bytes minus per-chunk overhead):
+       1. If one exists, use a remainderless chunk in associated smallbin.
+          (Remainderless means that there are too few excess bytes to
+          represent as a chunk.)
+       2. If it is big enough, use the dv chunk, which is normally the
+          chunk adjacent to the one used for the most recent small request.
+       3. If one exists, split the smallest available chunk in a bin,
+          saving remainder in dv.
+       4. If it is big enough, use the top chunk.
+       5. If available, get memory from system and use it
+     Otherwise, for a large request:
+       1. Find the smallest available binned chunk that fits, and use it
+          if it is better fitting than dv chunk, splitting if necessary.
+       2. If better fitting than any binned chunk, use the dv chunk.
+       3. If it is big enough, use the top chunk.
+       4. If request size >= mmap threshold, try to directly mmap this chunk.
+       5. If available, get memory from system and use it
+
+     The ugly goto's here ensure that postaction occurs along all paths.
+  */
+
+  if (!PREACTION(gm)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = gm->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(gm, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(gm, b, p, idx);
+        set_inuse_and_pinuse(gm, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > gm->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(gm, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(gm, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(gm, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(gm, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+
+        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= gm->dvsize) {
+      size_t rsize = gm->dvsize - nb;
+      mchunkptr p = gm->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
+        gm->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = gm->dvsize;
+        gm->dvsize = 0;
+        gm->dv = 0;
+        set_inuse_and_pinuse(gm, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < gm->topsize) { /* Split top */
+      size_t rsize = gm->topsize -= nb;
+      mchunkptr p = gm->top;
+      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(gm, gm->top);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(gm, nb);
+
+  postaction:
+    POSTACTION(gm);
+    return mem;
+  }
+
+  return 0;
+}
+
+void dlfree(void* mem) {
+  /*
+     Consolidate freed chunks with preceding or succeeding bordering
+     free chunks, if they exist, and then place in a bin.  Intermixed
+     with special cases for top, dv, mmapped chunks, and usage errors.
+  */
+
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+#else /* FOOTERS */
+#define fm gm
+#endif /* FOOTERS */
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if ((prevsize & IS_MMAPPED_BIT) != 0) {
+            prevsize &= ~IS_MMAPPED_BIT;
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+          insert_chunk(fm, p, psize);
+          check_free_chunk(fm, p);
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+#if !FOOTERS
+#undef fm
+#endif /* FOOTERS */
+}
+
+void* dlcalloc(size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = dlmalloc(req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+void* dlrealloc(void* oldmem, size_t bytes) {
+  if (oldmem == 0)
+    return dlmalloc(bytes);
+#ifdef REALLOC_ZERO_BYTES_FREES
+  if (bytes == 0) {
+    dlfree(oldmem);
+    return 0;
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+#if ! FOOTERS
+    mstate m = gm;
+#else /* FOOTERS */
+    mstate m = get_mstate_for(mem2chunk(oldmem));
+    if (!ok_magic(m)) {
+      USAGE_ERROR_ACTION(m, oldmem);
+      return 0;
+    }
+#endif /* FOOTERS */
+    return internal_realloc(m, oldmem, bytes);
+  }
+}
+
+void* dlmemalign(size_t alignment, size_t bytes) {
+  return internal_memalign(gm, alignment, bytes);
+}
+
+void** dlindependent_calloc(size_t n_elements, size_t elem_size,
+                                 void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  return ialloc(gm, n_elements, &sz, 3, chunks);
+}
+
+void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
+                                   void* chunks[]) {
+  return ialloc(gm, n_elements, sizes, 0, chunks);
+}
+
+void* dlvalloc(size_t bytes) {
+  size_t pagesz;
+  init_mparams();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, bytes);
+}
+
+void* dlpvalloc(size_t bytes) {
+  size_t pagesz;
+  init_mparams();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
+}
+
+int dlmalloc_trim(size_t pad) {
+  int result = 0;
+  if (!PREACTION(gm)) {
+    result = sys_trim(gm, pad);
+    POSTACTION(gm);
+  }
+  return result;
+}
+
+size_t dlmalloc_footprint(void) {
+  return gm->footprint;
+}
+
+size_t dlmalloc_max_footprint(void) {
+  return gm->max_footprint;
+}
+
+#if !NO_MALLINFO
+struct mallinfo dlmallinfo(void) {
+  return internal_mallinfo(gm);
+}
+#endif /* NO_MALLINFO */
+
+void dlmalloc_stats(void) {
+  internal_malloc_stats(gm);
+}
+
+size_t dlmalloc_usable_size(void* mem) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    if (cinuse(p))
+      return chunksize(p) - overhead_for(p);
+  }
+  return 0;
+}
+
+int dlmallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+#endif /* !ONLY_MSPACES */
+
+/* ----------------------------- user mspaces ---------------------------- */
+
+#if MSPACES
+
+static mstate init_user_mstate(char* tbase, size_t tsize) {
+  size_t msize = pad_request(sizeof(struct malloc_state));
+  mchunkptr mn;
+  mchunkptr msp = align_as_chunk(tbase);
+  mstate m = (mstate)(chunk2mem(msp));
+  memset(m, 0, msize);
+  INITIAL_LOCK(&m->mutex);
+  msp->head = (msize|PINUSE_BIT|CINUSE_BIT);
+  m->seg.base = m->least_addr = tbase;
+  m->seg.size = m->footprint = m->max_footprint = tsize;
+  m->magic = mparams.magic;
+  m->mflags = mparams.default_mflags;
+  disable_contiguous(m);
+  init_bins(m);
+  mn = next_chunk(mem2chunk(m));
+  init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
+  check_top_chunk(m, m->top);
+  return m;
+}
+
+mspace create_mspace(size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize = pad_request(sizeof(struct malloc_state));
+  init_mparams(); /* Ensure pagesize etc initialized */
+
+  if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    size_t rs = ((capacity == 0)? mparams.granularity :
+                 (capacity + TOP_FOOT_SIZE + msize));
+    size_t tsize = granularity_align(rs);
+    char* tbase = (char*)(CALL_MMAP(tsize));
+    if (tbase != CMFAIL) {
+      m = init_user_mstate(tbase, tsize);
+      set_segment_flags(&m->seg, IS_MMAPPED_BIT);
+      set_lock(m, locked);
+    }
+  }
+  return (mspace)m;
+}
+
+mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize = pad_request(sizeof(struct malloc_state));
+  init_mparams(); /* Ensure pagesize etc initialized */
+
+  if (capacity > msize + TOP_FOOT_SIZE &&
+      capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    m = init_user_mstate((char*)base, capacity);
+    set_segment_flags(&m->seg, EXTERN_BIT);
+    set_lock(m, locked);
+  }
+  return (mspace)m;
+}
+
+size_t destroy_mspace(mspace msp) {
+  size_t freed = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    msegmentptr sp = &ms->seg;
+    while (sp != 0) {
+      char* base = sp->base;
+      size_t size = sp->size;
+      flag_t flag = get_segment_flags(sp);
+      sp = sp->next;
+      if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&
+          CALL_MUNMAP(base, size) == 0)
+        freed += size;
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return freed;
+}
+
+/*
+  mspace versions of routines are near-clones of the global
+  versions. This is not so nice but better than the alternatives.
+*/
+
+
+void* mspace_malloc(mspace msp, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (!PREACTION(ms)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = ms->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(ms, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(ms, b, p, idx);
+        set_inuse_and_pinuse(ms, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > ms->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(ms, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(ms, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(ms, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(ms, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+
+        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= ms->dvsize) {
+      size_t rsize = ms->dvsize - nb;
+      mchunkptr p = ms->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
+        ms->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = ms->dvsize;
+        ms->dvsize = 0;
+        ms->dv = 0;
+        set_inuse_and_pinuse(ms, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < ms->topsize) { /* Split top */
+      size_t rsize = ms->topsize -= nb;
+      mchunkptr p = ms->top;
+      mchunkptr r = ms->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(ms, ms->top);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(ms, nb);
+
+  postaction:
+    POSTACTION(ms);
+    return mem;
+  }
+
+  return 0;
+}
+
+void mspace_free(mspace msp, void* mem) {
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+#else /* FOOTERS */
+    mstate fm = (mstate)msp;
+#endif /* FOOTERS */
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if ((prevsize & IS_MMAPPED_BIT) != 0) {
+            prevsize &= ~IS_MMAPPED_BIT;
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+          insert_chunk(fm, p, psize);
+          check_free_chunk(fm, p);
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+}
+
+void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = internal_malloc(ms, req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
+  if (oldmem == 0)
+    return mspace_malloc(msp, bytes);
+#ifdef REALLOC_ZERO_BYTES_FREES
+  if (bytes == 0) {
+    mspace_free(msp, oldmem);
+    return 0;
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+#if FOOTERS
+    mchunkptr p  = mem2chunk(oldmem);
+    mstate ms = get_mstate_for(p);
+#else /* FOOTERS */
+    mstate ms = (mstate)msp;
+#endif /* FOOTERS */
+    if (!ok_magic(ms)) {
+      USAGE_ERROR_ACTION(ms,ms);
+      return 0;
+    }
+    return internal_realloc(ms, oldmem, bytes);
+  }
+}
+
+void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return internal_memalign(ms, alignment, bytes);
+}
+
+void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, &sz, 3, chunks);
+}
+
+void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, sizes, 0, chunks);
+}
+
+int mspace_trim(mspace msp, size_t pad) {
+  int result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (!PREACTION(ms)) {
+      result = sys_trim(ms, pad);
+      POSTACTION(ms);
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+void mspace_malloc_stats(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    internal_malloc_stats(ms);
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+}
+
+size_t mspace_footprint(mspace msp) {
+  size_t result;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->footprint;
+  }
+  USAGE_ERROR_ACTION(ms,ms);
+  return result;
+}
+
+
+size_t mspace_max_footprint(mspace msp) {
+  size_t result;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->max_footprint;
+  }
+  USAGE_ERROR_ACTION(ms,ms);
+  return result;
+}
+
+
+#if !NO_MALLINFO
+struct mallinfo mspace_mallinfo(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return internal_mallinfo(ms);
+}
+#endif /* NO_MALLINFO */
+
+int mspace_mallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+#endif /* MSPACES */
+
+/* -------------------- Alternative MORECORE functions ------------------- */
+
+/*
+  Guidelines for creating a custom version of MORECORE:
+
+  * For best performance, MORECORE should allocate in multiples of pagesize.
+  * MORECORE may allocate more memory than requested. (Or even less,
+      but this will usually result in a malloc failure.)
+  * MORECORE must not allocate memory when given argument zero, but
+      instead return one past the end address of memory from previous
+      nonzero call.
+  * For best performance, consecutive calls to MORECORE with positive
+      arguments should return increasing addresses, indicating that
+      space has been contiguously extended.
+  * Even though consecutive calls to MORECORE need not return contiguous
+      addresses, it must be OK for malloc'ed chunks to span multiple
+      regions in those cases where they do happen to be contiguous.
+  * MORECORE need not handle negative arguments -- it may instead
+      just return MFAIL when given negative arguments.
+      Negative arguments are always multiples of pagesize. MORECORE
+      must not misinterpret negative args as large positive unsigned
+      args. You can suppress all such calls from even occurring by defining
+      MORECORE_CANNOT_TRIM,
+
+  As an example alternative MORECORE, here is a custom allocator
+  kindly contributed for pre-OSX macOS.  It uses virtually but not
+  necessarily physically contiguous non-paged memory (locked in,
+  present and won't get swapped out).  You can use it by uncommenting
+  this section, adding some #includes, and setting up the appropriate
+  defines above:
+
+      #define MORECORE osMoreCore
+
+  There is also a shutdown routine that should somehow be called for
+  cleanup upon program exit.
+
+  #define MAX_POOL_ENTRIES 100
+  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
+  static int next_os_pool;
+  void *our_os_pools[MAX_POOL_ENTRIES];
+
+  void *osMoreCore(int size)
+  {
+    void *ptr = 0;
+    static void *sbrk_top = 0;
+
+    if (size > 0)
+    {
+      if (size < MINIMUM_MORECORE_SIZE)
+         size = MINIMUM_MORECORE_SIZE;
+      if (CurrentExecutionLevel() == kTaskLevel)
+         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
+      if (ptr == 0)
+      {
+        return (void *) MFAIL;
+      }
+      // save ptrs so they can be freed during cleanup
+      our_os_pools[next_os_pool] = ptr;
+      next_os_pool++;
+      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
+      sbrk_top = (char *) ptr + size;
+      return ptr;
+    }
+    else if (size < 0)
+    {
+      // we don't currently support shrink behavior
+      return (void *) MFAIL;
+    }
+    else
+    {
+      return sbrk_top;
+    }
+  }
+
+  // cleanup any allocated memory pools
+  // called as last thing before shutting down driver
+
+  void osCleanupMem(void)
+  {
+    void **ptr;
+
+    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)
+      if (*ptr)
+      {
+         PoolDeallocate(*ptr);
+         *ptr = 0;
+      }
+  }
+
+*/
+
+
+/* -----------------------------------------------------------------------
+History:
+    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
+      * Add max_footprint functions
+      * Ensure all appropriate literals are size_t
+      * Fix conditional compilation problem for some #define settings
+      * Avoid concatenating segments with the one provided
+        in create_mspace_with_base
+      * Rename some variables to avoid compiler shadowing warnings
+      * Use explicit lock initialization.
+      * Better handling of sbrk interference.
+      * Simplify and fix segment insertion, trimming and mspace_destroy
+      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
+      * Thanks especially to Dennis Flanagan for help on these.
+
+    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
+      * Fix memalign brace error.
+
+    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
+      * Fix improper #endif nesting in C++
+      * Add explicit casts needed for C++
+
+    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
+      * Use trees for large bins
+      * Support mspaces
+      * Use segments to unify sbrk-based and mmap-based system allocation,
+        removing need for emulation on most platforms without sbrk.
+      * Default safety checks
+      * Optional footer checks. Thanks to William Robertson for the idea.
+      * Internal code refactoring
+      * Incorporate suggestions and platform-specific changes.
+        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
+        Aaron Bachmann,  Emery Berger, and others.
+      * Speed up non-fastbin processing enough to remove fastbins.
+      * Remove useless cfree() to avoid conflicts with other apps.
+      * Remove internal memcpy, memset. Compilers handle builtins better.
+      * Remove some options that no one ever used and rename others.
+
+    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
+      * Fix malloc_state bitmap array misdeclaration
+
+    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
+      * Allow tuning of FIRST_SORTED_BIN_SIZE
+      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.
+      * Better detection and support for non-contiguousness of MORECORE.
+        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
+      * Bypass most of malloc if no frees. Thanks To Emery Berger.
+      * Fix freeing of old top non-contiguous chunk im sysmalloc.
+      * Raised default trim and map thresholds to 256K.
+      * Fix mmap-related #defines. Thanks to Lubos Lunak.
+      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
+      * Branch-free bin calculation
+      * Default trim and mmap thresholds now 256K.
+
+    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
+      * Introduce independent_comalloc and independent_calloc.
+        Thanks to Michael Pachos for motivation and help.
+      * Make optional .h file available
+      * Allow > 2GB requests on 32bit systems.
+      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.
+        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
+        and Anonymous.
+      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
+        helping test this.)
+      * memalign: check alignment arg
+      * realloc: don't try to shift chunks backwards, since this
+        leads to  more fragmentation in some programs and doesn't
+        seem to help in any others.
+      * Collect all cases in malloc requiring system memory into sysmalloc
+      * Use mmap as backup to sbrk
+      * Place all internal state in malloc_state
+      * Introduce fastbins (although similar to 2.5.1)
+      * Many minor tunings and cosmetic improvements
+      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
+      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
+        Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.
+      * Include errno.h to support default failure action.
+
+    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
+      * return null for negative arguments
+      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>
+         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
+          (e.g. WIN32 platforms)
+         * Cleanup header file inclusion for WIN32 platforms
+         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
+         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
+           memory allocation routines
+         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
+         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
+           usage of 'assert' in non-WIN32 code
+         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
+           avoid infinite loop
+      * Always call 'fREe()' rather than 'free()'
+
+    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
+      * Fixed ordering problem with boundary-stamping
+
+    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
+      * Added pvalloc, as recommended by H.J. Liu
+      * Added 64bit pointer support mainly from Wolfram Gloger
+      * Added anonymously donated WIN32 sbrk emulation
+      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
+      * malloc_extend_top: fix mask error that caused wastage after
+        foreign sbrks
+      * Add linux mremap support code from HJ Liu
+
+    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
+      * Integrated most documentation with the code.
+      * Add support for mmap, with help from
+        Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Use last_remainder in more cases.
+      * Pack bins using idea from  colin@nyx10.cs.du.edu
+      * Use ordered bins instead of best-fit threshold
+      * Eliminate block-local decls to simplify tracing and debugging.
+      * Support another case of realloc via move into top
+      * Fix error occurring when initial sbrk_base not word-aligned.
+      * Rely on page size for units instead of SBRK_UNIT to
+        avoid surprises about sbrk alignment conventions.
+      * Add mallinfo, mallopt. Thanks to Raymond Nijssen
+        (raymond@es.ele.tue.nl) for the suggestion.
+      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
+      * More precautions for cases where other routines call sbrk,
+        courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Added macros etc., allowing use in linux libc from
+        H.J. Lu (hjl@gnu.ai.mit.edu)
+      * Inverted this history list
+
+    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
+      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
+      * Removed all preallocation code since under current scheme
+        the work required to undo bad preallocations exceeds
+        the work saved in good cases for most test programs.
+      * No longer use return list or unconsolidated bins since
+        no scheme using them consistently outperforms those that don't
+        given above changes.
+      * Use best fit for very large chunks to prevent some worst-cases.
+      * Added some support for debugging
+
+    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
+      * Removed footers when chunks are in use. Thanks to
+        Paul Wilson (wilson@cs.texas.edu) for the suggestion.
+
+    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
+      * Added malloc_trim, with help from Wolfram Gloger
+        (wmglo@Dent.MED.Uni-Muenchen.DE).
+
+    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)
+
+    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
+      * realloc: try to expand in both directions
+      * malloc: swap order of clean-bin strategy;
+      * realloc: only conditionally expand backwards
+      * Try not to scavenge used bins
+      * Use bin counts as a guide to preallocation
+      * Occasionally bin return list chunks in first scan
+      * Add a few optimizations from colin@nyx10.cs.du.edu
+
+    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
+      * faster bin computation & slightly different binning
+      * merged all consolidations to one part of malloc proper
+         (eliminating old malloc_find_space & malloc_clean_bin)
+      * Scan 2 returns chunks (not just 1)
+      * Propagate failure in realloc if malloc returns 0
+      * Add stuff to allow compilation on non-ANSI compilers
+          from kpv@research.att.com
+
+    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
+      * removed potential for odd address access in prev_chunk
+      * removed dependency on getpagesize.h
+      * misc cosmetics and a bit more internal documentation
+      * anticosmetics: mangled names in macros to evade debugger strangeness
+      * tested on sparc, hp-700, dec-mips, rs6000
+          with gcc & native cc (hp, dec only) allowing
+          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
+
+    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
+      * Based loosely on libg++-1.2X malloc. (It retains some of the overall
+         structure of old version,  but most details differ.)
+ 
+*/
Index: libffi-3.4.6/src/microblaze/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/microblaze/ffi.c b/libffi-3.4.6/src/microblaze/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/microblaze/ffi.c	
@@ -0,0 +1,321 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2012, 2013 Xilinx, Inc
+
+   MicroBlaze Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+extern void ffi_call_SYSV(void (*)(void*, extended_cif*), extended_cif*,
+		unsigned int, unsigned int, unsigned int*, void (*fn)(void),
+		unsigned int, unsigned int);
+
+extern void ffi_closure_SYSV(void);
+
+#define WORD_SIZE			sizeof(unsigned int)
+#define ARGS_REGISTER_SIZE	(WORD_SIZE * 6)
+#define WORD_FFI_ALIGN(x)		FFI_ALIGN(x, WORD_SIZE)
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+void ffi_prep_args(void* stack, extended_cif* ecif)
+{
+	unsigned int i;
+	ffi_type** p_arg;
+	void** p_argv;
+	void* stack_args_p = stack;
+
+	if (ecif == NULL || ecif->cif == NULL) {
+		return; /* no description to prepare */
+	}
+
+	p_argv = ecif->avalue;
+
+	if ((ecif->cif->rtype != NULL) &&
+			(ecif->cif->rtype->type == FFI_TYPE_STRUCT))
+	{
+		/* if return type is a struct which is referenced on the stack/reg5,
+		 * by a pointer. Stored the return value pointer in r5.
+		 */
+		char* addr = stack_args_p;
+		memcpy(addr, &(ecif->rvalue), WORD_SIZE);
+		stack_args_p += WORD_SIZE;
+	}
+
+	if (ecif->avalue == NULL) {
+		return; /* no arguments to prepare */
+	}
+
+	for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;
+			i++, p_arg++)
+	{
+		size_t size = (*p_arg)->size;
+		int type = (*p_arg)->type;
+		void* value = p_argv[i];
+		char* addr = stack_args_p;
+		int aligned_size = WORD_FFI_ALIGN(size);
+
+		/* force word alignment on the stack */
+		stack_args_p += aligned_size;
+		
+		switch (type)
+		{
+			case FFI_TYPE_UINT8:
+				*(unsigned int *)addr = (unsigned int)*(UINT8*)(value);
+				break;
+			case FFI_TYPE_SINT8:
+				*(signed int *)addr = (signed int)*(SINT8*)(value);
+				break;
+			case FFI_TYPE_UINT16:
+				*(unsigned int *)addr = (unsigned int)*(UINT16*)(value);
+				break;
+			case FFI_TYPE_SINT16:
+				*(signed int *)addr = (signed int)*(SINT16*)(value);
+				break;
+			case FFI_TYPE_STRUCT:
+#if __BIG_ENDIAN__
+				/*
+				 * MicroBlaze toolchain appears to emit:
+				 * bsrli r5, r5, 8 (caller)
+				 * ...
+				 * <branch to callee>
+				 * ...
+				 * bslli r5, r5, 8 (callee)
+				 * 
+				 * For structs like "struct a { uint8_t a[3]; };", when passed
+				 * by value.
+				 *
+				 * Structs like "struct b { uint16_t a; };" are also expected
+				 * to be packed strangely in registers.
+				 *
+				 * This appears to be because the microblaze toolchain expects
+				 * "struct b == uint16_t", which is only any issue for big
+				 * endian.
+				 *
+				 * The following is a work around for big-endian only, for the
+				 * above mentioned case, it will re-align the contents of a
+				 * <= 3-byte struct value.
+				 */
+				if (size < WORD_SIZE)
+				{
+				  memcpy (addr + (WORD_SIZE - size), value, size);
+				  break;
+				}
+#endif
+			case FFI_TYPE_SINT32:
+			case FFI_TYPE_UINT32:
+			case FFI_TYPE_FLOAT:
+			case FFI_TYPE_SINT64:
+			case FFI_TYPE_UINT64:
+			case FFI_TYPE_DOUBLE:
+			default:
+				memcpy(addr, value, aligned_size);
+		}
+	}
+}
+
+ffi_status ffi_prep_cif_machdep(ffi_cif* cif)
+{
+	/* check ABI */
+	switch (cif->abi)
+	{
+		case FFI_SYSV:
+			break;
+		default:
+			return FFI_BAD_ABI;
+	}
+	return FFI_OK;
+}
+
+void ffi_call(ffi_cif* cif, void (*fn)(void), void* rvalue, void** avalue)
+{
+	extended_cif ecif;
+	ecif.cif = cif;
+	ecif.avalue = avalue;
+
+	/* If the return value is a struct and we don't have a return */
+	/* value address then we need to make one */
+	if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {
+		ecif.rvalue = alloca(cif->rtype->size);
+	} else {
+		ecif.rvalue = rvalue;
+	}
+
+	switch (cif->abi)
+	{
+	case FFI_SYSV:
+		ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags,
+				ecif.rvalue, fn, cif->rtype->type, cif->rtype->size);
+		break;
+	default:
+		FFI_ASSERT(0);
+		break;
+	}
+}
+
+void ffi_closure_call_SYSV(void* register_args, void* stack_args,
+			ffi_closure* closure, void* rvalue,
+			unsigned int* rtype, unsigned int* rsize)
+{
+	/* prepare arguments for closure call */
+	ffi_cif* cif = closure->cif;
+	ffi_type** arg_types = cif->arg_types;
+
+	/* re-allocate data for the args. This needs to be done in order to keep
+	 * multi-word objects (e.g. structs) in contiguous memory. Callers are not
+	 * required to store the value of args in the lower 6 words in the stack
+	 * (although they are allocated in the stack).
+	 */
+	char* stackclone = alloca(cif->bytes);
+	void** avalue = alloca(cif->nargs * sizeof(void*));
+	void* struct_rvalue = NULL;
+	char* ptr = stackclone;
+	int i;
+
+	/* copy registers into stack clone */
+	int registers_used = cif->bytes;
+	if (registers_used > ARGS_REGISTER_SIZE) {
+		registers_used = ARGS_REGISTER_SIZE;
+	}
+	memcpy(stackclone, register_args, registers_used);
+
+	/* copy stack allocated args into stack clone */
+	if (cif->bytes > ARGS_REGISTER_SIZE) {
+		int stack_used = cif->bytes - ARGS_REGISTER_SIZE;
+		memcpy(stackclone + ARGS_REGISTER_SIZE, stack_args, stack_used);
+	}
+
+	/* preserve struct type return pointer passing */
+	if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {
+		struct_rvalue = *((void**)ptr);
+		ptr += WORD_SIZE;
+	}
+
+	/* populate arg pointer list */
+	for (i = 0; i < cif->nargs; i++)
+	{
+		switch (arg_types[i]->type)
+		{
+			case FFI_TYPE_SINT8:
+			case FFI_TYPE_UINT8:
+#ifdef __BIG_ENDIAN__
+				avalue[i] = ptr + 3;
+#else
+				avalue[i] = ptr;
+#endif
+				break;
+			case FFI_TYPE_SINT16:
+			case FFI_TYPE_UINT16:
+#ifdef __BIG_ENDIAN__
+				avalue[i] = ptr + 2;
+#else
+				avalue[i] = ptr;
+#endif
+				break;
+			case FFI_TYPE_STRUCT:
+#if __BIG_ENDIAN__
+				/*
+				 * Work around strange ABI behaviour.
+				 * (see info in ffi_prep_args)
+				 */
+				if (arg_types[i]->size < WORD_SIZE)
+				{
+				  memcpy (ptr, ptr + (WORD_SIZE - arg_types[i]->size), arg_types[i]->size);
+				}
+#endif
+				avalue[i] = (void*)ptr;
+				break;
+			case FFI_TYPE_UINT64:
+			case FFI_TYPE_SINT64:
+			case FFI_TYPE_DOUBLE:
+				avalue[i] = ptr;
+				break;
+			case FFI_TYPE_SINT32:
+			case FFI_TYPE_UINT32:
+			case FFI_TYPE_FLOAT:
+			default:
+				/* default 4-byte argument */
+				avalue[i] = ptr;
+				break;
+		}
+		ptr += WORD_FFI_ALIGN(arg_types[i]->size);
+	}
+
+	/* set the return type info passed back to the wrapper */
+	*rsize = cif->rtype->size;
+	*rtype = cif->rtype->type;
+	if (struct_rvalue != NULL) {
+		closure->fun(cif, struct_rvalue, avalue, closure->user_data);
+		/* copy struct return pointer value into function return value */
+		*((void**)rvalue) = struct_rvalue;
+	} else {
+		closure->fun(cif, rvalue, avalue, closure->user_data);
+	}
+}
+
+ffi_status ffi_prep_closure_loc(
+		ffi_closure* closure, ffi_cif* cif,
+		void (*fun)(ffi_cif*, void*, void**, void*),
+		void* user_data, void* codeloc)
+{
+	unsigned long* tramp = (unsigned long*)&(closure->tramp[0]);
+	unsigned long cls = (unsigned long)codeloc;
+	unsigned long fn = 0;
+	unsigned long fn_closure_call_sysv = (unsigned long)ffi_closure_call_SYSV;
+
+	closure->cif = cif;
+	closure->fun = fun;
+	closure->user_data = user_data;
+
+	switch (cif->abi)
+	{
+	case FFI_SYSV:
+		fn = (unsigned long)ffi_closure_SYSV;
+
+		/* load r11 (temp) with fn */
+		/* imm fn(upper) */
+		tramp[0] = 0xb0000000 | ((fn >> 16) & 0xffff);
+		/* addik r11, r0, fn(lower) */
+		tramp[1] = 0x31600000 | (fn & 0xffff);
+
+		/* load r12 (temp) with cls */
+		/* imm cls(upper) */
+		tramp[2] = 0xb0000000 | ((cls >> 16) & 0xffff);
+		/* addik r12, r0, cls(lower) */
+		tramp[3] = 0x31800000 | (cls & 0xffff);
+
+		/* load r3 (temp) with ffi_closure_call_SYSV */
+		/* imm fn_closure_call_sysv(upper) */
+		tramp[4] = 0xb0000000 | ((fn_closure_call_sysv >> 16) & 0xffff);
+		/* addik r3, r0, fn_closure_call_sysv(lower) */
+		tramp[5] = 0x30600000 | (fn_closure_call_sysv & 0xffff);
+		/* branch/jump to address stored in r11 (fn) */
+		tramp[6] = 0x98085800; /* bra r11 */
+
+		break;
+	default:
+		return FFI_BAD_ABI;
+	}
+	return FFI_OK;
+}
Index: libffi-3.4.6/src/microblaze/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/microblaze/sysv.S b/libffi-3.4.6/src/microblaze/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/microblaze/sysv.S	
@@ -0,0 +1,302 @@
+/* -----------------------------------------------------------------------
+   sysv.S - Copyright (c) 2012, 2013 Xilinx, Inc
+
+   MicroBlaze Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	/*
+	 * arg[0] (r5)  = ffi_prep_args,
+	 * arg[1] (r6)  = &ecif,
+	 * arg[2] (r7)  = cif->bytes,
+	 * arg[3] (r8)  = cif->flags,
+	 * arg[4] (r9)  = ecif.rvalue,
+	 * arg[5] (r10) = fn
+	 * arg[6] (sp[0]) = cif->rtype->type
+	 * arg[7] (sp[4]) = cif->rtype->size
+	 */
+	.text
+	.globl ffi_call_SYSV
+	.type ffi_call_SYSV, @function
+ffi_call_SYSV:
+	/* push callee saves */
+	addik r1, r1, -20
+	swi r19, r1, 0 /* Frame Pointer */
+	swi r20, r1, 4 /* PIC register */
+	swi r21, r1, 8 /* PIC register */
+	swi r22, r1, 12 /* save for locals */
+	swi r23, r1, 16 /* save for locals */
+	
+	/* save the r5-r10 registers in the stack */
+	addik r1, r1, -24 /* increment sp to store 6x 32-bit words */
+	swi r5, r1, 0
+	swi r6, r1, 4
+	swi r7, r1, 8
+	swi r8, r1, 12
+	swi r9, r1, 16
+	swi r10, r1, 20
+
+	/* save function pointer */
+	addik r3, r5, 0 /* copy ffi_prep_args into r3 */
+	addik r22, r1, 0 /* save sp for unallocated args into r22 (callee-saved) */
+	addik r23, r10, 0 /* save function address into r23 (callee-saved) */
+
+	/* prepare stack with allocation for n (bytes = r7) args */
+	rsub r1, r7, r1 /* subtract bytes from sp */
+
+	/* prep args for ffi_prep_args call */
+	addik r5, r1, 0 /* store stack pointer into arg[0] */
+	/* r6 still holds ecif for arg[1] */
+
+	/* Call ffi_prep_args(stack, &ecif). */
+	addik r1, r1, -4
+	swi r15, r1, 0 /* store the link register in the frame */
+	brald r15, r3
+	nop /* branch has delay slot */
+	lwi r15, r1, 0
+	addik r1, r1, 4 /* restore the link register from the frame */
+	/* returns calling stack pointer location */
+
+	/* prepare args for fn call, prep_args populates them onto the stack */
+	lwi r5, r1, 0 /* arg[0] */
+	lwi r6, r1, 4 /* arg[1] */
+	lwi r7, r1, 8 /* arg[2] */
+	lwi r8, r1, 12 /* arg[3] */
+	lwi r9, r1, 16 /* arg[4] */
+	lwi r10, r1, 20 /* arg[5] */
+
+	/* call (fn) (...). */
+	addik r1, r1, -4
+	swi r15, r1, 0 /* store the link register in the frame */
+	brald r15, r23
+	nop /* branch has delay slot */
+	lwi r15, r1, 0
+	addik r1, r1, 4 /* restore the link register from the frame */
+
+	/* Remove the space we pushed for the args. */
+	addik r1, r22, 0 /* restore old SP */
+
+	/* restore this functions parameters */
+	lwi r5, r1, 0 /* arg[0] */
+	lwi r6, r1, 4 /* arg[1] */
+	lwi r7, r1, 8 /* arg[2] */
+	lwi r8, r1, 12 /* arg[3] */
+	lwi r9, r1, 16 /* arg[4] */
+	lwi r10, r1, 20 /* arg[5] */
+	addik r1, r1, 24 /* decrement sp to de-allocate 6x 32-bit words */
+
+	/* If the return value pointer is NULL, assume no return value. */
+	beqi r9, ffi_call_SYSV_end
+
+	lwi r22, r1, 48 /* get return type (20 for locals + 28 for arg[6]) */
+	lwi r23, r1, 52 /* get return size (20 for locals + 32 for arg[7])  */
+	
+	/* Check if return type is actually a struct, do nothing */
+	rsubi r11, r22, FFI_TYPE_STRUCT
+	beqi r11, ffi_call_SYSV_end
+
+	/* Return 8bit */
+	rsubi r11, r23, 1
+	beqi r11, ffi_call_SYSV_store8
+
+	/* Return 16bit */
+	rsubi r11, r23, 2
+	beqi r11, ffi_call_SYSV_store16
+
+	/* Return 32bit */
+	rsubi r11, r23, 4
+	beqi r11, ffi_call_SYSV_store32
+
+	/* Return 64bit */
+	rsubi r11, r23, 8
+	beqi r11, ffi_call_SYSV_store64
+
+	/* Didn't match anything */
+	bri ffi_call_SYSV_end
+
+ffi_call_SYSV_store64:
+	swi r3, r9, 0 /* store word r3 into return value */
+	swi r4, r9, 4 /* store word r4 into return value */
+	bri ffi_call_SYSV_end
+
+ffi_call_SYSV_store32:
+	swi r3, r9, 0 /* store word r3 into return value */
+	bri ffi_call_SYSV_end
+
+ffi_call_SYSV_store16:
+#ifdef __BIG_ENDIAN__
+	shi r3, r9, 2 /* store half-word r3 into return value */
+#else
+	shi r3, r9, 0 /* store half-word r3 into return value */
+#endif
+	bri ffi_call_SYSV_end
+
+ffi_call_SYSV_store8:
+#ifdef __BIG_ENDIAN__
+	sbi r3, r9, 3 /* store byte r3 into return value */
+#else
+	sbi r3, r9, 0 /* store byte r3 into return value */
+#endif
+	bri ffi_call_SYSV_end
+
+ffi_call_SYSV_end:
+	/* callee restores */
+	lwi r19, r1, 0 /* frame pointer */
+	lwi r20, r1, 4 /* PIC register */
+	lwi r21, r1, 8 /* PIC register */
+	lwi r22, r1, 12
+	lwi r23, r1, 16
+	addik r1, r1, 20
+
+	/* return from sub-routine (with delay slot) */
+	rtsd r15, 8
+	nop
+
+	.size ffi_call_SYSV, . - ffi_call_SYSV
+
+/* ------------------------------------------------------------------------- */
+
+	/*
+	 * args passed into this function, are passed down to the callee.
+	 * this function is the target of the closure trampoline, as such r12 is 
+	 * a pointer to the closure object.
+	 */
+	.text
+	.globl ffi_closure_SYSV
+	.type ffi_closure_SYSV, @function
+ffi_closure_SYSV:
+	/* push callee saves */
+	addik r11, r1, 28 /* save stack args start location (excluding regs/link) */
+	addik r1, r1, -12
+	swi r19, r1, 0 /* Frame Pointer */
+	swi r20, r1, 4 /* PIC register */
+	swi r21, r1, 8 /* PIC register */
+
+	/* store register args on stack */
+	addik r1, r1, -24
+	swi r5, r1, 0
+	swi r6, r1, 4
+	swi r7, r1, 8
+	swi r8, r1, 12
+	swi r9, r1, 16
+	swi r10, r1, 20
+
+	/* setup args */
+	addik r5, r1, 0 /* register_args */
+	addik r6, r11, 0 /* stack_args */
+	addik r7, r12, 0 /* closure object */
+	addik r1, r1, -8 /* allocate return value */
+	addik r8, r1, 0 /* void* rvalue */
+	addik r1, r1, -8 /* allocate for return type/size values */
+	addik r9, r1, 0 /* void* rtype */
+	addik r10, r1, 4 /* void* rsize */
+
+	/* call the wrap_call function */
+	addik r1, r1, -28 /* allocate args + link reg */
+	swi r15, r1, 0 /* store the link register in the frame */
+	brald r15, r3
+	nop /* branch has delay slot */
+	lwi r15, r1, 0
+	addik r1, r1, 28 /* restore the link register from the frame */
+
+ffi_closure_SYSV_prepare_return:
+	lwi r9, r1, 0 /* rtype */
+	lwi r10, r1, 4 /* rsize */
+	addik r1, r1, 8 /* de-allocate return info values */
+
+	/* Check if return type is actually a struct, store 4 bytes */
+	rsubi r11, r9, FFI_TYPE_STRUCT
+	beqi r11, ffi_closure_SYSV_store32
+
+	/* Return 8bit */
+	rsubi r11, r10, 1
+	beqi r11, ffi_closure_SYSV_store8
+
+	/* Return 16bit */
+	rsubi r11, r10, 2
+	beqi r11, ffi_closure_SYSV_store16
+
+	/* Return 32bit */
+	rsubi r11, r10, 4
+	beqi r11, ffi_closure_SYSV_store32
+
+	/* Return 64bit */
+	rsubi r11, r10, 8
+	beqi r11, ffi_closure_SYSV_store64
+
+	/* Didn't match anything */
+	bri ffi_closure_SYSV_end
+
+ffi_closure_SYSV_store64:
+	lwi r3, r1, 0 /* store word r3 into return value */
+	lwi r4, r1, 4 /* store word r4 into return value */
+	/* 64 bits == 2 words, no sign extend occurs */
+	bri ffi_closure_SYSV_end
+
+ffi_closure_SYSV_store32:
+	lwi r3, r1, 0 /* store word r3 into return value */
+	/* 32 bits == 1 word, no sign extend occurs */
+	bri ffi_closure_SYSV_end
+
+ffi_closure_SYSV_store16:
+#ifdef __BIG_ENDIAN__
+	lhui r3, r1, 2 /* store half-word r3 into return value */
+#else
+	lhui r3, r1, 0 /* store half-word r3 into return value */
+#endif
+	rsubi r11, r9, FFI_TYPE_SINT16
+	bnei r11, ffi_closure_SYSV_end
+	sext16 r3, r3 /* fix sign extend of sint8 */
+	bri ffi_closure_SYSV_end
+
+ffi_closure_SYSV_store8:
+#ifdef __BIG_ENDIAN__
+	lbui r3, r1, 3 /* store byte r3 into return value */
+#else
+	lbui r3, r1, 0 /* store byte r3 into return value */
+#endif
+	rsubi r11, r9, FFI_TYPE_SINT8
+	bnei r11, ffi_closure_SYSV_end
+	sext8 r3, r3 /* fix sign extend of sint8 */
+	bri ffi_closure_SYSV_end
+
+ffi_closure_SYSV_end:
+	addik r1, r1, 8 /* de-allocate return value */
+
+	/* de-allocate stored args */
+	addik r1, r1, 24
+
+	/* callee restores */
+	lwi r19, r1, 0 /* frame pointer */
+	lwi r20, r1, 4 /* PIC register */
+	lwi r21, r1, 8 /* PIC register */
+	addik r1, r1, 12
+
+	/* return from sub-routine (with delay slot) */
+	rtsd r15, 8
+	nop
+
+	.size ffi_closure_SYSV, . - ffi_closure_SYSV
Index: libffi-3.4.6/src/microblaze/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/microblaze/ffitarget.h b/libffi-3.4.6/src/microblaze/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/microblaze/ffitarget.h	
@@ -0,0 +1,53 @@
+/* -----------------------------------------------------------------------
+   ffitarget.h - Copyright (c) 2012, 2013 Xilinx, Inc
+
+   Target configuration macros for MicroBlaze.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long			ffi_arg;
+typedef signed long			ffi_sarg;
+
+typedef enum ffi_abi {
+	FFI_FIRST_ABI = 0,
+	FFI_SYSV,
+	FFI_LAST_ABI,
+	FFI_DEFAULT_ABI = FFI_SYSV
+} ffi_abi;
+#endif
+
+/* Definitions for closures */
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#define FFI_TRAMPOLINE_SIZE (4*8)
+
+#endif
Index: libffi-3.4.6/src/prep_cif.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/prep_cif.c b/libffi-3.4.6/src/prep_cif.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/prep_cif.c	
@@ -0,0 +1,283 @@
+/* -----------------------------------------------------------------------
+   prep_cif.c - Copyright (c) 2011, 2012, 2021  Anthony Green
+                Copyright (c) 1996, 1998, 2007  Red Hat, Inc.
+                Copyright (c) 2022 Oracle and/or its affiliates.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+
+/* Round up to FFI_SIZEOF_ARG. */
+
+#define STACK_ARG_SIZE(x) FFI_ALIGN(x, FFI_SIZEOF_ARG)
+
+/* Perform machine independent initialization of aggregate type
+   specifications. */
+
+static ffi_status initialize_aggregate(ffi_type *arg, size_t *offsets)
+{
+  ffi_type **ptr;
+
+  if (UNLIKELY(arg == NULL || arg->elements == NULL))
+    return FFI_BAD_TYPEDEF;
+
+  arg->size = 0;
+  arg->alignment = 0;
+
+  ptr = &(arg->elements[0]);
+
+  if (UNLIKELY(ptr == 0))
+    return FFI_BAD_TYPEDEF;
+
+  while ((*ptr) != NULL)
+    {
+      if (UNLIKELY(((*ptr)->size == 0)
+		    && (initialize_aggregate((*ptr), NULL) != FFI_OK)))
+	return FFI_BAD_TYPEDEF;
+
+      /* Perform a sanity check on the argument type */
+      FFI_ASSERT_VALID_TYPE(*ptr);
+
+      arg->size = FFI_ALIGN(arg->size, (*ptr)->alignment);
+      if (offsets)
+	*offsets++ = arg->size;
+      arg->size += (*ptr)->size;
+
+      arg->alignment = (arg->alignment > (*ptr)->alignment) ?
+	arg->alignment : (*ptr)->alignment;
+
+      ptr++;
+    }
+
+  /* Structure size includes tail padding.  This is important for
+     structures that fit in one register on ABIs like the PowerPC64
+     Linux ABI that right justify small structs in a register.
+     It's also needed for nested structure layout, for example
+     struct A { long a; char b; }; struct B { struct A x; char y; };
+     should find y at an offset of 2*sizeof(long) and result in a
+     total size of 3*sizeof(long).  */
+  arg->size = FFI_ALIGN (arg->size, arg->alignment);
+
+  /* On some targets, the ABI defines that structures have an additional
+     alignment beyond the "natural" one based on their elements.  */
+#ifdef FFI_AGGREGATE_ALIGNMENT
+  if (FFI_AGGREGATE_ALIGNMENT > arg->alignment)
+    arg->alignment = FFI_AGGREGATE_ALIGNMENT;
+#endif
+
+  if (arg->size == 0)
+    return FFI_BAD_TYPEDEF;
+  else
+    return FFI_OK;
+}
+
+#ifndef __CRIS__
+/* The CRIS ABI specifies structure elements to have byte
+   alignment only, so it completely overrides this functions,
+   which assumes "natural" alignment and padding.  */
+
+/* Perform machine independent ffi_cif preparation, then call
+   machine dependent routine. */
+
+/* For non variadic functions isvariadic should be 0 and
+   nfixedargs==ntotalargs.
+
+   For variadic calls, isvariadic should be 1 and nfixedargs
+   and ntotalargs set as appropriate. nfixedargs must always be >=1 */
+
+
+ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,
+			     unsigned int isvariadic,
+                             unsigned int nfixedargs,
+                             unsigned int ntotalargs,
+			     ffi_type *rtype, ffi_type **atypes)
+{
+  unsigned bytes = 0;
+  unsigned int i;
+  ffi_type **ptr;
+
+  FFI_ASSERT(cif != NULL);
+  FFI_ASSERT((!isvariadic) || (nfixedargs >= 1));
+  FFI_ASSERT(nfixedargs <= ntotalargs);
+
+  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI))
+    return FFI_BAD_ABI;
+
+  cif->abi = abi;
+  cif->arg_types = atypes;
+  cif->nargs = ntotalargs;
+  cif->rtype = rtype;
+
+  cif->flags = 0;
+#if (defined(_M_ARM64) || defined(__aarch64__)) && defined(_WIN32)
+  cif->is_variadic = isvariadic;
+#endif
+#if HAVE_LONG_DOUBLE_VARIANT
+  ffi_prep_types (abi);
+#endif
+
+  /* Initialize the return type if necessary */
+  if ((cif->rtype->size == 0)
+      && (initialize_aggregate(cif->rtype, NULL) != FFI_OK))
+    return FFI_BAD_TYPEDEF;
+
+#ifndef FFI_TARGET_HAS_COMPLEX_TYPE
+  if (rtype->type == FFI_TYPE_COMPLEX)
+    abort();
+#endif
+  /* Perform a sanity check on the return type */
+  FFI_ASSERT_VALID_TYPE(cif->rtype);
+
+  /* x86, x86-64 and s390 stack space allocation is handled in prep_machdep. */
+#if !defined FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+  /* Make space for the return structure pointer */
+  if (cif->rtype->type == FFI_TYPE_STRUCT
+#ifdef TILE
+      && (cif->rtype->size > 10 * FFI_SIZEOF_ARG)
+#endif
+#ifdef XTENSA
+      && (cif->rtype->size > 16)
+#endif
+#ifdef NIOS2
+      && (cif->rtype->size > 8)
+#endif
+     )
+    bytes = STACK_ARG_SIZE(sizeof(void*));
+#endif
+
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+
+      /* Initialize any uninitialized aggregate type definitions */
+      if (((*ptr)->size == 0)
+	  && (initialize_aggregate((*ptr), NULL) != FFI_OK))
+	return FFI_BAD_TYPEDEF;
+
+#ifndef FFI_TARGET_HAS_COMPLEX_TYPE
+      if ((*ptr)->type == FFI_TYPE_COMPLEX)
+	abort();
+#endif
+      /* Perform a sanity check on the argument type, do this
+	 check after the initialization.  */
+      FFI_ASSERT_VALID_TYPE(*ptr);
+
+#if !defined FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+	{
+	  /* Add any padding if necessary */
+	  if (((*ptr)->alignment - 1) & bytes)
+	    bytes = (unsigned)FFI_ALIGN(bytes, (*ptr)->alignment);
+
+#ifdef TILE
+	  if (bytes < 10 * FFI_SIZEOF_ARG &&
+	      bytes + STACK_ARG_SIZE((*ptr)->size) > 10 * FFI_SIZEOF_ARG)
+	    {
+	      /* An argument is never split between the 10 parameter
+		 registers and the stack.  */
+	      bytes = 10 * FFI_SIZEOF_ARG;
+	    }
+#endif
+#ifdef XTENSA
+	  if (bytes <= 6*4 && bytes + STACK_ARG_SIZE((*ptr)->size) > 6*4)
+	    bytes = 6*4;
+#endif
+
+	  bytes += (unsigned int)STACK_ARG_SIZE((*ptr)->size);
+	}
+#endif
+    }
+
+  cif->bytes = bytes;
+
+  /* Perform machine dependent cif processing */
+#ifdef FFI_TARGET_SPECIFIC_VARIADIC
+  if (isvariadic)
+	return ffi_prep_cif_machdep_var(cif, nfixedargs, ntotalargs);
+#endif
+
+  return ffi_prep_cif_machdep(cif);
+}
+#endif /* not __CRIS__ */
+
+ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,
+			     ffi_type *rtype, ffi_type **atypes)
+{
+  return ffi_prep_cif_core(cif, abi, 0, nargs, nargs, rtype, atypes);
+}
+
+ffi_status ffi_prep_cif_var(ffi_cif *cif,
+                            ffi_abi abi,
+                            unsigned int nfixedargs,
+                            unsigned int ntotalargs,
+                            ffi_type *rtype,
+                            ffi_type **atypes)
+{
+  ffi_status rc;
+  size_t int_size = ffi_type_sint.size;
+  unsigned int i;
+
+  rc = ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);
+
+  if (rc != FFI_OK)
+    return rc;
+
+  for (i = nfixedargs; i < ntotalargs; i++)
+    {
+      ffi_type *arg_type = atypes[i];
+      if (arg_type == &ffi_type_float
+          || ((arg_type->type != FFI_TYPE_STRUCT
+               && arg_type->type != FFI_TYPE_COMPLEX)
+              && arg_type->size < int_size))
+        return FFI_BAD_ARGTYPE;
+    }
+
+  return FFI_OK;
+}
+
+#if FFI_CLOSURES
+
+ffi_status
+ffi_prep_closure (ffi_closure* closure,
+		  ffi_cif* cif,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+{
+  return ffi_prep_closure_loc (closure, cif, fun, user_data, closure);
+}
+
+#endif
+
+ffi_status
+ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type, size_t *offsets)
+{
+  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI))
+    return FFI_BAD_ABI;
+  if (struct_type->type != FFI_TYPE_STRUCT)
+    return FFI_BAD_TYPEDEF;
+
+#if HAVE_LONG_DOUBLE_VARIANT
+  ffi_prep_types (abi);
+#endif
+
+  return initialize_aggregate(struct_type, offsets);
+}
Index: libffi-3.4.6/src/loongarch64/ffi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/loongarch64/ffi.c b/libffi-3.4.6/src/loongarch64/ffi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/loongarch64/ffi.c	
@@ -0,0 +1,624 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2022 Xu Chenghua <xuchenghua@loongson.cn>
+                         2022 Cheng Lulu <chenglulu@loongson.cn>
+   Based on RISC-V port
+
+   LoongArch Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <tramp.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#if defined(__loongarch_soft_float)
+# define ABI_FRLEN 0
+#elif defined(__loongarch_single_float)
+# define ABI_FRLEN 32
+# define ABI_FLOAT float
+#elif defined(__loongarch_double_float)
+# define ABI_FRLEN 64
+# define ABI_FLOAT double
+#else
+#error unsupported LoongArch floating-point ABI
+#endif
+
+#define NARGREG 8
+#define STKALIGN 16
+#define MAXCOPYARG (2 * sizeof (double))
+
+/* call_context registers
+   - 8 floating point parameter/result registers.
+   - 8 integer parameter/result registers.
+   - 2 registers used by the assembly code to in-place construct its own
+     stack frame
+     - frame register
+     - return register
+*/
+typedef struct call_context
+{
+#if !defined(__loongarch_soft_float)
+  ABI_FLOAT fa[8];
+#endif
+  size_t a[10];
+} call_context;
+
+typedef struct call_builder
+{
+  call_context *aregs;
+  int used_integer;
+  int used_float;
+  size_t *used_stack;
+  size_t *stack;
+  size_t next_struct_area;
+} call_builder;
+
+/* Integer (not pointer) less than ABI GRLEN.  */
+/* FFI_TYPE_INT does not appear to be used.  */
+#if __SIZEOF_POINTER__ == 8
+# define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT64)
+#else
+# define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT32)
+#endif
+
+#if ABI_FRLEN
+typedef struct float_struct_info
+{
+  char as_elements;
+  char type1;
+  char offset2;
+  char type2;
+} float_struct_info;
+
+#if ABI_FRLEN >= 64
+# define IS_FLOAT(type) ((type) >= FFI_TYPE_FLOAT && (type) <= FFI_TYPE_DOUBLE)
+#else
+# define IS_FLOAT(type) ((type) == FFI_TYPE_FLOAT)
+#endif
+
+static ffi_type **
+flatten_struct (ffi_type *in, ffi_type **out, ffi_type **out_end)
+{
+  int i;
+
+  if (out == out_end)
+    return out;
+  if (in->type != FFI_TYPE_STRUCT)
+    *(out++) = in;
+  else
+    for (i = 0; in->elements[i]; i++)
+      out = flatten_struct (in->elements[i], out, out_end);
+  return out;
+}
+
+/* Structs with at most two fields after flattening, one of which is of
+   floating point type, are passed in multiple registers if sufficient
+   registers are available.  */
+static float_struct_info
+struct_passed_as_elements (call_builder *cb, ffi_type *top)
+{
+  float_struct_info ret = {0, 0, 0, 0};
+  ffi_type *fields[3];
+  int num_floats, num_ints;
+  int num_fields = flatten_struct (top, fields, fields + 3) - fields;
+
+  if (num_fields == 1)
+    {
+      if (IS_FLOAT (fields[0]->type))
+	{
+	  ret.as_elements = 1;
+	  ret.type1 = fields[0]->type;
+	}
+    }
+  else if (num_fields == 2)
+    {
+      num_floats = IS_FLOAT (fields[0]->type) + IS_FLOAT (fields[1]->type);
+      num_ints = IS_INT (fields[0]->type) + IS_INT (fields[1]->type);
+      if (num_floats == 0 || num_floats + num_ints != 2)
+	return ret;
+      if (cb->used_float + num_floats > NARGREG
+	  || cb->used_integer + (2 - num_floats) > NARGREG)
+	return ret;
+      if (!IS_FLOAT (fields[0]->type) && !IS_FLOAT (fields[1]->type))
+	return ret;
+
+      ret.type1 = fields[0]->type;
+      ret.type2 = fields[1]->type;
+      ret.offset2 = FFI_ALIGN (fields[0]->size, fields[1]->alignment);
+      ret.as_elements = 1;
+    }
+  return ret;
+}
+#endif
+
+/* Allocates a single register, float register, or GRLEN-sized stack slot to a
+   datum.  */
+static void
+marshal_atom (call_builder *cb, int type, void *data)
+{
+  size_t value = 0;
+  switch (type)
+    {
+    case FFI_TYPE_UINT8:
+      value = *(uint8_t *) data;
+      break;
+    case FFI_TYPE_SINT8:
+      value = *(int8_t *) data;
+      break;
+    case FFI_TYPE_UINT16:
+      value = *(uint16_t *) data;
+      break;
+    case FFI_TYPE_SINT16:
+      value = *(int16_t *) data;
+      break;
+    /* 32-bit quantities are always sign-extended in the ABI.  */
+    case FFI_TYPE_UINT32:
+      value = *(int32_t *) data;
+      break;
+    case FFI_TYPE_SINT32:
+      value = *(int32_t *) data;
+      break;
+#if __SIZEOF_POINTER__ == 8
+    case FFI_TYPE_UINT64:
+      value = *(uint64_t *) data;
+      break;
+    case FFI_TYPE_SINT64:
+      value = *(int64_t *) data;
+      break;
+#endif
+    case FFI_TYPE_POINTER:
+      value = *(size_t *) data;
+      break;
+
+#if ABI_FRLEN >= 32
+    case FFI_TYPE_FLOAT:
+      *(float *)(cb->aregs->fa + cb->used_float++) = *(float *) data;
+      return;
+#endif
+#if ABI_FRLEN >= 64
+    case FFI_TYPE_DOUBLE:
+      (cb->aregs->fa[cb->used_float++]) = *(double *) data;
+      return;
+#endif
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+
+  if (cb->used_integer == NARGREG)
+    *cb->used_stack++ = value;
+  else
+    cb->aregs->a[cb->used_integer++] = value;
+}
+
+static void
+unmarshal_atom (call_builder *cb, int type, void *data)
+{
+  size_t value;
+  switch (type)
+    {
+#if ABI_FRLEN >= 32
+    case FFI_TYPE_FLOAT:
+      *(float *) data = *(float *)(cb->aregs->fa + cb->used_float++);
+      return;
+#endif
+#if ABI_FRLEN >= 64
+    case FFI_TYPE_DOUBLE:
+      *(double *) data = cb->aregs->fa[cb->used_float++];
+      return;
+#endif
+    }
+
+  if (cb->used_integer == NARGREG)
+    value = *cb->used_stack++;
+  else
+    value = cb->aregs->a[cb->used_integer++];
+
+  switch (type)
+    {
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+#if __SIZEOF_POINTER__ == 8
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+#endif
+    case FFI_TYPE_POINTER:
+      *(ffi_arg *)data = value;
+      break;
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+/* Allocate and copy a structure that is passed by value on the stack and
+   return a pointer to it.  */
+static void *
+allocate_and_copy_struct_to_stack (call_builder *cb, void *data,
+				   ffi_type *type)
+{
+  size_t dest = cb->next_struct_area - type->size;
+
+  dest = FFI_ALIGN_DOWN (dest, type->alignment);
+  cb->next_struct_area = dest;
+
+  return memcpy ((char *)cb->stack + dest, data, type->size);
+}
+
+/* Adds an argument to a call, or a not by reference return value.  */
+static void
+marshal (call_builder *cb, ffi_type *type, int var, void *data)
+{
+  size_t realign[2];
+
+#if ABI_FRLEN
+  if (!var && type->type == FFI_TYPE_STRUCT)
+    {
+      float_struct_info fsi = struct_passed_as_elements (cb, type);
+      if (fsi.as_elements)
+	{
+	  marshal_atom (cb, fsi.type1, data);
+	  if (fsi.offset2)
+	    marshal_atom (cb, fsi.type2, ((char *) data) + fsi.offset2);
+	  return;
+	}
+    }
+
+  if (!var && cb->used_float < NARGREG
+      && IS_FLOAT (type->type))
+    {
+      marshal_atom (cb, type->type, data);
+      return;
+    }
+
+  double promoted;
+  if (var && type->type == FFI_TYPE_FLOAT)
+    {
+      /* C standard requires promoting float -> double for variable arg.  */
+      promoted = *(float *) data;
+      type = &ffi_type_double;
+      data = &promoted;
+    }
+#endif
+
+  if (type->size > 2 * __SIZEOF_POINTER__)
+    /* Pass by reference.  */
+    {
+      allocate_and_copy_struct_to_stack (cb, data, type);
+      data = (char *)cb->stack + cb->next_struct_area;
+      marshal_atom (cb, FFI_TYPE_POINTER, &data);
+    }
+  else if (IS_INT (type->type) || type->type == FFI_TYPE_POINTER)
+    marshal_atom (cb, type->type, data);
+  else
+    {
+      /* Overlong integers, soft-float floats, and structs without special
+	 float handling are treated identically from this point on.  */
+
+      /* Variadics are aligned even in registers.  */
+      if (type->alignment > __SIZEOF_POINTER__)
+	{
+	  if (var)
+	    cb->used_integer = FFI_ALIGN (cb->used_integer, 2);
+	  cb->used_stack
+	    = (size_t *) FFI_ALIGN (cb->used_stack, 2 * __SIZEOF_POINTER__);
+	}
+
+      memcpy (realign, data, type->size);
+      if (type->size > 0)
+	marshal_atom (cb, FFI_TYPE_POINTER, realign);
+      if (type->size > __SIZEOF_POINTER__)
+	marshal_atom (cb, FFI_TYPE_POINTER, realign + 1);
+    }
+}
+
+/* For arguments passed by reference returns the pointer, otherwise the arg
+   is copied (up to MAXCOPYARG bytes).  */
+static void *
+unmarshal (call_builder *cb, ffi_type *type, int var, void *data)
+{
+  size_t realign[2];
+  void *pointer;
+
+#if ABI_FRLEN
+  if (!var && type->type == FFI_TYPE_STRUCT)
+    {
+      float_struct_info fsi = struct_passed_as_elements (cb, type);
+      if (fsi.as_elements)
+	{
+	  unmarshal_atom (cb, fsi.type1, data);
+	  if (fsi.offset2)
+	    unmarshal_atom (cb, fsi.type2, ((char *) data) + fsi.offset2);
+	  return data;
+	}
+    }
+
+  if (!var && cb->used_float < NARGREG
+      && IS_FLOAT (type->type))
+    {
+      unmarshal_atom (cb, type->type, data);
+      return data;
+    }
+
+  if (var && type->type == FFI_TYPE_FLOAT)
+    {
+      int m = cb->used_integer;
+      void *promoted
+	= m < NARGREG ? cb->aregs->a + m : cb->used_stack + m - NARGREG + 1;
+      *(float *) promoted = *(double *) promoted;
+    }
+#endif
+
+  if (type->size > 2 * __SIZEOF_POINTER__)
+    {
+      /* Pass by reference.  */
+      unmarshal_atom (cb, FFI_TYPE_POINTER, (char *) &pointer);
+      return pointer;
+    }
+  else if (IS_INT (type->type) || type->type == FFI_TYPE_POINTER)
+    {
+      unmarshal_atom (cb, type->type, data);
+      return data;
+    }
+  else
+    {
+      /* Overlong integers, soft-float floats, and structs without special
+	 float handling are treated identically from this point on.  */
+
+      /* Variadics are aligned even in registers.  */
+      if (type->alignment > __SIZEOF_POINTER__)
+	{
+	  if (var)
+	    cb->used_integer = FFI_ALIGN (cb->used_integer, 2);
+	  cb->used_stack
+	    = (size_t *) FFI_ALIGN (cb->used_stack, 2 * __SIZEOF_POINTER__);
+	}
+
+      if (type->size > 0)
+	unmarshal_atom (cb, FFI_TYPE_POINTER, realign);
+      if (type->size > __SIZEOF_POINTER__)
+	unmarshal_atom (cb, FFI_TYPE_POINTER, realign + 1);
+      memcpy (data, realign, type->size);
+      return data;
+    }
+}
+
+static int
+passed_by_ref (call_builder *cb, ffi_type *type, int var)
+{
+#if ABI_FRLEN
+  if (!var && type->type == FFI_TYPE_STRUCT)
+    {
+      float_struct_info fsi = struct_passed_as_elements (cb, type);
+      if (fsi.as_elements)
+	return 0;
+    }
+#endif
+
+  return type->size > 2 * __SIZEOF_POINTER__;
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  cif->loongarch_nfixedargs = cif->nargs;
+  return FFI_OK;
+}
+
+/* Perform machine dependent cif processing when we have a variadic
+   function.  */
+ffi_status
+ffi_prep_cif_machdep_var (ffi_cif *cif, unsigned int nfixedargs,
+			  unsigned int ntotalargs)
+{
+  cif->loongarch_nfixedargs = nfixedargs;
+  return FFI_OK;
+}
+
+/* Low level routine for calling functions.  */
+extern void ffi_call_asm (void *stack, struct call_context *regs,
+			  void (*fn) (void), void *closure) FFI_HIDDEN;
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	      void *closure)
+{
+  /* This is a conservative estimate, assuming a complex return value and
+     that all remaining arguments are long long / __int128 */
+  size_t arg_bytes = cif->bytes;
+  size_t rval_bytes = 0;
+  if (rvalue == NULL && cif->rtype->size > 2 * __SIZEOF_POINTER__)
+    rval_bytes = FFI_ALIGN (cif->rtype->size, STKALIGN);
+  size_t alloc_size = arg_bytes + rval_bytes + sizeof (call_context);
+
+  /* The assembly code will deallocate all stack data at lower addresses
+     than the argument region, so we need to allocate the frame and the
+     return value after the arguments in a single allocation.  */
+  size_t alloc_base;
+  /* Argument region must be 16-byte aligned in LP64 ABIs.  */
+  if (_Alignof(max_align_t) >= STKALIGN)
+    /* Since sizeof long double is normally 16, the compiler will
+       guarantee alloca alignment to at least that much.  */
+    alloc_base = (size_t) alloca (alloc_size);
+  else
+    alloc_base = FFI_ALIGN (alloca (alloc_size + STKALIGN - 1), STKALIGN);
+
+  if (rval_bytes)
+    rvalue = (void *) (alloc_base + arg_bytes);
+
+  call_builder cb;
+  cb.used_float = cb.used_integer = 0;
+  cb.aregs = (call_context *) (alloc_base + arg_bytes + rval_bytes);
+  cb.used_stack = (void *) alloc_base;
+  cb.stack = (void *) alloc_base;
+  cb.next_struct_area = arg_bytes;
+
+  int return_by_ref = passed_by_ref (&cb, cif->rtype, 0);
+  if (return_by_ref)
+    cb.aregs->a[cb.used_integer++] = (size_t)rvalue;
+
+  int i;
+  for (i = 0; i < cif->nargs; i++)
+    marshal (&cb, cif->arg_types[i], i >= cif->loongarch_nfixedargs,
+	     avalue[i]);
+
+  ffi_call_asm ((void *) alloc_base, cb.aregs, fn, closure);
+
+  cb.used_float = cb.used_integer = 0;
+  if (!return_by_ref && rvalue)
+    unmarshal (&cb, cif->rtype, 0, rvalue);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	     void *closure)
+{
+  ffi_call_int (cif, fn, rvalue, avalue, closure);
+}
+
+extern void ffi_closure_asm (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure *closure, ffi_cif *cif,
+		      void (*fun) (ffi_cif *, void *, void **, void *),
+		      void *user_data, void *codeloc)
+{
+  uint32_t *tramp = (uint32_t *) &closure->tramp[0];
+  uint64_t fn = (uint64_t) (uintptr_t) ffi_closure_asm;
+
+  if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+  if (ffi_tramp_is_present(closure))
+    {
+      ffi_tramp_set_parms (closure->ftramp, ffi_closure_asm, closure);
+      goto out;
+    }
+#endif
+
+  /* Fill the dynamic trampoline.  We will call ffi_closure_inner with codeloc,
+     not closure, but as long as the memory is readable it should work.  */
+  tramp[0] = 0x1800000c; /* pcaddi $t0, 0 (i.e. $t0 <- tramp) */
+  tramp[1] = 0x28c0418d; /* ld.d   $t1, $t0, 16 */
+  tramp[2] = 0x4c0001a0; /* jirl   $zero, $t1, 0 */
+  tramp[3] = 0x03400000; /* nop */
+  tramp[4] = fn;
+  tramp[5] = fn >> 32;
+
+  __builtin___clear_cache (codeloc, codeloc + FFI_TRAMPOLINE_SIZE);
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+out:
+#endif
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+extern void ffi_go_closure_asm (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+  if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (void *) ffi_go_closure_asm;
+  closure->cif = cif;
+  closure->fun = fun;
+  return FFI_OK;
+}
+
+/* Called by the assembly code with aregs pointing to saved argument registers
+   and stack pointing to the stacked arguments.  Return values passed in
+   registers will be reloaded from aregs.  */
+void FFI_HIDDEN
+ffi_closure_inner (ffi_cif *cif,
+		   void (*fun) (ffi_cif *, void *, void **, void *),
+		   void *user_data, size_t *stack, call_context *aregs)
+{
+  void **avalue = alloca (cif->nargs * sizeof (void *));
+  /* Storage for arguments which will be copied by unmarshal().  We could
+     theoretically avoid the copies in many cases and use at most 128 bytes
+     of memory, but allocating disjoint storage for each argument is
+     simpler.  */
+  char *astorage = alloca (cif->nargs * MAXCOPYARG);
+  void *rvalue;
+  call_builder cb;
+  int return_by_ref;
+  int i;
+
+  cb.aregs = aregs;
+  cb.used_integer = cb.used_float = 0;
+  cb.used_stack = stack;
+
+  return_by_ref = passed_by_ref (&cb, cif->rtype, 0);
+  if (return_by_ref)
+    unmarshal (&cb, &ffi_type_pointer, 0, &rvalue);
+  else
+    rvalue = alloca (cif->rtype->size);
+
+  for (i = 0; i < cif->nargs; i++)
+    avalue[i]
+      = unmarshal (&cb, cif->arg_types[i], i >= cif->loongarch_nfixedargs,
+		   astorage + i * MAXCOPYARG);
+
+  fun (cif, rvalue, avalue, user_data);
+
+  if (!return_by_ref && cif->rtype->type != FFI_TYPE_VOID)
+    {
+      cb.used_integer = cb.used_float = 0;
+      marshal (&cb, cif->rtype, 0, rvalue);
+    }
+}
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+void *
+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)
+{
+  extern void *trampoline_code_table;
+
+  *tramp_size = 16;
+  /* A mapping size of 64K is chosen to cover the page sizes of 4K, 16K, and
+     64K.  */
+  *map_size = 1 << 16;
+  return &trampoline_code_table;
+}
+#endif
Index: libffi-3.4.6/src/loongarch64/sysv.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/loongarch64/sysv.S b/libffi-3.4.6/src/loongarch64/sysv.S
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/loongarch64/sysv.S	
@@ -0,0 +1,327 @@
+/* -----------------------------------------------------------------------
+  sysv.S  - Copyright (c) 2022 Xu Chenghua <xuchenghua@loongson.cn>
+                          2022 Cheng Lulu <chenglulu@loongson.cn>
+
+   LoongArch Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Define aliases so that we can handle all ABIs uniformly.  */
+
+#if __SIZEOF_POINTER__ == 8
+# define PTRS 8
+# define LARG ld.d
+# define SARG st.d
+#else
+# define PTRS 4
+# define LARG ld.w
+# define SARG st.w
+#endif
+
+#if defined(__loongarch_single_float)
+# define FLTS 4
+# define FLD fld.w
+# define FST fst.w
+#elif defined(__loongarch_double_float)
+# define FLTS 8
+# define FLARG fld.d
+# define FSARG fst.d
+#elif defined(__loongarch_soft_float)
+# define FLTS 0
+#else
+#error unsupported LoongArch floating-point ABI
+#endif
+
+    .text
+    .globl  ffi_call_asm
+    .type   ffi_call_asm, @function
+    .hidden ffi_call_asm
+/* struct call_context
+   {
+     ABI_FLOAT fa[8];
+     size_t a[10];
+   }
+
+   - 8 floating point parameter/result registers (fa[0] - fa[7])
+   - 8 integer parameter/result registers (a[0] - a[7])
+   - 2 registers used by the assembly code to in-place construct its own stack
+     frame.
+    - frame pointer (a[8])
+    - return address (a[9])
+
+   void ffi_call_asm (size_t *stackargs, struct call_context *regargs,
+		      void (*fn)(void), void *closure); */
+
+#define FRAME_LEN (8 * FLTS + 10 * PTRS)
+
+ffi_call_asm:
+	.cfi_startproc
+
+	/* We are NOT going to set up an ordinary stack frame.  In order to pass
+	   the stacked args to the called function, we adjust our stack pointer
+	   to a0, which is in the _caller's_ alloca area.  We establish our own
+	   stack frame at the end of the call_context.
+
+	   Anything below the arguments will be freed at this point, although
+	   we preserve the call_context so that it can be read back in the
+	   caller.  */
+
+	.cfi_def_cfa	5, FRAME_LEN # Interim CFA based on a1.
+	SARG	$fp, $a1, FRAME_LEN - 2*PTRS
+	.cfi_offset	22, -2*PTRS
+	SARG	$ra, $a1, FRAME_LEN - 1*PTRS
+	.cfi_offset	1, -1*PTRS
+
+	addi.d	$fp, $a1, FRAME_LEN
+	move	$sp, $a0
+	.cfi_def_cfa	22, 0 # Our frame is fully set up.
+
+	# Load arguments.
+	move	$t1, $a2
+	move	$t2, $a3
+
+#if FLTS
+	FLARG	$fa0, $fp, -FRAME_LEN+0*FLTS
+	FLARG	$fa1, $fp, -FRAME_LEN+1*FLTS
+	FLARG	$fa2, $fp, -FRAME_LEN+2*FLTS
+	FLARG	$fa3, $fp, -FRAME_LEN+3*FLTS
+	FLARG	$fa4, $fp, -FRAME_LEN+4*FLTS
+	FLARG	$fa5, $fp, -FRAME_LEN+5*FLTS
+	FLARG	$fa6, $fp, -FRAME_LEN+6*FLTS
+	FLARG	$fa7, $fp, -FRAME_LEN+7*FLTS
+#endif
+
+	LARG	$a0, $fp, -FRAME_LEN+8*FLTS+0*PTRS
+	LARG	$a1, $fp, -FRAME_LEN+8*FLTS+1*PTRS
+	LARG	$a2, $fp, -FRAME_LEN+8*FLTS+2*PTRS
+	LARG	$a3, $fp, -FRAME_LEN+8*FLTS+3*PTRS
+	LARG	$a4, $fp, -FRAME_LEN+8*FLTS+4*PTRS
+	LARG	$a5, $fp, -FRAME_LEN+8*FLTS+5*PTRS
+	LARG	$a6, $fp, -FRAME_LEN+8*FLTS+6*PTRS
+	LARG	$a7, $fp, -FRAME_LEN+8*FLTS+7*PTRS
+
+	/* Call */
+	jirl	$ra, $t1, 0
+
+#if FLTS
+	/* Save return values - only a0/a1 (fa0/fa1) are used.  */
+	FSARG	$fa0, $fp, -FRAME_LEN+0*FLTS
+	FSARG	$fa1, $fp, -FRAME_LEN+1*FLTS
+#endif
+
+	SARG	$a0, $fp, -FRAME_LEN+8*FLTS+0*PTRS
+	SARG	$a1, $fp, -FRAME_LEN+8*FLTS+1*PTRS
+
+	/* Restore and return.  */
+	addi.d	$sp, $fp, -FRAME_LEN
+	.cfi_def_cfa	3, FRAME_LEN
+	LARG	$ra, $fp, -1*PTRS
+	.cfi_restore	1
+	LARG	$fp, $fp, -2*PTRS
+	.cfi_restore	22
+	jr	$ra
+	.cfi_endproc
+	.size	ffi_call_asm, .-ffi_call_asm
+
+
+/* ffi_closure_asm. Expects address of the passed-in ffi_closure in t0.
+   void ffi_closure_inner (ffi_cif *cif,
+			   void (*fun)(ffi_cif *, void *, void **, void *),
+			   void *user_data,
+			   size_t *stackargs, struct call_context *regargs) */
+
+	.globl	ffi_closure_asm
+	.hidden	ffi_closure_asm
+	.type	ffi_closure_asm, @function
+
+ffi_closure_asm:
+	.cfi_startproc
+	addi.d	$sp, $sp, -FRAME_LEN
+	.cfi_def_cfa_offset FRAME_LEN
+
+	/* Make a frame.  */
+	SARG	$fp, $sp, FRAME_LEN - 2*PTRS
+	.cfi_offset	22, -2*PTRS
+	SARG	$ra, $sp, FRAME_LEN - 1*PTRS
+	.cfi_offset	1, -1*PTRS
+	addi.d	$fp, $sp, FRAME_LEN
+
+	/* Save arguments.  */
+#if FLTS
+	FSARG	$fa0, $sp, 0*FLTS
+	FSARG	$fa1, $sp, 1*FLTS
+	FSARG	$fa2, $sp, 2*FLTS
+	FSARG	$fa3, $sp, 3*FLTS
+	FSARG	$fa4, $sp, 4*FLTS
+	FSARG	$fa5, $sp, 5*FLTS
+	FSARG	$fa6, $sp, 6*FLTS
+	FSARG	$fa7, $sp, 7*FLTS
+#endif
+
+	SARG	$a0, $sp, 8*FLTS+0*PTRS
+	SARG	$a1, $sp, 8*FLTS+1*PTRS
+	SARG	$a2, $sp, 8*FLTS+2*PTRS
+	SARG	$a3, $sp, 8*FLTS+3*PTRS
+	SARG	$a4, $sp, 8*FLTS+4*PTRS
+	SARG	$a5, $sp, 8*FLTS+5*PTRS
+	SARG	$a6, $sp, 8*FLTS+6*PTRS
+	SARG	$a7, $sp, 8*FLTS+7*PTRS
+
+	/* Enter C */
+	LARG	$a0, $t0, FFI_TRAMPOLINE_SIZE+0*PTRS
+	LARG	$a1, $t0, FFI_TRAMPOLINE_SIZE+1*PTRS
+	LARG	$a2, $t0, FFI_TRAMPOLINE_SIZE+2*PTRS
+	addi.d	$a3, $sp, FRAME_LEN
+	move	$a4, $sp
+
+	bl	ffi_closure_inner
+
+	/* Return values.  */
+#if FLTS
+	FLARG	$fa0, $sp, 0*FLTS
+	FLARG	$fa1, $sp, 1*FLTS
+#endif
+
+	LARG	$a0, $sp, 8*FLTS+0*PTRS
+	LARG	$a1, $sp, 8*FLTS+1*PTRS
+
+	/* Restore and return.  */
+	LARG	$ra, $sp, FRAME_LEN-1*PTRS
+	.cfi_restore	1
+	LARG	$fp, $sp, FRAME_LEN-2*PTRS
+	.cfi_restore	22
+	addi.d	$sp, $sp, FRAME_LEN
+	.cfi_def_cfa_offset 0
+	jr	$ra
+	.cfi_endproc
+	.size	ffi_closure_asm, .-ffi_closure_asm
+
+/* Static trampoline code table, in which each element is a trampoline.
+
+   The trampoline clobbers t0 and t1, but we don't save them on the stack
+   because our psABI explicitly says they are scratch registers, at least for
+   ELF.  Our dynamic trampoline is already clobbering them anyway.
+
+   The trampoline has two parameters - target code to jump to and data for
+   the target code. The trampoline extracts the parameters from its parameter
+   block (see tramp_table_map()).  The trampoline saves the data address in
+   t0 and jumps to the target code.  As ffi_closure_asm() already expects the
+   data address to be in t0, we don't need a "ffi_closure_asm_alt".  */
+
+#if defined(FFI_EXEC_STATIC_TRAMP)
+	.align	16
+	.globl	trampoline_code_table
+	.hidden	trampoline_code_table
+	.type	trampoline_code_table, @function
+
+trampoline_code_table:
+
+	.rept	65536 / 16
+	pcaddu12i	$t1, 16 # 65536 >> 12
+	ld.d	$t0, $t1, 0
+	ld.d	$t1, $t1, 8
+	jirl	$zero, $t1, 0
+	.endr
+	.size	trampoline_code_table, .-trampoline_code_table
+
+	.align	2
+#endif
+
+/* ffi_go_closure_asm.  Expects address of the passed-in ffi_go_closure in t2.
+   void ffi_closure_inner (ffi_cif *cif,
+			   void (*fun)(ffi_cif *, void *, void **, void *),
+			   void *user_data,
+			   size_t *stackargs, struct call_context *regargs) */
+
+	.globl	ffi_go_closure_asm
+	.hidden	ffi_go_closure_asm
+	.type	ffi_go_closure_asm, @function
+
+ffi_go_closure_asm:
+	.cfi_startproc
+	addi.d	$sp, $sp, -FRAME_LEN
+	.cfi_def_cfa_offset FRAME_LEN
+
+	/* Make a frame.  */
+	SARG	$fp, $sp, FRAME_LEN - 2*PTRS
+	.cfi_offset	22, -2*PTRS
+	SARG	$ra, $sp, FRAME_LEN - 1*PTRS
+	.cfi_offset	1, -1*PTRS
+	addi.d	$fp, $sp, FRAME_LEN
+
+	/* Save arguments.  */
+#if FLTS
+	FSARG	$fa0, $sp, 0*FLTS
+	FSARG	$fa1, $sp, 1*FLTS
+	FSARG	$fa2, $sp, 2*FLTS
+	FSARG	$fa3, $sp, 3*FLTS
+	FSARG	$fa4, $sp, 4*FLTS
+	FSARG	$fa5, $sp, 5*FLTS
+	FSARG	$fa6, $sp, 6*FLTS
+	FSARG	$fa7, $sp, 7*FLTS
+#endif
+
+	SARG	$a0, $sp, 8*FLTS+0*PTRS
+	SARG	$a1, $sp, 8*FLTS+1*PTRS
+	SARG	$a2, $sp, 8*FLTS+2*PTRS
+	SARG	$a3, $sp, 8*FLTS+3*PTRS
+	SARG	$a4, $sp, 8*FLTS+4*PTRS
+	SARG	$a5, $sp, 8*FLTS+5*PTRS
+	SARG	$a6, $sp, 8*FLTS+6*PTRS
+	SARG	$a7, $sp, 8*FLTS+7*PTRS
+
+	/* Enter C */
+	LARG	$a0, $t2, 1*PTRS
+	LARG	$a1, $t2, 2*PTRS
+	move	$a2, $t2
+	addi.d	$a3, $sp, FRAME_LEN
+	move	$a4, $sp
+
+	bl	ffi_closure_inner
+
+	/* Return values.  */
+#if FLTS
+	FLARG	$fa0, $sp, 0*FLTS
+	FLARG	$fa1, $sp, 1*FLTS
+#endif
+
+	LARG	$a0, $sp, 8*FLTS+0*PTRS
+	LARG	$a1, $sp, 8*FLTS+1*PTRS
+
+	/* Restore and return.  */
+	LARG	$ra, $sp, FRAME_LEN-1*PTRS
+	.cfi_restore	1
+	LARG	$fp, $sp, FRAME_LEN-2*PTRS
+	.cfi_restore	22
+	addi.d	$sp, $sp, FRAME_LEN
+	.cfi_def_cfa_offset 0
+	jr	$ra
+	.cfi_endproc
+	.size	ffi_go_closure_asm, .-ffi_go_closure_asm
+
+#if defined __ELF__ && defined __linux__
+	.section .note.GNU-stack,"",%progbits
+#endif
Index: libffi-3.4.6/src/loongarch64/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/loongarch64/ffitarget.h b/libffi-3.4.6/src/loongarch64/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/loongarch64/ffitarget.h	
@@ -0,0 +1,82 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2022 Xu Chenghua <xuchenghua@loongson.cn>
+                               2022 Cheng Lulu <chenglulu@loongson.cn>
+
+   Target configuration macros for LoongArch.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error \
+  "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef __loongarch__
+#error \
+  "libffi was configured for a LoongArch target but this does not appear to be a LoongArch compiler."
+#endif
+
+#ifndef LIBFFI_ASM
+
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+typedef enum ffi_abi
+{
+  FFI_FIRST_ABI = 0,
+  FFI_LP64S,
+  FFI_LP64F,
+  FFI_LP64D,
+  FFI_LAST_ABI,
+
+#if defined(__loongarch64)
+#if defined(__loongarch_soft_float)
+  FFI_DEFAULT_ABI = FFI_LP64S
+#elif defined(__loongarch_single_float)
+  FFI_DEFAULT_ABI = FFI_LP64F
+#elif defined(__loongarch_double_float)
+  FFI_DEFAULT_ABI = FFI_LP64D
+#else
+#error unsupported LoongArch floating-point ABI
+#endif
+#else
+#error unsupported LoongArch base architecture
+#endif
+} ffi_abi;
+
+#endif /* LIBFFI_ASM */
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_NATIVE_RAW_API 0
+#define FFI_EXTRA_CIF_FIELDS \
+  unsigned loongarch_nfixedargs; \
+  unsigned loongarch_unused;
+#define FFI_TARGET_SPECIFIC_VARIADIC
+#endif
Index: libffi-3.4.6/src/java_raw_api.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/src/java_raw_api.c b/libffi-3.4.6/src/java_raw_api.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/src/java_raw_api.c	
@@ -0,0 +1,374 @@
+/* -----------------------------------------------------------------------
+   java_raw_api.c - Copyright (c) 1999, 2007, 2008  Red Hat, Inc.
+
+   Cloned from raw_api.c
+
+   Raw_api.c author: Kresten Krab Thorup <krab@gnu.org>
+   Java_raw_api.c author: Hans-J. Boehm <hboehm@hpl.hp.com>
+
+   $Id $
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+/* This defines a Java- and 64-bit specific variant of the raw API.	*/
+/* It assumes that "raw" argument blocks look like Java stacks on a	*/
+/* 64-bit machine.  Arguments that can be stored in a single stack	*/
+/* stack slots (longs, doubles) occupy 128 bits, but only the first	*/
+/* 64 bits are actually used.						*/
+
+#include <ffi.h>
+#include <ffi_common.h>
+#include <stdlib.h>
+
+#if !defined(NO_JAVA_RAW_API)
+
+size_t
+ffi_java_raw_size (ffi_cif *cif)
+{
+  size_t result = 0;
+  int i;
+
+  ffi_type **at = cif->arg_types;
+
+  for (i = cif->nargs-1; i >= 0; i--, at++)
+    {
+      switch((*at) -> type) {
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_DOUBLE:
+	  result += 2 * FFI_SIZEOF_JAVA_RAW;
+	  break;
+	case FFI_TYPE_STRUCT:
+	  /* No structure parameters in Java.	*/
+	  abort();
+	case FFI_TYPE_COMPLEX:
+	  /* Not supported yet.  */
+	  abort();
+	default:
+	  result += FFI_SIZEOF_JAVA_RAW;
+      }
+    }
+
+  return result;
+}
+
+
+void
+ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)
+{
+  unsigned i;
+  ffi_type **tp = cif->arg_types;
+
+#if WORDS_BIGENDIAN
+
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {
+      switch ((*tp)->type)
+	{
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	  *args = (void*) ((char*)(raw++) + 3);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	  *args = (void*) ((char*)(raw++) + 2);
+	  break;
+
+#if FFI_SIZEOF_JAVA_RAW == 8
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_DOUBLE:
+	  *args = (void *)raw;
+	  raw += 2;
+	  break;
+#endif
+
+	case FFI_TYPE_POINTER:
+	  *args = (void*) &(raw++)->ptr;
+	  break;
+
+	case FFI_TYPE_COMPLEX:
+	  /* Not supported yet.  */
+	  abort();
+
+	default:
+	  *args = raw;
+	  raw +=
+	    FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);
+	}
+    }
+
+#else /* WORDS_BIGENDIAN */
+
+#if !PDP
+
+  /* then assume little endian */
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {
+#if FFI_SIZEOF_JAVA_RAW == 8
+      switch((*tp)->type) {
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_DOUBLE:
+	  *args = (void*) raw;
+	  raw += 2;
+	  break;
+	case FFI_TYPE_COMPLEX:
+	  /* Not supported yet.  */
+	  abort();
+	default:
+	  *args = (void*) raw++;
+      }
+#else /* FFI_SIZEOF_JAVA_RAW != 8 */
+	*args = (void*) raw;
+	raw +=
+	  FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);
+#endif /* FFI_SIZEOF_JAVA_RAW == 8 */
+    }
+
+#else
+#error "pdp endian not supported"
+#endif /* ! PDP */
+
+#endif /* WORDS_BIGENDIAN */
+}
+
+void
+ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw)
+{
+  unsigned i;
+  ffi_type **tp = cif->arg_types;
+
+  for (i = 0; i < cif->nargs; i++, tp++, args++)
+    {
+      switch ((*tp)->type)
+	{
+	case FFI_TYPE_UINT8:
+#if WORDS_BIGENDIAN
+	  *(UINT32*)(raw++) = *(UINT8*) (*args);
+#else
+	  (raw++)->uint = *(UINT8*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_SINT8:
+#if WORDS_BIGENDIAN
+	  *(SINT32*)(raw++) = *(SINT8*) (*args);
+#else
+	  (raw++)->sint = *(SINT8*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_UINT16:
+#if WORDS_BIGENDIAN
+	  *(UINT32*)(raw++) = *(UINT16*) (*args);
+#else
+	  (raw++)->uint = *(UINT16*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_SINT16:
+#if WORDS_BIGENDIAN
+	  *(SINT32*)(raw++) = *(SINT16*) (*args);
+#else
+	  (raw++)->sint = *(SINT16*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_UINT32:
+#if WORDS_BIGENDIAN
+	  *(UINT32*)(raw++) = *(UINT32*) (*args);
+#else
+	  (raw++)->uint = *(UINT32*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_SINT32:
+#if WORDS_BIGENDIAN
+	  *(SINT32*)(raw++) = *(SINT32*) (*args);
+#else
+	  (raw++)->sint = *(SINT32*) (*args);
+#endif
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  (raw++)->flt = *(FLOAT32*) (*args);
+	  break;
+
+#if FFI_SIZEOF_JAVA_RAW == 8
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_DOUBLE:
+	  raw->uint = *(UINT64*) (*args);
+	  raw += 2;
+	  break;
+#endif
+
+	case FFI_TYPE_POINTER:
+	  (raw++)->ptr = **(void***) args;
+	  break;
+
+	default:
+#if FFI_SIZEOF_JAVA_RAW == 8
+	  FFI_ASSERT(0);	/* Should have covered all cases */
+#else
+	  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);
+	  raw +=
+	    FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);
+#endif
+	}
+    }
+}
+
+#if !FFI_NATIVE_RAW_API
+
+static void
+ffi_java_rvalue_to_raw (ffi_cif *cif, void *rvalue)
+{
+#if WORDS_BIGENDIAN && FFI_SIZEOF_ARG == 8
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_UINT32:
+      *(UINT64 *)rvalue <<= 32;
+      break;
+
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_INT:
+#if FFI_SIZEOF_JAVA_RAW == 4
+    case FFI_TYPE_POINTER:
+#endif
+      *(SINT64 *)rvalue <<= 32;
+      break;
+
+    case FFI_TYPE_COMPLEX:
+      /* Not supported yet.  */
+      abort();
+
+    default:
+      break;
+    }
+#endif
+}
+
+static void
+ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)
+{
+#if WORDS_BIGENDIAN && FFI_SIZEOF_ARG == 8
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_UINT32:
+      *(UINT64 *)rvalue >>= 32;
+      break;
+
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_INT:
+      *(SINT64 *)rvalue >>= 32;
+      break;
+
+    case FFI_TYPE_COMPLEX:
+      /* Not supported yet.  */
+      abort();
+
+    default:
+      break;
+    }
+#endif
+}
+
+/* This is a generic definition of ffi_raw_call, to be used if the
+ * native system does not provide a machine-specific implementation.
+ * Having this, allows code to be written for the raw API, without
+ * the need for system-specific code to handle input in that format;
+ * these following couple of functions will handle the translation forth
+ * and back automatically. */
+
+void ffi_java_raw_call (ffi_cif *cif, void (*fn)(void), void *rvalue,
+			ffi_java_raw *raw)
+{
+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
+  ffi_java_raw_to_ptrarray (cif, raw, avalue);
+  ffi_call (cif, fn, rvalue, avalue);
+  ffi_java_rvalue_to_raw (cif, rvalue);
+}
+
+#if FFI_CLOSURES		/* base system provides closures */
+
+static void
+ffi_java_translate_args (ffi_cif *cif, void *rvalue,
+		    void **avalue, void *user_data)
+{
+  ffi_java_raw *raw = (ffi_java_raw*)alloca (ffi_java_raw_size (cif));
+  ffi_raw_closure *cl = (ffi_raw_closure*)user_data;
+
+  ffi_java_ptrarray_to_raw (cif, avalue, raw);
+  (*cl->fun) (cif, rvalue, (ffi_raw*)raw, cl->user_data);
+  ffi_java_raw_to_rvalue (cif, rvalue);
+}
+
+ffi_status
+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure* cl,
+			       ffi_cif *cif,
+			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+			       void *user_data,
+			       void *codeloc)
+{
+  ffi_status status;
+
+  status = ffi_prep_closure_loc ((ffi_closure*) cl,
+				 cif,
+				 &ffi_java_translate_args,
+				 codeloc,
+				 codeloc);
+  if (status == FFI_OK)
+    {
+      cl->fun       = fun;
+      cl->user_data = user_data;
+    }
+
+  return status;
+}
+
+/* Again, here is the generic version of ffi_prep_raw_closure, which
+ * will install an intermediate "hub" for translation of arguments from
+ * the pointer-array format, to the raw format */
+
+ffi_status
+ffi_prep_java_raw_closure (ffi_java_raw_closure* cl,
+			   ffi_cif *cif,
+			   void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+			   void *user_data)
+{
+  return ffi_prep_java_raw_closure_loc (cl, cif, fun, user_data, cl);
+}
+
+#endif /* FFI_CLOSURES */
+#endif /* !FFI_NATIVE_RAW_API */
+#endif /* !NO_JAVA_RAW_API */
Index: libffi-3.4.6/include/tramp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/include/tramp.h b/libffi-3.4.6/include/tramp.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/include/tramp.h	
@@ -0,0 +1,45 @@
+/* -----------------------------------------------------------------------
+   ffi_tramp.h - Copyright (C) 2021  Microsoft, Inc.
+
+   Static trampoline definitions.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef FFI_TRAMP_H
+#define FFI_TRAMP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int ffi_tramp_is_supported(void);
+void *ffi_tramp_alloc (int flags);
+void ffi_tramp_set_parms (void *tramp, void *data, void *code);
+void *ffi_tramp_get_addr (void *tramp);
+void ffi_tramp_free (void *tramp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FFI_TRAMP_H */
Index: libffi-3.4.6/include/ffi.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/include/ffi.h.in b/libffi-3.4.6/include/ffi.h.in
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/include/ffi.h.in	
@@ -0,0 +1,518 @@
+/* -----------------------------------------------------------------*-C-*-
+   libffi @VERSION@
+     - Copyright (c) 2011, 2014, 2019, 2021, 2022, 2024 Anthony Green
+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------
+   Most of the API is documented in doc/libffi.texi.
+
+   The raw API is designed to bypass some of the argument packing and
+   unpacking on architectures for which it can be avoided.  Routines
+   are provided to emulate the raw API if the underlying platform
+   doesn't allow faster implementation.
+
+   More details on the raw API can be found in:
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00138.html
+
+   and
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00174.html
+   -------------------------------------------------------------------- */
+
+#ifndef LIBFFI_H
+#define LIBFFI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Specify which architecture libffi is configured for. */
+#ifndef @TARGET@
+#define @TARGET@
+#endif
+
+/* ---- System configuration information --------------------------------- */
+
+/* If these change, update src/mips/ffitarget.h. */
+#define FFI_TYPE_VOID       0
+#define FFI_TYPE_INT        1
+#define FFI_TYPE_FLOAT      2
+#define FFI_TYPE_DOUBLE     3
+#if @HAVE_LONG_DOUBLE@
+#define FFI_TYPE_LONGDOUBLE 4
+#else
+#define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE
+#endif
+#define FFI_TYPE_UINT8      5
+#define FFI_TYPE_SINT8      6
+#define FFI_TYPE_UINT16     7
+#define FFI_TYPE_SINT16     8
+#define FFI_TYPE_UINT32     9
+#define FFI_TYPE_SINT32     10
+#define FFI_TYPE_UINT64     11
+#define FFI_TYPE_SINT64     12
+#define FFI_TYPE_STRUCT     13
+#define FFI_TYPE_POINTER    14
+#define FFI_TYPE_COMPLEX    15
+
+/* This should always refer to the last type code (for sanity checks).  */
+#define FFI_TYPE_LAST       FFI_TYPE_COMPLEX
+
+#include <ffitarget.h>
+
+#ifndef LIBFFI_ASM
+
+#if defined(_MSC_VER) && !defined(__clang__)
+#define __attribute__(X)
+#endif
+
+#include <stddef.h>
+#include <limits.h>
+
+/* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).
+   But we can find it either under the correct ANSI name, or under GNU
+   C's internal name.  */
+
+#define FFI_64_BIT_MAX 9223372036854775807
+
+#ifdef LONG_LONG_MAX
+# define FFI_LONG_LONG_MAX LONG_LONG_MAX
+#else
+# ifdef LLONG_MAX
+#  define FFI_LONG_LONG_MAX LLONG_MAX
+#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */
+#   undef FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif /* _AIX52 or newer */
+# else
+#  ifdef __GNUC__
+#   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__
+#  endif
+#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */
+#   ifndef __PPC64__
+#    if defined (__IBMC__) || defined (__IBMCPP__)
+#     define FFI_LONG_LONG_MAX LONGLONG_MAX
+#    endif
+#   endif /* __PPC64__ */
+#   undef  FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif
+# endif
+#endif
+
+/* The closure code assumes that this works on pointers, i.e. a size_t
+   can hold a pointer.  */
+
+typedef struct _ffi_type
+{
+  size_t size;
+  unsigned short alignment;
+  unsigned short type;
+  struct _ffi_type **elements;
+} ffi_type;
+
+/* Need minimal decorations for DLLs to work on Windows.  GCC has
+   autoimport and autoexport.  Always mark externally visible symbols
+   as dllimport for MSVC clients, even if it means an extra indirection
+   when using the static version of the library.
+   Besides, as a workaround, they can define FFI_BUILDING if they
+   *know* they are going to link with the static library.  */
+#if defined _MSC_VER && !defined(FFI_STATIC_BUILD)
+# if defined FFI_BUILDING_DLL /* Building libffi.DLL with msvcc.sh */
+#  define FFI_API __declspec(dllexport)
+# else  /* Importing libffi.DLL */
+#  define FFI_API __declspec(dllimport)
+# endif
+#else
+# define FFI_API
+#endif
+
+/* The externally visible type declarations also need the MSVC DLL
+   decorations, or they will not be exported from the object file.  */
+#if defined LIBFFI_HIDE_BASIC_TYPES
+# define FFI_EXTERN FFI_API
+#else
+# define FFI_EXTERN extern FFI_API
+#endif
+
+#ifndef LIBFFI_HIDE_BASIC_TYPES
+#if SCHAR_MAX == 127
+# define ffi_type_uchar                ffi_type_uint8
+# define ffi_type_schar                ffi_type_sint8
+#else
+ #error "char size not supported"
+#endif
+
+#if SHRT_MAX == 32767
+# define ffi_type_ushort       ffi_type_uint16
+# define ffi_type_sshort       ffi_type_sint16
+#elif SHRT_MAX == 2147483647
+# define ffi_type_ushort       ffi_type_uint32
+# define ffi_type_sshort       ffi_type_sint32
+#else
+ #error "short size not supported"
+#endif
+
+#if INT_MAX == 32767
+# define ffi_type_uint         ffi_type_uint16
+# define ffi_type_sint         ffi_type_sint16
+#elif INT_MAX == 2147483647
+# define ffi_type_uint         ffi_type_uint32
+# define ffi_type_sint         ffi_type_sint32
+#elif INT_MAX == 9223372036854775807
+# define ffi_type_uint         ffi_type_uint64
+# define ffi_type_sint         ffi_type_sint64
+#else
+ #error "int size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX
+ #error "no 64-bit data type supported"
+# endif
+#elif LONG_MAX != FFI_64_BIT_MAX
+ #error "long size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# define ffi_type_ulong        ffi_type_uint32
+# define ffi_type_slong        ffi_type_sint32
+#elif LONG_MAX == FFI_64_BIT_MAX
+# define ffi_type_ulong        ffi_type_uint64
+# define ffi_type_slong        ffi_type_sint64
+#else
+ #error "long size not supported"
+#endif
+
+/* These are defined in types.c.  */
+FFI_EXTERN ffi_type ffi_type_void;
+FFI_EXTERN ffi_type ffi_type_uint8;
+FFI_EXTERN ffi_type ffi_type_sint8;
+FFI_EXTERN ffi_type ffi_type_uint16;
+FFI_EXTERN ffi_type ffi_type_sint16;
+FFI_EXTERN ffi_type ffi_type_uint32;
+FFI_EXTERN ffi_type ffi_type_sint32;
+FFI_EXTERN ffi_type ffi_type_uint64;
+FFI_EXTERN ffi_type ffi_type_sint64;
+FFI_EXTERN ffi_type ffi_type_float;
+FFI_EXTERN ffi_type ffi_type_double;
+FFI_EXTERN ffi_type ffi_type_pointer;
+FFI_EXTERN ffi_type ffi_type_longdouble;
+
+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
+FFI_EXTERN ffi_type ffi_type_complex_float;
+FFI_EXTERN ffi_type ffi_type_complex_double;
+FFI_EXTERN ffi_type ffi_type_complex_longdouble;
+#endif
+#endif /* LIBFFI_HIDE_BASIC_TYPES */
+
+typedef enum {
+  FFI_OK = 0,
+  FFI_BAD_TYPEDEF,
+  FFI_BAD_ABI,
+  FFI_BAD_ARGTYPE
+} ffi_status;
+
+typedef struct {
+  ffi_abi abi;
+  unsigned nargs;
+  ffi_type **arg_types;
+  ffi_type *rtype;
+  unsigned bytes;
+  unsigned flags;
+#ifdef FFI_EXTRA_CIF_FIELDS
+  FFI_EXTRA_CIF_FIELDS;
+#endif
+} ffi_cif;
+
+/* ---- Definitions for the raw API -------------------------------------- */
+
+#ifndef FFI_SIZEOF_ARG
+# if LONG_MAX == 2147483647
+#  define FFI_SIZEOF_ARG        4
+# elif LONG_MAX == FFI_64_BIT_MAX
+#  define FFI_SIZEOF_ARG        8
+# endif
+#endif
+
+#ifndef FFI_SIZEOF_JAVA_RAW
+#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG
+#endif
+
+typedef union {
+  ffi_sarg  sint;
+  ffi_arg   uint;
+  float	    flt;
+  char      data[FFI_SIZEOF_ARG];
+  void*     ptr;
+} ffi_raw;
+
+#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8
+/* This is a special case for mips64/n32 ABI (and perhaps others) where
+   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */
+typedef union {
+  signed int	sint;
+  unsigned int	uint;
+  float		flt;
+  char		data[FFI_SIZEOF_JAVA_RAW];
+  void*		ptr;
+} ffi_java_raw;
+#else
+typedef ffi_raw ffi_java_raw;
+#endif
+
+
+FFI_API
+void ffi_raw_call (ffi_cif *cif,
+		   void (*fn)(void),
+		   void *rvalue,
+		   ffi_raw *avalue);
+
+FFI_API void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
+FFI_API void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
+FFI_API size_t ffi_raw_size (ffi_cif *cif);
+
+/* This is analogous to the raw API, except it uses Java parameter
+   packing, even on 64-bit machines.  I.e. on 64-bit machines longs
+   and doubles are followed by an empty 64-bit word.  */
+
+#if !FFI_NATIVE_RAW_API
+FFI_API
+void ffi_java_raw_call (ffi_cif *cif,
+			void (*fn)(void),
+			void *rvalue,
+			ffi_java_raw *avalue) __attribute__((deprecated));
+#endif
+
+FFI_API
+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));
+FFI_API
+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));
+FFI_API
+size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#if FFI_CLOSURES
+
+#ifdef _MSC_VER
+__declspec(align(8))
+#endif
+typedef struct {
+#if @FFI_EXEC_TRAMPOLINE_TABLE@
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  union {
+    char tramp[FFI_TRAMPOLINE_SIZE];
+    void *ftramp;
+  };
+#endif
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+  void      *user_data;
+#if defined(_MSC_VER) && defined(_M_IX86)
+  void      *padding;
+#endif
+} ffi_closure
+#ifdef __GNUC__
+    __attribute__((aligned (8)))
+#endif
+    ;
+
+#ifndef __GNUC__
+# ifdef __sgi
+#  pragma pack 0
+# endif
+#endif
+
+FFI_API void *ffi_closure_alloc (size_t size, void **code);
+FFI_API void ffi_closure_free (void *);
+
+FFI_API ffi_status
+ffi_prep_closure (ffi_closure*,
+		  ffi_cif *,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+#if defined(__GNUC__) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 405)
+  __attribute__((deprecated ("use ffi_prep_closure_loc instead")))
+#elif defined(__GNUC__) && __GNUC__ >= 3
+  __attribute__((deprecated))
+#endif
+  ;
+
+FFI_API ffi_status
+ffi_prep_closure_loc (ffi_closure*,
+		      ffi_cif *,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc);
+
+#ifdef __sgi
+# pragma pack 8
+#endif
+typedef struct {
+#if @FFI_EXEC_TRAMPOLINE_TABLE@
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout
+     as a regular closure.  We use this to install an intermediate
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_raw*,void*);
+  void      *user_data;
+
+} ffi_raw_closure;
+
+typedef struct {
+#if @FFI_EXEC_TRAMPOLINE_TABLE@
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout
+     as a regular closure.  We use this to install an intermediate
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
+  void      *user_data;
+
+} ffi_java_raw_closure;
+
+FFI_API ffi_status
+ffi_prep_raw_closure (ffi_raw_closure*,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+		      void *user_data);
+
+FFI_API ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure*,
+			  ffi_cif *cif,
+			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+			  void *user_data,
+			  void *codeloc);
+
+#if !FFI_NATIVE_RAW_API
+FFI_API ffi_status
+ffi_prep_java_raw_closure (ffi_java_raw_closure*,
+		           ffi_cif *cif,
+		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+		           void *user_data) __attribute__((deprecated));
+
+FFI_API ffi_status
+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
+			       ffi_cif *cif,
+			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+			       void *user_data,
+			       void *codeloc) __attribute__((deprecated));
+#endif
+
+#endif /* FFI_CLOSURES */
+
+#ifdef FFI_GO_CLOSURES
+
+typedef struct {
+  void      *tramp;
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+} ffi_go_closure;
+
+FFI_API ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
+				void (*fun)(ffi_cif*,void*,void**,void*));
+
+FFI_API void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+		  void **avalue, void *closure);
+
+#endif /* FFI_GO_CLOSURES */
+
+/* ---- Public interface definition -------------------------------------- */
+
+FFI_API
+ffi_status ffi_prep_cif(ffi_cif *cif,
+			ffi_abi abi,
+			unsigned int nargs,
+			ffi_type *rtype,
+			ffi_type **atypes);
+
+FFI_API
+ffi_status ffi_prep_cif_var(ffi_cif *cif,
+			    ffi_abi abi,
+			    unsigned int nfixedargs,
+			    unsigned int ntotalargs,
+			    ffi_type *rtype,
+			    ffi_type **atypes);
+
+FFI_API
+void ffi_call(ffi_cif *cif,
+	      void (*fn)(void),
+	      void *rvalue,
+	      void **avalue);
+
+FFI_API
+ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
+				   size_t *offsets);
+
+/* Convert between closure and function pointers.  */
+#if defined(PA_LINUX) || defined(PA_HPUX)
+#define FFI_FN(f) ((void (*)(void))((unsigned int)(f) | 2))
+#define FFI_CL(f) ((void *)((unsigned int)(f) & ~3))
+#else
+#define FFI_FN(f) ((void (*)(void))f)
+#define FFI_CL(f) ((void *)(f))
+#endif
+
+/* ---- Definitions shared with assembly code ---------------------------- */
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: libffi-3.4.6/include/ffi_cfi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/include/ffi_cfi.h b/libffi-3.4.6/include/ffi_cfi.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/include/ffi_cfi.h	
@@ -0,0 +1,76 @@
+/* -----------------------------------------------------------------------
+   ffi_cfi.h - Copyright (c) 2014  Red Hat, Inc.
+
+   Conditionally assemble cfi directives. Only necessary for building libffi.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef FFI_CFI_H
+#define FFI_CFI_H
+
+#ifdef HAVE_AS_CFI_PSEUDO_OP
+
+# define cfi_startproc			.cfi_startproc
+# define cfi_endproc			.cfi_endproc
+# define cfi_def_cfa(reg, off)		.cfi_def_cfa reg, off
+# define cfi_def_cfa_register(reg)	.cfi_def_cfa_register reg
+# define cfi_def_cfa_offset(off)	.cfi_def_cfa_offset off
+# define cfi_adjust_cfa_offset(off)	.cfi_adjust_cfa_offset off
+# define cfi_offset(reg, off)		.cfi_offset reg, off
+# define cfi_rel_offset(reg, off)	.cfi_rel_offset reg, off
+# define cfi_register(r1, r2)		.cfi_register r1, r2
+# define cfi_return_column(reg)		.cfi_return_column reg
+# define cfi_restore(reg)		.cfi_restore reg
+# define cfi_same_value(reg)		.cfi_same_value reg
+# define cfi_undefined(reg)		.cfi_undefined reg
+# define cfi_remember_state		.cfi_remember_state
+# define cfi_restore_state		.cfi_restore_state
+# define cfi_window_save		.cfi_window_save
+# define cfi_personality(enc, exp)	.cfi_personality enc, exp
+# define cfi_lsda(enc, exp)		.cfi_lsda enc, exp
+# define cfi_escape(...)		.cfi_escape __VA_ARGS__
+
+#else
+
+# define cfi_startproc
+# define cfi_endproc
+# define cfi_def_cfa(reg, off)
+# define cfi_def_cfa_register(reg)
+# define cfi_def_cfa_offset(off)
+# define cfi_adjust_cfa_offset(off)
+# define cfi_offset(reg, off)
+# define cfi_rel_offset(reg, off)
+# define cfi_register(r1, r2)
+# define cfi_return_column(reg)
+# define cfi_restore(reg)
+# define cfi_same_value(reg)
+# define cfi_undefined(reg)
+# define cfi_remember_state
+# define cfi_restore_state
+# define cfi_window_save
+# define cfi_personality(enc, exp)
+# define cfi_lsda(enc, exp)
+# define cfi_escape(...)
+
+#endif /* HAVE_AS_CFI_PSEUDO_OP */
+#endif /* FFI_CFI_H */
Index: libffi-3.4.6/include/Makefile.am
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/include/Makefile.am b/libffi-3.4.6/include/Makefile.am
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/include/Makefile.am	
@@ -0,0 +1,9 @@
+## Process this with automake to create Makefile.in
+
+AUTOMAKE_OPTIONS=foreign
+
+DISTCLEANFILES=ffitarget.h
+noinst_HEADERS=ffi_common.h ffi_cfi.h tramp.h
+EXTRA_DIST=ffi.h.in
+
+nodist_include_HEADERS = ffi.h ffitarget.h
Index: libffi-3.4.6/include/ffi_common.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/include/ffi_common.h b/libffi-3.4.6/include/ffi_common.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/include/ffi_common.h	
@@ -0,0 +1,184 @@
+/* -----------------------------------------------------------------------
+   ffi_common.h - Copyright (C) 2011, 2012, 2013  Anthony Green
+                  Copyright (C) 2007  Free Software Foundation, Inc
+                  Copyright (c) 1996  Red Hat, Inc.
+                  
+   Common internal definitions and macros. Only necessary for building
+   libffi.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef FFI_COMMON_H
+#define FFI_COMMON_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <fficonfig.h>
+
+/* Do not move this. Some versions of AIX are very picky about where
+   this is positioned. */
+#ifdef __GNUC__
+# if HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+  /* mingw64 defines this already in malloc.h. */
+#  ifndef alloca
+#    define alloca __builtin_alloca
+#  endif
+# endif
+# define MAYBE_UNUSED __attribute__((__unused__))
+# define NORETURN __attribute__((__noreturn__))
+#else
+# define MAYBE_UNUSED
+# define NORETURN
+# if HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+#   pragma alloca
+#  else
+#   ifndef alloca /* predefined by HP cc +Olibcalls */
+#    ifdef _MSC_VER
+#     define alloca _alloca
+#    else
+char *alloca ();
+#   endif
+#  endif
+# endif
+# endif
+#endif
+
+/* Check for the existence of memcpy. */
+#if STDC_HEADERS
+# include <string.h>
+#else
+# ifndef HAVE_MEMCPY
+#  define memcpy(d, s, n) bcopy ((s), (d), (n))
+# endif
+#endif
+
+#if defined(FFI_DEBUG)
+#include <stdio.h>
+#endif
+
+#ifdef FFI_DEBUG
+NORETURN void ffi_assert(const char *expr, const char *file, int line);
+void ffi_stop_here(void);
+void ffi_type_test(ffi_type *a, const char *file, int line);
+
+#define FFI_ASSERT(x) ((x) ? (void)0 : ffi_assert(#x, __FILE__,__LINE__))
+#define FFI_ASSERT_AT(x, f, l) ((x) ? 0 : ffi_assert(#x, (f), (l)))
+#define FFI_ASSERT_VALID_TYPE(x) ffi_type_test (x, __FILE__, __LINE__)
+#else
+#define FFI_ASSERT(x)
+#define FFI_ASSERT_AT(x, f, l)
+#define FFI_ASSERT_VALID_TYPE(x)
+#endif
+
+/* v cast to size_t and aligned up to a multiple of a */
+#define FFI_ALIGN(v, a)  (((((size_t) (v))-1) | ((a)-1))+1)
+/* v cast to size_t and aligned down to a multiple of a */
+#define FFI_ALIGN_DOWN(v, a) (((size_t) (v)) & -a)
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif);
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
+	 unsigned int nfixedargs, unsigned int ntotalargs);
+
+
+#if HAVE_LONG_DOUBLE_VARIANT
+/* Used to adjust size/alignment of ffi types.  */
+void ffi_prep_types (ffi_abi abi);
+#endif
+
+/* Used internally, but overridden by some architectures */
+ffi_status ffi_prep_cif_core(ffi_cif *cif,
+			     ffi_abi abi,
+			     unsigned int isvariadic,
+			     unsigned int nfixedargs,
+			     unsigned int ntotalargs,
+			     ffi_type *rtype,
+			     ffi_type **atypes);
+
+/* Translate a data pointer to a code pointer.  Needed for closures on
+   some targets.  */
+void *ffi_data_to_code_pointer (void *data) FFI_HIDDEN;
+
+/* The arch code calls this to determine if a given closure has a
+   static trampoline. */
+int ffi_tramp_is_present (void *closure) FFI_HIDDEN;
+
+/* Return a file descriptor of a temporary zero-sized file in a
+   writable and executable filesystem. */
+int open_temp_exec_file(void) FFI_HIDDEN;
+
+/* Extended cif, used in callback from assembly routine */
+typedef struct
+{
+  ffi_cif *cif;
+  void *rvalue;
+  void **avalue;
+} extended_cif;
+
+/* Terse sized type definitions.  */
+#if defined(_MSC_VER) || defined(__sgi) || defined(__SUNPRO_C)
+typedef unsigned char UINT8;
+typedef signed char   SINT8;
+typedef unsigned short UINT16;
+typedef signed short   SINT16;
+typedef unsigned int UINT32;
+typedef signed int   SINT32;
+# ifdef _MSC_VER
+typedef unsigned __int64 UINT64;
+typedef signed __int64   SINT64;
+# else
+# include <inttypes.h>
+typedef uint64_t UINT64;
+typedef int64_t  SINT64;
+# endif
+#else
+typedef unsigned int UINT8  __attribute__((__mode__(__QI__)));
+typedef signed int   SINT8  __attribute__((__mode__(__QI__)));
+typedef unsigned int UINT16 __attribute__((__mode__(__HI__)));
+typedef signed int   SINT16 __attribute__((__mode__(__HI__)));
+typedef unsigned int UINT32 __attribute__((__mode__(__SI__)));
+typedef signed int   SINT32 __attribute__((__mode__(__SI__)));
+typedef unsigned int UINT64 __attribute__((__mode__(__DI__)));
+typedef signed int   SINT64 __attribute__((__mode__(__DI__)));
+#endif
+
+typedef float FLOAT32;
+
+#ifndef __GNUC__
+#define __builtin_expect(x, expected_value) (x)
+#endif
+#define LIKELY(x)    __builtin_expect(!!(x),1)
+#define UNLIKELY(x)  __builtin_expect((x)!=0,0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: libffi-3.4.6/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/LICENSE b/libffi-3.4.6/LICENSE
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/LICENSE	
@@ -0,0 +1,21 @@
+libffi - Copyright (c) 1996-2024  Anthony Green, Red Hat, Inc and others.
+See source files for details.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
Index: libffi-3.4.6/msvcc.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvcc.sh b/libffi-3.4.6/msvcc.sh
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvcc.sh	
@@ -0,0 +1,353 @@
+#!/bin/sh
+
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the MSVC wrappificator.
+#
+# The Initial Developer of the Original Code is
+# Timothy Wall <twalljava@dev.java.net>.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Daniel Witte <dwitte@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+#
+# GCC-compatible wrapper for cl.exe and ml.exe. Arguments are given in GCC
+# format and translated into something sensible for cl or ml.
+#
+
+args_orig=$@
+args="-nologo -W3"
+linkargs=
+static_crt=
+debug_crt=
+cl="cl"
+ml="ml"
+safeseh="-safeseh"
+output=
+libpaths=
+libversion=8
+verbose=
+
+while [ $# -gt 0 ]
+do
+  case $1
+  in
+    --verbose)
+      verbose=1
+      shift 1
+    ;;
+    --version)
+      args="-help"
+      shift 1
+    ;;
+    -fexceptions)
+      # Don't enable exceptions for now.
+      #args="$args -EHac"
+      shift 1
+    ;;
+    -m32)
+      shift 1
+    ;;
+    -m64)
+      ml="ml64" # "$MSVC/x86_amd64/ml64"
+      safeseh=
+      shift 1
+    ;;
+    -marm)
+      ml='armasm'
+      safeseh=
+      shift 1
+    ;;
+    -marm64)
+      ml='armasm64'
+      safeseh=
+      shift 1
+    ;;
+    -clang-cl)
+      cl="clang-cl"
+      shift 1
+    ;;
+    -O0)
+      args="$args -Od"
+      shift 1
+    ;;
+    -O*)
+      # Runtime error checks (enabled by setting -RTC1 in the -DFFI_DEBUG
+      # case below) are not compatible with optimization flags and will
+      # cause the build to fail. Therefore, drop the optimization flag if
+      # -DFFI_DEBUG is also set.
+      case $args_orig in
+        *-DFFI_DEBUG*)
+          args="$args"
+        ;;
+        *)
+          # The ax_cc_maxopt.m4 macro from the upstream autoconf-archive
+          # project doesn't support MSVC and therefore ends up trying to
+          # use -O3. Use the equivalent "max optimization" flag for MSVC
+          # instead of erroring out.
+          case $1 in
+            -O3)
+              args="$args -O2"
+            ;;
+            *)
+              args="$args $1"
+            ;;
+          esac
+          opt="true"
+        ;;
+      esac
+      shift 1
+    ;;
+    -g)
+      # Enable debug symbol generation.
+      args="$args -Zi"
+      shift 1
+    ;;
+    -DFFI_DEBUG)
+      # Enable runtime error checks.
+      args="$args -RTC1"
+      defines="$defines $1"
+      shift 1
+    ;;
+    -DUSE_STATIC_RTL)
+      # Link against static CRT.
+      static_crt=1
+      shift 1
+    ;;
+    -DUSE_DEBUG_RTL)
+      # Link against debug CRT.
+      debug_crt=1
+      shift 1
+    ;;
+    -c)
+      args="$args -c"
+      args="$(echo $args | sed 's%/Fe%/Fo%g')"
+      single="-c"
+      shift 1
+    ;;
+    -D*=*)
+      name="$(echo $1|sed 's/-D\([^=][^=]*\)=.*/\1/g')"
+      value="$(echo $1|sed 's/-D[^=][^=]*=//g')"
+      args="$args -D${name}='$value'"
+      defines="$defines -D${name}='$value'"
+      shift 1
+    ;;
+    -D*)
+      args="$args $1"
+      defines="$defines $1"
+      shift 1
+    ;;
+    -I)
+      p=$(cygpath -ma "$2")
+      args="$args -I\"$p\""
+      includes="$includes -I\"$p\""
+      shift 2
+    ;;
+    -I*)
+      p=$(cygpath -ma "${1#-I}")
+      args="$args -I\"$p\""
+      includes="$includes -I\"$p\""
+      shift 1
+    ;;
+    -L)
+      p=$(cygpath -ma $2)
+      linkargs="$linkargs -LIBPATH:$p"
+      shift 2
+    ;;
+    -L*)
+      p=$(cygpath -ma ${1#-L})
+      linkargs="$linkargs -LIBPATH:$p"
+      shift 1
+    ;;
+    -link)
+      # add next argument verbatim to linker args
+      linkargs="$linkargs $2"
+      shift 2
+      ;;
+    -l*)
+      case $1
+      in
+        -lffi)
+          linkargs="$linkargs lib${1#-l}-${libversion}.lib"
+          ;;
+        *)
+          # ignore other libraries like -lm, hope they are
+          # covered by MSVCRT
+          # linkargs="$linkargs ${1#-l}.lib"
+          ;;
+      esac
+      shift 1
+    ;;
+    -W|-Wextra)
+      # TODO map extra warnings
+      shift 1
+    ;;
+    -Wall)
+      # -Wall on MSVC is overzealous, and we already build with -W3. Nothing
+      # to do here.
+      shift 1
+    ;;
+    -pedantic)
+      # libffi tests -pedantic with -Wall, so drop it also.
+      shift 1
+    ;;
+    -warn)
+      # ignore -warn all from libtool as well.
+      if test "$2" = "all"; then
+        shift 2
+      else
+        args="$args -warn"
+        shift 1
+      fi
+    ;;
+    -Werror)
+      args="$args -WX"
+      shift 1
+    ;;
+    -W*)
+      # TODO map specific warnings
+      shift 1
+    ;;
+    -S)
+      args="$args -FAs"
+      shift 1
+    ;;
+    -o)
+      outdir="$(dirname $2)"
+      base="$(basename $2|sed 's/\.[^.]*//g')"
+      if [ -n "$single" ]; then 
+        output="-Fo$2"
+      else
+        output="-Fe$2"
+      fi
+      armasm_output="-o $2"
+      if [ -n "$assembly" ]; then
+        args="$args $output"
+      else
+        args="$args $output -Fd$outdir/$base -Fp$outdir/$base -Fa$outdir/$base"
+      fi
+      shift 2
+    ;;
+    *.S)
+      src="$(cygpath -ma $1)"
+      assembly="true"
+      shift 1
+    ;;
+    *.c)
+      args="$args $(cygpath -ma $1)"
+      shift 1
+    ;;
+    *)
+      # Assume it's an MSVC argument, and pass it through.
+      args="$args $1"
+      shift 1
+    ;;
+  esac
+done
+
+if [ -n "$linkargs" ]; then
+
+    # If -Zi is specified, certain optimizations are implicitly disabled
+    # by MSVC. Add back those optimizations if this is an optimized build.
+    # NOTE: These arguments must come after all others.
+    if [ -n "$opt" ]; then
+	linkargs="$linkargs -OPT:REF -OPT:ICF -INCREMENTAL:NO"
+    fi
+
+    args="$args -link $linkargs"
+fi
+
+if [ -n "$static_crt" ]; then
+    md=-MT
+else
+    md=-MD
+fi
+
+if [ -n "$debug_crt" ]; then
+    md="${md}d"
+fi
+
+if [ -n "$assembly" ]; then
+    if [ -z "$outdir" ]; then
+      outdir="."
+    fi
+    ppsrc="$outdir/$(basename $src|sed 's/.S$/.asm/g')"
+
+    if [ $ml = "armasm" ]; then
+      defines="$defines -D_M_ARM"
+    fi
+
+    if [ $ml = "armasm64" ]; then
+      defines="$defines -D_M_ARM64"
+    fi
+
+    if test -n "$verbose"; then
+      echo "$cl -nologo -EP $includes $defines $src > $ppsrc"
+    fi
+
+    eval "\"$cl\" -nologo -EP $includes $defines $src" > $ppsrc || exit $?
+    output="$(echo $output | sed 's%/F[dpa][^ ]*%%g')"
+    if [ $ml = "armasm" ]; then
+      args="-nologo -g -oldit $armasm_output $ppsrc -errorReport:prompt"
+    elif [ $ml = "armasm64" ]; then
+      args="-nologo -g $armasm_output $ppsrc -errorReport:prompt"
+    else
+      args="-nologo $safeseh $single $output $ppsrc"
+    fi
+
+    if test -n "$verbose"; then
+      echo "$ml $args"
+    fi
+
+    eval "\"$ml\" $args"
+    result=$?
+
+    # required to fix ml64 broken output?
+    #mv *.obj $outdir
+else
+    args="$md $args"
+
+    if test -n "$verbose"; then
+      echo "$cl $args"
+    fi
+    # Return an error code of 1 if an invalid command line parameter is passed
+    # instead of just ignoring it. Any output that is not a warning or an
+    # error is filtered so this command behaves more like gcc. cl.exe prints
+    # the name of the compiled file otherwise, which breaks the dejagnu checks
+    # for excess warnings and errors.
+    eval "(\"$cl\" $args 2>&1 1>&3 | \
+          awk '{print \$0} /D9002/ {error=1} END{exit error}' >&2) 3>&1 | \
+          awk '/warning|error/'"
+    result=$?
+fi
+
+exit $result
+
+# vim: noai:ts=4:sw=4
Index: libffi-3.4.6/ChangeLog
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/ChangeLog b/libffi-3.4.6/ChangeLog
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/ChangeLog	
@@ -0,0 +1,15095 @@
+commit 3d0ce1e6fcf19f853894862abcbac0ae78a7be60
+Author: Anthony Green <green@moxielogic.org>
+Date:   Sun Feb 18 09:22:51 2024 -0500
+
+    chore: update version to 3.4.6 and fix long double regression on mips64 and alpha
+
+commit 94eaedb40e67e26d2fa35d1c22d8818f4d9f4c2d
+Author: Anthony Green <green@moxielogic.org>
+Date:   Sun Feb 18 08:41:04 2024 -0500
+
+    Update sparc64 host
+
+commit e1dcf03b4642e75a1058799a3023e0ebd0024258
+Author: Anthony Green <green@moxielogic.org>
+Date:   Sun Feb 18 08:02:45 2024 -0500
+
+    Update cfarm hostnames
+
+commit cd78b539125ae615d76df5a57039fe70ebd56c27
+Author: Anthony Green <green@moxielogic.org>
+Date:   Sun Feb 18 07:48:51 2024 -0500
+
+    Always define long double types.
+
+commit 012fcaf96c87ab617ba34babce9b6b259188fcf0
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Feb 15 08:35:02 2024 -0500
+
+    Update
+
+commit d1597239af492240770692b8e453f0dca70fc551
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Feb 15 08:32:42 2024 -0500
+
+    update copyright year in libffi.texi
+
+commit 91739a1a912476adbf1e0e4dcb091b9a2c5007d9
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Feb 15 08:30:09 2024 -0500
+
+    Update version, copyright and testsuite info.
+
+commit 9752a622d12e696eaf9a4c46d4f09b58bca6bb83
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Feb 15 08:03:21 2024 -0500
+
+    Fix test filename reference
+
+commit 404355317b3314da14a9ead0c0a50c040212e1fc
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Feb 15 08:01:43 2024 -0500
+
+    docs(README): update release details for libffi-3.4.5
+
+commit 04f6fa310ddec494cfcf32fd3685cefe35a8d2a2
+Author: Xi Ruoyao <xry111@xry111.site>
+Date:   Thu Feb 15 20:52:13 2024 +0800
+
+    mips: Fix N32 ABI return value handling (#813)
+    
+    In N32 ABI, 8-bit or 16-bit integers should be extended following the
+    signedness of the integer, but 32-bit integers should always be
+    sign-extended to 64-bit (note that N32 ABI only works on 64-bit CPUs).
+    
+    So handling this in everything using libffi would be nasty.  And the
+    libffi code for architectures with a similar rule (LoongArch & RISC-V)
+    also properly handle this.  Let's do this work in libffi for MIPS N32
+    too.
+    
+    This fixes two failures in Python 3.12.1 ctypes test.
+
+commit 00c0c87773910a320d82f026bb481eea31b50206
+Author: 杨屿杰 <30362409+scylaac@users.noreply.github.com>
+Date:   Thu Feb 15 20:51:40 2024 +0800
+
+    Fix loongarch64 soft-float build (#816) (#817)
+
+commit b3091029ed85339c856224c243826022ae93c041
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Thu Feb 15 04:51:12 2024 -0800
+
+    Emscripten: Don't unbox single element structs if they are larger than 16 bytes (#818)
+    
+    This arguably is a compensation for a Python ctypes bug / strange behavior
+    described here:
+    https://github.com/python/cpython/blob/a16a9f978f42b8a09297c1efbf33877f6388c403/Modules/_ctypes/stgdict.c#L718-L779
+    
+    If a struct is larger than 16 bytes, Python does not bother to accurately report
+    its contents figuring that we don't need to know.
+
+commit 98881ecb8eec6d5f2beaaced96d9f625b0dee499
+Author: Bill Roberts <152999275+billatarm@users.noreply.github.com>
+Date:   Thu Feb 15 06:50:40 2024 -0600
+
+    aarch64: add BTI flag to ELF notes (#822)
+    
+    When a program is loaded and linked, the first ELF file that doesn't
+    declare that BTI is supported in the GNU NOTES section disables BTI
+    support.
+    
+    Example:
+    readelf -n ./aarch64-unknown-linux-gnu/.libs/libffi.so
+    Displaying notes found in: .note.gnu.property
+      Owner                Data size        Description
+      GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0
+          Properties: AArch64 feature: BTI
+    
+    Fixes: #823
+    
+    Signed-off-by: Bill Roberts <bill.roberts@arm.com>
+
+commit f9da12e944c947e797e5f3a98f3860c2a0ed055e
+Author: Dan Horák <dan@danny.cz>
+Date:   Thu Feb 15 13:50:13 2024 +0100
+
+    don't skip ffi_type_longdouble symbols (#814) (#824)
+    
+    Seems there are configurations (ppc64 or ppc64le) that define
+    HAVE_LONG_DOUBLE_VARIANT in fficonfig.h, but do not define
+    HAVE_LONG_DOUBLE, and still want ffi_type_{,complex_}longdouble
+    symbols. Update the condition in libffi.map.in accordingly.
+
+commit f8ed78f1b2e65f2741455612d38477424e321850
+Author: Xi Ruoyao <xry111@xry111.site>
+Date:   Thu Feb 15 20:49:27 2024 +0800
+
+    LoongArch: Fix a build error with GCC 14 (#825)
+    
+    Fix the build error with GCC 14:
+    
+        ../src/loongarch64/ffi.c: In function 'ffi_prep_closure_loc':
+        ../src/loongarch64/ffi.c:525:7: error: implicit declaration of
+        function 'ffi_tramp_set_parms' [-Wimplicit-function-declaration]
+
+commit 0b1dd62bef4192b61153182f7687edf7e885611c
+Author: bartoli <perso.olivier.barthelemy@gmail.com>
+Date:   Thu Feb 1 04:54:57 2024 +0100
+
+    Update README.md (#820)
+    
+    For cygwin/MSVC build, CXXCPP is also needed to pass configure checks
+
+commit c07c40ee9444e029bc595860a669de32b7af282a
+Author: Anthony Green <green@moxielogic.org>
+Date:   Wed Jan 31 22:43:38 2024 -0500
+
+    `feat(github-actions): add new build workflow for warp`
+
+commit 622caabcd25f4e11f752241417d06c9062acdf1f
+Author: Chongyun Lee <45286352+licy183@users.noreply.github.com>
+Date:   Sun Dec 24 23:38:32 2023 +0800
+
+    Put more optional symbols behind ifdefs (#812)
+
+commit a1c391bd8e604c611c7e9c8f6705dc723d403eb5
+Author: Виктор Чернякин <56512186+LocalSpook@users.noreply.github.com>
+Date:   Fri Dec 22 03:30:50 2023 -0700
+
+    Fix a variety of warnings (#811)
+
+commit 3a62a08af7bd0b5d540a087590dc54cdc312416b
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Dec 21 15:19:44 2023 -0500
+
+    Remove warnings
+
+commit d96fa2117cc6ca2923de9a2f34311ef0219b7590
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Dec 21 14:04:19 2023 -0500
+
+    Eliminate warning
+
+commit 5b1944b4ce4b03e28a5843d36812756168d66b08
+Author: Martin Storsjö <martin@martin.st>
+Date:   Wed Nov 29 00:38:13 2023 +0200
+
+    aarch64: Write the BTI instructions as "hint" instructions (#810)
+    
+    GNU binutils refuses to assemble the direct BTI instructions unless
+    the target architecture explicitly supports BTI, ending up with errors
+    such as
+    
+        ../src/aarch64/sysv.S: Assembler messages:
+        ../src/aarch64/sysv.S:87: Error: selected processor does not support `bti c'
+        ../src/aarch64/sysv.S:156: Error: selected processor does not support `bti j'
+    
+    Building with -march=armv8.5-a fixes building this.
+    
+    However, the BTI instructions assemble into hint instructions, that
+    are ignored by processors that don't implement them. Therefore it is
+    possible to assemble them for the baseline armv8.0-a target as well,
+    by replacing "bti j" with "hint #36", "bti c" with "hint #34" and
+    "bti jc" with "hint #38"; this assembles into the same instruction
+    bits.
+
+commit 11af2196d5f4e8c756758cf86e4ab79dda89f405
+Author: Anthony Green <green@moxielogic.org>
+Date:   Thu Nov 23 09:22:20 2023 -0500
+
+    Reference recent changes
+
+commit d7f5e98b437a242ac712cda8df3e47b205339711
+Author: David Tenty <daltenty.dev@gmail.com>
+Date:   Thu Nov 23 09:16:56 2023 -0500
+
+    Fix visibility check for AIX (#804)
+
+commit 7f960d9a062fab0624302e9f63ef8b025f51dd10
+Author: David Tenty <daltenty.dev@gmail.com>
+Date:   Thu Nov 23 09:16:35 2023 -0500
+
+    [powerpc][AIX] fix layout issues for nested struct types (#805)
+    
+    * [powerpc][AIX] fix layout issues for nested struct types
+    
+    On AIX under the default power alignment rules, the layout
+    of struct types which are nested inside other structs may
+    be different than the layout of those types on their own.
+    
+    Specifically the first member double rules which would
+    apply an eight byte alignment if that type appears in the
+    first position of a struct:
+    
+     1) apply recursively if the struct appear in the first member
+        of another struct
+     2) do not apply if that struct is itself a member of another struct
+        and not the first member.
+    
+    The current implementation of the rules in libffi doesn't handle these
+    cases, causing a mismatch with the compiler and causing some crashes
+    we see when OpenJ9 is used with libffi on AIX.
+    
+    This PR corrects this and adds some representative test cases.
+    
+    * Fix code style
+    
+    * Add a size check
+    
+    * Add additional test
+    
+    * Fix padding in internal structs
+    
+    * Flip condition back to original form
+    
+    * Add a comment
+
+commit d93c0be8a0f11f207e8232770c5f0590406efad1
+Author: Tobias Heider <tobias.heider@stusta.de>
+Date:   Thu Nov 23 15:15:29 2023 +0100
+
+    Add bti intructions to aarch64 assembly to work with strict (#808)
+    
+    BTI enforcement on OpenBSD.
+
+commit adbcf2b247696dde2667ab552cb93e0c79455c84
+Author: Daily Price Depot Droid <anthony@atgreen.org>
+Date:   Sat Oct 21 09:58:28 2023 -0400
+
+    Disable firefox testing
+
+commit 357755eef44735676de1cec458192c7784fb3aa8
+Author: Daily Price Depot Droid <anthony@atgreen.org>
+Date:   Sat Oct 21 09:05:48 2023 -0400
+
+    Try logging
+
+commit c23e9a1c81a84ea4804d001865845b25ff8d4c8a
+Author: Nobuyoshi Nakada <nobu@ruby-lang.org>
+Date:   Sat Oct 21 20:44:24 2023 +0900
+
+    Check if FFI_GO_CLOSURES is defined (#796)
+    
+    This macro is always defined to 1 if defined, or undefined.
+    With `-Wundef` option, checking the value without checking if it is defined causes warnings:
+    
+    ```
+    /opt/local/include/ffi.h:477:5: warning: 'FFI_GO_CLOSURES' is not defined, evaluates to 0 [-Wundef]
+    #if FFI_GO_CLOSURES
+        ^
+    ```
+
+commit a4be0b7210b5a7fd67770d2f4d63105900bc459a
+Author: Yn0ga <ynoga@protonmail.com>
+Date:   Sat Oct 21 13:43:43 2023 +0200
+
+    Add support for Haikuos on PowerPC (#799)
+
+commit dd90749505559d38abb339f1a1cd03791a9dc484
+Author: Petr Sumbera <sumbera@volny.cz>
+Date:   Sat Oct 21 13:42:11 2023 +0200
+
+    Fix passing floating point arguments on 64bits SPARC (libffi#778) (#802)
+
+commit 44f6fa3e526c920c61c8ac10661f447ccfe30872
+Author: Alfred Wingate <parona@protonmail.com>
+Date:   Fri Oct 20 15:02:37 2023 +0300
+
+    Put optional symbols behind ifdefs (#800)
+    
+    Signed-off-by: Alfred Wingate <parona@protonmail.com>
+
+commit 5c6e53db873767cd2266745cebc62551958f5bee
+Author: Michael Osipov <1983-01-06@gmx.net>
+Date:   Mon Sep 4 13:27:01 2023 +0200
+
+    Fix build failures on HP-UX (#792)
+    
+    This fixes #328
+    
+    Co-authored-by: Chris Hunt <chrahunt@gmail.com>
+
+commit 1b3e7569fe114fc7d7779e35704b8519fe65fd4d
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Mon Sep 4 19:26:11 2023 +0800
+
+    Replace use of triple with target, and explicitly specify build host to force cross-compilation (#794)
+
+commit 22b50e896a80171648439497041afe3b6dba1c08
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 31 16:31:42 2023 -0400
+
+    Fix python and pyodide version
+
+commit 4467a3bc350bca106aee2c55cbb19ffffb144d1b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 31 08:48:50 2023 -0400
+
+    Upgrade pyodide version to match newer selenium API
+
+commit 1d0a28ab5a2ee2e12b0650d69184d561cd1fd83c
+Author: Ivan Tadeu Ferreira Antunes Filho <itadeufa@gmail.com>
+Date:   Sat Aug 12 09:02:39 2023 -0400
+
+    Make label private on apple (#788)
+    
+    Private labels on apple must start with L prefix, while on ELF they start with .L prefix.
+    This makes the label start with L on apple instead of .L.
+
+commit 9e8f1bd8de39ee90a73c6927e2df18a418f6da55
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Tue Jun 20 21:17:04 2023 -0700
+
+    Emscripten build: Remove -sSTRICT_JS (#781)
+    
+    This rasies errors on newer versions of the emscripten compiler.
+
+commit ac598b7f5272d536b75f4b3833a4610cf4cd9404
+Merge: 2d63cee 8bdd471
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Apr 3 08:20:32 2023 -0400
+
+    Merge branch 'master' of github.com:/libffi/libffi
+
+commit 2d63cee0e2154bb9027cff71f780cfaa2f543567
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Apr 3 08:18:23 2023 -0400
+
+    Add tests with homogeneous aggregate types
+
+commit 8bdd4716e5974ee0b28b3c09db1eaa9e8833481e
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Sun Apr 2 19:54:22 2023 -0700
+
+    More accurate explanation of wasm32 state in readme (#776)
+    
+    There are three main wasm32 target triples:
+    * wasm32-unknown-unknown
+    * wasm32-unknown-emscripten
+    * wasm32-unknown-wasi
+    
+    The wasm32 port is only for the wasm32-unknown-emscripten target triple.
+    (The other triples have no dynamic linking support so libffi would be both
+    hard to port and of limited utility.)
+
+commit f08493d249d2067c8b3207ba46693dd858f95db3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 17 20:35:44 2023 -0500
+
+    Mention ARCv3 work
+
+commit c4df19c99f8d8841942e3edaadbf331d30e298c8
+Author: Claudiu Zissulescu <claziss@gmail.com>
+Date:   Sat Feb 18 03:33:47 2023 +0200
+
+    Update ARC's libffi port (#771)
+    
+    * Add support for ARC and ARC64
+    
+    Add support for ARC/ARC32/ARC64
+    
+    * Implementation of GO Closure for ARC/ARC32/ARC64 Architectures
+    
+    ---------
+    
+    Co-authored-by: Nuno Cardoso <cardoso@synopsys.com>
+    Co-authored-by: Luis Silva <luiss@synopsys.com>
+
+commit 237520649730cb21daf4ebff1cf9a0a64f8507f8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 9 12:23:35 2023 -0500
+
+    Normalize libffi labels
+
+commit ca26801567e9ce19c83f132c6a116d3d25d3b8a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 9 10:31:22 2023 -0500
+
+    Use rlgl
+
+commit 7d23c2d28e884ad5978e0974ad2443570940d393
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Thu Feb 9 06:01:37 2023 -0800
+
+    Add emscripten gha workflow (#768)
+    
+    Resolves issue #767
+
+commit 883f5ae665bf96008a7a56bf4d6c64cb05c68272
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Feb 5 09:51:37 2023 -0500
+
+    Rename label
+
+commit 678dad5abe6c95ffa087b799922c2114b18c8541
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Thu Feb 2 14:48:07 2023 -0800
+
+    Use libffi-dg-prune to handle Emscripten INFO messages rather than patching emcc.py (#766)
+
+commit 7d03d3a3150c5c1ff70753edaa880bb5d57ae566
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 16:09:14 2023 -0500
+
+    Mention wasm32
+
+commit c267c72fa803316e95462f16bf1e3d6d5d55612c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 16:04:34 2023 -0500
+
+    Modernize
+
+commit 2687cfc5329d08d6bd4d397c1ca8eb0d171e22fd
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Thu Feb 2 09:10:00 2023 -0800
+
+    Add wasm32 emscripten support (#763)
+    
+    * added build script
+    
+    * Apply libffi-emscripten patch
+    
+    * Some changes to wasm32/ffi.c
+    
+    * Remove exit(0); from test suites
+    
+    * Fix LONGDOUBLE argument type
+    
+    * Use more macros in ffi.c
+    
+    * Use switch statements instead of if chains
+    
+    * Implemented struct args
+    
+    * Finish struct implementation
+    
+    * Partially working closures
+    
+    * Got closures working (most of closures test suite passes)
+    
+    * Revert changes to test suite
+    
+    * Update .gitignore
+    
+    * Apply code formatter
+    
+    * Use stackSave and stackRestore rather than directly adjusting stack pointer
+    
+    * Add missing break
+    
+    * Fix visibility of ffi_closure_alloc and ffi_closure_free
+    
+    * Fix FFI_TYPE_STRUCT and FFI_TYPE_LONGDOUBLE when WASM_BIGINT is not used
+    sig needs to be vi here for FFI_TYPE_STRUCT and FFI_TYPE_LONGDOUBLE, noticed this while running the test suite without WASM_BIGINT support.
+    
+    * Always use dynCall rather than direct wasmTable lookup (function pointer cast emulation changes dynCall)
+    
+    * Prevent closures.c from duplicating symbols
+    
+    * Try to set up CI
+    
+    * Add test with bigint
+    
+    * Make test methods static
+    
+    * Remove BigInt shorthand because it messes up terser
+    
+    * Add selenium tests
+    
+    * Update tests a bit to try to make CI work
+    
+    * WASM_BIGINT is a linker flag not a compile flag
+    
+    * Finish getting CI working (#1)
+    
+    * update gitignore
+    
+    * Avoid adding "use strict;" to generated JS
+    
+    This should be controlled by -s STRICT_JS in Emscripten.
+    
+    * Make JavaScript ES5 compliant
+    
+    * Remove redundant EXPORTED_RUNTIME_METHODS settings
+    
+    * Fix definition of DEREF_I16
+    
+    * Avoid marshalling FFI_TYPE_LONGDOUBLE when WASM_BIGINT is not used
+    
+    * Add missing FFI_TYPE_STRUCT signature
+    
+    * Improve test scripts
+    
+    * Remove redundant EXPORTED_RUNTIME_METHODS settings
+    
+    * Add missing EOL
+    
+    * Add struct unpacking tests
+    
+    * Update ci config to try to actually use WASM_BIGINT
+    
+    * Revert "Avoid marshalling FFI_TYPE_LONGDOUBLE when WASM_BIGINT is not used"
+    
+    This reverts commit 61bd5a3e20891623715604581b6e872ab3dfab80.
+    
+    * Fix single_entry_structs tests
+    
+    * Fix return from closure call
+    
+    * Fix 64 bit return from closures
+    
+    * only allocate as much space on stack for return pointer as needed
+    
+    * Revert "only allocate as much space on stack for return pointer as needed"
+    
+    This reverts commit e54a30faea3803e7ac33eed191bde9e573850fc1.
+    
+    * xfail two tests
+    
+    * Fix err_bad_abi test
+    
+    * Remove test logging junk
+    
+    * Try to set up long double marshalling for closures
+    
+    * xfail err_bad_abi
+    
+    * Fix reference errors in previous commit
+    
+    * Add missing argument pointer assignment
+    
+    * Fix signature of function pointer in cls_dbls_struct
+    
+    * Fix longdouble argument
+    
+    * Try some changes to bigint handling
+    
+    * Fix BigInt handling
+    
+    * Fix cls_longdouble test
+    
+    * Fix long double closure arg with no WASM_BIGINT
+    
+    * Use EM_JS to factor out js helpers
+    
+    * Support for varargs closure calls
+    
+    * Fix varargs calls
+    
+    * Fix err_bad_abi test
+    
+    * Fix typo in previous commit
+    
+    * Add more assertions to closures test suite
+    
+    * Fix some asserts
+    
+    * Add assertions to a few more tests
+    
+    * Fix some tests
+    
+    * Fix more floating point assertions
+    
+    * Update more tests
+    
+    * Var args for ffi_call
+    
+    * Don't do node tests
+    
+    * Macro for allocating on stack
+    
+    * Add some comments, simplify struct handling
+    
+    * Try again to fix varargs calls, add comments
+    
+    * Consolidate WASM_BIGINT conditionals into LOAD_U64 and STORE_U64 macros
+    
+    * A bit of cleanup
+    
+    * Fix another typo
+    
+    * Some fixes to the testsuite
+    
+    * Another testsuite fix
+    
+    * Fix varags with closures?
+    
+    * Another attempt at getting closure varargs to work
+    
+    * sig is initialized later
+    
+    * Allow libffi.closures tests to be run
+    
+    * Improve build script
+    
+    * Remove redundant semicolons
+    
+    * Fix a few libffi.closures test failures
+    
+    * Cleanup
+    
+    * Legacy dynCall API is no longer used
+    
+    * Fix FFI_TYPE_LONGDOUBLE offset
+    
+    * xfail 2 tests for WASM
+    
+    - closure_loc_fn0; not applicable -- codeloc doesn't point to closure.
+    - huge_struct; function signature too long.
+    
+    * Revert some redundant dg-output/printf statements
+    
+    Helps Node.
+    
+    * Revert "Don't do node tests"
+    
+    This reverts commit a341ef4b.
+    
+    * Fix assertions in cls_24byte
+    
+    * More tiny formating fixes to test suite
+    
+    * Revert "Revert "Don't do node tests""
+    
+    This reverts commit 7722e685ea04e2420e042886816d8c4dd31f5dcb.
+    
+    * Fix 64 bit returns when WASM_BIGINT is absent
+    
+    * Fix print statement in cls_24byte
+    
+    * Add CALL_FUNC_PTR macro to allow pyodide to define custom calling behavior to handle fpcast
+    
+    * Update single_entry_structs tests
+    
+    * More explanations
+    
+    * Fix compile error in last commit
+    
+    * Add more support for pyodide fpcast emulation, update CI to try to test it
+    
+    * Clone via https
+    
+    * Fix path to pyodide emsdk_env
+    
+    * Add asserts to the rest of the test suite
+    
+    * Fix test compile errors
+    
+    * Fix some tests
+    
+    * Fix cls_ulonglong
+    
+    * Fix alignment of <4 byte args
+    
+    * fix cls_ulonglong again
+    
+    * Use snprintf instead of sprintf
+    
+    * Should assert than strncmp returned 0
+    
+    * Fix va_struct1 and va_struct3
+    
+    * Change double and long double tests
+    
+    These tests are failing because of a strange bug with prinft and doubles, but I am not convinced
+    it necessarily has anything to do with libffi. This version casts the double to int before printing it and avoids the issue
+    
+    * Enable node tests
+    
+    * Revert "Change double and long double tests"
+    
+    This reverts commit 8f3ff89c6577dc99564181cd9974f2f1ba21f1e9.
+    
+    * Fix PYODIDE_FPCAST flag
+    
+    * add conftest.py back in
+    
+    * Fix emcc error: setting `EXPORTED_FUNCTIONS` expects `<class 'list'>` but got `<class 'str'>`
+    
+    See discussion on https://github.com/pyodide/pyodide/pull/1596
+    
+    * Remove test.html
+    
+    * Remove duplicate test file
+    
+    * More changes from upstream
+    
+    * Fix some whitespace
+    
+    * Add some basic debug logging statements
+    
+    * Reapply libffi.exp changes
+    
+    * Don't build docs (#7)
+    
+    Works around build issue makeinfo: command not found.
+    
+    * Update long double alignment
+    
+    Emscripten 2.0.26 reduces the aligmnet of long double to 8. Quoting
+    from `ChangeLog.md`:
+    
+    > The alignment of `long double`, which is a 128-bit floating-point
+    > value implemented in software, is reduced from 16 to 8. The lower
+    > alignment allows `max_align_t` to properly match the alignment we
+    > use for malloc, which is 8 (raising malloc's alignment to achieve
+    > correctness the other way would come with a performance regression).
+    > (#10072)
+    
+    * Update long double alignment
+    
+    Emscripten 2.0.26 reduces the aligmnet of long double to 8. Quoting
+    from `ChangeLog.md`:
+    
+    > The alignment of `long double`, which is a 128-bit floating-point
+    > value implemented in software, is reduced from 16 to 8. The lower
+    > alignment allows `max_align_t` to properly match the alignment we
+    > use for malloc, which is 8 (raising malloc's alignment to achieve
+    > correctness the other way would come with a performance regression).
+    > (#10072)
+    
+    * Improve error handling a bit (#8)
+    
+    * Fix handling of signed arguments to ffi_call (#11)
+    
+    * Fix struct argument handling in ffi_call (#10)
+    
+    * Remove fpcast emulation tests
+    
+    * Align the stack to MAX_ALIGN before making call (#12)
+    
+    * Increase MAX_ARGS
+    
+    * Cleanup (#14)
+    
+    * Fix Closure compiler error with -sASSERTIONS=1 (#15)
+    
+    * Remove function pointer cast emulation (#13)
+    
+    This reverts commit 593b402 and cbc54da, as it's no longer needed
+    after PR pyodide/pyodide#2019.
+    
+    * Prefer the `__EMSCRIPTEN__` definition over `EMSCRIPTEN` (#18)
+    
+    "The preprocessor define EMSCRIPTEN is deprecated. Don't pass it to code
+    in strict mode. Code should use the define __EMSCRIPTEN__ instead."
+    https://github.com/emscripten-core/emscripten/blob/84a634167a1cd9e8c47d37a559688153a4ceace6/emcc.py#L887-L890
+    
+    * Install autoconf 2.71
+    
+    * Try again with installing autoconf 2.71
+    
+    * Fix compatibility with Emscripten 3.1.28
+    
+    * CI: remove use of `EM_CONFIG` env
+    
+    See commit:
+    https://github.com/emscripten-core/emsdk/commit/3d87d5ea8143b3636f872fb05b896eb4a19a070b
+    
+    * Fix cls_multi_schar: cast rest_call to signed char
+    
+    * Remove test xfails (#17)
+    
+    * Fix long double when used as a varargs argument
+    
+    * Enable unwindtest and fix it
+    
+    * Add EM_JS_DEPS
+    
+    * Also require convertJsFunctionToWasm
+    
+    * Run tests very very verbose
+    
+    * Echo the .emscripten file
+    
+    * Remove --experimental-wasm-bigint insertion
+    
+    * Build with assertions
+    
+    * Move verbosity flags back out of LDFLAGS
+    
+    * Remove debug print statement
+    
+    * Use up to date pyodide docker image
+    
+    * Explicitly cast res_call to fix test failure
+    
+    * Put back name of main function in cls_longdouble_va.c
+    
+    * Fix alignment
+    
+    The stack pointer apparently needs to be aligned to 16. There were
+    some terrible subtle bugs caused by not respecting this. stackAlloc
+    knows that the stack should be 16 aligned, so we can use stackAlloc(0)
+    to enforce this. This way if alignment requirements change, as long
+    as Emscripten updates stackAlloc to continue to enforce them we should
+    be okay.
+    
+    * Fix handling of systems with no Js bigint integration
+    
+    When we run the node tests we use node v14 tests (since node v14 is
+    vendored with Emscripten). Node v14 has no Js bigint integration
+    unless the --experimental-wasm-bigint flag is passed. So only the
+    node tests really notice if we get this right. Turns out, it didn't
+    work. We can't call a JavaScript function with 64 bit integer arguments
+    without bigint integration.
+    
+    In ffi_call, we are trying to call a wasm function that takes 64 bit
+    integer arguments. dynCall is designed to do this. We need to go back
+    to tracking the signature when we don't have WASM_BIGINT, and then use
+    dynCall. This works better now that emscripten can dynamically fill in
+    extra dynCall wrappers:
+    https://github.com/emscripten-core/emscripten/pull/17328
+    
+    On the other hand, for the closures we are not getting a function pointer
+    as a first argument. We need to make our own wasm legalizer adaptor that
+    splits 64 bit integer arguments and then calls the JavaScript trampoline,
+    then the JavaScript trampoline reassembles them, calls the closure, then
+    splits the result (if it's a 64 bit integer) and the adaptor puts it back
+    together.
+    
+    * Improvements to emscripten test shell scripts (#21)
+    
+    This fixes the C++ unwinding tests and makes other minor improvements
+    to the Emscripten test shell scripts.
+    
+    * Rename the test folder and move test files into emscripten test folder
+    
+    * Use docker image that has autoconf-2.71
+    
+    * Cleanup
+    
+    * Pin emscripten 3.1.30
+    
+    * Fix build.sh path
+    
+    * Rearrange ci pipeline
+    
+    * Fix bpo_38748 test
+    
+    * Cleanup
+    
+    * Improvements to comments, add static asserts, and update copyright
+    
+    * Use `*_js` instead of `*_helper` for EM_JS functions (#22)
+    
+    * Minor code simplification
+    
+    * Xfail first dejagnu test to work around emscripten cache messages
+    
+    See https://github.com/emscripten-core/emscripten/issues/18607
+    
+    * Remove unneeded xfails
+    
+    * Shorten conftest.py by using pytest-pyodide
+    
+    * Apply formatters and linters to emscripten directory
+    
+    * Fix Emscripten xfail hack
+    
+    * Fix build-tests script
+    
+    * Patch emscripten to quiet info messages
+    
+    * Clean up compiler flags in scripts and remove some settings from circleci config
+    
+    * Rename emscripten quiet script
+    
+    * Add missing export
+    
+    * Don't remove go.exp
+    
+    * Add reference to emscripten logging issue
+    
+    ---------
+    
+    Co-authored-by: Kleis Auke Wolthuizen <info@kleisauke.nl>
+    Co-authored-by: Kleis Auke Wolthuizen <github@kleisauke.nl>
+    Co-authored-by: Christian Heimes <christian@python.org>
+
+commit ce077e5565366171aa1b4438749b0922fce887a4
+Author: serge-sans-paille <serge.guelton@telecom-bretagne.eu>
+Date:   Thu Feb 2 14:46:29 2023 +0000
+
+    Forward declare open_temp_exec_file (#764)
+    
+    It's defined in closures.c and used in tramp.c.
+    Also declare it as an hidden symbol, as it should be.
+    
+    Co-authored-by: serge-sans-paille <sguelton@mozilla.com>
+
+commit abf211d1603da9d687455169646e0e9667be17c1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 07:06:02 2023 -0500
+
+    Mention HPPA fixes
+
+commit 222abd0c65babe2174b21753217145f5031a8b91
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 07:04:55 2023 -0500
+
+    From Dave Anglin:
+    
+    This patch is derived from the work done in implementing libffi for 64-bit hppa64-hpux target. Currently, the 32-bit hppa targets do a linear search for the return type of an ffi_call. This is slow and inefficient. A jump table can used to jump directly to the code used to process the return value. In most common cases, the return value can be processed in the jump table itself.
+    
+    The patch also fixes return handling for FFI_TYPE_UINT8, FFI_TYPE_SINT8, FFI_TYPE_UINT16 and FFI_TYPE_SINT16.
+
+commit e58e22b22386ed0e0a95e97eb8eed016e3f01b02
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 07:02:53 2023 -0500
+
+    From Dave Anglin:
+    
+    A couple of years ago the 32-bit hppa targets were converted from using a trampoline executed on the stack to the function descriptor technique used by ia64. This is more efficient and avoids having to have an executable stack. However, function pointers on 32-bit need the PLABEL bit set in the pointer. It distinguishes between pointers that point directly to the executable code and pointer that point to a function descriptor. We need the later for libffi. But as a result, it is not possible to convert using casts data pointers to function pointers.
+    
+    The solution at the time was to set the PLABEL bit in hppa closure pointers using FFI_CLOSURE_PTR. However, I realized recently that this was a bad choice. Packages like python-cffi allocate their own closure pointers, so this isn't going to work well there.
+    
+    A better solution is to leave closure pointers unchanged and only set the PLABEL bit in pointers used to point to executable code.
+    
+    The attached patch drops the FFI_CLOSURE_PTR and FFI_RESTORE_PTR defines. This allows some cleanup in the hppa closure routines. The FFI_FN define is now used to set the PLABEL bit on hppa. ffi_closure_alloc is modified to set the PLABEL bit in the value set in *code.
+    
+    I also added a FFI_CL define to convert a function pointer to a closure pointer. It is only used in one test case.
+
+commit baa6bbbc176b3c572eaf05b3fae0311df7e5f7b7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 2 06:59:46 2023 -0500
+
+    Add HPPA64 support
+
+commit e70dd1aa240159bd2050cb1eafffb49cdc1d8b22
+Author: Iain Sandoe <iain@sandoe.co.uk>
+Date:   Thu Feb 2 11:44:13 2023 +0000
+
+    libffi: Fix X86 32b Darwin build and EH frames. (#757)
+    
+    This addresses a number of issues in the X86 Darwin 32b port for libffi.
+    
+    1. The pic symbol stubs are weak definitions; the correct section placement
+       for these depends on the linker version in use.  We do not have access
+       to that information, but we can use the target OS version (assumes that
+       the user has installed the latest version of xcode available).
+       When a coalesced section is in use (OS versions earlier than Darwin12 /
+       OSX 10.8), its name must differ from  __TEXT,__text since otherwise that
+       would correspond to altering the attributes of the .text section (which
+       produces a diagnostic from the assembler).
+       Here we use __TEXT, __textcoal_nt for this which is what GCC emits for
+       these stubs.
+       For later versions than Darwin 12 (OS X 10.8) we can place the stubs in
+       the .text section (if we do not we get a diagnostic from clang -cc1as
+       saying that the use of coalesced sections for this is deprecated).
+    
+    2. The EH frame is specified manually, since there is no support for .cfi_
+       directives in 'cctools' assemblers.  The implementation needs to provide
+       offsets for CFA advance, code size and to the CIE as signed values
+       rather than relocations. However the cctools assembler will produce a
+       relocation for expressions like ' .long Lxx-Lyy' which then leads to a
+       link-time error.  We correct this by forming the offset values using
+       ' .set' directives and then assigning the results of them.
+    
+    3. The register numbering used by m32 X86 Darwin EH frames is not the same
+       as the DWARF debug numbering (the Frame and Stack pointer numbers are
+       swapped).
+    
+    4. The FDE address encoding used by the system tools is '0x10' (PCrel + abs)
+       where the value provided was PCrel + sdata4.
+    
+    5. GCC does not use compact unwind at present, and it was not implemented
+       until Darwin10 / OSX 10.6.  There were some issues with function location
+       in 10.6 so that the solution here suppresses emitting the compact unwind
+       section until Darwin11 / OSX 10.7.
+
+commit 7effe99955b228ae828d06fa8d07dc546ef67b1a
+Author: Iain Sandoe <iain@sandoe.co.uk>
+Date:   Thu Feb 2 11:42:46 2023 +0000
+
+    Darwin: Search for both shared and convenience libraries in each path. (#761)
+    
+    For several Darwin linker versions, the default behaviour is to first traverse
+    the set of library paths, looking for shared libraries, and then a second time
+    looking for archives.
+    
+    This means that if the library is configured --disable-shared the installed
+    system version /usr/lib/libffi.dylib will be found before the archive under
+    test.
+    
+    Using the linker option '-search-paths-first' alters the strategy to search each
+    path for dylib and then archive before moving on to the next.
+
+commit ebbc5e14cdbfcc24bf3c9bb7b41ee10cd979c535
+Author: serge-sans-paille <serge.guelton@telecom-bretagne.eu>
+Date:   Thu Feb 2 11:40:17 2023 +0000
+
+    Fix signed vs unsigned comparison (#765)
+    
+    As reported by -Wsign-compare. In the case of getting the result of
+    comparing the result of sysconf (_SC_PAGESIZE) to other value, this also
+    correctly handles edge cases where the above fails and returns -1.
+    
+    Co-authored-by: serge-sans-paille <sguelton@mozilla.com>
+
+commit 7611bb4cfe90884b55ad225e0166136a1d2cf22b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jan 8 09:01:00 2023 -0500
+
+    Use checkout@v3, with nodejs 16
+
+commit 3a8bb6bb7f51844b890ce6ae44fc6d7c4547fbd0
+Author: YongKang Zhou <zhouyongkang4321@gmail.com>
+Date:   Sun Jan 8 21:56:34 2023 +0800
+
+    fix typo (#758)
+    
+    `mingW` -> `MinGW`
+
+commit 00116b6d0171ba69ffe23d6b5c21c0fdb5907a48
+Author: Alexander Kanavin <alex.kanavin@gmail.com>
+Date:   Mon Dec 5 03:20:09 2022 +0100
+
+    arm/sysv: reverted clang VFP mitigation (#747)
+    
+    Since commit e3d2812ce43940aacae5bab2d0e965278cb1e7ea,
+    seperate instructions were used when compiling under clang,
+    as clang didn't allow the directives at the time. This mitigation
+    now causes compilation to fail under clang 10, as described by
+    https://github.com/libffi/libffi/issues/607. Now that
+    clang supports the LDC and SDC instructions, this mitigation
+    has been reverted.
+    
+    Co-authored-by: Brett Warren <brett.warren@arm.com>
+
+commit c50c16d0bcb58952840184aa83e62c6d912bf779
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 20 12:20:40 2022 -0500
+
+    Fix large struct passing on PA-RISC
+
+commit c6dc125afba294b9b9613392c492ae18df3ede84
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 25 10:28:19 2022 -0400
+
+    Add missing test cases
+
+commit 2b2f61f6e6a79d46fa277965745a8cd8bb5f04bc
+Author: Xavier Claessens <xclaesse@gmail.com>
+Date:   Mon Oct 24 20:39:04 2022 +0200
+
+    Small build cleanup (#743)
+    
+    * configure.ac: Remove some unused checks
+    
+    * Fix FFI_API definition
+    
+    When doing a static build dllimport/dllexport should be disabled. It was
+    also using 2 different macros FFI_BUILDING_DLL and FFI_BUILDING for no
+    reason.
+
+commit f24180be1367f942824365b131ae894b9c769c7d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 23 20:17:29 2022 -0400
+
+    Update to version 3.4.4
+
+commit 848052fabb207d6f56485c8c2c3509eddecbe828
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 23 11:25:10 2022 -0400
+
+    More aarch64 fixes
+
+commit af0f14cd6d932bd1c2f7c39c01e2df3b0ad19ea9
+Author: Icecream95 <the.real.icecream95@gmail.com>
+Date:   Mon Oct 24 04:08:10 2022 +1300
+
+    Fix types of temporary variables in aarch64 extend_integer_type (#745)
+    
+    Fixes truncated values in weston-info output.
+
+commit f7233db2a781b43e419a30edbec7639f74fa2a00
+Author: musvaage <112724366+musvaage@users.noreply.github.com>
+Date:   Mon Oct 17 17:26:17 2022 -0500
+
+    typos (#742)
+
+commit 45e492952e9f984a105ab281fb9433a4bbc12146
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 16 12:41:56 2022 -0400
+
+    Add 32-bit cygwin test
+
+commit 93cfb655200f34ab1b2b7d8955291c457b91ee9f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 10 14:32:35 2022 -0400
+
+    Correction for older compilers
+
+commit 77a0fb82b53087647a12334c6ddd590ea6215199
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Mon Oct 10 17:59:04 2022 +0200
+
+    Flush output before aborting (#740)
+    
+    Co-authored-by: Andreas Schwab <schwab@suse.de>
+
+commit 3874fd9865eef72a5cf5a761781b51f8db9fa267
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Mon Oct 10 17:58:48 2022 +0200
+
+    Fix strict aliasing problem in aarch64 ffi_call (#739)
+    
+    The assignment a = &dest in ffi_call_int may be moved after the call to
+    extend_integer_type because that function accesses the assigned value with
+    a different type.
+    
+    Co-authored-by: Andreas Schwab <schwab@suse.de>
+
+commit 4b0c358e28fae22164bf0d423f183dfed8a1ba10
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Mon Oct 10 17:57:47 2022 +0200
+
+    riscv: make copies of structs passed by reference (#738)
+    
+    Co-authored-by: Andreas Schwab <schwab@suse.de>
+
+commit c163d93ac032a101cda1818855d681430f7af89a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Oct 8 18:35:38 2022 -0400
+
+    Add gcc-12 testing for aarch64 linux
+
+commit 62fd1f218be35976858a9f3a0b36fe0d38146bc9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 2 13:03:37 2022 -0400
+
+    Tweak quotes
+
+commit e1d1b094d31dbf97bd53c09736be97e1e9812d6a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 28 10:16:45 2022 -0400
+
+    Add .
+
+commit b45f68949d7d1b705eb5e26f58a09972ad70a9c4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 28 10:16:01 2022 -0400
+
+    Update README for 3.4.4.
+
+commit 817a43fbc1d6d1c702c492e926f158b17ae988e4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 28 09:05:45 2022 -0400
+
+    Revert to previous cfi check. (#735)
+
+commit 963c4a969326192a2a0ad536d3943f21dbbb0eaa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 22:05:42 2022 -0400
+
+    Remove nested comments
+
+commit e9e44157526c00bfd1142175ed6a7eb936ea0ede
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 21:25:30 2022 -0400
+
+    Don't tweak path
+
+commit 4594dcc98770b4fa60fce313abf557f090f8a0fd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 21:05:26 2022 -0400
+
+    Fix find
+
+commit fe68a7b998329f471c3c0c5726073b9cb1a5a126
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 20:29:17 2022 -0400
+
+    Locate tools
+
+commit cfb3f4c255cda534d1dc5de6a31cff70f02f9d69
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 20:13:42 2022 -0400
+
+    Use cross tools for Windows
+
+commit ae544e0043079d778fdf0e16408db3b7a6d723bd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 18:23:06 2022 -0400
+
+    Fix shell
+
+commit b8d849bd85294253787bbe1838de354ad2f54201
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 17:58:31 2022 -0400
+
+    Find ms tools
+
+commit 9785eee066782d7575023f94b64402963b55aa8c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 17:39:44 2022 -0400
+
+    32- and 64-bit Windows
+
+commit 1421717effc7b5052e3c26e2b715a83a8a61355c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 08:13:17 2022 -0400
+
+    Add "lto" to triple to identify lto builds
+
+commit 425acd4c2f217b00868ec1577c20b73de032c114
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 27 07:57:37 2022 -0400
+
+    Try aarch64 linux with -flto
+
+commit c4261a0588fa997837e44f8417fc8577b37cd461
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 26 16:45:00 2022 -0400
+
+    Show compiler version
+
+commit a1467200c36ce80dacb8d9d0d50049765809b6f4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 26 11:41:48 2022 -0400
+
+    Never link pthread for android
+
+commit 5ce26a0e03eacb483709189e8cbb05509fa68612
+Author: Frederik Seiffert <frederik@seiffert.org>
+Date:   Mon Sep 26 13:43:40 2022 +0200
+
+    CI: add Android builds (#732)
+
+commit 55bcc47717bb0f9c5276a45710d757cda7a61f8e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 24 22:03:52 2022 -0400
+
+    Test idea borrowed from cpython
+
+commit a2473cde0a02c096dc3e0b57f0cb73f598765570
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 24 21:41:02 2022 -0400
+
+    or1k: All struct args are passed in memory
+
+commit f93224d38662a8cdc33ca56fe6f2d5650a86d690
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 24 21:38:57 2022 -0400
+
+    moxie: All struct args are passed in memory
+
+commit e79f19489bb294ce60bef5cdba5e56c3e7d84382
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 24 17:11:30 2022 -0400
+
+    Add test case transcribed from cpython
+
+commit ab96038772ec4f4ccfaf49d621cd20f58742c401
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 19:42:35 2022 -0400
+
+    Set host triplet for native builds
+
+commit a6fc81653d6ce649a6bc29675baa112c68a21df0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 19:25:09 2022 -0400
+
+    Update job names
+
+commit 6b7fb6ce9eb4751ed3179de256566971c9d46cb7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 18:23:42 2022 -0400
+
+    Give better names to CI workflows
+
+commit f0675ab7e85ca31095b51db5a5c955f1005240cb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 17:30:51 2022 -0400
+
+    Update version to 3.4.4-experimental
+
+commit e3eaa609882fbcffb6c1b21270b6ff46fb57699f
+Author: Hans <h-c-mueller@users.noreply.github.com>
+Date:   Mon Sep 19 23:26:59 2022 +0200
+
+    Suppress error console output duing configure in case not an ELF file (#729)
+    
+    On Cygwin, MSYS and MinGW readelf is available, but files generated are no
+    ELF files. This results in an Error output on console:
+    'checking whether .eh_frame section should be read-only... readelf: Error: Not an ELF file - it has the wrong magic bytes at the start
+    yes'
+    With this patch the error output is suppressed resulting in only
+    'checking whether .eh_frame section should be read-only... yes'
+    Setting of related variables is not changed.
+    
+    Co-authored-by: Hannes Müller <>
+
+commit 84817695eab13c282436fca278bde2384ca955e5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 13:31:46 2022 -0400
+
+    Fix typo
+
+commit 53338d2bbf547682b2461a6e4199276e24ec5c85
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 13:07:50 2022 -0400
+
+    Update version
+
+commit 0bd41b75df49f002f3fee9f4d5df225d742d3f1b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 12:26:05 2022 -0400
+
+    Update libtool version
+
+commit 9b1dd8f2d5af8c76d120ffd566bf3c821580c96c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 12:22:04 2022 -0400
+
+    Update version to 3.4.3
+
+commit 0a769ccc0f7a4a7e3e76a79b61c28341fc47e3be
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 08:17:15 2022 -0400
+
+    Update release dates
+
+commit f26b56e1c547d2b4d8c9303275ecea47b5936184
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 08:15:22 2022 -0400
+
+    Add new files for distribution
+
+commit b801b54b667340867441e922c14230a93832c8e2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 06:49:32 2022 -0400
+
+    Mention AIX with GCC
+
+commit ff34df233c863371912881516eae039f850fcad6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 06:45:19 2022 -0400
+
+    Update comment about platform support
+
+commit 598ea692b81ac8116bd9907d2b498c16fc92bde7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 06:43:41 2022 -0400
+
+    Clean ups, preparing for new release
+
+commit fc6b939066f211b99eed3c8111e446ec95d51ca6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 19 06:42:29 2022 -0400
+
+    Standardize temp exec file creation
+
+commit 4c2984c43fbb3db8e65b2b5702b27944eb0ed343
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 15:06:57 2022 -0400
+
+    Handle win32 ABIs for struct return
+
+commit b05dc51bbe9aef6fcac66a8e68b59472bfaff126
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 13:03:10 2022 -0400
+
+    Debug x86
+
+commit cafdb8377a8be2eadac05c318fae9ef6786c36c2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 12:05:12 2022 -0400
+
+    Revert
+
+commit acf0ce9e9b0bcd73d39f599a53e9924ba74c13c1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 11:04:54 2022 -0400
+
+    Add test case
+
+commit b49308eaac7288e01a36894598fb62bfaf61b238
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 08:26:23 2022 -0400
+
+    Add missing ABI_ATTR
+
+commit 735e7be4fb2a0401a9ca66cc64004b8b3418feb3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 18 08:21:34 2022 -0400
+
+    X86 is never defined.
+
+commit ee22ecbd11f52f8de1adbb2a6561aee2125a576a
+Author: Hans <h-c-mueller@users.noreply.github.com>
+Date:   Sun Sep 18 01:56:25 2022 +0200
+
+    Add MSYS configuration files (#728)
+    
+    * Add MSYS configuration files
+    
+    MSYS behaves very similiar to Cygwin, e.g. also __CYGWIN__ is defined.
+    Now 'make check' passes on MSYS without extra patches.
+    
+    * Fix warning extra tokens at end of #endif in closures.c
+    
+    Extra tokens converted into a comment. Also nearby indentations corrected.
+    
+    * Fix missing prototype warning mkostemp() on Cygwin
+    
+    Cygwin requires also _GNU_SOURCE to be defined to enable mkostemp() prototype.
+    
+    * Fix warning label ‘out’ defined but not used in ffi functions
+    
+    Define same preprocessor conditions for goto and label visibility.
+    
+    * Fix warning label ‘out’ defined but not used and related indentations.
+    
+    Define same preprocessor conditions for goto and label visibility. Correct also
+    related indentations.
+    
+    Co-authored-by: Hannes Müller <>
+
+commit 5e010474cf2e30fa053f0a1a460a752f06438cf7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 16:57:59 2022 -0400
+
+    Fix test case for 64-bit mingw
+
+commit 305cde7904ab676b7974ae68acb40b788b4c484e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 15:50:35 2022 -0400
+
+    Passes on 64bit mingw
+
+commit 05785cafcf584d80c6b48651e1d33c4a3feca75c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 15:18:09 2022 -0400
+
+    Fix arg alignment for STDCALL
+
+commit 98d4ad65e9933ed4878ef4aacfaa8299e467a903
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 09:42:53 2022 -0400
+
+    Fix test headers
+
+commit 2abf00a6c61f4cf6232dc50f28204be020bef05d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 08:25:39 2022 -0400
+
+    Tweak msys2 tools again
+
+commit d1b31536af74590b74236a00254e77617a8d50b0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 08:16:26 2022 -0400
+
+    Fix msys2 tool selection
+
+commit d352ed366722d5dfce0c1581c3820124c0bbafed
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 08:10:53 2022 -0400
+
+    Build 32- and 64-bit msys2
+
+commit 4d0a0384ce11446e02fb7f233aae5c19c8082fb1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 07:58:26 2022 -0400
+
+    msvc requires the printf change, not mingw
+
+commit a509abf6b0ef9045b8df05b0c3663969b21290c4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 06:45:00 2022 -0400
+
+    Install unzip
+
+commit 950ed4a75384c4e7b0a512cb49f71f4d99c50a5d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 06:33:14 2022 -0400
+
+    Don't make msys2 default shell
+
+commit 5d02c0cca3750c7aac61971b9e4cb94940793303
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 06:28:23 2022 -0400
+
+    Try msys2
+
+commit 64a78fa760c581f9c70199abb34aef1e0d086bd2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 06:08:30 2022 -0400
+
+    Try new path
+
+commit 77fdeae859f3ab96bc936f0a967d34a5609af40d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 01:37:31 2022 -0400
+
+    Find mingw32
+
+commit bb4e7278b7f362afd03d128e7cb68a5e0e2efaf7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 15 01:28:58 2022 -0400
+
+    DEbug
+
+commit 7443b421d39087cad2e607d00b845c670b18920f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 23:17:21 2022 -0400
+
+    Try new shell
+
+commit 2ebc36f4be835437fa5d6c4c2b796fc22f769323
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 23:11:52 2022 -0400
+
+    Fix indentation
+
+commit 3740b243277c6dc210d45bd0b4f8abe8c2e1cb29
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 23:10:43 2022 -0400
+
+    set mingw32 path
+
+commit 7bf23f899cef435d023ecc8afde34d9e83829c2f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 23:04:42 2022 -0400
+
+    Rename job
+
+commit ce5b2208121667236874181360ca91aaa285b528
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 23:02:32 2022 -0400
+
+    Fix mingw32 github actions
+
+commit 317c9b6a13d3414c510b27bdc7ce57be56399df5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 22:54:10 2022 -0400
+
+    Add mingw32 testing
+
+commit 19e8354ff9b608b5410451caef6a9773375de005
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 07:36:06 2022 -0400
+
+    Fix test case
+
+commit 4932f351579fb722e1e0b58a173b1571a6dfae79
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 07:08:06 2022 -0400
+
+    Improve test case
+
+commit 819b01ced894028d41a34ec0178de9e7637b23de
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 14 07:07:15 2022 -0400
+
+    Add test case
+
+commit b577a5b801b1d1aef1aec5920d34fd1fd6597122
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 12 10:23:59 2022 -0400
+
+    Mention Cygwin static trampoline support.
+
+commit 4b54a6471a8f98eb8bc1ea1694a8f3a3a433e538
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 12 09:02:08 2022 -0400
+
+    Fix limits.h inclusion for cygwin
+
+commit a1130f37712c03957c9b0adf316cd006fa92a60b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 12 08:53:06 2022 -0400
+
+    Add static trampoline support for Cygwin
+
+commit 26cc9a6c73c80e8459c25da3718c91cf5a36cbd8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 10 20:36:45 2022 -0400
+
+    Remove stray }}
+
+commit 078184887d65bf4a3ecd2f78f6cdbf4c91ccc357
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 10 11:45:28 2022 -0400
+
+    Update rlgl usage (switch from player ID to labels)
+
+commit 6e7caacb9c94efba6775825df2479be389da51f1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 10 10:31:37 2022 -0400
+
+    Label rlgl reports
+
+commit d9a19e21c2b86e03b6acb8a2d73d992c8e4974e8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:58:03 2022 -0400
+
+    The right kind of quotes
+
+commit 2b2644969cbeeaee50938fbea591ea7f85df809e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:57:26 2022 -0400
+
+    More quotes
+
+commit eb9eb1f6f041548fe670c76f7a90d1c53c75d620
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:49:51 2022 -0400
+
+    Fix random build dir
+
+commit ea124a99da9efb3bde86a1706e15f62be7e68a66
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:21:21 2022 -0400
+
+    Remove bogus sparc compiler flag
+
+commit cca77833fd53ffec93a4962d1e9cd7ea5a38f13f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:20:59 2022 -0400
+
+    Fix typo
+
+commit 8ee64076f1b7cc654ff24adaffff25ddb3d57484
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:14:13 2022 -0400
+
+    Fix typo
+
+commit 086935029d23dad133c97dfaf68749b7726460a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 7 07:12:10 2022 -0400
+
+    Set CC and CXX for GCC compile farm builds
+
+commit da905276850342df0f9dfe2c775f6c649d4eed6b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 21:15:58 2022 -0400
+
+    dlmmap fix and always check for PaX MPROTECT on linux
+    
+    Also make EMUTRAMP experimental
+    From Stefan Bühler
+    https://github.com/libffi/libffi/pull/282
+
+commit b86c3dc0950ad5d8991e3970d56daeb409650d60
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 14:25:09 2022 -0400
+
+    Fix typos
+
+commit c9be1378c709586f264dd643f92f71b9f1a842b2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 14:12:21 2022 -0400
+
+    Retry autoconf downloads
+
+commit 62471fd078db7ef66ca8b3118187a2911f2bb3e7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 13:00:02 2022 -0400
+
+    Fix typo
+
+commit b2344575569bc3bd129ad0ff92b49dc220fb287b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 12:43:08 2022 -0400
+
+    Fix unwindtest on macos
+
+commit fc4e7c4a10dff3c99d7ea9be33d47e6d5f0efda7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 22:13:58 2022 -0400
+
+    Install automake on macos
+
+commit 5a6c94f7d49bcd64c85bde04c2d1f10b59d5797c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 22:04:52 2022 -0400
+
+    Test with gcc and clang on macos 11 and 12.
+
+commit 351318e3bde9ac90c6d5eddbaa7f26ee3e7bcc6c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 15:45:53 2022 -0400
+
+    Switch to 7 char SHA IDs.  Fix windows crlf at git clone time.
+
+commit 2a024088801403ca0c579d20c3decb8dc1453df1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 12:56:19 2022 -0400
+
+    Use GitHub SHA for rlgl ID
+
+commit e4c5d46b0abaa8a12e97f0e0673e3efdda59fab8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 12:19:57 2022 -0400
+
+    Pass large structs by value
+
+commit 4b79267be359b42e7a4cbf95068abe805aae0061
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 08:11:45 2022 -0400
+
+    outputs vs output
+
+commit 3020ad832144e35d2a42fb8782ddbd3ed69fdbaf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 08:07:57 2022 -0400
+
+    Use single quotes
+
+commit f969a50aadfdf288797d5492dfb768d9916b9477
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 08:06:53 2022 -0400
+
+    Try {{}}
+
+commit 8df671a35e517f27da78b1b933f19294cfc7224f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 08:05:39 2022 -0400
+
+    Fix compares
+
+commit 6a9bbc85a95a8a6d314452c8c5ef4add61e7b280
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:54:47 2022 -0400
+
+    Show host availability
+
+commit 49a361c35b3d826c02e6dc3f15c86555e62ed933
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:51:34 2022 -0400
+
+    Fix conditionals?
+
+commit d9189beb6e61b20ff4b84fd994d895a29351c422
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:47:46 2022 -0400
+
+    Use boolean values
+
+commit 2bcdcda8eda82cce594d2c821fc6a87069041bcc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:44:01 2022 -0400
+
+    Try conditional steps
+
+commit d86d55e51fc2d35ff3a829d41c8ec1c83570cd40
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:15:38 2022 -0400
+
+    Tweak test for host availability
+
+commit 5b4d5f2b3a3f3f9fb71ce40e3be00ae6191ffc37
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 07:11:12 2022 -0400
+
+    Fix triples
+
+commit 02e6a894cbb1d851ec1a31b3277f2414c4a1370f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 06:55:08 2022 -0400
+
+    Add missing paren
+
+commit fcaa8ebbccf2e2e4e0317164b624b683ac95c474
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 06:47:40 2022 -0400
+
+    Unnest quotes
+
+commit f4009ed4f0351c6c8e8f410dac7c558fe9996e7e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 06:40:00 2022 -0400
+
+    Fix syntax error
+
+commit f92e32cfacdbf82172b06ce13d63eab65f205598
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Sep 5 06:17:38 2022 -0400
+
+    Try dribbling output during make check
+
+commit ef57e08aa34dc9f55abb493a554a957ca358d931
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 22:35:32 2022 -0400
+
+    Split up build into multiple steps
+
+commit 2480cc48def54eb155429710187452e0d495b773
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 21:09:06 2022 -0400
+
+    Try to fix ssh issues
+
+commit 1105db1ce6cf1f7ab5a254cd04453b0c5e9dad30
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:52:28 2022 -0400
+
+    Try forcing exit upon completion
+
+commit 92a7775150978b3e98b0d47280dd6dd6580dbd07
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:17:01 2022 -0400
+
+    Source .profile on remote host if it exists
+
+commit 8e3ea879a9e538c9237c34ae113babe078565da9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:07:13 2022 -0400
+
+    Only ignore errors when testing for ssh connectivity.
+
+commit a643db6c1f1bd7594e42a03865b7a9063cfbf1c1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 08:28:50 2022 -0400
+
+    Don't fail on error
+
+commit 33f1f19a7da022a7d8dba59bb97c28cb4fd6aadf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 08:24:06 2022 -0400
+
+    Add POWER hosts
+
+commit 7a300f3d657ee7b94bda5296b3b366b5915a5c79
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 08:08:47 2022 -0400
+
+    Fix the setting of the host
+
+commit b104dd621f9d2b298ede781f0bd289ce8a0c20ee
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 08:07:12 2022 -0400
+
+    If a remote host is unavailable, don't fail the build.
+
+commit 7194e11832ad9609bd38c2a1fd4995d749443ee0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 08:01:47 2022 -0400
+
+    Debug build
+
+commit 6fccf95b4f97335eda1d8bfe2e12fc38bea571d2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 07:57:53 2022 -0400
+
+    Add connection timeouts and retries
+
+commit b4cf3d64b1807667eba7863701b6fcae68c65e68
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 07:32:18 2022 -0400
+
+    Prune warnings from sparc64 linux ld
+
+commit 807283704a4a77187103f9d4d73c9feb75f3c757
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 07:21:02 2022 -0400
+
+    For host triples to distinguish m1 arm64 from others.
+
+commit 4cba6c1858e842ef674ed41b5d79bc981fdfc411
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 11:42:11 2022 -0400
+
+    Don't exit if runtest fails
+
+commit 439dfa1f7f96aec5689d5b28511e0162bc0ae3f9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:42:46 2022 -0400
+
+    Fix spaces
+
+commit b7d9e3a1a0c3138df513cd5df49a0e14584c7556
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:41:45 2022 -0400
+
+    Run rlgl
+
+commit e85b55c2d30783db52d148f2691c8a3afd3d4ec3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:16:01 2022 -0400
+
+    Fix recursive copy flag
+
+commit 98168532a22615bd2aab0f3bf08e8a5f8abcd375
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:14:56 2022 -0400
+
+    Fix typo
+
+commit 943219e3281d4f9f3ae416ca3bf9fd3482cf8c63
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:13:04 2022 -0400
+
+    Use scp, as rsync isn't available on all hosts
+
+commit 0e912017c96afe6bf6500e90075df6b7366c337a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 10:04:54 2022 -0400
+
+    Use ssh port numbers and copy dejagnu results back
+
+commit c8fe3d3d440d46b7b465e8d11ea8461a5ae86462
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:58:43 2022 -0400
+
+    Use username
+
+commit 3e75f9554f06bab33e022276d320a301f1b04e44
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:56:13 2022 -0400
+
+    Tighten permissions on key
+
+commit d893eda74196ecc39f1d839b340d0b158fc536eb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:55:01 2022 -0400
+
+    Disable host key checking
+
+commit da35cf0fb693b6f93a745119c777b3c4aa6d779b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:52:26 2022 -0400
+
+    Add quotes
+
+commit 128d57ab940a3a76658a8c8b4b98cd80fb602d65
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:51:00 2022 -0400
+
+    Remove bad command
+
+commit 5b34bed4ff0a5c1c0257f4d586b868ded173dc67
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:49:45 2022 -0400
+
+    Debug
+
+commit 77b32cb1533e5166bebf2a7cd1465e3a1eef55ad
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:43:41 2022 -0400
+
+    Fix typo
+
+commit 22c1ceb27597d21779c7565c94c444dadc606478
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:42:01 2022 -0400
+
+    Simplify remote tests
+
+commit dde8e81deba0c2ef3edca804f34347bfae0e88bd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:22:19 2022 -0400
+
+    Revert to old file copy
+
+commit 3cd913c8dafa71c1bb14ca5e1f4208343cc3a194
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:19:08 2022 -0400
+
+    Remove SHA256
+
+commit 3127a25df827f2afa3f6bdfdfceff169fe241fcf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:13:16 2022 -0400
+
+    Try new fingerprint
+
+commit f095b747423806b44c2ef883ec65a7ce5230fbf7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 09:11:47 2022 -0400
+
+    Use correct fingerprint
+
+commit 1f44118157a005661b55f1747cfd15773214e458
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:55:20 2022 -0400
+
+    Ignore fingerprints
+
+commit 8fd73fe61f496a24a4093ba1d195a884f86d547e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:51:33 2022 -0400
+
+    Use rsa fingerprints
+
+commit 09c3908a4279f4c9e2c4a8282efb29c412964119
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:43:23 2022 -0400
+
+    Use host fingerprints
+
+commit caa793a3401b92b0ef2006ab90c4dd30b7ab7d5c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:35:56 2022 -0400
+
+    Try new scp
+
+commit 0cbffe5ef542641170b8cbe588fb703e7410cb13
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:23:35 2022 -0400
+
+    Fix GITHUB_RUN_NUMBER usage
+
+commit 628cc2f675c6df35213d74388aac69c5c165b1f4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:16:47 2022 -0400
+
+    Fix loongarch64 server port. Try GITHUB_RUN_NUMBER.
+
+commit 9382d7955f80aaa6fc0ca036956fe4e14a0d45b6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 08:06:11 2022 -0400
+
+    Reference matrix variables properly
+
+commit e081b2cec74253b48a0d09d8a0d309f60e8f82e5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 07:58:27 2022 -0400
+
+    List cfarm servers explicitly
+
+commit 074e9c79e36e63a9cc8c8fca6c76dd927778dc54
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 07:46:02 2022 -0400
+
+    Try multiple hosts
+
+commit 6002b2ad639f9125da56834e4b0a1b12fa232c57
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 07:10:58 2022 -0400
+
+    Use correct version of scp-action
+
+commit a990426c5f4114c85f6cfc190276786ef5c49521
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 07:09:33 2022 -0400
+
+    Use scp instead of rsync
+
+commit 0fabd777d91e13bb4795d0b9db0b2201f9298904
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 07:02:34 2022 -0400
+
+    Remove extra debug
+
+commit 1922870fe3baf41991670db81b35c1ab0b482895
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 06:53:52 2022 -0400
+
+    Debug rsync
+
+commit aee50966ca85d777271cd7e14714b916264cb190
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 3 06:47:49 2022 -0400
+
+    Change remote path
+
+commit 73552c2e732df17c7f9008fecfc448c1d6397cfe
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 20:03:02 2022 -0400
+
+    Tweak
+
+commit 904424fe82bd6d4a498fee84b3f26d55426ff75f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:58:19 2022 -0400
+
+    Work in actions dir
+
+commit 31c31db079b054270a19cc710f06fbb84e805511
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:48:33 2022 -0400
+
+    Run autogen before copying files to remote server
+
+commit d84f2ea0ea760b8e63f50eb6c3583aeb38d89d0e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:44:34 2022 -0400
+
+    Install autoconf
+
+commit 78beb4aee5386cd4ea14cfa753a778eafcc3ec2d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:34:50 2022 -0400
+
+    Try more remote testing
+
+commit 16f17cd8418ce2239f8b9b31e5f3b5414298292f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:16:12 2022 -0400
+
+    Fix ssh
+
+commit badccc01c84ee38f5f443c910ba06b3792029d8b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:11:53 2022 -0400
+
+    Add platform
+
+commit 0eae6af297d9a34bd6adcbf43fbbd27e5feebc53
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:09:43 2022 -0400
+
+    Missing colon
+
+commit ce8cec023499d8da04936e2dc40111f8d6a1783e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Sep 2 19:04:39 2022 -0400
+
+    Try cfarm access
+
+commit 9b58d4bad688820fa9bb077c0ec5f5949ac18bd2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 1 08:57:13 2022 -0400
+
+    GCC_AS_CFI_PSEUDO_OP passes on msvc, although it's not sufficient.
+
+commit e6d05bea0b4c350edaaf215a81f49298f34b10e4
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Thu Sep 1 14:51:15 2022 +0200
+
+    Fix struct padding warning reported by MSVC (#613)
+    
+    When building on 32-bit x86.
+
+commit 80912f2f09f4c06b2f720ff243d7b9b6795093f9
+Author: Clément Chigot <pro@helflym.eu>
+Date:   Thu Sep 1 14:47:16 2022 +0200
+
+    Makefile: enable target overridings. (#661)
+    
+    This patch allows target to provide extra files enabling the
+    override of Makefile rules.
+    This patch is not needed for libffi itself but only for GCC on AIX. The
+    t-aix file which is here empty will be replaced in GCC repository. We cannot
+    include GCC version directly here because it has no sense for a standalone
+    libffi.
+    
+    Co-authored-by: Clement <clement.chigot@atos.net>
+
+commit 1fa7d96cdf7bba354f61337854210f060ea56b9f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 1 08:28:59 2022 -0400
+
+    Don't use cached configure test result
+
+commit bcb42e432b5372b1876e8c8db68837d92d1f94ae
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 1 08:05:01 2022 -0400
+
+    Fix .cfi pseudo-ops test.
+    
+    The existing tests were failing because the GCC was wrapping the test
+    asm in cfi directives, which gas doesn't like.  So now we test if the
+    compiler emits them first, and assume that the assembler will accept
+    them.  If that doesn't work, then we test if the assembler will accept
+    them assuming the compiler doesn't emit them.
+
+commit 0eb91425f355be19939507d4d4d056bdad12c9dd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 31 20:46:24 2022 -0400
+
+    Change comment style
+
+commit ca76ab3b8551d9e7cee6f533ecd1e89fee70e16a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 31 10:30:26 2022 -0400
+
+    Fix exports for tests
+
+commit 7b1dd8ce10e6bef043088896136105b8aabbb882
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 31 09:49:21 2022 -0400
+
+    Don't -malign-double for x86-32
+
+commit 41d0851fc545ff1ffd8377236d193268c8a10740
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 31 07:36:43 2022 -0400
+
+    Update copyright year
+
+commit 5a4774cd4d90f9ea7e7f9e34b15de29463aba4c4
+Author: Xi Ruoyao <xry111@xry111.site>
+Date:   Fri Jul 22 05:56:30 2022 +0800
+
+    static trampoline for LoongArch (#723)
+    
+    For the benefit and technical details of static trampoline, see
+    https://github.com/libffi/libffi/pull/624.  As a new architecture, let's
+    be "safer" from the start.
+    
+    The change survived libffi testsuite on loongarch64-linux-gnu.
+
+commit 5264a7c5cd3460465326ebd347559828196dceb1
+Author: matoro <matoro@users.noreply.github.com>
+Date:   Thu Jul 21 17:54:19 2022 -0400
+
+    Move FFI_TYPE definitions above <ffitarget.h> include (#722)
+    
+    For powerpc at least, these definitions are referenced in the
+    target-specific ffitarget.h.  Discovered in the jffi project.  Should
+    close https://github.com/libffi/libffi/issues/637.  Downstream jffi bug
+    https://github.com/jnr/jffi/issues/107.  Downstream distro bug
+    https://bugs.gentoo.org/827215.
+    
+    Testing - both libffi and jffi test suites pass with this patch applied,
+    at least on ppc64le linux.  I did not see any warnings about
+    redefinitions.
+    
+    Tested versions - libffi 3.4.2, jffi 1.3.6 and 1.3.9.
+
+commit ddc6764386b29449d941b2b18d000f2987a9d848
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 22:04:53 2022 -0400
+
+    Add missing file
+
+commit 2b4728a21f9a36c6567df8dd27fc8a665264019c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:58:51 2022 -0400
+
+    Fix path
+
+commit 37cc25bb25344ee33c5b7ff06c6804d31374a544
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:56:40 2022 -0400
+
+    Install and use autoconf from special dir
+
+commit 2f2eab957d3acbf571c570ab2ccf894e3c85b033
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:53:00 2022 -0400
+
+    Fix autoconf version number
+
+commit 4b1465495c9d6e5ef95bacc38b86483fd910f887
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:51:25 2022 -0400
+
+    Fix wget
+
+commit 398b7534d97b2b642492fbb024e15be3df564da8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:49:09 2022 -0400
+
+    Fix wget
+
+commit 2c047eb7b108fba1203ba6122e830a7ae17721ca
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:46:54 2022 -0400
+
+    Fix untar
+
+commit 446c092f409bd37c21b5b986c2be8f87a1cb1dec
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:45:32 2022 -0400
+
+    Install autoconf-2.71
+
+commit 5c76ac1ff55c4ed6faa145b395e9a14cdb834708
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:22:01 2022 -0400
+
+    Update autoconf?
+
+commit 4a46f35ba5a4bbb3ea396e1fa836535d338f8930
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 21:14:30 2022 -0400
+
+    Update configury
+
+commit fc8c8c1e2c31321b38dc079e549bc7748da4159d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 11:06:00 2022 -0400
+
+    Fix ILP32 for aarch64
+
+commit b5abc4f6478147ce72fa6b2eb95296883d5ef3ef
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 25 10:43:00 2022 -0400
+
+    Remove duplicate macro definition.
+
+commit 280fe78d37f58927b280e2e316a2ae19201f2b83
+Author: Xi Ruoyao <xry111@xry111.site>
+Date:   Sat Jun 25 18:58:53 2022 +0800
+
+    configure.ac: use grep -E instead of egrep if possible (#720)
+    
+    Upstream will start to emit a warning if egrep is invoked in the next
+    grep release.  Stop invoking it explicitly.  Use AC_PROG_EGREP to try
+    "grep -E" first, and fallback to egrep if "grep -E" does not work.  We
+    need this fallback for some non-GNU grep implementations (like Solaris).
+    
+    Url: https://git.savannah.gnu.org/cgit/grep.git/commit/?id=a951562
+
+commit 1f14b3fa92d4442a60233e9596ddec428a985e3c
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Fri Jun 3 02:46:35 2022 +0800
+
+    Ensure that VM_PROT_EXECUTE is set on the trampoline page. (#718)
+
+commit 000ecd01cb534fd8bb593422013a79c8497263ff
+Author: Sergei Trofimovich <slyich@gmail.com>
+Date:   Thu Jun 2 18:43:53 2022 +0000
+
+    powerpc64: fix build on gcc-12 (assembly requires AltiVec) (#719)
+    
+    Without the change build fails on powerpc64-gcc-12 as:
+    
+        src/powerpc/linux64_closure.S: Assembler messages:
+        src/powerpc/linux64_closure.S:363: Error: unrecognized opcode: `lvx'
+    
+    It's a 90205f67 "rs6000: Fix bootstrap (libffi)" patch by
+    Segher Boessenkool from gcc upstream repository. It's enough to get
+    libffi build on powerpc64.
+
+commit c528d5b45e248f47b5af6f16bfcafc779b196ed1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 29 11:22:38 2022 -0400
+
+    Fix windows arg passing
+
+commit aa2c4141722ec8b8b014b97e049ffa2d140d0c0d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 29 10:28:10 2022 -0400
+
+    64-bit cygwin: fix struct args. Document change.
+
+commit 36b265ae438a364722c98136ba79cb450a48fca3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 29 10:12:30 2022 -0400
+
+    m32r: pass copies of large structs
+
+commit c248764d3391a460cdd31a1cae82281fd6dfbecd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 29 07:27:32 2022 -0400
+
+    Update testsuite Makefile
+
+commit fd1fe195e1d98b65ac3b0735cc0d0df95fc1b27b
+Author: Martin Storsjö <martin@martin.st>
+Date:   Sun May 29 14:16:49 2022 +0300
+
+    Fix building on aarch64 after e409225b41b60c490a094bb068e639a2364202fd (#716)
+    
+    The ALIGN_DOWN macro was renamed in 2018 in
+    e6eac7863e2bf1a009ea863041b354bdb4af6b67.
+
+commit c1e237b22ee6042e2d4229008acea8f38c3d0109
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 20:46:14 2022 -0400
+
+    Pass large structs by value on the stack
+
+commit 769b7366d2312c7efdfa605cf1fc1156b94ba2e0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 19:59:35 2022 -0400
+
+    Fix for MS x64 ABI
+
+commit faafcb9df9aebdde1415a73d17fe9e943d97d455
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 17:24:43 2022 -0400
+
+    Fix moxie struct passing
+
+commit f55d7ff1a24e9c678dac3397175772a9914c02b0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 14:30:13 2022 -0400
+
+    moxie: structs > 8 go on stack
+
+commit 55f80b026c2ac854086a2770d324fa55188f0f81
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 14:17:53 2022 -0400
+
+    New test cases
+
+commit 72c3192773fe483f6517e343ecc3ea468ce73a4f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 13:53:26 2022 -0400
+
+    Pass copies of large structs on the stack
+
+commit e409225b41b60c490a094bb068e639a2364202fd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 28 09:42:13 2022 -0400
+
+    Pass large structs by value for Linux x86_64 and Aarch64.
+    
+    Aarch patch by Andreas Schwab. https://github.com/libffi/libffi/commit/482b37f00467325e3389bab322525099860dd9aa
+
+commit 01d54435c9f9e22345cb2f7d482fcfb42fd11416
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue May 24 21:38:51 2022 -0400
+
+    Mention loongson64
+
+commit f259a6f6deff9bdc7dd998b8b6bdbb4c166b33c3
+Author: zhangwenlong <zhangwenlong@loongson.cn>
+Date:   Wed May 25 09:31:08 2022 +0800
+
+    Support loongarch64 (#678)
+    
+    * update config.{guess,sub}
+    
+    * Support loongarch64
+    
+    Co-Authored-By: Cheng Lulu <chenglulu@loongson.cn>
+    Co-Authored-By: Xi Ruoyao <xry111@mengyan1223.wang>
+    Co-Authored-By: Xu Hao
+    Co-Authored-By: Zhang Wenlong <zhangwenlong@loongson.cn>
+    Co-Authored-By: Pan Xuefeng <panxuefeng@loongson.cn>
+    
+    Co-authored-by: panxuefeng <panxuefeng@loongson.cn>
+    Co-authored-by: Cheng Lulu <chenglulu@loongson.cn>
+    Co-authored-by: Xi Ruoyao <xry111@mengyan1223.wang>
+
+commit d02d46607b5ba62510ddab5fa89303dfa09a7853
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue May 24 12:28:08 2022 -0400
+
+    Debug cygwin builds
+
+commit 7e93ded9302d7e6e3cc77b39e8eec4b323e63585
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 21:42:52 2022 -0400
+
+    Revert "Don't dereference beyond the last array entry. (#667)" (#715)
+    
+    This reverts commit 92d77d0e87a5f2a8c9c9b2431ffd264cb664e17a.
+
+commit 432384b6d47087d144d3e947b62c48ddc6e4740b
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Tue May 24 09:06:19 2022 +0800
+
+    Add support for ARM64 as an Apple simulator platform. (#712)
+
+commit 9af445fd70e4d7f2b3bdfc511cc3cc76a6b84c9a
+Author: Kevin Bowling <kevin.bowling@kev009.com>
+Date:   Mon May 23 18:05:01 2022 -0700
+
+    Upstream FreeBSD riscv patch (#708)
+    
+    Like 8276f812a99b10d1f2c387dbd6ef2ca4f597c733 commit message:
+        > devel/libffi: Fix abort() on ARM related to __clear_cache()
+        >
+        > The current FreeBSD __clear_cache() implementation does nothing #if
+        > __i386__ || __x86_64__ #else abort();
+        >
+        > cognet@ advises this is an issue for anything !Apple that is using the
+        > libcompiler_rt provided by Clang on ARM, and requires upstreaming.
+    
+    Co-authored-by: Kristof Provost <kp@FreeBSD.org>
+
+commit de95947ae5db07e4589bb16bab30b6c8ba2b3106
+Author: Roland Schatz <roland.schatz@oracle.com>
+Date:   Tue May 24 03:04:43 2022 +0200
+
+    Fix check for invalid varargs arguments. (#707)
+
+commit 92d77d0e87a5f2a8c9c9b2431ffd264cb664e17a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 21:03:00 2022 -0400
+
+    Don't dereference beyond the last array entry. (#667)
+
+commit e504f90fe9123d256f6bc556badb25d1d0aa7046
+Author: A. Wilcox <AWilcox@Wilcox-Tech.com>
+Date:   Mon May 23 18:42:32 2022 -0500
+
+    testsuite/libffi.closures: Fix PowerPC 64 (#709)
+    
+    -mlong-double-128 is only supported on glibc.
+    
+    This test still passes on glibc targets, and now passes on musl targets
+    as well (which uses 64-bit ldbl).
+
+commit f3e61d497a5ddc3bbe506e0554a0be421f6f0f35
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 09:11:42 2022 -0400
+
+    Remove debug code
+
+commit a36880e710f2ec37c0cc50d436facd7c2d282e7b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 08:35:21 2022 -0400
+
+    Remove stray export command
+
+commit 5f98afe802e189584e5649f53a7dd07280516efd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 08:11:26 2022 -0400
+
+    Debug cygwin builds
+
+commit abaacbf8cdf80ddd9303fda5d9be4312d52b531c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 23 07:57:26 2022 -0400
+
+    Debug cygwin tests
+
+commit e770fb76a781c642f185c23e686bf2af0429ce4c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 22 20:43:41 2022 -0400
+
+    Clean up types
+
+commit 2e825e219fa06d308b9a9863d70320606d67490d
+Author: YunQiang Su <syq@debian.org>
+Date:   Mon May 16 09:47:11 2022 +0800
+
+    MIPS: fix some N32 test failure (#701)
+    
+    Some go closure and pointer testcase fails.
+    These failures is not introduced by the complex support code.
+
+commit 1f1c33753b65a75216770928018e8932168e8908
+Author: YunQiang Su <syq@debian.org>
+Date:   Mon May 16 09:45:27 2022 +0800
+
+    MIPS: fix O32 softfloat support (#702)
+
+commit 3ac265d5c0e038e324bae29131dbc4bacb4935ea
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Sun May 15 18:43:56 2022 -0700
+
+    x86-64: Always double jump table slot size for CET (#710) (#711)
+    
+    When CET is enabled, double jump table slot size to add 4 bytes of ENDBR64
+    for CET.  Since CET enabled clang doesn't have the LLVM assembler bug:
+    
+    https://bugs.llvm.org/show_bug.cgi?id=21501
+    
+    fixed by
+    
+    commit 04d39260d64e08b8bfb3844109ad43d4055b2e8d
+    Author: Rafael Espindola <rafael.espindola@gmail.com>
+    Date:   Wed Nov 4 23:50:29 2015 +0000
+    
+        Simplify .org processing and make it a bit more powerful.
+    
+    we can use .org to allocate jump table slot size to 16 bytes.
+
+commit e67697c370e8875f28b2bf62fac25edad7558eca
+Author: YunQiang Su <syq@debian.org>
+Date:   Thu Mar 31 20:44:49 2022 +0800
+
+    MIPS: add Complex support (#698)
+
+commit e3cf8b806c3ca919f95b9d33d6037869a059c035
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Thu Mar 31 14:42:03 2022 +0200
+
+    Allow system to have overlapping mallopt defines (#700)
+    
+    Which is the case on some OSes, such as QNX.
+
+commit c086cacb8b9665fab0c046fc92959fc8af5239b8
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Thu Mar 31 14:40:59 2022 +0200
+
+    Clean up the QNX ARM bits (#699)
+    
+    - Add missing include.
+    - Use constants instead of magic values.
+
+commit ab1677106605aba1c27665964ff90bea59612ce3
+Author: Max Filippov <jcmvbkbc@gmail.com>
+Date:   Sun Feb 20 16:01:38 2022 -0800
+
+    Xtensa cleanups and XEA3 support (#677)
+    
+    * xtensa: clean up stack usage in ffi_trampoline call
+    
+    Space for outgoing call arguments reserved in the stack frame of the
+    function ffi_trampoline overlaps register spill overflow area at the
+    top of the frame. In xtensa XEA2 exception architecture the layout of
+    overlapping areas is identical so that even if the ffi_trampoline
+    registers frame gets spilled the memory contents doesn't change.
+    This is not so with the xtensa XEA3 exception architecture, where
+    registers a0 - a7 of a different function are spilled in that location.
+    
+    Reserve spill area for 8 registers to avoid overlapping of the spill
+    area with the outgoing call arguments area in the ffi_trampoline.
+    
+    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
+    
+    * xtensa: support xtensa XEA3 exception architecture
+    
+    XEA3 requires that 32 bytes of register spill area is reserved in all
+    functions. Fix ffi_cacheflush entry instruction to satisfy this
+    requirement.
+    
+    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
+    
+    * xtensa: maintain stack alignment
+    
+    xtensa ABI requires stack alignment on 16 byte boundary and passing
+    up to 6 arguments in registers. To simplify stack alignment maintenance
+    fixed amount of stack space is reserved for arguments passed in
+    registers and variable but correctly aligned amount is reserved for the
+    remaining arguments. After copying arguments to the stack and loading
+    registers the fixed part of the stack reservation is freed.
+    
+    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
+    
+    * xtensa: fix err_bad_abi tests
+    
+    Check ffi_cif::abi value in the ffi_prep_closure_loc and return
+    FFI_BAD_ABI error if it's not one of the supported values.
+    
+    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
+
+commit aa3fce08ba620c50db17215a9f14dd0f1facf741
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Sun Feb 13 21:04:33 2022 +0100
+
+    riscv: extend return types smaller than ffi_arg (#680)
+    
+    Co-authored-by: Andreas Schwab <schwab@suse.de>
+
+commit 464b4b66e3cf3b5489e730c1466ee1bf825560e0
+Author: Dan Horák <dan@danny.cz>
+Date:   Mon Jan 31 14:08:09 2022 +0100
+
+    powerpc64: fix handling of homogeneous float128 structs (#689)
+    
+    If there is a homogeneous struct with float128 members, they should be
+    copied to vector register save area. The current code incorrectly copies
+    only the value of the first member, not increasing the pointer with each
+    iteration. Fix this.
+
+commit b60d4fc7bb4419021bf566e09de55ed1d9b041db
+Author: rorth <ro@CeBiTec.Uni-Bielefeld.DE>
+Date:   Thu Dec 23 14:32:46 2021 +0100
+
+    src/x86/win64.S: Use #define instead of .macro (#665) (#669)
+    
+    The Solaris/x86 assembler doesn't support .macro/.endm, so use #define since
+    win64.S is passed through cpp anyway.
+
+commit 4fa6239f42ddc7df12e40da9ae25ba715312239c
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Thu Dec 23 14:27:32 2021 +0100
+
+    testsuite/libffi.call: fix mismatching return types (#679)
+    
+    Co-authored-by: Andreas Schwab <schwab@suse.de>
+
+commit 0f2dd369cd5edcefad29b3fca4e1d08cb34f8f19
+Author: Jules Maselbas <54854023+jmaselbas@users.noreply.github.com>
+Date:   Wed Sep 22 21:39:56 2021 +0200
+
+    Makefile: Add missing kvx/asm.h to dist headers (#660)
+    
+    The header kvx/asm.h is required to build libffi and is missing from
+    the dist tarball.
+    
+    Signed-off-by: Jules Maselbas <jmaselbas@kalray.eu>
+
+commit ee1263f7d43bd29b15fc72c4d9520a824e8004df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 17:46:17 2021 -0400
+
+    Fix 'type'-o
+
+commit 86d5ecc5e84fbbc79fcff6a307310630d9d68549
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 16:58:32 2021 -0400
+
+    Fix struct arg passing
+
+commit 03596285ed36b94bb3e1d8bdebfe58590e2766df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 10:16:42 2021 -0400
+
+    No more xfail for alpha
+
+commit 4ac18f26ed16588377b1482208212aaa39624e21
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 10:01:40 2021 -0400
+
+    Add alpha CPU
+
+commit 7643c6ee68e376810b4185e5f38e156c97bcc090
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 08:51:35 2021 -0400
+
+    Try to fix ARM QEMU tests
+
+commit a04f57bce057604f38bb7c1bf32b7f671d2b56d5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 08:47:53 2021 -0400
+
+    Fix m32r testing
+
+commit 339acf3d8f049d296dafac3f482c1b7db29c0bae
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 08:38:18 2021 -0400
+
+    Debug cross-in-containers builds
+
+commit 43e4ad4d7b4bcc87ee447736a1172b2801a47908
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 07:55:59 2021 -0400
+
+    Test passing structs by value
+
+commit 68485e33a413c3d91fbfd7ec270803ae6bd3d3db
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jul 29 07:13:35 2021 -0400
+
+    Mention x32 static tramponline fix
+
+commit 07f826fdd4d8a23a190f107f7ec6ad830a4864a0
+Author: Harald van Dijk <harald@gigawatt.nl>
+Date:   Sun Jul 25 02:39:37 2021 +0100
+
+    Fix trampoline_code_table for x32. (#657)
+    
+    x32's struct tramp_parm has 32-bit pointers. This change adjusts the
+    loads and offsets accordingly.
+
+commit be0b3b6e75d4890fe18ba4164b91387beaebee06
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 21:51:03 2021 -0400
+
+    Fix CHECK
+
+commit 7db17442a6c9f1399065748b7d5b9fbcac203344
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 11:30:01 2021 -0400
+
+    Don't check the whole buffer, just what we printed.
+
+commit 8bcf594749882e9e4966fec2e3d6009d08a554ab
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 11:26:02 2021 -0400
+
+    Fix test case
+
+commit c96b057757446fe4277f30e8423f09851ae5d0fa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 11:16:39 2021 -0400
+
+    Fix test check
+
+commit 4ed23be8e2a59e438c201ca1ba5affc0b0477b15
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 11:08:01 2021 -0400
+
+    Fix test check
+
+commit eb2447249540ca568b0b464f6107501dcc0f65ab
+Author: Hood Chatham <hood@mit.edu>
+Date:   Fri Jul 16 14:33:04 2021 +0000
+
+    Use CHECK to assert more things in test suite (#654)
+    
+    * Use CHECK to assert more things in test suite
+    
+    * Use snprintf instead of sprintf
+    
+    * Fix va_struct1 and va_struct3
+
+commit a541fc600f4418441f91073a0834ea47b0989de9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 08:56:30 2021 -0400
+
+    Update README for next release.
+
+commit b4cf80ab54b6d9d31ef2135036e471388cf026df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 08:55:02 2021 -0400
+
+    Trigger actions on master branch
+
+commit d1eef904766dbd647de6c240a57dbc98d46e33dd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 16 08:29:08 2021 -0400
+
+    Migrate from travis-ci to github actions.
+
+commit f9ea41683444ebe11cfa45b05223899764df28fb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 21:10:49 2021 -0400
+
+    Update version to 3.4.2
+
+commit 2bdc8e52efb78d939f23efb4f9c515355610bff5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 19:50:29 2021 -0400
+
+    Version 3.4.1
+
+commit c1d09bf08c2859abb40c476c57ae521d208f92a8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 18:50:31 2021 -0400
+
+    Update version to 3.4.0
+
+commit 1ed0aa73806872f0c31dccf2c689c762239d3353
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 18:45:11 2021 -0400
+
+    Fix warnings
+
+commit 0a2cc2ec2893821f62b36b269da1dbc0442a5617
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 14:59:07 2021 -0400
+
+    Add missing test cases to distribution
+
+commit ee3ef737857e13cc01a15dbef298478d90188805
+Author: Hood Chatham <hood@mit.edu>
+Date:   Mon Jun 28 11:51:35 2021 -0700
+
+    Add tests for single entry structs (#653)
+
+commit f08c5ace5750f1e1f234f52f4d3d772bb8d276a0
+Author: Hood Chatham <hood@mit.edu>
+Date:   Mon Jun 28 07:24:19 2021 -0700
+
+    Fix the assertions in cls-24byte (#652)
+    
+    * Fix the assertions in cls-24byte
+    
+    * Update print statement too
+
+commit 4557f232926353f5cdec0f2f459e4d59ce8f19e4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jun 28 09:53:01 2021 -0400
+
+    3.4.0 release candidate 2
+
+commit cd4428911d5c4d25ce2c24e6728124792124bba2
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Mon Jun 28 04:56:30 2021 -0700
+
+    Add missing FFI_HIDDEN to ffi_tramp_is_present declaration (#651)
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit 9fa94c607852081adce33547bde292fe4313cff7
+Author: Hood Chatham <hood@mit.edu>
+Date:   Sun Jun 27 11:02:33 2021 -0700
+
+    Print more information when an assertion fails in test suite (#649)
+
+commit 91eaadfb2e4b79d12a45d24002b06563e5905e5d
+Author: Hood Chatham <hood@mit.edu>
+Date:   Sun Jun 27 09:49:31 2021 -0700
+
+    Fix signature of function pointer in cls_dbls_struct (#648)
+
+commit 132699b95d3ee4d889ea2a80540acf3300987dad
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sun Jun 27 16:50:20 2021 +0100
+
+    configure.ac: add --disable-exec-static-tramp flag (#647)
+    
+    Some projects like GHC (Glasgow Haskell Compiler) and
+    gobject-introspection use `ffi_closure_alloc()` as a way
+    to allocate executable memory. exec static tramp
+    interferes with it (unclear how exactly yet).
+    
+    GHC symptom: ffi closure freeing cimplains about unexpected
+    trampoline (GHC manually fills one):
+    
+    ```
+    $ ghci
+    GHCi, version 8.10.5: https://www.haskell.org/ghc/  :? for help
+    ghc: freeHaskellFunctionPtr: not for me, guv! 0x7f0417a1efe8
+    ghc: freeHaskellFunctionPtr: not for me, guv! 0x7f0417a1efc8
+    ```
+    
+    gobject-introspection symptom:
+    
+    ```
+    $ meld
+    Segmentation fault (core dumped)
+    
+    $ gdb --args /usr/bin/python3.9 /usr/bin/meld
+    (gdb) run
+    ...
+    Thread 1 "python3.9" received signal SIGSEGV, Segmentation fault.
+    0x00007fffe9ac1ae8 in g_callable_info_free_closure (
+      callable_info=0x555555d45990, closure=0x7fffe9e70c20)
+        at ../gobject-introspection-1.68.0/girepository/girffi.c:428
+    428       g_free (wrapper->ffi_closure.cif->arg_types);
+    (gdb) bt
+      callable_info=0x555555d45990, closure=0x7fffe9e70c20)
+        at ../gobject-introspection-1.68.0/girepository/girffi.c:428
+      data=0x555555d252d0)
+        at ../pygobject-3.40.1/gi/pygi-closure.c:635
+    ...
+    ```
+    
+    To ease downstreams narrowing down the actual problem let's
+    provide a knob to disable exec static trampolines.
+    
+    The change for not affect current default.
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 4e07374c2773711902ec12905d5c64d95d22d050
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jun 27 11:25:06 2021 -0400
+
+    Remove caveat about varargs support
+
+commit 11f9713887e1d8e9bdf861c1555de55aba9fc46c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jun 27 07:46:12 2021 -0400
+
+    Update contact info
+
+commit f792adb61a27aa2a7d24573b956ce29ebdb82e03
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sat Jun 26 22:26:52 2021 +0100
+
+    configure.ac: allow user to specify READELF (#646)
+    
+    Before the change with x86_64-pc-linux-gnu cross-compiler
+    installed the configure was not able to find cross-readelf:
+    
+    ```
+    $ ./configure --host=x86_64-pc-linux-gnu
+    ...
+    checking whether .eh_frame section should be read-only... .././configure: line 19540: readelf: command not found
+    yes
+    ...
+    ```
+    
+    The change uses AC_CHECK_TOOL to automatically seatch for ${host}-readelf,
+    readelf. And as a bonus it also allows user to override readelf with
+    something like READELF=llvm-readelf.
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 9cf15b3a284d8e79f3673b8743d4157739df5d36
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 26 12:12:06 2021 -0400
+
+    Make 3.4 release candidate 1
+
+commit 1e5dc8de825d03f5493884a45e1edeacda2106c5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 26 12:08:35 2021 -0400
+
+    Add missing file from make dist.  Add missing license info.
+
+commit c0b210c7fd1e5b4a17e9fc839a4cf1d75483d591
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jun 26 10:55:57 2021 -0400
+
+    Remove test case
+
+commit 87429ce726ead7bb789d194c6d979c5b0c4086e9
+Author: Matthew Green <85970515+squidhacks@users.noreply.github.com>
+Date:   Sat Jun 26 08:49:45 2021 -0400
+
+    This test includes a closure and must live in the closures test directory. (#645)
+    
+    Co-authored-by: Matthew Green <squidhacks@users.noreply.github.com>
+
+commit 8d83c7c1fa331b93e58967979c59c38600df1ee9
+Author: Hood Chatham <roberthoodchatham@gmail.com>
+Date:   Fri Jun 25 19:50:33 2021 -0700
+
+    Make test methods static (#644)
+
+commit becae7397873d6bb85a271b16961f055e71f42a6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 22 13:01:06 2021 -0400
+
+    Switch from travis-ci.org to travis-ci.com.
+
+commit fa1ef887d4dc5d18696517e32e2ae98310f0040d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 22 08:48:24 2021 -0400
+
+    Avoid undefined behaviour
+
+commit 84bb56914756845371be62e2753041521fd5d261
+Author: Tres Finocchiaro <tres.finocchiaro@gmail.com>
+Date:   Tue Jun 22 07:33:46 2021 -0400
+
+    Remove libtool-ldflags file from .gitignore (#600)
+    
+    This is correct.  Thank you!
+
+commit 5651bea284ad0822eafe768e3443c2f4d7da2c8f
+Author: Jakub Jelinek <jakub@redhat.com>
+Date:   Tue Jun 15 15:19:26 2021 -0400
+
+    2021-06-15  Jakub Jelinek  <jakub@redhat.com>
+    
+            * src/x86/ffi64.c (classify_argument): For FFI_TYPE_STRUCT set words
+            to number of words needed for type->size + byte_offset bytes rather
+            than just type->size bytes.  Compute pos before the loop and check
+            total size of the structure.
+            * testsuite/libffi.call/nested_struct12.c: New test.
+
+commit f56eb85227bbcc7bd81232a338655146385a77ca
+Author: DJ Delorie <dj@delorie.com>
+Date:   Tue Jun 15 08:50:20 2021 -0400
+
+    Don't stop test on copy failure (#636)
+    
+    * Don't stop test on copy failure
+    
+    Static-library tests were failing only because there were
+    no DLLs to copy.  This change makes a copy failure not stop
+    the build; if a failed copy would otherwise be relevent, the
+    later tests would fail anyway.
+    
+    While there are more clever ways to solve this, a brute force
+    fix is sufficient.
+    
+    * [TEST] Try cygwin64; install more packages explicitly
+    
+    * use correct cygwin64 directory name
+    
+    appveyor has cygwin64 pre-installed in /cygwin64, and 32-bit cygwin
+    in /cygwin
+    
+    * More testing - revert VS change, bump travis timeout
+    
+    * Add -g to update the rest of perl
+    
+    * Skip execution tests on non-native platforms
+    
+    Special site.exp that skips the unix_load() command for arm platforms.
+    
+    Unset TERM to avoid cruft in stdout
+    
+    Try harder to find the libffi libraries
+
+commit ff059dd96af6ba4daf7bc9ddf22d1d2dbf6a177b
+Author: vhankala <81743325+vhankala@users.noreply.github.com>
+Date:   Thu Jun 10 18:41:02 2021 +0000
+
+    Fix build on OpenBSD/mips64 (#638)
+    
+    The build fails on OpenBSD/mips64 because clang 11's integrated
+    assembler expects read-only .eh_frame:
+    
+    ../src/mips/n32.S:585:9: error: changed section flags for .eh_frame, expected: 0x2
+            .section .eh_frame,"aw",@progbits
+            ^
+    
+    Use EH_FRAME_FLAGS to get matching flags for the section.
+
+commit e6eb59cde6580607544160f8e7dedc326b4799fd
+Author: Cheng Jin <jincheng@ca.ibm.com>
+Date:   Wed Jun 9 16:00:10 2021 -0400
+
+    Add struct test to verify a nested float struct (#640)
+    
+    The test aims to check a nested float struct
+    [float, [float,float]] to see whether it works good
+    with libffi.
+    
+    Signed-off-by: Cheng Jin <jincheng@ca.ibm.com>
+
+commit 6eb38863bc0b21854959ebf845f8672c44a99684
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jun 9 15:45:31 2021 -0400
+
+    Remove reference to old test case
+
+commit ca2235ecfe717ecaed6abbef3a2ca2918a91c60b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jun 4 18:20:24 2021 -0400
+
+    Revert appveyor changes
+
+commit 243004cc4c8be552503a5d10710ebb252b406064
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 1 23:00:29 2021 -0400
+
+    Update vs version
+
+commit 04c157f49a1b83798c102f3259bc397b9b7f7266
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 1 22:57:47 2021 -0400
+
+    Upgrade to vs2019
+
+commit 03a78e88402fff424426a1968e014be93666b86f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 1 22:53:44 2021 -0400
+
+    Try updating automake
+
+commit 1f1829bd4ce19b58d0354db3bef21cb8402cdf82
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 1 22:34:37 2021 -0400
+
+    Bring in the latest version of perl
+
+commit dd5bd03075149d7cf8441875c1a344e8beb57dde
+Author: Martin Storsjö <martin@martin.st>
+Date:   Wed Apr 7 05:42:10 2021 +0300
+
+    Fix building for arm windows with mingw toolchains (#631)
+    
+    * arm: Check _WIN32 instead of _M_ARM or _MSC_VER for detecting windows
+    
+    This matches what was done for ARM64 in
+    c06468fa6674d3783a0edb1d0fae9afc8bc28513.
+    
+    * arm: Only use armasm source when building with MSVC
+    
+    When building for windows/arm with clang, the normal gas style .S
+    source works fine (if fixed up to support thumb and other windows
+    specifics).
+    
+    This matches what was done for ARM64 in
+    c06468fa6674d3783a0edb1d0fae9afc8bc28513.
+    
+    * arm: Fix sysv.S to work in thumb mode
+    
+    Align cases in jump tables (adding nop padding to make sure each
+    case starts where expected).
+    
+    Rewrite instructions that add directly to the pc register.
+    
+    For ffi_closure_ret, factor out a call_epilogue subroutine that
+    restores both sp and pc from the stack; the thumb version of ldm
+    can't load into the sp register. To avoid excessive ifdeffing, keep
+    using call_epilogue in arm mode, but keep the shorter "ldm sp, {sp, pc}"
+    epilogue in that case.
+    
+    * arm: Add win32 version of trampoline to sysv.S
+    
+    This matches the version of it in sysv_msvc_arm32.S. The calling
+    C code expects a specific form of the trampoline on windows; make
+    sure these work the same on windows regardless of the form of
+    assembly used.
+    
+    * arm: Avoid optimizing out clearing the thumb bit of ffi_arm_trampoline
+    
+    We clear the thumb bit of ffi_arm_trampoline with a bitmask before
+    memcpying its instructions into closure->tramp.
+    
+    If the bit isn't cleared, the memcpy of the trampoline function
+    copies the wrong instructions.
+    
+    If the ffi_arm_trampoline symbol is declared as an array of int,
+    the compiler can assume that it is aligned to a 4 byte boundary
+    and the bitmask operation is a no-op, and optimize it out.
+    
+    See https://godbolt.org/z/dE3jE1WTz; both Clang and GCC optimize
+    out the bitmask as it is, while MSVC doesn't. By declaring the
+    trampoline as an array of unsigned char, the bitmask works as
+    intended.
+
+commit 95ef857d5c6ed15c6c6ba5f8a5b26c0a38b417ab
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 25 10:43:05 2021 -0400
+
+    Verbose brew update.
+
+commit 78c97c9ff4491e14e78992ffabdd043674c05e15
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 25 09:15:37 2021 -0400
+
+    Move container images to quay.io.
+
+commit 58dfdf6a84b98296ceb2b8b4237d37aa75bb2cd4
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Wed Mar 24 23:19:54 2021 +0000
+
+    testsuite: fix compiler vendor detection on dash as /bin/sh (#594)
+    
+    In https://bugs.gentoo.org/753299 Paolo Pedroni reported
+    a single test failure out of all libffi. Here is the minimal
+    reproducer:
+    
+    ```
+    $ ./autogen
+    $ CONFIG_SHELL=/bin/dash ./configure --host=x86_64-pc-linux-gnu
+    $ make check RUNTESTFLAGS='complex.exp'
+    ...
+    FAIL: libffi.complex/cls_align_complex_float.c (test for excess errors)
+    ```
+    
+    This happens because under 'dash' shell autoconf generates slightly
+    different style of string quotation in `config.log`:
+    
+    - on bash: `ax_cv_c_compiler_vendor=gnu`
+    - on dash: `ax_cv_c_compiler_vendor='gnu'`
+    
+    To avoid shell quotation parsing the change just embeds
+    `compiler_vendor` into `local.exp` at configure time.
+    
+    Reported-by: Paolo Pedroni
+    Bug: https://bugs.gentoo.org/753299
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit eafab2356e8dcf5f01d2bcfa311cafba3b395a7e
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Wed Mar 24 11:38:36 2021 -0700
+
+    arm64e: Pull in pointer authentication code from Apple's arm64e libffi port (#565)
+    
+    NOTES: This changes the ptrauth support from #548 to match what Apple is
+           shipping in its libffi-27 tag.
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit 01b56f4b3e89a349228c4ccf55061d847153c8d6
+Author: ericLemanissier <ericLemanissier@users.noreply.github.com>
+Date:   Wed Mar 24 12:20:27 2021 +0100
+
+    fix windows tests (#595)
+    
+    * Update .appveyor.yml
+    
+    * add (debug+release)*(shared+static) CI
+    
+    * fix libversion
+
+commit 1aeb26714ec30649f5d9de5b4884a4ac46f5f474
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Mar 24 12:16:12 2021 +0100
+
+    x86: Fix thiscall and fastcall stack cleanup behavior (#611)
+    
+    These are meant to use callee clean-up.
+
+commit e92c81a549924c80d70666ecbe5ed0c2fcd7963a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 24 07:07:53 2021 -0400
+
+    Mention MSVC runtime stack checking improvement
+
+commit f88add14e40de398706c732e578620e8106062c7
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Mar 24 12:04:51 2021 +0100
+
+    x86: Fix MSVC runtime checks interop (#612)
+    
+    MSVC can add runtime code that checks if a stack frame is mismanaged,
+    however our custom assembly deliberately accesses and modifies the parent
+    stack frame.  Fortunately we can disable that specific check for the
+    function call so do that.
+    
+    Co-authored-by: Matthew Waters <matthew@centricular.com>
+
+commit aa4dafb159a2e0f74aa39353a1bf23a943f36656
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 23 19:06:08 2021 -0400
+
+    Mention LIBFFI_TMPDIR
+
+commit 70ea259c603e0f84eda766be29d4259f1e8fe5b7
+Author: DJ Delorie <dj@delorie.com>
+Date:   Tue Mar 23 19:03:45 2021 -0400
+
+    Search $LIBFFI_TMPDIR also (#605)
+    
+    Most temp file directories need to be hardened against execution, but
+    libffi needs execute privileges.  Add a libffi-specific temp directory
+    that can be set up by sysadmins as needed with suitable permissions.
+    This both ensures that libffi will have a valid temp directory to use
+    as well as preventing attempts to access other directories.
+
+commit f58e5ee63263657a7e8f2892d27c012a16facc1a
+Author: AndreRH <andre.hentschel@ok.de>
+Date:   Tue Mar 23 23:54:00 2021 +0100
+
+    aarch64: Fix closures for win64 (#606)
+
+commit 5865450decd13275b2bde064bd4a0f79bca6dba2
+Author: Francisco Boni <boboniboni@gmail.com>
+Date:   Tue Mar 23 19:50:09 2021 -0300
+
+    Update ax_cc_maxopt m4 macro (#617)
+    
+    Keeps libffi's specific changes
+    (https://github.com/libffi/libffi/commit/cec3a3a201f17a7f018f25e1a0917bd5206e5a5a#diff-2396a1256ac4b1c6849c931ddb8018bdd984bb2383be21bb819a33b95d8d603f)
+    and updates to the latest ax_cc_maxopt.m4
+    (http://git.savannah.gnu.org/gitweb/?p=autoconf-archive.git;a=commit;h=73ee1b396c21062ee8eeb8721ba5323322110fb5):
+    
+    ax_cc_maxopt.m4: retain setting of CFLAGS by configure
+    
+    AX_CC_MAXOPT checks whether CFLAGS was set by the user; if so, the user’s
+    setting is respected. This behavior is retained, of course.
+    
+    However, AX_CC_MAXOPT was then setting CFLAGS="". This overrode the default
+    setting by configure, which usually includes -g. Hence, if CFLAGS was not
+    set by the user, retain the default setting, to preserve the ability to
+    debug.
+    
+    A typical default setting from configure is "-g -O2". This means that
+    AX_CC_MAXOPT might typically set CFLAGS to "-g -O2 -O3". This is fine,
+    because the later -O3 will override the earlier -O2. (The only assumption is
+    that all compilers that AX_CC_MAXOPT knows behave in this sane way.)
+
+commit 8f44384df17b536615caef951a615655a967103f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 23 14:24:54 2021 -0400
+
+    Fix formatting
+
+commit 9d491b5e21ffd7fcf2370d998a4832b755d1c9e9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 23 12:26:37 2021 -0400
+
+    Mention KVX
+
+commit 205cf01b57972fdc8c090fc79192b464dc43fc0d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 23 11:31:08 2021 -0400
+
+    Bug #680.  Don't accept floats or small ints as var args. (#628)
+    
+    * Bug #680.  Don't accept floats or small ints as var args.
+    
+    * Bug #680.  Don't accept floats or small ints as var args.
+    
+    * Bug #680.  Don't accept floats or small ints as var args.
+
+commit d271dbe0a8b230e566fa3385babdc9cc0ca214ea
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Sat Mar 20 06:06:28 2021 -0700
+
+    Add some missing #if conditionals from Apple's code drop (#620)
+    
+    * arm/aarch64: Add FFI_CLOSURES conditionals where appropriate
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * aarch64: Don't emit the do_closure label when building without FFI_GO_CLOSURES
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit bae695da367b6abd83152f8f1e9b1a8b79794c8d
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Sat Mar 6 00:09:17 2021 +0800
+
+    Add configuration generator for tvOS and watchOS. (#625)
+
+commit 9ba559217bea0803263a9a9a0bafcf9203606f5b
+Author: Madhavan T. Venkataraman <75220914+madvenka786@users.noreply.github.com>
+Date:   Fri Mar 5 10:07:30 2021 -0600
+
+    Static tramp v5 (#624)
+    
+    * Static Trampolines
+    
+    Closure Trampoline Security Issue
+    =================================
+    
+    Currently, the trampoline code used in libffi is not statically defined in
+    a source file (except for MACH). The trampoline is either pre-defined
+    machine code in a data buffer. Or, it is generated at runtime. In order to
+    execute a trampoline, it needs to be placed in a page with executable
+    permissions.
+    
+    Executable data pages are attack surfaces for attackers who may try to
+    inject their own code into the page and contrive to have it executed. The
+    security settings in a system may prevent various tricks used in user land
+    to write code into a page and to have it executed somehow. On such systems,
+    libffi trampolines would not be able to run.
+    
+    Static Trampoline
+    =================
+    
+    To solve this problem, the trampoline code needs to be defined statically
+    in a source file, compiled and placed in the text segment so it can be
+    mapped and executed naturally without any tricks. However, the trampoline
+    needs to be able to access the closure pointer at runtime.
+    
+    PC-relative data referencing
+    ============================
+    
+    The solution implemented in this patch set uses PC-relative data references.
+    The trampoline is mapped in a code page. Adjacent to the code page, a data
+    page is mapped that contains the parameters of the trampoline:
+    
+            - the closure pointer
+            - pointer to the ABI handler to jump to
+    
+    The trampoline code uses an offset relative to its current PC to access its
+    data.
+    
+    Some architectures support PC-relative data references in the ISA itself.
+    E.g., X64 supports RIP-relative references. For others, the PC has to
+    somehow be loaded into a general purpose register to do PC-relative data
+    referencing. To do this, we need to define a get_pc() kind of function and
+    call it to load the PC in a desired register.
+    
+    There are two cases:
+    
+    1. The call instruction pushes the return address on the stack.
+    
+       In this case, get_pc() will extract the return address from the stack
+       and load it in the desired register and return.
+    
+    2. The call instruction stores the return address in a designated register.
+    
+       In this case, get_pc() will copy the return address to the desired
+       register and return.
+    
+    Either way, the PC next to the call instruction is obtained.
+    
+    Scratch register
+    ================
+    
+    In order to do its job, the trampoline code would need to use a scratch
+    register. Depending on the ABI, there may not be a register available for
+    scratch. This problem needs to be solved so that all ABIs will work.
+    
+    The trampoline will save two values on the stack:
+    
+            - the closure pointer
+            - the original value of the scratch register
+    
+    This is what the stack will look like:
+    
+            sp before trampoline ------>    --------------------
+                                            | closure pointer  |
+                                            --------------------
+                                            | scratch register |
+            sp after trampoline ------->    --------------------
+    
+    The ABI handler can do the following as needed by the ABI:
+    
+            - the closure pointer can be loaded in a desired register
+    
+            - the scratch register can be restored to its original value
+    
+            - the stack pointer can be restored to its original value
+              (the value when the trampoline was invoked)
+    
+    To do this, I have defined prolog code for each ABI handler. The legacy
+    trampoline jumps to the ABI handler directly. But the static trampoline
+    defined in this patch jumps tp the prolog code which performs the above
+    actions before jumping to the ABI handler.
+    
+    Trampoline Table
+    ================
+    
+    In order to reduce the trampoline memory footprint, the trampoline code
+    would be defined as a code array in the text segment. This array would be
+    mapped into the address space of the caller. The mapping would, therefore,
+    contain a trampoline table.
+    
+    Adjacent to the trampoline table mapping, there will be a data mapping that
+    contains a parameter table, one parameter block for each trampoline. The
+    parameter block will contain:
+    
+            - a pointer to the closure
+            - a pointer to the ABI handler
+    
+    The static trampoline code would finally look like this:
+    
+            - Make space on the stack for the closure and the scratch register
+              by moving the stack pointer down
+            - Store the original value of the scratch register on the stack
+            - Using PC-relative reference, get the closure pointer
+            - Store the closure pointer on the stack
+            - Using PC-relative reference, get the ABI handler pointer
+            - Jump to the ABI handler
+    
+    Mapping size
+    ============
+    
+    The size of the code mapping that contains the trampoline table needs to be
+    determined on a per architecture basis. If a particular architecture
+    supports multiple base page sizes, then the largest supported base page size
+    needs to be chosen. E.g., we choose 16K for ARM64.
+    
+    Trampoline allocation and free
+    ==============================
+    
+    Static trampolines are allocated in ffi_closure_alloc() and freed in
+    ffi_closure_free().
+    
+    Normally, applications use these functions. But there are some cases out
+    there where the user of libffi allocates and manages its own closure
+    memory. In such cases, static trampolines cannot be used. These will
+    fall back to using legacy trampolines. The user has to make sure that
+    the memory is executable.
+    
+    ffi_closure structure
+    =====================
+    
+    I did not want to make any changes to the size of the closure structure for
+    this feature to guarantee compatibility. But the opaque static trampoline
+    handle needs to be stored in the closure. I have defined it as follows:
+    
+    -  char tramp[FFI_TRAMPOLINE_SIZE];
+    +  union {
+    +    char tramp[FFI_TRAMPOLINE_SIZE];
+    +    void *ftramp;
+    +  };
+    
+    If static trampolines are used, then tramp[] is not needed to store a
+    dynamic trampoline. That space can be reused to store the handle. Hence,
+    the union.
+    
+    Architecture Support
+    ====================
+    
+    Support has been added for x64, i386, aarch64 and arm. Support for other
+    architectures can be added very easily in the future.
+    
+    OS Support
+    ==========
+    
+    Support has been added for Linux. Support for other OSes can be added very
+    easily.
+    
+    Signed-off-by: Madhavan T. Venkataraman <madvenka@linux.microsoft.com>
+    
+    * x86: Support for Static Trampolines
+    
+            - Define the arch-specific initialization function ffi_tramp_arch ()
+              that returns trampoline size information to common code.
+    
+            - Define the trampoline code mapping and data mapping sizes.
+    
+            - Define the trampoline code table statically. Define two tables,
+              actually, one with CET and one without.
+    
+            - Introduce a tiny prolog for each ABI handling function. The ABI
+              handlers addressed are:
+    
+                    - ffi_closure_unix64
+                    - ffi_closure_unix64_sse
+                    - ffi_closure_win64
+    
+              The prolog functions are called:
+    
+                    - ffi_closure_unix64_alt
+                    - ffi_closure_unix64_sse_alt
+                    - ffi_closure_win64_alt
+    
+              The legacy trampoline jumps to the ABI handler. The static
+              trampoline jumps to the prolog function. The prolog function uses
+              the information provided by the static trampoline, sets things up
+              for the ABI handler and then jumps to the ABI handler.
+    
+            - Call ffi_tramp_set_parms () in ffi_prep_closure_loc () to
+              initialize static trampoline parameters.
+    
+    Signed-off-by: Madhavan T. Venkataraman <madvenka@linux.microsoft.com>
+    
+    * i386: Support for Static Trampolines
+    
+            - Define the arch-specific initialization function ffi_tramp_arch ()
+              that returns trampoline size information to common code.
+    
+            - Define the trampoline code table statically. Define two tables,
+              actually, one with CET and one without.
+    
+            - Define the trampoline code table statically.
+    
+            - Introduce a tiny prolog for each ABI handling function. The ABI
+              handlers addressed are:
+    
+                    - ffi_closure_i386
+                    - ffi_closure_STDCALL
+                    - ffi_closure_REGISTER
+    
+              The prolog functions are called:
+    
+                    - ffi_closure_i386_alt
+                    - ffi_closure_STDCALL_alt
+                    - ffi_closure_REGISTER_alt
+    
+              The legacy trampoline jumps to the ABI handler. The static
+              trampoline jumps to the prolog function. The prolog function uses
+              the information provided by the static trampoline, sets things up
+              for the ABI handler and then jumps to the ABI handler.
+    
+            - Call ffi_tramp_set_parms () in ffi_prep_closure_loc () to
+              initialize static trampoline parameters.
+    
+    Signed-off-by: Madhavan T. Venkataraman <madvenka@linux.microsoft.com>
+    
+    * arm64: Support for Static Trampolines
+    
+            - Define the arch-specific initialization function ffi_tramp_arch ()
+              that returns trampoline size information to common code.
+    
+            - Define the trampoline code mapping and data mapping sizes.
+    
+            - Define the trampoline code table statically.
+    
+            - Introduce a tiny prolog for each ABI handling function. The ABI
+              handlers addressed are:
+    
+                    - ffi_closure_SYSV
+                    - ffi_closure_SYSV_V
+    
+              The prolog functions are called:
+    
+                    - ffi_closure_SYSV_alt
+                    - ffi_closure_SYSV_V_alt
+    
+              The legacy trampoline jumps to the ABI handler. The static
+              trampoline jumps to the prolog function. The prolog function uses
+              the information provided by the static trampoline, sets things up
+              for the ABI handler and then jumps to the ABI handler.
+    
+            - Call ffi_tramp_set_parms () in ffi_prep_closure_loc () to
+              initialize static trampoline parameters.
+    
+    Signed-off-by: Madhavan T. Venkataraman <madvenka@linux.microsoft.com>
+    
+    * arm: Support for Static Trampolines
+    
+            - Define the arch-specific initialization function ffi_tramp_arch ()
+              that returns trampoline size information to common code.
+    
+            - Define the trampoline code mapping and data mapping sizes.
+    
+            - Define the trampoline code table statically.
+    
+            - Introduce a tiny prolog for each ABI handling function. The ABI
+              handlers addressed are:
+    
+                    - ffi_closure_SYSV
+                    - ffi_closure_VFP
+    
+              The prolog functions are called:
+    
+                    - ffi_closure_SYSV_alt
+                    - ffi_closure_VFP_alt
+    
+              The legacy trampoline jumps to the ABI handler. The static
+              trampoline jumps to the prolog function. The prolog function uses
+              the information provided by the static trampoline, sets things up
+              for the ABI handler and then jumps to the ABI handler.
+    
+            - Call ffi_tramp_set_parms () in ffi_prep_closure_loc () to
+              initialize static trampoline parameters.
+    
+    Signed-off-by: Madhavan T. Venkataraman <madvenka@linux.microsoft.com>
+
+commit 5c63b463b87d3c06102a4a7f05f395929d9ea79b
+Author: DJ Delorie <dj@delorie.com>
+Date:   Wed Dec 2 16:14:27 2020 -0500
+
+    Use memfd_create() (#604)
+    
+    memfd_create creates a file in a memory-only filesystem that may
+    bypass strict security protocols in filesystem-based temporary
+    files.
+
+commit cb8474368cdef3207638d047bd6c707ad8fcb339
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Wed Dec 2 12:52:12 2020 -0800
+
+    libffi/x86: Always check __x86_64__ for x32 hosts (#601) (#602)
+    
+    Since for x86_64-*x32 and x86_64-x32-* hosts, -m32 generates ia32 codes.
+    We should always check __x86_64__ for x32 hosts.
+
+commit e70bf987daa7b7b5df2de7579d5c51a888e8bf7d
+Author: Tres Finocchiaro <tres.finocchiaro@gmail.com>
+Date:   Tue Nov 24 19:13:57 2020 -0500
+
+    Properly quote and resolve msvcc.sh params (#596)
+
+commit 8cc8f446f5aac13e107161dffbc15d1ee1a58878
+Author: Mike Hommey <mh@glandium.org>
+Date:   Tue Nov 10 20:41:33 2020 +0900
+
+    Allow to build with mingw-clang (#579)
+    
+    For some reason, compiling sysv.S with mingw-clang fails with:
+    ```
+    error: invalid variant 'ffi_closure_inner@8'
+    ```
+    
+    This can be fixed (worked around?) by quoting the symbol. This works
+    fine with mingw-gcc too.
+
+commit d817d0daa312c58548d7a081aa876027ca103766
+Author: Mike Hommey <mh@glandium.org>
+Date:   Tue Nov 10 20:39:25 2020 +0900
+
+    Don't use FFI_TYPE_LONGDOUBLE in the jump table in win64*.S (#580)
+    
+    It may have the same value as FFI_TYPE_DOUBLE per ffi.h, which
+    possibly can make things go wrong with .org/ORG.
+    
+    For instance, GCC complains about "Error: attempt to move .org
+    backwards"
+
+commit 56f7df711f70414d4f3663b34e54b122b38bab88
+Author: AndreRH <andre.hentschel@ok.de>
+Date:   Tue Nov 10 12:27:59 2020 +0100
+
+    aarch64: Allow FFI_WIN64 for winelib (#593)
+
+commit 8111cd06921e80d5d7192ce8d1f64733072fdbcd
+Author: Brandon Bergren <git@bdragon.rtk0.net>
+Date:   Tue Oct 27 09:07:38 2020 -0500
+
+    Add support for powerpc64le-*-freebsd*. (#581)
+    
+    Tests pass with no additional changes needed, tested on hardware.
+
+commit 484c1a0d7536be60002473f7bb82223efe139883
+Author: Ken <21211439+kencu@users.noreply.github.com>
+Date:   Tue Oct 27 07:07:07 2020 -0700
+
+    darwin powerpc: use go closures only if enabled (#583)
+    
+    SHA: 0ff9419f2e75652426469e256cb7d0748064ad58 added go closures for darwin powerpc AIX, but
+    these have not yet been implemented for non-AIX systems
+    
+    use the go closures only if enabled
+
+commit 032b3cd6f7850f3ebc1269eeab7d1db3ea518d29
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Tue Oct 27 07:06:21 2020 -0700
+
+    Support building x86 and arm64 without FFI_GO_CLOSURES (#586)
+    
+    * x86: Support building without FFI_GO_CLOSURES
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * arm: Support building without FFI_GO_CLOSURES
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit 93cf288ddd59c7cb203c1aba25de5e5b8f308da6
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Tue Oct 27 07:05:28 2020 -0700
+
+    testsuite: Add a missing include of <inttypes.h> to fix build failure in test suite (#587)
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit c78fcf88ab13a5cc414826a018dd46c3f886adee
+Author: petersn <schmidtnielsenpeter@gmail.com>
+Date:   Tue Oct 27 07:02:36 2020 -0700
+
+    Removing unnecessary instruction from ffi_call_unix64 (#588)
+    
+    unix64.S's `ffi_call_unix64` looks like it used to take six parameters,
+    where the sixth said the number of SSE register arguments. However,
+    currently the function only takes five parameters, and the number of SSE
+    register arguments is encoded in the `struct register_args *` passed as
+    the first parameter to `ffi_call_unix64`. This change removes an
+    instruction that tries to use this missing sixth parameter as the number
+    of SSE arguments.
+    
+    This fix should not change any behavior, nor fix any bugs, because a few
+    instructions later the value moved from %r9d into %eax is overwritten by
+    the correct value anyway. This change merely makes the code a tad less
+    confusing, because currently the assembly moves from a register (r9)
+    whose value is never set.
+
+commit 2d86809db6d1d626a9df40c283ec564ac98ff85d
+Author: jacobly0 <jacobly0@users.noreply.github.com>
+Date:   Tue Oct 27 10:00:03 2020 -0400
+
+    Fix read-only .eh_frame section test when CFLAGS contains -flto. (#590)
+
+commit f4435980fa2da335fe388db431d4a7946a99a2b9
+Author: Alan Modra <amodra@gmail.com>
+Date:   Tue Oct 27 23:36:21 2020 +1030
+
+    Power10 libffi fixes (#585)
+    
+    Power10 pc-relative code doesn't use or preserve r2 as a TOC pointer.
+    That means calling between pc-relative and TOC using code can't be
+    done without intervening linker stubs, and a call from TOC code to
+    pc-relative code must have a nop after the bl in order to restore r2.
+    
+    Now the PowerPC libffi assembly code doesn't use r2 except for the
+    implicit use when making calls back to C, ffi_closure_helper_LINUX64
+    and ffi_prep_args64.  So changing the assembly to interoperate with
+    pc-relative code without stubs is easily done.
+    
+            * src/powerpc/linux64.S (ffi_call_LINUX64): Don't emit global
+            entry when __PCREL__.  Call using @notoc.  Add nops.
+            * src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Likewise.
+            (ffi_go_closure_linux64): Likewise.
+
+commit 407394c0aac2db4a1978a7691035889db9924a01
+Author: Tim Gates <tim.gates@iress.com>
+Date:   Sun Oct 11 15:07:40 2020 +1100
+
+    docs: fix simple typo, paramters -> parameters (#589)
+    
+    There is a small typo in src/x86/ffi.c.
+    
+    Should read `parameters` rather than `paramters`.
+
+commit ead65ca8711aa07efc0453f67136aff82f33c01f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 19 08:34:09 2020 -0400
+
+    Re-enable s390x testing
+
+commit 8276f812a99b10d1f2c387dbd6ef2ca4f597c733
+Author: Niclas Zeising <zeising+github@daemonic.se>
+Date:   Fri Aug 7 21:05:23 2020 +0200
+
+    Upstream local FreeBSD patches (#567)
+    
+    * Add support for FreeBSD mips
+    
+    Add support for FreeBSD mips, this has been a local patch in the FreeBSD
+    ports tree for quite some time.
+    
+    Originally submitted by sson, and committed by sbruno AT FreeBSD DOT org
+    See https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=191909 for
+    background details.
+    
+    Signed-off-by: Niclas Zeising <zeising@daemonic.se>
+    
+    * Add support for FreeBSD powerpcspe
+    
+    Add support for powerpcspe on FreeBSD
+    This has been in the FreeBSD ports tree for some time.
+    Originally submitted by jhibbits AT FreeBSD DOT org.
+    
+    Signed-off-by: Niclas Zeising <zeising@daemonic.se>
+    
+    * Fix abort() on FreeBSD arm related to __clear_cache()
+    
+    This patch has been in the FreeBSD ports tree for a number of years.
+    Original commit by koobs AT FreeBSD DOT org
+    
+    Original commit message:
+    > devel/libffi: Fix abort() on ARM related to __clear_cache()
+    >
+    > The current FreeBSD/ARM __clear_cache() implementation does nothing #if
+    > __i386__ || __x86_64__ #else abort();
+    >
+    > cognet@ advises this is an issue for anything !Apple that is using the
+    > libcompiler_rt provided by Clang on ARM, and requires upstreaming.
+    
+    See https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=149167 for some
+    background details.
+    
+    Signed-off-by: Niclas Zeising <zeising@daemonic.se>
+
+commit 392afbaf60663e530bd740da0b5a39ee9f4ba052
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 5 21:38:51 2020 -0400
+
+    Don't test s390.  Travis-ci is broken.
+
+commit e08eb1ced18598a26cd7f14fea05693e89638ed2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 5 17:59:59 2020 -0400
+
+    Add support for eabisim back.  This was removed upstream.
+
+commit 4661ba7928b49588aec9e6976673208c8cbf0295
+Merge: 45875da 1a4b786
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Aug 4 11:08:19 2020 -0600
+
+    Merge pull request #576 from froydnj/config-updates
+    
+    update config.{guess,sub}
+
+commit 1a4b786df34b61af7b6738a2ce7b8d34f5377a71
+Author: Nathan Froyd <froydnj@gmail.com>
+Date:   Tue Aug 4 12:17:04 2020 -0400
+
+    update config.{guess,sub}
+    
+    This change is primarily for aarch64 macOS support, since that configuration
+    is now properly supported upstream.
+
+commit 45875da4bc71578f6f45471141c14e1743239b7e
+Merge: fbd1de8 8e58f88
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Jul 1 09:32:37 2020 -0600
+
+    Merge pull request #570 from jwilk-forks/spelling
+    
+    aarch64: Fix typo
+
+commit 8e58f88d33eb878b0fbca1433f83bbf872d5d0f3
+Author: Jakub Wilk <jwilk@jwilk.net>
+Date:   Tue Jun 30 22:59:28 2020 +0200
+
+    aarch64: Fix typo
+
+commit fbd1de85f6532f8a8f61abbd7892f8cb58b233d0
+Author: Ma Jun <majun258@linux.alibaba.com>
+Date:   Mon Jun 29 08:02:20 2020 -0400
+
+    Add support for csky
+
+commit 0027b072627aa9d3ada71c4374561966064ecd5a
+Author: M. Herdiansyah <herdiansyah@netc.eu>
+Date:   Thu Jun 11 19:40:24 2020 +0700
+
+    Makefile: increase compatibility with bmake (#551)
+
+commit b7af8f47d5fff2957521dc269637c00b8a4b6c75
+Author: Andre Miras <AndreMiras@users.noreply.github.com>
+Date:   Thu Jun 11 14:38:59 2020 +0200
+
+    Fixes macOS build on Python 3 (#563)
+    
+    The error was:
+    ```
+    Traceback (most recent call last):
+      File "_generate-darwin-source-and-headers.py", line 209, in <module>
+        generate_source_and_headers(generate_osx=not args.only_ios, generate_ios=not args.only_osx)
+      File "_generate-darwin-source-and-headers.py", line 197, in generate_source_and_headers
+        for header_name, tag_tuples in platform_headers.iteritems():
+    AttributeError: 'collections.defaultdict' object has no attribute 'iteritems'
+    ```
+
+commit 5c45c40c04f89cf67ade3fdfa99915ca5409e51a
+Author: Kentaro Hayashi <kenhys@gmail.com>
+Date:   Thu Jun 11 21:37:41 2020 +0900
+
+    Fix Free software foundation address (#564)
+    
+    ref. https://www.fsf.org/about/contact/
+
+commit 2e90bb5577ea1fe3bc1716954e790999bc3549f7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jun 7 14:31:06 2020 -0400
+
+    Add gcc bug tests back
+
+commit 5e6ca054148dfb4d78e6f79457d48b745f919def
+Author: Yann Sionneau <yann@sionneau.net>
+Date:   Fri May 1 13:59:11 2020 +0200
+
+    Add support for Kalray KVX architecture (#559)
+
+commit 4f9e20ac51ce13d46fed3c869e1deb6d9bb89444
+Author: Andrew Geissler <geissonator@users.noreply.github.com>
+Date:   Fri May 1 06:58:30 2020 -0500
+
+    ffi_powerpc.h: fix build failure with powerpc7 (#561)
+    
+    This is a patch pulled down from the following:
+    https://github.com/buildroot/buildroot/blob/78926f610b1411b03464152472fd430012deb9ac/package/libffi/0004-ffi_powerpc.h-fix-build-failure-with-powerpc7.patch
+    
+    This issue is being hit on OpenBMC code when pulling the latest
+    libffi tag and building on a P8 ppc64le machine. I verified this
+    patch fixes the issue we are seeing.
+    
+    Below is the original commit message:
+    
+    Sicne commit 73dd43afc8a447ba98ea02e9aad4c6898dc77fb0, build on powerpc7
+    fails on:
+    
+    In file included from ../src/powerpc/ffi.c:33:0:
+    ../src/powerpc/ffi_powerpc.h:61:9: error: '_Float128' is not supported on this target
+     typedef _Float128 float128;
+             ^~~~~~~~~
+    
+    Fix this build failure by checking for __HAVE_FLOAT128 before using
+    _Float128, as _Float128 is enabled only on specific conditions, see
+    output/host/powerpc64-buildroot-linux-gnu/sysroot/usr/include/bits/floatn.h:
+    
+     /* Defined to 1 if the current compiler invocation provides a
+        floating-point type with the IEEE 754 binary128 format, and this glibc
+        includes corresponding *f128 interfaces for it.  */
+     #if defined _ARCH_PWR8 && defined __LITTLE_ENDIAN__ && (_CALL_ELF == 2) \
+         && defined __FLOAT128__ && !defined __NO_LONG_DOUBLE_MATH
+     # define __HAVE_FLOAT128 1
+     #else
+     # define __HAVE_FLOAT128 0
+     #endif
+    
+    Fixes:
+     - http://autobuild.buildroot.org/results/5c9dd8fb3b6a128882b6250f197c80232d8a3b53
+    
+    Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
+    Signed-off-by: Andrew Geissler <geissonator@yahoo.com>
+    
+    Co-authored-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
+
+commit 053b04c525a00abdc25ec646096a44208a1b9423
+Author: Martin Storsjö <martin@martin.st>
+Date:   Sun Apr 26 05:02:14 2020 +0300
+
+    arm: Fix the clang specific version of the assembly (#556)
+    
+    Also fix the same error in the comment for the non-clang case.
+    That typo there seems to have existed since the code was written
+    in that form, in e7f15f60e86 - and when the clang specific codepath
+    was added in e3d2812ce43, the typo in the comment made it into the
+    actual code.
+
+commit c543849c3767cc0f0a84e3ed7b664a63724ed516
+Author: Martin Storsjö <martin@martin.st>
+Date:   Sun Apr 26 05:01:03 2020 +0300
+
+    win64_armasm: Fix the spelling of ALIGN (#553)
+
+commit 15d3ea31a53bd0e5b828c90a9f7c4285c58f73e1
+Author: Martin Storsjö <martin@martin.st>
+Date:   Sun Apr 26 04:59:35 2020 +0300
+
+    Use __builtin_ffs instead of ffs (#554)
+    
+    USE_BUILTIN_FFS is defined to 1 within __GNUC__, and the __builtin_ffs
+    function is available since GCC 3.x at least, while the ffs function
+    only exists on some OSes.
+    
+    This fixes compilation for non-x86 mingw platforms. For x86,
+    USE_BUILTIN_FFS is explicitly disabled for windows targets - but
+    if USE_BUILTIN_FFS is enabled based on __GNUC__, it should also use
+    the builtin which actually is available correspondingly, not dependent
+    on the target OS.
+
+commit c06468fa6674d3783a0edb1d0fae9afc8bc28513
+Author: Martin Storsjö <martin@martin.st>
+Date:   Sun Apr 26 04:58:33 2020 +0300
+
+    Fix building for aarch64 windows with mingw toolchains (#555)
+    
+    * aarch64: Check _WIN32 instead of _M_ARM64 for detecting windows
+    
+    This fixes building for aarch64 with mingw toolchains. _M_ARM64 is
+    predefined by MSVC, while mingw compilers predefine __aarch64__.
+    
+    In aarch64 specific code, change checks for _M_ARM64 into checks for
+    _WIN32.
+    
+    In arch independent code, check for
+    (defined(_M_ARM64) || defined(__aarch64__)) && defined(_WIN32)
+    instead of just _M_ARM64.
+    
+    In src/closures.c, coalesce checks like
+    defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64)
+    into plain defined(_WIN32). Technically, this enables code for
+    ARM32 windows where it wasn't, but as far as I can see it, those
+    codepaths should be fine for that architecture variant as well.
+    
+    * aarch64: Only use armasm source when building with MSVC
+    
+    When building for windows/arm64 with clang, the normal gas style .S
+    source works fine. sysv.S and win64_armasm.S seem to be functionally
+    equivalent, with only differences being due to assembler syntax.
+
+commit 8c50837f0b58ba5b2bcb1b424a2a4bfa01559fb2
+Author: Fangrui Song <i@maskray.me>
+Date:   Tue Mar 10 04:36:09 2020 -0700
+
+    Improve read-write .eh_frame check (#546)
+    
+    llvm-objdump -h does not print BFD SEC_* constants like "READONLY",
+    so the check will consider .eh_frame writable.
+    clang 11 (since https://reviews.llvm.org/D73999) will error for mismatching section flags.
+    
+    Use readelf -S and check "WA" instead.
+
+commit 4a6414f2785a60f455c91fdd04f7745fe7fc11e0
+Author: Moxie Bot <bot@moxielogic.com>
+Date:   Mon Mar 9 21:10:53 2020 -0400
+
+    Mention ARM Pointer Authentication
+
+commit 909b37ffffe2a0bb08947b07508a3a4eed5f36a8
+Author: Moxie Bot <bot@moxielogic.com>
+Date:   Mon Mar 9 21:10:33 2020 -0400
+
+    Test on aarch64 Linux with clang
+
+commit 4c7bde32ea3af479babdf527d94f241282951cb9
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Tue Mar 10 02:05:42 2020 +0100
+
+    Port to iOS/arm64e (#548)
+
+commit 211e929df4388a6724b0dba4df4e3a1283dc49e9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Mar 9 12:39:22 2020 -0400
+
+    Try to fix RLGL_KEY nonsense (#547)
+    
+    * Try to fix RLGL_KEY nonsense
+    
+    * Hard code policy bound API key
+    
+    Co-authored-by: Anthony Green <green@moxielogic.com>
+
+commit 8eb2d2b05626b1cbbed100725bc440709499e8a6
+Author: Moxie Bot <bot@moxielogic.com>
+Date:   Mon Feb 24 10:29:20 2020 -0500
+
+    Revamp PA_LINUX and PA_HPUX target closures to use function descriptors.
+    
+            2020-02-23  John David Anglin  <danglin@gcc.gnu.org>
+    
+            * include/ffi.h.in (FFI_CLOSURE_PTR, FFI_RESTORE_PTR): Define.
+            * src/closures.c (ffi_closure_alloc): Convert closure pointer
+            return by malloc to function pointer.
+            (ffi_closure_free): Convert function pointer back to malloc pointer.
+            * src/pa/ffi.c (ffi_closure_inner_pa32): Use union to double word
+            align return address on stack.  Adjust statements referencing return
+            address.  Convert closure argument from function pointer to standard
+            closure pointer.
+            (ffi_prep_closure_loc): Likewise convert closure argument back to
+            closure pointer.  Remove assembler trampolines.  Setup simulated
+            function descriptor as on ia64.
+            src/pa/ffitarget.h (FFI_TRAMPOLINE_SIZE): Reduce to 12.
+            src/pa/hpux32.S (ffi_closure_pa32): Retrieve closure pointer and real
+            gp from fake gp value in register %r19.
+            src/pa/linux.S (ffi_closure_pa32): Likewise.
+
+commit be815544c1588c6ca70120361c168b196376aa56
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Sun Feb 23 07:45:42 2020 -0800
+
+    Update the ABI version to LIBFFI_BASE_8.0 (#544)
+    
+    Since x86 and x86-64 FFI_TRAMPOLINE_SIZE have been increased, we must
+    bump the ABI version.  This fixes:
+    
+    https://github.com/libffi/libffi/issues/543
+
+commit d9abffeabe4f38bac12b864146cf974ede814411
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Sat Feb 22 06:32:22 2020 -0800
+
+    x86: Fix ffi_prep_closure_loc (#542)
+    
+    Since FFI_TRAMPOLINE_SIZE is increased by 4 bytes to add ENDBR32, adjust
+    jump displacement by 4 bytes.
+
+commit 624c7a35f7e1d12f917453d6c657cd5947ac57f7
+Merge: 4c775d7 7855656
+Author: Moxie Bot <bot@moxielogic.com>
+Date:   Fri Feb 21 22:13:14 2020 -0500
+
+    Merge branch 'master' of github.com:/libffi/libffi
+
+commit 4c775d7cd6e914c6a2f66465497106cff360aeb5
+Author: Moxie Bot <bot@moxielogic.com>
+Date:   Fri Feb 21 22:12:34 2020 -0500
+
+    Update for pending 3.4 release.
+
+commit 7855656148b96c7070ec362d2a73af840025a2b7
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Fri Feb 21 19:08:06 2020 -0800
+
+    x86: Add indirect branch tracking support (#540)
+    
+    Intel Control-flow Enforcement Technology (CET):
+    
+    https://software.intel.com/en-us/articles/intel-sdm
+    
+    contains shadow stack (SHSTK) and indirect branch tracking (IBT).  When
+    CET is enabled, ELF object files must be marked with .note.gnu.property
+    section.  When Intel CET is enabled, include <cet.h> in assembly codes
+    to mark Intel CET support.
+    
+    Also when IBT is enabled, all indirect branch targets must start with
+    ENDBR instruction and notrack prefix can be used to disable IBT on
+    indirect branch.  <cet.h> defines _CET_ENDBR which can be used in
+    assembly codes for ENDBR instruction.  If <cet.h> isn't included,
+    define _CET_ENDBR as empty so that _CET_ENDBR can be used in assembly
+    codes.
+    
+    Trampoline must be enlarged to add ENDBR instruction unconditionally,
+    which is NOP on non-CET processors.  This is required regardless if
+    libffi is enabled with CET since libffi.so will be marked in legacy
+    bitmap, but trampoline won't.  Update library version for larger
+    FFI_TRAMPOLINE_SIZE.
+    
+    This fixed:
+    
+    https://github.com/libffi/libffi/issues/474
+    
+    Tested with
+    
+    $ CC="gcc -Wl,-z,cet-report=error -fcf-protection" CXX="g++ -Wl,-z,cet-report=error -fcf-protection" .../configure
+    
+    on Linux CET machines in i686, x32 and x86-64 modes.
+
+commit 4d6d2866ae43e55325e8ee96561221804602cd7a
+Author: Samuel Holland <samuel@sholland.org>
+Date:   Fri Feb 21 21:06:15 2020 -0600
+
+    Update powerpc sysv assembly for ffi_powerpc.h changes (#541)
+    
+    Some of the flag bits were moved when adding powerpc64 vector support.
+    
+    Fixes #536
+
+commit b844a9c7f1ca792a1dfb0c09d5dae576178e6729
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 10 10:22:10 2020 -0500
+
+    Update copyright year.
+
+commit 81b5491a4ef46103f2e1be79d368e76dba021ffa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jan 5 21:37:05 2020 -0500
+
+    Fix script
+
+commit 1e08a45535d929915e14e48af38e45f8c8e4f8de
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jan 5 21:18:23 2020 -0500
+
+    Use rlgl API key on login
+
+commit e50b9ef8b910fa642ef158f6642e60d54d7ad740
+Author: Khem Raj <raj.khem@gmail.com>
+Date:   Sat Dec 7 02:34:14 2019 -0800
+
+    powerpc64: Use memcpy to help platforms with no __int128. (#534)
+    
+    Signed-off-by: Khem Raj <raj.khem@gmail.com>
+
+commit f9da75e157ab089363d079a781644c3e6f7db2c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 07:37:19 2019 -0500
+
+    Remove 32-bit x86 file references to fix macosx builds
+
+commit 76c0cfea70f78586231d7994492396eebfb12d5f
+Author: Carl Hurd <carl.m.hurd@gmail.com>
+Date:   Fri Nov 29 14:46:11 2019 -0500
+
+    Fixed missed #ifndef for __mips_soft_float (#442)
+    
+    Thank you!
+
+commit 98da256096c63406ef77f92369ada622c50ce388
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 29 14:29:51 2019 -0500
+
+    Clean up macosx builds
+
+commit 6663047f56c2932a6b10a790f4ac6666dd181326
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 29 07:00:35 2019 -0500
+
+    Address platforms with no __int128.
+
+commit 0069526c5adea9e6268b8a0087a6120c9c5c89fa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 28 18:58:40 2019 -0500
+
+    Make build errors easier to debug
+
+commit 43887a9108f10124d05c8e0e67f3942cd980cb86
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 28 17:44:51 2019 -0500
+
+    Add powerpc-eabi
+
+commit 29297445da5c2c9437de0e20f3189799a27f0301
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 28 17:31:44 2019 -0500
+
+    Test on powerpc-eabisim
+
+commit 01a75ed76ea7e57f1b7a5c183e2b1e890e6aa0fd
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Thu Nov 28 12:42:41 2019 +0000
+
+    powerpc: fix build failure on power7 and older (#532)
+    
+    Build failure looks as:
+    ```
+    libtool: compile:  powerpc-unknown-linux-gnu-gcc \
+        -O2 -mcpu=powerpc -mtune=powerpc -pipe ... -c src/powerpc/ffi.c ...
+    In file included from src/powerpc/ffi.c:33:
+    src/powerpc/ffi_powerpc.h:65:9: error: '__int128' is not supported on this target
+       65 | typedef __int128 float128;
+          |         ^~~~~~~~
+    ```
+    
+    The fix avoids using __int128 in favour of aligned char[16].
+    
+    Closes: https://github.com/libffi/libffi/issues/531
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 1ec01ea81cf18e12748082f48f7c279a3fdd505d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 22:47:48 2019 -0500
+
+    Run aarch64-linux-gnu tests on travi-ci directly
+
+commit 66022e52ec0409f9170eb0884c6d0bdd048bc04e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 16:52:14 2019 -0500
+
+    Fixes for ppc64le and s390x travis testing
+
+commit 932e5bb68a603885e4bd9cf1bd5146542f736ccf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 16:26:14 2019 -0500
+
+    Force the use of docker
+
+commit 803db14c5a0aeb52ee521fe4fe4a7919926373de
+Merge: 86be66c fb914c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 16:10:22 2019 -0500
+
+    Merge branch 'master' of github.com:libffi/libffi
+
+commit 86be66c8f608a84caea2ef724698093d2da2e5e2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 16:09:44 2019 -0500
+
+    Try travis-ci's new ppc64le and s390x support
+
+commit fb914c366fabb29ac373050ca0bfa4d9c1fef149
+Author: Panayotis <panayotis@panayotis.com>
+Date:   Sun Nov 24 18:25:13 2019 +0200
+
+    disable obsolete 32-bit targets in macOS (#511)
+
+commit fd99c95f90f85963f5ec88630c0428a8132012db
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 24 11:11:25 2019 -0500
+
+    Minor clean-up
+
+commit 5dcb741f1544c5e18c9dbf96aeb8b61cc556a616
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 10:24:58 2019 -0500
+
+    Move nested_struct3 test to closures directory
+
+commit 1aca33301a791f503d943f5e3abe2c720296eb8f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 09:42:04 2019 -0500
+
+    Add missing closing brace
+
+commit d996cb283cf373936498defa902be040ec20455e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 09:00:14 2019 -0500
+
+    Version 3.3
+
+commit c72b82f465148b89f118ee73f8956dafdbac9b65
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 08:48:53 2019 -0500
+
+    Remove junk file from dist
+
+commit 642d40ee6ae9a779b3c5ad930785d4b33cf94029
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 07:49:58 2019 -0500
+
+    Account for moved test files
+
+commit 049da08a22b0ca6d63d2be6c209da5ac1335365c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 23 07:44:26 2019 -0500
+
+    Add dejagnu directives accidentally removed
+
+commit 36730f5d87c2a432e1b3bf1a0129fedbf4b0a488
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 19:49:38 2019 -0500
+
+    Move closure test to closure directory
+
+commit c88c0e92a9fbb4e69513394682c61aa848a035cc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 19:27:34 2019 -0500
+
+    More more closure tests to the closure test directory
+
+commit a37cc1755cc276b2b9e601b9b112919f8c882a2e
+Merge: 332a539 247a5e7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 18:55:36 2019 -0500
+
+    Merge branch 'master' of github.com:libffi/libffi
+
+commit 332a539e88d26a0524c10a39283a3099d071ca10
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 18:54:30 2019 -0500
+
+    Move closure tests so we can easily XFAIL them for some targets
+
+commit 1761a10645dadc0840bf1ff3a4998f9a342e8cad
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 18:53:09 2019 -0500
+
+    Remove gccbug detection.  GCC is good now.
+
+commit 247a5e7878379b7af33338d51898d7fb9e82e686
+Author: Michael Haubenwallner <michael.haubenwallner@ssi-schaefer.com>
+Date:   Fri Nov 22 20:17:58 2019 +0100
+
+    Capture x86-windows host like x86_64-windows (#529)
+
+commit 8e3935fa761d3e6f19ccf5e6733fd40dee637d94
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 22 12:42:26 2019 -0500
+
+    Manual clean-ups, and include the PDF in the source distribution.
+
+commit d01088a5194ff1a2250e7dbee04a9a167b582db7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 21 05:36:06 2019 -0500
+
+    Mention more major port contributors
+
+commit 970b7fce4f804df57ec582a0220c22eaeccc239a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 21 05:04:54 2019 -0500
+
+    Update autoconf-archive m4 macros
+
+commit 34a3a661b80c0fa7817c0654ae9fd0686d3b8cd2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 21 04:59:39 2019 -0500
+
+    Fix formatting of README.
+
+commit 91a7fbe94e3884536cf2eb8e644bc79d6b19c80e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 20 07:16:41 2019 -0500
+
+    Fix or1k lack-of-g++ checking in testsuite
+
+commit 31543c799a224ef446cef19a2372b054ecad3822
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 20 06:15:55 2019 -0500
+
+    Add work-around for users who manage their own closure memory
+    
+    As suggested by DJ
+
+commit bd3a4687c0743076f420dee2a02075fd64fa547e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 19 17:14:23 2019 -0500
+
+    No C++ for or1k-unknown-elf
+
+commit d6e4f96b482690e6cdaf67a70bb33d1bfe0acd15
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 19 13:36:49 2019 -0500
+
+    No C++ for or1k
+
+commit 497018686d4df0012ea7bf1a4ab41b918b5e65bc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 19 10:07:16 2019 -0500
+
+    Disable type warnings for or1k.
+
+commit 262cf74fd4003a928ca73e96ef8698546e535c46
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 19 10:06:57 2019 -0500
+
+    No c++ for or1k-elf
+
+commit 54fc80dfd8d608ec718cade762c358b8fd819f38
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 15:20:00 2019 -0500
+
+    Fake TRAVIS_BUILD_DIR
+
+commit 6f734f8a5ff13d106f81741c11c7cb2551706c7f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 15:13:16 2019 -0500
+
+    Adapt for new old ChangeLog file
+
+commit 27d31130cabfe82683fc0e3e82247fd522f45607
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 15:06:51 2019 -0500
+
+    Fix DEJAGNU variable
+
+commit da1358816e7b02e6f8431e4df336d0934bcabd4c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 14:54:14 2019 -0500
+
+    Set vars
+
+commit 9a394c24951f3fc5cfbd0ff268278a7b45afc77e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 14:45:29 2019 -0500
+
+    Remove verbosity
+
+commit 14bfbec0fd312001f7922ee6100cbc3155ae585b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 14:40:30 2019 -0500
+
+    Pull before running
+
+commit dfa60e5eb44482d45b8c79b815e6b6789e62ce18
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 14:02:33 2019 -0500
+
+    Fix cross builds for or1k
+
+commit a8223271a3d7ff1e8a1553c2a5ed9b4e1a24a774
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 13:59:10 2019 -0500
+
+    More cross build debugging
+
+commit 8c9cf44cb2a2d46ddcb148508fb5350438b4a62b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 13:47:42 2019 -0500
+
+    Set path to simulator. Add debugging output.
+
+commit 581048f91e9e25e3b17a2906edd8840f35999918
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 13:17:27 2019 -0500
+
+    Be specific when building CI container images
+
+commit bbea6394f9f27de68aac037abb264151d6de9f64
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 13:06:26 2019 -0500
+
+    Capture more or1k hosts
+
+commit 97e3b1fe1a0fbdb43bf28fe6198cb26eaa719c93
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 13:02:44 2019 -0500
+
+    Add test support for or1k. Fix yaml typo.
+
+commit c88f4d2677d4dc6659a1aa6418e636f8fcf9bd9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 12:25:51 2019 -0500
+
+    Fix typo for m32r and bfin builds
+
+commit 93c203b347ea7d110355e12f832725f755e10eff
+Merge: d087b59 73dd43a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 06:35:19 2019 -0500
+
+    Merge branch 'master' of github.com:libffi/libffi
+
+commit d087b595637ebb795c0cec1ff0c4409befb486b7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 06:34:42 2019 -0500
+
+    Build/test for m32r-elf and bfin-elf
+
+commit b6804d16453890b78844b1b3c1acf16af98cadb8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 17 09:19:14 2019 -0500
+
+    Mention binary128 long double support for Power
+
+commit 73dd43afc8a447ba98ea02e9aad4c6898dc77fb0
+Author: Samuel Holland <samuel@sholland.org>
+Date:   Sun Nov 17 07:22:25 2019 -0600
+
+    IEEE754 binary128 long double support for PowerPC64 (#526)
+    
+    * powerpc: Adjust flags to make room for vector types
+    
+    * powerpc64 ELFv2 IEEE128 long double support
+
+commit b58bd77236e7d41fc04b4be7edd1c6728626c99b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 15 11:18:59 2019 -0500
+
+    Re-enable mingw32 tests.
+
+commit 6f221e8269aa16f6b5eec41cfd1d7d90a9fbea0c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 15 11:06:17 2019 -0500
+
+    Disable wine builds.
+
+commit 09dc0a71a44c95ee0d2f47de94b6b59534c2ce24
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 15 10:19:00 2019 -0500
+
+    Stretch out timeout for test
+
+commit 28a7cc464c21b4955fba28cc55a6f095ddf5838b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 15 06:07:51 2019 -0500
+
+    Consolidate all of the old ChangeLog files into ChangeLog.old.
+
+commit 86d3d3767a40fe1cae10c419a913dd97e7e6cd23
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 10:07:00 2019 -0500
+
+    Don't build aarch64-linux-gnu
+
+commit db198a19375858879dbcc51a443c193efa0b6c0a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 10:05:36 2019 -0500
+
+    Extend timeout for builds.
+
+commit 54af0256a00a40b2218950f93e5415c60f675714
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 09:15:05 2019 -0500
+
+    Platform test tweaks
+
+commit 3a7580da73b7f16f275277316d00e3497cbb5a8c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 07:59:18 2019 -0500
+
+    Mark java raw APIs as deprecated.
+
+commit cda60c1a8aec070a7a822c047d89d0f18cf7c5fc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 06:51:44 2019 -0500
+
+    Disable mips64 tests.  Fix log grabbing.
+
+commit a34254bdc1dee2857b759a22e657f92aadfa85dc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 06:37:26 2019 -0500
+
+    Re-add wine based testing
+
+commit 9bd3a9742c04d2fac489f236163d7e7fbb1b7568
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 06:35:40 2019 -0500
+
+    Add wine-sim.exp for wine-based testing
+
+commit de6df6dce6420d4643598c228b72da4e455a0da7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 06:32:46 2019 -0500
+
+    Fix log file URL extraction.  Grab rlgl cli for OSX
+
+commit c8986e871f82b497493d28c36be1a755c2ea6b8d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 06:01:43 2019 -0500
+
+    Fix log name extraction
+
+commit 6630764d244aeb3bc0797d0c3c7ccc79084061a8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 22:56:37 2019 -0500
+
+    Account for shorter ==LOGFILE== string
+
+commit aa975ec3e4ac07bd7dacec18f1c8282baeb7c398
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 22:35:47 2019 -0500
+
+    Fix grep matcher
+
+commit 6dd88bc5b3f3d3d975409b7336f4127ae18da4b3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 18:44:27 2019 -0500
+
+    Debug
+
+commit 7e318cf50d8c481957b3be76e508054c70cbdf9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 17:55:35 2019 -0500
+
+    Pull test logs from cfarm
+
+commit 5123e9cf0193031bdc580cb221427cbd29ba3677
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 09:21:57 2019 -0500
+
+    Use rlgl for cfarm test results
+
+commit 486f88f985affa215a9daaadcdc703c8baea9020
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 09:20:21 2019 -0500
+
+    Use rlgl for cross builds.
+
+commit 042c6671b0456d17af24d61b79cbd3f9261c3f2b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 09:14:20 2019 -0500
+
+    Always exit build container successfully. Don't test mingw.
+
+commit 82f7f80aa9ac3cd753bcb6d2b88cc930aee72bcc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 08:58:52 2019 -0500
+
+    Run rlgl outside of the build container.
+
+commit 5b297e036e61ad1ecac9c8a3e57895737c55feb7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 12 05:51:09 2019 -0500
+
+    Don't bother dumping logs.  Use rlgl instead.
+
+commit 2a8d88d92d56747101078c5592ab2473e6c5cb29
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 11 21:24:58 2019 -0500
+
+    Fix rlgl usage
+
+commit 3c2b810e99a10f97d1eb6ba485eb09bfdb158084
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 11 21:11:59 2019 -0500
+
+    Test rlgl
+
+commit 2cc11720be0c4d3bbe906be5a4aad3b2dc167072
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 11 16:19:45 2019 -0500
+
+    Debug in-container builds
+
+commit 0de0c6a28006902c203e8dc6629cd9ef35d61e09
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 10 08:20:46 2019 -0500
+
+    Build both iOS and Macosx
+
+commit 4e3e0586efbbc7828c15fb48e49401840beefcdd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 12:35:27 2019 -0500
+
+    Fix tpyo
+
+commit f764f278160831f7e4d8ee8a48d18f5a7937f742
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 12:17:29 2019 -0500
+
+    Change s390x options
+
+commit 188de63c597f23b0ccdb953b076c8cb0711fbcf0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 12:03:19 2019 -0500
+
+    Mark xfail for m68k and alpha.
+
+commit 0da221f8094ec504d91b5f88c74e98b8b9aa9eda
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 12:03:01 2019 -0500
+
+    Clean up.  Debug s390x cpu support.
+
+commit 7e0fbf41934020c9ff76816fde5000482c7e6a6c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 11:50:08 2019 -0500
+
+    Try coldfire for m68k builds
+
+commit 6a9fa770a436bbb71dbe8311e75123353e6836cc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 11:37:25 2019 -0500
+
+    Add GCC_OPTIONS flag
+
+commit eebcbb1113742df7d41fc3d39eca970a026ad1d1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 11:26:53 2019 -0500
+
+    Compile m68k target for m5208
+
+commit 08cb33ff5824b2ea24b2b62841cca1934a27f36f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 11:15:13 2019 -0500
+
+    Dump supported CPUs
+
+commit 16c935000d459b1aba9e1f7b48e2c1d7dadc8cf1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 11:00:09 2019 -0500
+
+    Fix shell script
+
+commit 588e87461fe48441806be4bb5654f058e1c37649
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 10:56:40 2019 -0500
+
+    Print debug output. Use podman when available.
+
+commit 04d14a66ff807a0ac2578ce886ef338aa2066b4d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 09:23:10 2019 -0500
+
+    Set QEMU_CPU within the build containers
+
+commit 28d9c019dbbf6dea1ed127e1a7de829cece86639
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 7 07:36:11 2019 -0500
+
+    Set QEMU_CPU for m68k
+
+commit 75464caf658f176848db6f48325c5067cdf94a9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 22:02:11 2019 -0500
+
+    Add alpha and m68k testing
+
+commit 259c497a2f326cc89344766e106cf73e62485a2a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 11:31:17 2019 -0500
+
+    Sett CC and CXX for cross builds
+
+commit d23d3959fdb764984cfb888c5d6aed910926dd5f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 11:21:46 2019 -0500
+
+    autogen before cross building
+
+commit a6dc8ef270c1f022720aedadb6b0d2678d1bc39e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 11:10:59 2019 -0500
+
+    Fix typo. Don't double test.
+
+commit 136a235d3f36408628c0459d8740546acad0ca5a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 10:51:33 2019 -0500
+
+    Use the right cross build container image
+
+commit 92f5309def05c66e6c5034c10d620d6fbc7a1018
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 10:49:04 2019 -0500
+
+    Try s390x and sh4 cross builds/tests
+
+commit d4a28fee720c8f389b138b3f7726157fbcb7eaaf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 06:47:05 2019 -0500
+
+    Revert to older test cross compilers
+
+commit 0fb9ee21e68ca3e70cf236a63ba00b5ca32031ff
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 06:44:19 2019 -0500
+
+    Use older test compiler.  Enable s390x testing.
+
+commit 36d281ab70daf7dcf890df9c3f5bdd76f665bb68
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 06:30:52 2019 -0500
+
+    Test cross-builds for hppa-linux-gnu
+
+commit c95cc4b354f24dbbf5776eb297fa036bcbfed252
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 6 06:30:20 2019 -0500
+
+    Reference FFI_BUILDING_DLL
+
+commit 88a76477debe83ed6a75f96394853c891fb1dac4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 3 06:28:51 2019 -0500
+
+    rc2. hack as per: https://github.com/travis-ci/travis-ci/issues/6934
+
+commit 45ba4aefed15be24fdbaaffec805fb02b1343e0f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 19:07:04 2019 -0400
+
+    Add sparc64-linux-gnu testing back
+
+commit a26323b7e0824f0becaeaffc8d3b700dc09f741c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 15:32:48 2019 -0400
+
+    Don't build sparc.  Build mips.
+
+commit f325324818a6aaa9e8a75782d75c412872e6b21c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 14:35:43 2019 -0400
+
+    Test mips64el-linux-gnu
+
+commit 39bad2f396de7885c9569144b5bb6e8a639ac011
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 12:33:22 2019 -0400
+
+    Don't run autogen.sh all the time.
+
+commit 82719cbba06c2fc527df156d728341867d86f82c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 12:23:11 2019 -0400
+
+    Test sparc64-linux-gnu on travis
+
+commit 0348d0e4fa585d9a3d9762132a3eee94f918fe3b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 31 10:53:37 2019 -0400
+
+    Try new cfarm build for power
+
+commit 290bc3164bb0e0b3fb912c457b49e61f9a728eef
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Oct 26 10:13:20 2019 -0400
+
+    Add make_sunver.pl to distribution.
+
+commit a8efc2f7897b439fdf2144329d35fea820498dc7
+Author: Andreas Schwab <schwab@linux-m68k.org>
+Date:   Sat Oct 26 14:57:05 2019 +0200
+
+    Fix FFI_STDCALL ABI (#514)
+    
+    Even for a stdcall function, the stack alignment is still the
+    responsibility of the caller.  Remember the original, not stack-aligned
+    argument size, but align when setting up a stack frame.  In
+    ffi_closure_inner, return the true argument size, so that
+    ffi_[go_]closure_STDCALL doesn't adjust too much.
+
+commit ca112537df7b9cdbccad7541aa3cb43b2a2dac9a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Oct 26 07:26:30 2019 -0400
+
+    Add missing build script, make_sunver.pl.
+
+commit 52b066f04fdd81c1037e1cb714a07a2a352bcf9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 24 07:03:43 2019 -0400
+
+    Update versions to 3.3-rc1
+
+commit 9b10df3be2d8f81876b7cc90ee5d8833ccdf6b34
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 24 06:41:11 2019 -0400
+
+    Remove some debugging output
+
+commit ec042885cfa5a9450bfcc87152a41529d26545de
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 24 06:39:00 2019 -0400
+
+    Don't test ppc64le with buggy qemu.
+
+commit 90fb897839bb7006a2f751d283e3d23b3bfec1ea
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 24 06:24:14 2019 -0400
+
+    Strip build status from README.md at 'make dist' time.
+
+commit 1d6059446fb986d2de933f7ccf6fe38bcdf0c76c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 24 05:25:11 2019 -0400
+
+    Add missing dist files.
+
+commit 825b2a359468af8bf3570a5a0695e8b805c5446f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 16 16:05:46 2019 -0400
+
+    Test on arm32v7-linux-gnu, ppc64le-linux-gnu and aarch64-linux-gnu.
+    
+    Use docker images and qemu to test libffi for non-x86 architectures on
+    travis-ci.
+    Use the LIBFFI_TEST_OPTIMIZATION environment variable to
+    force specific optimization levels at test time.
+
+commit d2a4095af68f4530571bc3fa613dd7f5e5b815a3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 14 06:46:52 2019 -0400
+
+    Fix comments.
+
+commit 058aa4130445b4ef3c2f77f796c33506873031ca
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 14 05:47:07 2019 -0400
+
+    Update copyright year
+
+commit c4f61240ab19401bd86c0dfb271e243e8159abb4
+Author: zhanhb <6323014+zhanhb@users.noreply.github.com>
+Date:   Wed Oct 9 18:59:32 2019 +0800
+
+    Add long double test (#492)
+    
+    Required to fix build error on macos with gcc-9
+
+commit 09f9d856112f2f105337e95e32ba9e2da63f65ae
+Author: pichikaudaykiran <51439150+pichikaudaykiran@users.noreply.github.com>
+Date:   Wed Oct 9 16:26:06 2019 +0530
+
+    Making the change to correct the comment when SUN (#521)
+    
+    and GCC are used together
+
+commit 55c22092dc54e706a64af3a49ae9d5471a9e8317
+Author: pnallan <46887249+pnallan@users.noreply.github.com>
+Date:   Tue Oct 8 18:46:47 2019 +0530
+
+    handle compilation warnings with ftruncate API (#508)
+    
+    * fix me: avoid warning while handle ftruncate API
+    
+    Signed-off-by: Prasad Nallani <prasad.nallani@intel.com>
+    
+    * Update closures.c
+
+commit e5f0eb1552f222eb2630e40ee348b090d56412a3
+Author: John Ericson <git@JohnEricson.me>
+Date:   Tue Oct 8 06:58:52 2019 -0400
+
+    Clean up line endings (#509)
+    
+    The CLRF visual studio files can be kept that way, but recognized as
+    text. The assembly file can be converted to LF.
+
+commit ea9b6639c69cbffeacd1ce0c1953c1997cf29d2e
+Author: Samuel Holland <samuel@sholland.org>
+Date:   Tue Oct 8 05:57:28 2019 -0500
+
+    PowerPC bugfixes (#520)
+    
+    * powerpc: Silence warnings about unused labels
+    
+    * powerpc: Fix a couple of comments
+    
+    * powerpc: Fix alignment after float structs
+    
+    * powerpc: Don't pad rvalues copied from FP regs
+    
+    * powerpc: Add missing check in struct alignment
+    
+    * powerpc: Support homogeneous long double structs
+
+commit 25cf9cc4a5ce4a272252de3f681d60dafd838ceb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 8 06:24:55 2019 -0400
+
+    Use https for moxie toolchain repo
+
+commit c2a6859012d928b67a83619bd5087674a96b9254
+Author: Paul Monson <paulmon@users.noreply.github.com>
+Date:   Wed Aug 7 11:57:45 2019 -0700
+
+    fix mingw build and crashing bugs for Python Windows ARM64 (#496)
+    
+    * fix mingw build and crashing bugs for Python Windows ARM64
+    
+    * Fix issues found in PR review
+
+commit e0b4f84fb71c6760068c9d1306e77c9382e76d8d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jun 26 06:18:48 2019 -0400
+
+    Clear the apt cache
+
+commit 68668fe4f22dea7b829fb84b724f5a74091f22f2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jun 26 06:01:15 2019 -0400
+
+    More debugging output
+
+commit 1d7635d18ae4aebe4ec1cd129b0b4f71b685131e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jun 25 23:39:52 2019 -0400
+
+    Debug moxie builds in travis
+
+commit d856743e6b02fcb5911491204131e277a7a4e10b
+Author: ossdev07 <39188636+ossdev07@users.noreply.github.com>
+Date:   Wed Jun 26 07:31:22 2019 +0530
+
+     libffi: added ARM64 support for Windows (#486)
+    
+    *  libffi: added ARM64 support for Windows
+    
+        1. ported sysv.S to win64_armasm.S for armasm64 assembler
+        2. added msvc_build folder for visual studio solution
+        3. updated README.md for the same
+        4. MSVC solution created with the changes, and below test suites are tested
+           with test script written in python.
+    
+           libffi.bhaible
+           libffi.call
+        5. Basic functionality of above test suites are getting passed
+    
+    Signed-off-by: ossdev07 <ossdev@puresoftware.com>
+    
+    * Update README.md
+
+commit 80d07104c33045ea34a4d5185600495dc7461a12
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Apr 28 07:36:24 2019 -0400
+
+    uuencode compressed log files for travis
+
+commit fadf1eb530713fde0be9774d926bc8202c97e379
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sat Apr 27 20:53:29 2019 +0100
+
+    hppa: avoid TEXTREL in .eh_frame section (#447)
+    
+    Before the change hand-crafted .eh_frame section contained
+    ABS relocation and caused TEXTREL tag to be emitted:
+    
+    ```
+    $ ./configure --host=hppa2.0-unknown-linux-gnu LDFLAGS=-Wl,-z,text
+    $ make
+    ...
+    /usr/libexec/gcc/hppa2.0-unknown-linux-gnu/ld:
+        read-only segment has dynamic relocations.
+    ```
+    
+    Link failure is caused by absolute address of FDEs
+    encoded into .eh_frame entries.
+    
+    Fixed TEXTREL by using pcrel (instead of ABS) encoding
+    for absolute addresses (__PIC__ code) by adding augmentation
+    information ("zR" CIE type).
+    
+    All tests still pass on hppa2.0. The specific tests that still pass
+    and exercise this code path:
+        testsuite/libffi.call/unwindtest.cc
+        testsuite/libffi.call/unwindtest_ffi_call.cc
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 06bf1a9deaa781b711c4d3718561e7faf303a842
+Author: driver1998 <driver1998.ms@outlook.com>
+Date:   Sun Apr 28 03:21:44 2019 +0800
+
+    fix x86/x64 MSVC build (#487)
+
+commit db5706ff285c476aa3c0f811ff2b188319ac3ebe
+Author: Paul Monson <paulmon@users.noreply.github.com>
+Date:   Fri Apr 26 04:58:58 2019 -0700
+
+    add support for 32-bit ARM on Windows (#477)
+    
+    * add support for 32-bit ARM on Windows
+    
+    * fix mismatched brace in appveyor.yml
+    
+    * remove arm platform from appveyor.yml for now
+    
+    * fix arm build
+    
+    * fix typo
+    
+    * fix assembler names
+    
+    * try Visual Studio 2017
+    
+    * add windows arm32 to .appveyor.yml
+    
+    * update README.md
+
+commit d1e9b4b96cc8d237c3532cf83da0d4b99d19abb5
+Merge: 05a1796 a7d6396
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Apr 9 14:00:10 2019 -0600
+
+    Merge pull request #482 from sharkcz/aarch64
+    
+    fix check for Linux/aarch64
+
+commit a7d6396f06d5e1a726f24b746b509514f466380f
+Author: Dan Horák <dan@danny.cz>
+Date:   Fri Mar 29 14:19:20 2019 +0100
+
+    fix check for Linux/aarch64
+    
+    fixes #473
+
+commit 05a1796419f68267250c0b8ae7138da36ab60b01
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Tue Feb 19 04:11:28 2019 -0800
+
+    Cleanup symbol exports on darwin and add architecture preprocessor checks to assist in building fat binaries (eg: i386+x86_64 on macOS or arm+aarch64 on iOS) (#450)
+    
+    * x86: Ensure _efi64 suffixed symbols are not exported
+    
+    * x86: Ensure we do not export ffi_prep_cif_machdep
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * x86: Ensure we don't export ffi_call_win64, ffi_closure_win64, or ffi_go_closure_win64
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * closures: Silence a semantic warning
+    
+    libffi/src/closures.c:175:23: This function declaration is not a prototype
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * aarch64: Ensure we don't export ffi_prep_cif_machdep
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * arm: Ensure we don't export ffi_prep_cif_machdep
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * aarch64, arm, x86: Add architecture preprocessor checks to support easier fat builds (eg: iOS)
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * x86: Silence some static analysis warnings
+    
+    libffi/src/x86/ffi64.c:286:21: The left operand of '!=' is a garbage value due to array index out of bounds
+    libffi/src/x86/ffi64.c:297:22: The left operand of '!=' is a garbage value due to array index out of bounds
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * aarch: Use FFI_HIDDEN rather than .hidden
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+    
+    * ffi.h: Don't advertise ffi_java_rvalue_to_raw, ffi_prep_java_raw_closure, and ffi_prep_java_raw_closure_loc when FFI_NATIVE_RAW_API is 0
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit 3ec522bc1c1c5a7fb66b85d4fb6a0fe80581d597
+Author: dabrain34 <scerveau@gmail.com>
+Date:   Tue Feb 19 13:09:09 2019 +0100
+
+    Fix cfi checks for old compiler (#453)
+    
+    cfi_sections can be unsupported when cfi_startproc
+    and cfi_endproc are.
+
+commit e1118af50599314a2cbac3eb51a81896e8e21d0c
+Author: Paul Monson <paulmon@users.noreply.github.com>
+Date:   Tue Feb 19 03:58:25 2019 -0800
+
+    changes for win32 on windows (#468)
+
+commit 44a6c28545186d78642487927952844156fc7ab5
+Author: Florian Weimer <fw@deneb.enyo.de>
+Date:   Tue Feb 19 12:55:11 2019 +0100
+
+    aarch64: Flush code mapping in addition to data mapping (#471)
+    
+    This needs a new function, ffi_data_to_code_pointer, to translate
+    from data pointers to code pointers.
+    
+    Fixes issue #470.
+
+commit 042ef8c314a946ef1cd58c6e10cd74e403ef5bf9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 12 08:50:30 2019 -0500
+
+    Remove -Os testing. No ABI impact, and helps trim log lengths.
+
+commit 8fa88373a1d433c675b11200ccd58418e91f81e4
+Merge: 737d4fa 2c5b164
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Dec 19 14:18:40 2018 -0700
+
+    Merge pull request #461 from NativeScript/bektchiev/fix-visibility-hidden-check-in-configure
+    
+    fix(configure): Correctly detect visibility("hidden") support on Darwin
+
+commit 2c5b164288712cc048048d73a3cd841d845a132c
+Author: Martin Bektchiev <martin.bektchiev@progress.com>
+Date:   Wed Dec 19 18:33:08 2018 +0200
+
+    fix(configure): Correctly detect visibility("hidden") support on Darwin
+
+commit 737d4faa00d681b4c758057f67e1a02d813d01c2
+Merge: a5ea752 4a84df4
+Author: Tom Tromey <tom@tromey.com>
+Date:   Fri Nov 30 08:16:00 2018 -0700
+
+    Merge pull request #457 from NativeScript/bektchiev/fix-arm64-q3-q4-args
+    
+    Fix Q registers parameter passing on ARM64
+
+commit 4a84df4ae9d33bb766fb34ce8a871d84d6e0ed9c
+Author: Martin Bektchiev <martin.bektchiev@progress.com>
+Date:   Wed Oct 31 15:53:54 2018 +0200
+
+    Fix Q registers parameter passing on ARM64
+    
+    The second two quads are located at offset 32 not 16
+
+commit a5ea7527cda8d9b7d011eb4004dfcbad54583bd2
+Merge: b11b08c ba73a67
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Sep 19 07:29:36 2018 -0600
+
+    Merge pull request #443 from jeremyhu/master
+    
+    Update FFI_HIDDEN() to use .private_extern on Apple platforms and use the macro where appropriate
+
+commit b11b08ca8daacb08943ae5ea8c124771a8b82dde
+Merge: 980908b e6eac78
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Sep 18 08:26:31 2018 -0600
+
+    Merge pull request #449 from gpakosz/align-macros
+    
+    Prefix ALIGN_DOWN macro with FFI_
+
+commit e6eac7863e2bf1a009ea863041b354bdb4af6b67
+Author: Gregory Pakosz <gregory.pakosz@gmail.com>
+Date:   Tue Sep 18 15:19:53 2018 +0200
+
+    Prefix ALIGN_DOWN macro with FFI_
+
+commit 980908b47bbde09fab88ee4b2b61d8bc5d4378a7
+Merge: 65da63a 4cb776b
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sat Aug 11 09:53:15 2018 -0600
+
+    Merge pull request #445 from andreas-schwab/master
+    
+    RISC-V go closures
+
+commit 4cb776bc8075332d2f3e59f51785d621fcda48f6
+Author: Andreas Schwab <schwab@suse.de>
+Date:   Thu Aug 9 12:12:29 2018 +0200
+
+    RISC-V go closures
+    
+    This implements go closures for RISC-V.  It has been tested on
+    riscv64-suse-linux and against the libgo testsuite.
+
+commit ba73a671cb49f8e2c4417723a9dc233e328926ae
+Author: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+Date:   Fri Jul 20 09:37:43 2018 -0700
+
+    Update FFI_HIDDEN() to use .private_extern on Apple platforms and use the macro where appropriate
+    
+    Fix issue #439
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+
+commit 65da63abc843fe448aaa86015d094cf016f325ba
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Mon Jun 25 04:38:58 2018 -0700
+
+    Add compact unwind for darwin/i386 (#440)
+    
+    * x86: Add implementation of compact unwind for ffi_call_i386, et al.
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+    
+    * x86: Use __text as the section name to avoid deprecated section name warnings.
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+    
+    * darwin: Add missing regular,debug attributes for compact unwind sections
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+
+commit 2309b58448b0c8349156d687d7fa8709dfb68992
+Author: Shoaib Meenai <shoaib.meenai@gmail.com>
+Date:   Sun Jun 17 17:04:24 2018 -0700
+
+    Mark sysv.S as SafeSEH compatible (#438)
+    
+    It contains no exception handler, so we can just emit the special
+    @feat.00 symbol to indicate that it's trivially SafeSEH compatible.
+    SafeSEH only applies to x86 and not x86-64, hence its inclusion in the
+    x86-specific block. See [1] for details.
+    
+    [1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#the_.sxdata_section_
+
+commit 1d704051b2da207d715351b8613e74437d8e2eb7
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Sun Jun 17 17:01:50 2018 -0700
+
+    i386: Fix missing break; in case statement leading to incorrectly returned FFI_BAD_ABI (#437)
+    
+    * i386: Add missing break triggering dead store static analyzer checks.
+    
+    Register calling sequence is being reported as bad ABI instead of working as intended.
+    
+    Found-by: Clang Static Analysis
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+    
+    * Mark ffi arm sysv entry points as private_extern.
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+    
+    * x86_64: Add implementation of compact unwind for ffi_call_unix64.
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
+
+commit b55baf0b500ccc7636a8a55e0506d9da787ad2dd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed May 9 13:21:02 2018 -0400
+
+    Handle FFI_GNUW64 on non-Windows systems (EFI)
+
+commit 8206253fdf01226173c36f087226d8ea53584566
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed May 9 10:50:46 2018 -0400
+
+    Mark some cases as xfail due to GCC bug
+
+commit b5ee395710e2db830749c3c95558c91b66ac111f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 5 07:41:53 2018 -0400
+
+    Revert "Remove some symbol exports and cleanup newline warnings (#433)"
+    
+    This reverts commit a5a0f3cf36dfb4d64316414a872288c3170e6c1d.
+
+commit a5a0f3cf36dfb4d64316414a872288c3170e6c1d
+Author: Jeremy Huddleston Sequoia <jeremyhu@users.noreply.github.com>
+Date:   Sat May 5 03:44:33 2018 -0700
+
+    Remove some symbol exports and cleanup newline warnings (#433)
+    
+    * build: Ensure darwin generated sources end with a new line
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+    
+    * build: Use .private_extern where missing to prevent exporting symbols that are not API
+    
+    Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@macports.org>
+
+commit d3c54cf3a2b2bb2e889173b6a0a959517b42c47f
+Author: hjl-tools <hjl.tools@gmail.com>
+Date:   Wed May 2 06:19:58 2018 -0700
+
+    Re-enable msabi testing (#436)
+    
+    * Revert "disable msabi testing for now"
+    
+    This reverts commit 7b7638eb0eac2adfa72f7ec9f254ba287c9947e2.
+    
+    * x86: Correct testing for 64-bit x86-64
+    
+    Since passing -m32 to x86-64 compiler will generate i386 code, we
+    need to check both __ILP32__ and __i386__ for 64-bit x86-64.
+    
+    * x86: Check __i386__ instead of i?86-*-* targets
+    
+    Since passing -m32 to x86-64 compiler will generate i386 code, we need
+    to check __i386__ instead of i?86-*-* targets for i386 targets.
+    
+    * i386: Properly passing integer parameters in registers
+    
+    For thiscall and fastcall, if the paramter passed as 64-bit integer or
+    struct, all following integer paramters will be passed on stack.
+    
+    * test: Add ABI_ATTR to callback_code
+    
+    Add ABI_ATTR to callback_code to properly test different ABIs.
+
+commit ebf241663cc0fd0d76e4db8101e842e1630a2c78
+Author: Alan Modra <amodra@gmail.com>
+Date:   Wed May 2 13:55:29 2018 +0930
+
+    PowerPC64 ELFv1 fp arg fixes
+    
+    The ELFv1 ABI says: "Single precision floating point values are mapped
+    to the second word in a single doubleword" and also "Floating point
+    registers f1 through f13 are used consecutively to pass up to 13
+    floating point values, one member aggregates passed by value
+    containing a floating point value, and to pass complex floating point
+    values".
+    
+    libffi wasn't expecting float args in the second word, and wasn't
+    passing one member aggregates in fp registers.  This patch fixes those
+    problems, making use of the existing ELFv2 homogeneous aggregate
+    support since a one element fp struct is a special case of an
+    homogeneous aggregate.
+    
+    I've also set a flag when returning pointers that might be used one
+    day.  This is just a tidy since the ppc64 assembly support code
+    currently doesn't test FLAG_RETURNS_64BITS for integer types..
+    
+            * src/powerpc/ffi_linux64.c (discover_homogeneous_aggregate):
+            Compile for ELFv1 too, handling single element aggregates.
+            (ffi_prep_cif_linux64_core): Call discover_homogeneous_aggregate
+            for ELFv1.  Set FLAG_RETURNS_64BITS for FFI_TYPE_POINTER return.
+            (ffi_prep_args64): Call discover_homogeneous_aggregate for ELFv1,
+            and handle single element structs containing float or double
+            as if the element wasn't wrapped in a struct.  Store floats in
+            second word of doubleword slot when big-endian.
+            (ffi_closure_helper_LINUX64): Similarly.
+
+commit a2c6c7af9ffb9500a944abc666ced0922d0de762
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue May 1 06:46:30 2018 -0400
+
+    Add license for build-time tools
+
+commit 4c2206ace07f2fb4bef43cd4bfe952ccb584dcec
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sat Apr 28 04:46:10 2018 -0600
+
+    Fix two "return" issues in x86/ffi64.c (#431)
+    
+    Issue #70 pointed out that at least one compiler didn't like:
+    
+        return ffi_call_efi64(cif, fn, rvalue, avalue);
+    
+    ... where the return type is "void".  This patch splits the statement
+    into two.
+    
+    I also noticed that ffi_call_go here seems to do a double call.  I
+    suspect a "return" is missing here, so this patch adds it as well.
+
+commit ed3ed4d801a4d417ea304715d4d8ae581a6c6903
+Merge: 8e250c3 b69f95d
+Author: Tom Tromey <tom@tromey.com>
+Date:   Fri Apr 27 10:48:51 2018 -0600
+
+    Merge pull request #429 from yousong/m4subst
+    
+    build: fix subst toolexecdir, toolexeclibdir
+
+commit b69f95d6562b6a57c9be36da0cdf2a500adb94e9
+Author: Yousong Zhou <yszhou4tech@gmail.com>
+Date:   Thu Apr 26 19:27:54 2018 +0800
+
+    build: fix subst toolexecdir, toolexeclibdir
+    
+    On CentOS 7.4, configure script generated by autogen.sh will output the
+    following values when compiling GCC source code
+    
+        toolexecdir='NONE/$(target_alias)'
+        toolexeclibdir='NONE/$(target_alias)/lib'
+    
+    and cause build error
+    
+        ... -o libffi.la -rpath NONE/riscv64-bs-linux-gnu/lib ...
+        checking for shl_load in -ldld... libtool: link: only absolute run-paths are allowed
+
+commit 8e250c390a45f722387c1881ae5f99849a2d1e22
+Author: Stephen <stephengroat@users.noreply.github.com>
+Date:   Wed Apr 25 13:17:32 2018 -0700
+
+    update to https for cygwin download (#428)
+
+commit 7d3cab7926d08aad9a8e54420d6878cb17efd185
+Author: Lucas Pluvinage <lucas.pluvinage@gmail.com>
+Date:   Sat Apr 21 00:24:50 2018 +0200
+
+    xtensa-linux: use cache flush instruction only if it is available (#426)
+
+commit 159b94e5fd4aa2d88e1b5b389092cefd9472a741
+Author: James Cowgill <jcowgill@users.noreply.github.com>
+Date:   Thu Apr 19 01:28:23 2018 +0100
+
+    Various MIPS Fixes (#425)
+    
+    * mips: simplify closure #defines
+    
+    This commit should have no visible effect.
+    
+    * mips: add special handling of variadic functions
+    
+    MIPS requires special handling of variadic functions which pass floating
+    point arguments:
+    * In the o32 ABI, all float arguments are passed in integer registers.
+    * In the n32/n64 ABIs, float arguments after the ellipsis are passed in
+      integer registers.
+    
+    Implement this in libffi. To support this in n32/n64 closures, we need to add
+    a new mips_nfixedargs field to ffi_cif which will break the libffi ABI.
+    
+    This fixes the libffi.call/cls_longdouble_va.c test which was failing on
+    64-bit MIPS.
+    
+    * mips: align argn for all 64-bit types in o32 closure handler
+    
+    Ensure that argn is pre-aligned for all 64-bit argument types (including
+    doubles) and not just integer types.
+    
+    This fixes closures of the form "f(float, double, <some integer args>)".
+    Previously the first integer argument would be read from a2 which is garbage
+    at this point (the float arguments have already "consumed" a0-a3). After
+    this commit, argn is correctly padded between the "float" and "double"
+    arguments so that the first integer argument is read from the stack.
+    
+    Fixes "double f(float,double,int)" test in #371
+    
+    * mips: do not read from floating point register if returning a struct
+    
+    In the o32 ABI, the pointer passed in a0 used to return structures
+    indirectly is treated as the first argument for argument allocation purposes.
+    This means that it should inhibit floating point registers the same way that
+    other integer arguments do.
+    
+    Fixes "Double f(float,Double,double)" test in #371
+    
+    * mips: fix pointer cast warnings
+    
+    Fix two pointer cast warnings when compiled on 64-bit mips by casting
+    through uintptr_t.
+    
+    Fixes mips64el part of #404
+
+commit f2afda08e85b02888350449dcf39a6c37cfb7bc4
+Merge: e27f70b 801c1bd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Apr 8 18:25:43 2018 -0400
+
+    Merge branch 'master' of github.com:/libffi/libffi
+
+commit e27f70b8cf2a537bef84b2cb29ad8ea6209a11b8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Apr 8 18:25:34 2018 -0400
+
+    Fix case where callback arg value is split across regs and stack
+
+commit 801c1bd712ff8c76675b7aa69c29948907f1eeff
+Author: Andreas Krebbel <38103320+Andreas-Krebbel@users.noreply.github.com>
+Date:   Thu Apr 5 14:27:32 2018 +0200
+
+    Fix issue #421 (#422)
+    
+    Fantastic - thanks for digging into this.
+
+commit 8660e6935971c5abd7b528eaf54deeccd4bbaccd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Apr 2 08:30:17 2018 -0400
+
+    3.3 release candidate 0
+
+commit 7b7638eb0eac2adfa72f7ec9f254ba287c9947e2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Apr 2 08:24:44 2018 -0400
+
+    disable msabi testing for now
+
+commit af6773d6ab4db0577bc6b932ab5a2f98a0a8dca2
+Author: fwg <fwg@users.noreply.github.com>
+Date:   Mon Apr 2 13:55:31 2018 +0200
+
+    Fix appveyor windows build (#420)
+    
+    * Fix msvcc dll build by adding dllexport decorations to all API declarations
+    
+    * Fix appveyor build for VS 2013
+    
+    Use the new -DFFI_BUILDING_DLL for producing a working DLL. Update the
+    msvcc.sh wrapper script to successfully compile the testsuite files.
+    
+    * MSVC build: suppress warnings in testsuite
+    
+    * fix testsuite on appveyor
+
+commit 48bdb02867edb7e9f3785ccb4bdff1087fb44246
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 29 07:22:57 2018 -0400
+
+    Trim some optimization tests
+
+commit f98e0f0d777bf962057e18d036989b2b89fdf416
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 29 07:22:38 2018 -0400
+
+    Simplify matrix
+
+commit fa72b054e10acaea33ec8cc395e0ea5b31c9ac9e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 29 07:10:23 2018 -0400
+
+    Remove warning message from clang
+
+commit 746c3ce220cb155a8f3b613550a7ecad76f9fedc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 29 07:01:14 2018 -0400
+
+    Expand ABI tests on x86.  Testsuite bug fixes.
+
+commit 2eee934d0cb2beef7c0aa29767eca1ce03452ae9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 14:45:40 2018 -0400
+
+    deal with msvc warnings
+
+commit 206b2974f70f65b4c4c4d9e62b03ee7e0753ee2d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 14:37:50 2018 -0400
+
+    fix quoting issue
+
+commit 499e41c1ec6b760eff2b320ffc87e22de82a9e1d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 14:35:10 2018 -0400
+
+    Don't ignore a file
+
+commit 5b41e9f6d2c099add0e02db8c8054281f96b6d0e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 14:34:31 2018 -0400
+
+    Try different msvc hack
+
+commit e8cf133813e7fa2c606d93abab5b68989e5f6cbc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 14:12:02 2018 -0400
+
+    msvc c99 hack
+
+commit a3e20940898ed2ca96b9df87f34117d06d900e5f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:58:42 2018 -0400
+
+    More msvc hacks
+
+commit a82b456e98b0f3fbafe76725d1a1503d458a2178
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:49:46 2018 -0400
+
+    msvc fixes
+
+commit a2326aaf561798c3bfd5e464b16693a094bf6c45
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:36:04 2018 -0400
+
+    Remove debug output
+
+commit 85b6b209d7984667ce7d00351fe7e79ef6c4930c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:35:23 2018 -0400
+
+    Force literals to float (msvc warning)
+
+commit 2872c460ba8e96416b4f4ee4a0ed183461d8d6c9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:28:40 2018 -0400
+
+    Fix msvc linking
+
+commit b40a386c22a2bd164819b4f398b722357222b7c1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:20:21 2018 -0400
+
+    Fix library path handling
+
+commit d78c5f64f834c24a769bee78cfb7db4d468b6b21
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 11:14:56 2018 -0400
+
+    Deal with libpath
+
+commit f318bb63c5dc623d5a69ffc4a59a330050cac567
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 08:25:26 2018 -0400
+
+    Fix library path handling
+
+commit 4f0c9cb39b7599312729278380ce63247bca226b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 08:10:03 2018 -0400
+
+    Use mixed cygpath paths
+
+commit d3693b4665de7ef69b61fb4e483d5686302f9c69
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 08:05:42 2018 -0400
+
+    Copy - don't symlink - to support msvc builds
+
+commit 51ce3696cd0da4716d86b73a30bd89e139ec4b74
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 07:35:33 2018 -0400
+
+    Use cygpath to convert windows paths
+
+commit 70b93e4d863c1ff2a6498455339e17df3d7fe784
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 07:14:59 2018 -0400
+
+    try to fix windows builds
+
+commit 377134d7a946df13b60ff9c9dacc895e82c36178
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 07:06:01 2018 -0400
+
+    Reduce verbosity
+
+commit d01ef5b875dedcb9f7b3039b2334cbd594fdfcd4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 06:23:29 2018 -0400
+
+    iOS builds
+
+commit d13583f55fb31a302684cbc62c300ae81eb577e9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 06:22:57 2018 -0400
+
+    Fix -L support
+
+commit d49911544bf9d2b4fab782b0c5e76a68074223df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 05:59:26 2018 -0400
+
+    Fix quoting
+
+commit 8f47ec404fcf5a082fc4537ede8cdf897f4c5226
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 05:35:35 2018 -0400
+
+    Don't set AM_MAKEFLAGS
+
+commit df314193dc6cd00978b6e1517866448b604199af
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 05:13:38 2018 -0400
+
+    Run tests with lots of debug output
+
+commit b394947518fb15887802fe3bc7f0a337c495d65d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 05:11:52 2018 -0400
+
+    Add -L and -l support
+
+commit 33da6c075299317885385f19680b58a1e9feab5e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 05:07:08 2018 -0400
+
+    Mention C99 and build requirements
+
+commit e6bdbd7888b5c8a90f3c91f4d6caf3c8d574f3b5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 04:46:04 2018 -0400
+
+    Remove reference to wiki
+
+commit 24eb1f88d788399dde5fbb4804767e6b6cbf1bc8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 04:09:56 2018 -0400
+
+    Refactor travis build instructions.  Add iOS build
+
+commit ffc3ff162a15ed0ed0e946815c950c69ee0c8343
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 04:02:06 2018 -0400
+
+    Add issue template
+
+commit 5c2ca479e726dc2feec43e25475c63361387bf20
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 27 04:01:37 2018 -0400
+
+    Remove uninitialized warning. Fix #163.
+
+commit 0081378017c33a4b9b6fbf20efabdd9959d6a48d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 24 09:05:14 2018 -0400
+
+    revert
+
+commit 59d44242e15d2979291fe6793ddfb2681b7480ef
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 24 08:45:59 2018 -0400
+
+    Try bhaible tests in appveyor
+
+commit 6f7c29c5a6d2850ce53b99efcc71fcc4e8f8c8cc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 24 08:40:04 2018 -0400
+
+    Formatting fixes
+
+commit f3c2729ee4026c9f70a6656603bac8ba2ec40a5d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 23 11:47:29 2018 -0400
+
+    Add libffi.map.in to extra dist files
+
+commit 6d2233f96a08c5ac01a64e7b84e2bd678eed0a4b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 23 09:06:08 2018 -0400
+
+    Add sparc solaris build notes
+
+commit 99a80d2fc4ede48348af2edfb7126d60609c4b71
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 21:22:55 2018 -0400
+
+    Fix formatting
+
+commit a3e87ac8e7b7e609ab84541a69c7e51873efa437
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 20:36:52 2018 -0400
+
+    Fix formatting
+
+commit cec3a3a201f17a7f018f25e1a0917bd5206e5a5a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 16:00:04 2018 -0400
+
+    Don't align-double for 32-bit x86
+
+commit f34f8039c10c4d8d728bc335dcf2b2a38f6e8b50
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 15:30:00 2018 -0400
+
+    Remove debug output
+
+commit f31b915314b12904b858b54cfdf670ceaeda7b2d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 15:13:21 2018 -0400
+
+    Add m4/ax_require_defined.m4
+
+commit a2dc5848b53e9e45ff68e5ef70683b5ffb82592e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 13:41:15 2018 -0400
+
+    travis debug
+
+commit 81d345b2cff039c4389fad283a108ad978b609e0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 13:32:03 2018 -0400
+
+    Update autoconf archive macros
+
+commit 369ef49f71186fc9d6ab15614488ad466fac3fc1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 12:53:42 2018 -0400
+
+    Add missing FFI_GNUW64 enum
+
+commit 56655e58c7f966685c0d5635ee7215733121ae41
+Merge: 43980dd 9bc40d8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 12:34:18 2018 -0400
+
+    Merge branch 'master' of github.com:/libffi/libffi
+
+commit 43980dd10e0d5705e52f24d63988b722e31bf330
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 12:32:10 2018 -0400
+
+    Add FFI_GNUW64 ABI for GNU 80-bit long double support
+
+commit 9bc40d87ea5950969b234ed56cd2c6acd883fa0e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 12:32:10 2018 -0400
+
+    Add FFI_GWIN64 ABI for GNU 80-bit long double support
+
+commit d46406088d28b038a0a0f7396d9621f431482f6a
+Author: Ryan C. Underwood <nemesis@icequake.net>
+Date:   Sun Mar 18 07:00:42 2018 -0700
+
+    Fully allocate file backing writable maps (#389)
+    
+    When ftruncate() is used on a filesystem supporting sparse files,
+    space in the file is not actually allocated.  Then, when the file
+    is mmap'd and libffi writes to the mapping, SIGBUS is thrown to
+    the calling application.  Instead, always fully allocate the file
+    that will back writable maps.
+
+commit 247e44b3ef653f210de614a749b71449b8c70764
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 18 07:01:54 2018 -0400
+
+    Fix return values
+
+commit 1f99701fad1761ffe4e9adf88cfe26f74f427e7c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 17 22:49:58 2018 -0400
+
+    Make tests compile/run standalone
+
+commit d974207cd6373ff282a64038564d99b853dc3fab
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 17 09:03:42 2018 -0400
+
+    Formatting fixes.  Add 'bug fixes' note.
+
+commit a33bfa9b12993aae2edf669f62e141a84286d4de
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 17 07:17:24 2018 -0400
+
+    xfail unwind tests for moxie
+
+commit 8bf05481436ba085df3adfff2b47a879df738d67
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 16 23:54:28 2018 -0400
+
+    Install moxie libstdc++
+
+commit 84b383eda67ba75a6456e4b3587f17b749e6e1a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 16 23:36:51 2018 -0400
+
+    Install moxie-elf-g++
+
+commit 6a801d042ac1212fe8c0e11abb865061e515aa43
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 16 17:53:33 2018 -0400
+
+    Fix closure case where 8-byte value is partially passed in register.  Fixes cls_many_mixed_float_double test case.
+
+commit 0f0ba9e0ec52e0297c91cb63a889980a6f847219
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 16 07:28:33 2018 -0400
+
+    Run dejagnu's runtest with -a option to prevent travis timeouts after 10min
+
+commit 725454196afab82f7da7bd719e8bddf7cd7837dd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 15 08:17:18 2018 -0400
+
+    fix .travis.yml
+
+commit d71051c46a795a0669b2d83804030746f790edf4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 21:21:06 2018 -0400
+
+    fix .travis.yml
+
+commit e86aa54ce3418081dca403217c9216c773b82560
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 21:00:55 2018 -0400
+
+    fix .travis.yml
+
+commit 5b538ed61fb13efc8f01bad014c5485231714c96
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 20:32:00 2018 -0400
+
+    fix .travis.yml
+
+commit 6ed64a7953178cf07d2793650fcd64caa6b51d53
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 20:22:33 2018 -0400
+
+    fix .travis.yml
+
+commit 90809e928f8b5a0cdf0787d799111bc33689a9d1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 14:09:39 2018 -0400
+
+    fix .travis.yml
+
+commit 85e4c62351bd1e45dd6d77916778e18c435f1723
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 13:47:27 2018 -0400
+
+    fix .travis.yml
+
+commit aa8a5ec4a4ec4a4460ec3cd4e396e09ceaa3a2fa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 13:25:04 2018 -0400
+
+    fix .travis.yml
+
+commit 7c3e5da401ab7efef83a5bd4e7f64b0df053da0c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 13:07:04 2018 -0400
+
+    fix .travis.yml
+
+commit 19aec1989382fab8bd86c556aa24751a75b8246e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 12:40:58 2018 -0400
+
+    Fix travis.yml
+
+commit bf337b070977fb7e8934fc91e4d0e60209f53448
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 12:15:04 2018 -0400
+
+    yaml syntax error fix
+
+commit 076d5a987e016669993154b91525b02978c56727
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 11:13:32 2018 -0400
+
+    markdown fixes
+
+commit d2f7e788aecf37971c9be1cd650f78a3e4061e18
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 09:06:38 2018 -0400
+
+    Fix test cases with short results
+
+commit 18fe190068563bb2bf52a0993017887f438c85a4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 08:02:10 2018 -0400
+
+    Debug travis output
+
+commit 718a4177f23e9d6c5476d0118d49a3a093d72c6c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 14 07:40:53 2018 -0400
+
+    test
+
+commit 486c34b65deb43d6d9025b2a40284606f97f4e0b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 23:31:18 2018 -0400
+
+    debug
+
+commit 00464aa52022674bdc1f5aa9b2ceb575c9a04b87
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 23:30:52 2018 -0400
+
+    debug
+
+commit eb0544d0d42e5aef56ee1df0861bcd0c95102f88
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 23:20:15 2018 -0400
+
+    Debug env
+
+commit 9d5bd29d8dfb5f89d0927a175443240a19e93890
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 23:07:10 2018 -0400
+
+    Refactor
+
+commit 52a364d7699230be5e883f32b9ac0caaea0300b1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 22:49:48 2018 -0400
+
+    fix moxie build
+
+commit 1a32b3f146f7ade701cea74e3983b16145f93393
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 22:44:13 2018 -0400
+
+    fix moxie build
+
+commit e8958c3a64b5e59f0477bcaafaf9c03337d9f445
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 22:36:41 2018 -0400
+
+    revert test
+
+commit 58315ae125482c44821cfbdce41e350380024d0e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 22:35:50 2018 -0400
+
+    test
+
+commit 6239c28741a8abc1bd06cb47329d8c5cdb359c90
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 22:13:44 2018 -0400
+
+    Add experimental moxie travis build
+
+commit 01db31d94e97e71836fe862826bc8a2a399dd619
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 20:41:55 2018 -0400
+
+    Update moxie sub opcode
+
+commit e8f5a43033d53ad631ba477b78a3def61783a1dc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:27:00 2018 -0400
+
+    Fix appveyor badge
+
+commit d1689dd3bf78f4975aa6a6a16cbffcb794283acb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:24:37 2018 -0400
+
+    Fix travis badge.  Add REAME.md to dist files
+
+commit 785351fbc2a49f05535c412067ac51f906612779
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:21:49 2018 -0400
+
+    Preformat release notes
+
+commit 8c7fbd1616b075e3077346c7bf56befd723a9355
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:20:44 2018 -0400
+
+    Preformat release notes
+
+commit 54f31b00562e75e6aae2b736c70e6713618640cb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:17:57 2018 -0400
+
+    Try to fix table
+
+commit 3a29a27a86624512f405e4c9962276485517caf1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:14:40 2018 -0400
+
+    Clean up markdown table
+
+commit fbfc3b048fcf3f699f4495ca70b7e58461a0df4f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:12:21 2018 -0400
+
+    Move to markdown
+
+commit a31d3d3ba6644d308b6fb8cea2a60976e0531f4a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 09:11:24 2018 -0400
+
+    Add travis and appveyor build badges
+
+commit 16313cb2746ceed6bc1d25b52604642c14758e01
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 08:52:30 2018 -0400
+
+    Support compiler specific warning suppression flags
+
+commit cca6d1fb549e422514df4aad68f2ca9a8313327d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 08:51:34 2018 -0400
+
+    Support compiler specific warning suppression flags
+
+commit 9291f941c2df5ddf967f701b258ac2b3cc9d0820
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 08:37:21 2018 -0400
+
+    Add bhaible's missing Makefile
+
+commit bede01d82ec2f1cfe2bb42233fcd408a6e3a6323
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 07:53:33 2018 -0400
+
+    Remove stray directory
+
+commit 9aefbb1031c9be7c5121ab24742e025ccff236c4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 07:51:02 2018 -0400
+
+    Update version number to next pre-release
+
+commit ddf7a8f7511a038342f56c08dac718148e2f0151
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 13 07:47:57 2018 -0400
+
+    Update test list for dist
+
+commit 6186261cb36a33abbf31430569f83ccd7685474e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Mar 12 21:53:18 2018 -0400
+
+    Add Bruno Haible and Bill Triggs' libffi testsuite
+
+commit 4e8f79d5587ddb8e027f4df213e90f943e286594
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 11 18:21:46 2018 -0400
+
+    Next release will be 3.3
+
+commit 3840d49aaa831d649b1597518a2903dfed0d57f3
+Author: Stef O'Rear <sorear2@gmail.com>
+Date:   Sun Mar 11 05:55:15 2018 -0700
+
+    New RISC-V port (#281)
+    
+    * Add RISC-V support
+    
+    This patch adds support for the RISC-V architecture (https://riscv.org).
+    
+    This patch has been tested using QEMU user-mode emulation and GCC 7.2.0
+    in the following configurations:
+    
+    * -march=rv32imac -mabi=ilp32
+    * -march=rv32g -mabi=ilp32d
+    * -march=rv64imac -mabi=lp64
+    * -march=rv64g -mabi=lp64d
+    
+    The ABI currently can be found at
+    https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md .
+    
+    * Add RISC-V to README
+    
+    * RISC-V: fix configure.host
+
+commit dca52b55bc2ac0213c20849d7e9e19fbc9202023
+Merge: 83d9aba 11de69d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 11 08:50:01 2018 -0400
+
+    Merge pull request #406 from trofi/master
+    
+    ia64: fix variadic function closures with FP arguments
+
+commit 83d9aba3a44dff8426052312a9445a7ef52f1db1
+Merge: ab15405 b58caef
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 11 08:48:42 2018 -0400
+
+    Merge pull request #407 from trofi/ia64-small-struct
+    
+    ia64: fix small struct return
+
+commit ab154056937782c1c7f7005c8b46c5179bc719cb
+Merge: 9429968 e66fd67
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 11 08:46:58 2018 -0400
+
+    Merge pull request #409 from andreas-schwab/master
+    
+    Revert "Fix passing struct by value on aarch64"
+
+commit e66fd678200db456a2e9860e80451773efa96fe0
+Author: Andreas Schwab <schwab@suse.de>
+Date:   Tue Feb 20 10:47:09 2018 +0100
+
+    Revert "Fix passing struct by value on aarch64"
+    
+    This reverts commit 482b37f00467325e3389bab322525099860dd9aa.
+    
+    That was actually a bug in python, see <https://bugs.python.org/issue30353>.
+
+commit b58caef7fd620408be9239ac24ea89d5bc84f30b
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sat Feb 17 19:00:40 2018 +0000
+
+    ia64: fix small struct return
+    
+    This change fixes libffi.call/struct10.c failure on ia64:
+    FAIL: libffi.call/struct10.c -W -Wall -Wno-psabi -O0 execution test
+    
+    .Lst_small_struct handles returns for structs less than 32 bytes
+    (following ia64 return value ABI [1]). Subroutine does roughly the
+    following:
+    
+    ```
+        mov [sp+0]  = r8
+        mov [sp+8]  = r9
+        mov [sp+16] = r10
+        mov [sp+24] = r11
+        memcpy(destination, source=sp, 12);
+    ```
+    
+    The problem: ia64 ABI guarantees that top 16 bytes of stack are
+    scratch space for callee function. Thus it can clobber it. [1]
+    says (7.1 Procedure Frames):
+    """
+    * Scratch area. This 16-byte region is provided as scratch storage
+      for procedures that are called by the current procedure. Leaf
+      procedures do not need to allocate this region. A procedure may
+      use the 16 bytes at the top of its own frame as scratch memory,
+      but the contents of this area are not preserved by a procedure call.
+    """
+    
+    In our case 16 top bytes are clobbered by a PLT resolver when memcpy()
+    is called for the first time. As a result memcpy implementation reads
+    already clobbered data frop top of stack.
+    
+    The fix is simple: allocate 16 bytes of scrats space prior to memcpy()
+    call.
+    
+    [1]: https://www.intel.com/content/dam/www/public/us/en/documents/guides/itanium-software-runtime-architecture-guide.pdf
+    
+    Bug: https://bugs.gentoo.org/634190
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 45da2fcbcd0ecaba673275d22b04fac3e4376e22
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sat Feb 17 18:53:02 2018 +0000
+
+    new test: return small struct
+    
+    The bug originally was discovered in https://bugs.gentoo.org/634190
+    where complicated callback was returning invalid data on ia64.
+    
+    This change adds minimal reproducer that fails only on ia64 as:
+    
+    FAIL: libffi.call/struct10.c -W -Wall -Wno-psabi -O0 execution test
+    FAIL: libffi.call/struct10.c -W -Wall -Wno-psabi -O2 execution test
+    FAIL: libffi.call/struct10.c -W -Wall -Wno-psabi -O3 execution test
+    FAIL: libffi.call/struct10.c -W -Wall -Wno-psabi -Os execution test
+    
+    Test passes on amd64. The fix is in the following commit.
+    
+    Bug: https://bugs.gentoo.org/634190
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 11de69ddb788e4d87ef653898878384116ac16c6
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sun Feb 11 11:29:39 2018 +0000
+
+    ia64: fix variadic function closures with FP arguments
+    
+    libffi test framework already flagged failures as:
+    
+    ```
+        FAIL: libffi.call/cls_double_va.c -W -Wall -Wno-psabi -O0 output pattern test, is 7.0
+        res: 4
+        0.0
+        res: 4
+        ? should match 7.0
+        ?es: 4
+        ?.0
+        res: 4
+    ```
+    
+    Failure happens here at
+    
+    ```c
+        // testsuite/libffi.call/cls_double_va.c
+        ...
+        char*  format    = "%.1f\n";
+        double doubleArg = 7;
+        ...
+        CHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL,
+                                   code) == FFI_OK);
+        res = ((int(*)(char*, ...))(code))(format, doubleArg);
+    ```
+    
+    libffi expects 'doubleArg' to be located in 'f9' (second FP argument) but
+    gcc placed it to 'r33' (second GR).
+    
+    ia64 software [1] manual described argument passing ABI in
+    "8.5.2 Register Parameters" as:
+    
+    """
+        If an actual parameter is known to correspond to a floating-point
+        formal parameter, the following rules apply:
+        a) The actual parameter is passed in the next available floating-point
+           parameter register, if one is available. Floating-point parameter
+           registers are allocated as needed from the range f8-f15, starting
+           with f8.
+        b) If all available floating-point parameter registers have been used,
+           the actual parameter is passed in the appropriate general register(s).
+           (This case can occur only as a result of homogeneous floating-point
+           aggregates, described below.)
+    
+        If a floating-point actual parameter is known to correspond to
+        a variable-argument specification in  the formal parameter list,
+        the following rule applies:
+        c) The actual parameter is passed in the appropriate general
+           register(s).
+    
+        If the compiler cannot determine, at the point of call,
+        whether the corresponding formal parameter is a varargs parameter,
+        it must generate code that satisfies both of the above conditions.
+        (The compiler’s determination may be based on prototype declarations,
+        language standard assumptions,  analysis, or other user options or
+        information.)
+    """
+    
+    We have [c] case here and gcc uses only GR for parameter passing.
+    
+    The change binds known variadic arguments ro GRs instead of FPs as those
+    are always expected to be initialized for all variadic call types.
+    
+    This fixes all 10 failures on ia64-unknown-linux-gnu:
+    
+    ```
+                     === libffi Summary ===
+        -# of expected passes            1945
+        -# of unexpected failures        10
+        +
+        +# of expected passes            1955
+    ```
+    
+    [1]: https://www.intel.com/content/dam/www/public/us/en/documents/guides/itanium-software-runtime-architecture-guide.pdf
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 9429968b828de8775cfd7f139374888943f2186a
+Merge: f08b2be 28d3b61
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 10 23:23:33 2018 -0500
+
+    Merge pull request #403 from frida/fix/x86-sysv-pic-closure-regression
+    
+    Fix x86 SysV closure in PIC mode
+
+commit f08b2be6273f471863f1ea1afb0078a96fe73d74
+Merge: c194448 482b37f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 10 23:21:49 2018 -0500
+
+    Merge pull request #405 from andreas-schwab/master
+    
+    Fix passing struct by value on aarch64
+
+commit 482b37f00467325e3389bab322525099860dd9aa
+Author: Andreas Schwab <schwab@suse.de>
+Date:   Mon Sep 18 12:44:08 2017 +0200
+
+    Fix passing struct by value on aarch64
+    
+    This fixes the ctypes test in the python testsuite.
+
+commit 28d3b61bdd8b9fe786cb431165f2fb95f4e275d3
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Sat Jan 20 23:56:17 2018 +0100
+
+    Fix x86 SysV closure in PIC mode
+    
+    The assembly single-line comments swallowed up the remaining assembly
+    code of the macros due to lack of line-endings.
+    
+    This is a regression introduced in b7f6d7a.
+
+commit c194448ef08b4c0183c68dda95a4b8b9cfc47985
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 10 09:38:15 2018 -0500
+
+    adjust env usage in travis
+
+commit 5314b1067145d30acdc5bba3bebb788e8acfdaae
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 10 07:22:51 2018 -0500
+
+    test static lib
+
+commit bec6135dff061a35065efc106f920940a82c28ee
+Merge: f6ecf10 d15581c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 10 07:20:04 2018 -0500
+
+    Merge pull request #393 from thejunkjon/master
+    
+    Linker error "recompile with -fPIC" for x86_64
+
+commit f6ecf10ca021e94d496c75cc43c417161edf28b3
+Merge: c50ba18 746dbe3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 5 16:51:44 2018 -0500
+
+    Merge pull request #401 from wzssyqa/jr-r6
+    
+    mips/ffi.c: fix encoding for jr on r6
+
+commit 746dbe3a6a79a41931c03b51df2972be4d5e5028
+Author: YunQiang Su <wzssyqa@gmail.com>
+Date:   Wed Jan 3 10:07:41 2018 +0800
+
+    mips/ffi.c: fix encoding for jr on r6
+    
+    mips/ffi.c: instruction jr has a different encoding for r6
+
+commit c50ba182f43537e29dd92cfd9b2fa7a30549a06e
+Merge: 54cb3e2 af6949b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 1 15:18:46 2018 -0500
+
+    Merge pull request #398 from emaste/master
+    
+    Enable symbol versioning when ld is LLVM's lld
+
+commit 54cb3e2345ee8e2483d4705a9fb2967b6e5a9bd1
+Merge: 716bfd8 94c102a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Dec 31 07:46:05 2017 -0500
+
+    Merge pull request #396 from wzssyqa/master
+    
+    mips/n32.S: disable .set mips4 on mips r6
+
+commit af6949b7af98404729e04227165d0e32ce550ce8
+Author: Ed Maste <emaste@freebsd.org>
+Date:   Sun Dec 17 23:08:12 2017 -0500
+
+    Enable symbol versioning when ld is LLVM's lld
+    
+    Fixes #397
+
+commit 94c102aa69b04337f63498e0e6551fcdce549ae5
+Author: YunQiang Su <wzssyqa@gmail.com>
+Date:   Sun Dec 10 14:25:01 2017 +0800
+
+    Not set mips on mips r6
+    
+    MIPS release changed encodes of some instructions, include ll/sc etc.
+    
+    if .set mips4 on mips r6, as will generate some wrong encode of some instructions.
+
+commit d15581c6969657c79afcff4865bdc8f5ff23a2f7
+Author: jon <thejunkjon@gmail.com>
+Date:   Fri Dec 1 00:34:30 2017 -0800
+
+    Updating calls to ffi_closure_unix64_inner and ffi_closure_win64_inner to use PLT.  Without this fix, statically linking libffi causes the linker error i.e. 'requires dynamic R_X86_64_PC32 reloc against ffi_closure_unix64_inner which may overflow at runtime; recompile with -fPIC)'
+
+commit 716bfd83177689e2244c4707bd513003cff92c68
+Merge: 4fdbb05 cd5e9f8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 5 09:02:37 2017 -0500
+
+    Merge pull request #387 from trofi/master
+    
+    Makefile.am: add 'src/s390/internal.h' to source tarball
+
+commit cd5e9f8b87cc387d3ffef4db81ee6af200a84183
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Sun Nov 5 13:56:42 2017 +0000
+
+    Makefile.am: add 'src/s390/internal.h' to source tarball
+    
+    commit 2f530de168e0253ac06e044c832132c496e8788b
+    ("s390: Reorganize assembly") introduced new header
+    (similar to other arches) but did not add it to source
+    tarball.
+    
+    As a result build from 'make dist' tarballs failed as:
+    
+    ```
+    ../src/s390/ffi.c:34:10: fatal error: internal.h: No such file or directory
+     #include "internal.h"
+              ^~~~~~~~~~~~
+    ```
+    
+    To fix it the change adds file to 'Makefile.am'.
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 4fdbb0578e921a9da146c2b040061a3a39fe4fda
+Merge: b302bc3 2bfcd29
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 3 07:05:31 2017 -0400
+
+    Merge pull request #320 from 0-wiz-0/master
+    
+    Support NetBSD with mprotect.
+
+commit b302bc3dfe47e3ea57de11610fced3170c06df28
+Merge: 14eac93 1fb788a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 3 07:03:55 2017 -0400
+
+    Merge pull request #322 from compnerd/aarch64-base
+    
+    aarch64: fix index base register for AArch64
+
+commit 14eac93869eb109bea1daeb4f00609169d5488ff
+Merge: ad15ae7 9fc9dc5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 3 06:49:03 2017 -0400
+
+    Merge pull request #384 from yan12125/fix-sgidefs-checking
+    
+    Fix linux detection (closes #303)
+
+commit 9fc9dc535ee7af28f49f86a8ecacb7f575c46ba4
+Author: Yen Chi Hsuan <yan12125@gmail.com>
+Date:   Fri Oct 27 16:12:56 2017 +0800
+
+    Fix linux detection (closes #303)
+
+commit 1fb788ac898290d8e3044ca4c0a4fb3c3c254ce5
+Author: Saleem Abdulrasool <compnerd@compnerd.org>
+Date:   Tue Oct 10 11:37:00 2017 -0700
+
+    aarch64: fix index base register for AArch64
+    
+    The base is passed in `x3`, not in `x2`.  This fixes the indexing base
+    so that the right value is used.
+
+commit ad15ae762c8b3999e626ebccb9cf454455119555
+Merge: dc2ff5b 5e4fcdc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 25 13:16:49 2017 -0400
+
+    Merge pull request #298 from frida/fix/ios-trampoline-table-complexity
+    
+    Simplify iOS trampoline table allocation
+
+commit dc2ff5baabf89d473d61ae4b468638f8ea98bb04
+Merge: 927da71 79d1509
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 25 13:11:40 2017 -0400
+
+    Merge pull request #323 from compnerd/x86-alloca-alignment
+    
+    x86: align alloca to 16-byte boundary
+
+commit 927da71662f349f656fc1c5d0aaa533005e24f47
+Merge: a0455c0 181fc4c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 25 13:05:53 2017 -0400
+
+    Merge pull request #379 from jlj/master
+    
+    Xcode build improvements
+
+commit a0455c031824c6ab3f1a7a6ef9912edad6ebd742
+Merge: 0faf614 9d9d92b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 25 13:04:23 2017 -0400
+
+    Merge pull request #383 from hjl-tools/hjl/master
+    
+    Hjl/master
+
+commit 0faf614529ae7ac8bc929415a6e1b076ba1b8cc5
+Merge: 8d26e8c 3c372c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 25 13:03:55 2017 -0400
+
+    Merge pull request #381 from compnerd/ffi-nullptr-deref
+    
+    arm: fix a level of indirection issue
+
+commit 9d9d92b47f3f73644f808ae38e97d1ea8f4d22df
+Author: H.J. Lu <hjl.tools@gmail.com>
+Date:   Wed Oct 25 04:59:31 2017 -0700
+
+    Skip WIN64/EFI64 support for x32
+    
+    Since x32 doesn't support WIN64/EFI64, skip it if __ILP32__ is defined.
+
+commit b2a343ffc68f1af5368281e063c0ca5571c611cc
+Author: H.J. Lu <hjl.tools@gmail.com>
+Date:   Wed Oct 25 04:36:49 2017 -0700
+
+    Don't include WIN64/EFI64 for x32
+    
+    Since x32 doesn't support WIN64/EFI64, don't include it for x32.  Also
+    x32 has sizeof size_t == 4.  But TARGET should be X86_64.
+
+commit 3c372c384a94db23fdaf9fe64a4beb86159cf6d3
+Author: Saleem Abdulrasool <compnerd@compnerd.org>
+Date:   Tue Oct 24 13:53:56 2017 -0700
+
+    arm: fix a level of indirection issue
+    
+    Rather than relying on the stack being 0'ed out always, do it manually.
+    The stack generally happened to be zero, and because the compiler
+    realizes that the tests are dealing with chars truncates the read value.
+    However, the top 3 nibbles of the value are undefined and may be
+    non-zero.  The indirection level caused a null-pointer dereference.
+    
+    Explicitly scribbling on the stack during the allocation causes test
+    failures without the original zexting behaviour.
+
+commit 181fc4cc9ca211f3bc8209cecf3b2348b0674e21
+Merge: 8d26e8c 54529ba
+Author: Jean-Luc Jumpertz <jean-luc@celedev.eu>
+Date:   Mon Oct 23 15:02:29 2017 +0200
+
+    Merge branch 'master' based on ksjogo/libffi
+    
+      Added a tvOS target in Xcode project. Misc Xcode project cleanup.
+      Fix macOS build target in Xcode project.
+    
+    # Conflicts:
+    #       src/aarch64/ffi.c
+    #       src/x86/ffi64.c
+
+commit 54529ba1db9974b5efcbd2e893c44b6b01b0b2c8
+Author: Jean-Luc Jumpertz <jean-luc@celedev.eu>
+Date:   Mon Oct 23 09:49:35 2017 +0200
+
+    Added a tvOS target in Xcode project. Misc Xcode project cleanup.
+
+commit 79d1509cb06ba9067f56e2c62394d7bc60fa6bf2
+Author: Saleem Abdulrasool <compnerd@compnerd.org>
+Date:   Tue Oct 10 11:39:45 2017 -0700
+
+    x86: align alloca to 16-byte boundary
+    
+    Align the stack allocation to a 16-byte boundary.  This ensures that the
+    stack parameters are 16-byte aligned which is needed for some
+    instructions.
+
+commit 8d26e8c6da23b10331181a4bbf837f479ce5d7d2
+Merge: 1c9171e ed7488c
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Oct 17 10:46:49 2017 -0600
+
+    Merge pull request #326 from trofi/master
+    
+    src/ia64/unix.S: unbreak small struct handling
+
+commit ed7488c003765c7ee71b7da3e8c21f431b043809
+Author: Sergei Trofimovich <slyfox@gentoo.org>
+Date:   Tue Oct 17 13:00:51 2017 +0100
+
+    src/ia64/unix.S: unbreak small struct handling
+    
+    commit 6e8a4460833594d5af1b4539178025da0077df19
+    added FFI_TYPE_COMPLEX value type (comes after FFI_TYPE_POINTER)
+    
+    ia64 ffi_closure_unix reiles on the ordering of
+    FFI_ enums as ia64 has ia64-specific FFI types:
+    small struct and FPU extesions.
+    
+    As a result all tests handling small structs broke.
+    
+    The change fixes dispatch table by adding (no-op)
+    FFI_TYPE_COMPLEX entry
+    This has positive effect of unbreaking most tests
+    on ia64:
+    
+                     === libffi Summary ===
+    
+    -# of expected passes            1595
+    -# of unexpected failures        295
+    +# of expected passes            1930
+    +# of unexpected failures        10
+     # of unsupported tests          30
+    
+    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
+
+commit 1c9171ec89943d9b4b10a54091c8b5c104eb258d
+Merge: 9f1f874 7ad0ae7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 10 23:19:57 2017 -0400
+
+    Merge pull request #324 from compnerd/arm-zext
+    
+    arm: zext return value parameters
+
+commit 7ad0ae7f42f3e208431ab66a9032dc9549f978d0
+Author: Saleem Abdulrasool <compnerd@compnerd.org>
+Date:   Tue Oct 10 11:44:05 2017 -0700
+
+    arm: zext return value parameters
+    
+    The closure function (invoked as closure->fun in ffi_closure_XXX_inner)
+    will only populate the actual number of bytes for the true return type,
+    which may be a character.  This leaves garbage on the stack when the
+    assembly closure function (i.e. ffi_closure_XXX) reads the return value
+    off of the stack into r0 as a 4-byte value.  ffi_closure_XXX always
+    leaves room for at least 4 bytes here, so we can safely set them to 0.
+    Otherwise, if there is garbage in any of these bytes, these end up in r0
+    and in the returned value as well.
+
+commit 2bfcd29955c02b67fa10a68cc4200f6838181e0f
+Author: Joerg Sonnenberger <joerg@NetBSD.org>
+Date:   Mon Oct 2 15:34:03 2017 +0200
+
+    Support NetBSD with mprotect.
+    
+    Signed-off-by: Thomas Klausner <wiz@NetBSD.org>
+
+commit 9f1f8741b2ec0c8898ecff7b93005627b915dd02
+Merge: dca078f 6cf0dea
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sun Oct 1 20:25:50 2017 -0600
+
+    Merge pull request #319 from angerman/patch-5
+    
+    Adds `local.exp` to DISTCLEANFILES
+
+commit 6cf0dea78a5a4584eda871e264043974d0453e53
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Mon Oct 2 10:20:16 2017 +0800
+
+    Change CLEANFILES to DISTCLEANFILES
+
+commit dca078f468ff696134195e85fed3f48260115651
+Merge: 540258d bccba9a
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sun Oct 1 20:19:53 2017 -0600
+
+    Merge pull request #316 from angerman/patch-2
+    
+    Add `configure.host` and `libtool-version` to the `EXTRA_DIST` files
+
+commit 540258d13e1d427254cbeddacdd2bb1ab2c307d1
+Merge: 93d8e7d 4c6aa78
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sun Oct 1 20:17:02 2017 -0600
+
+    Merge pull request #317 from angerman/patch-3
+    
+    Add src/x86/asmnames.h to noinst_HEADERS
+
+commit bccba9a34e8ba0fe671c4b94671fea2efe181b01
+Merge: a1e6ccb 59d65d7
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun Oct 1 12:48:17 2017 +0800
+
+    Merged
+
+commit 6b6df1a7bb377651a07663879bd4162f0059dc5c
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun Oct 1 12:37:53 2017 +0800
+
+    Adds `local.exp` to CLEANFILES
+    
+    With #315, #316, #317, #318 and this patch, running
+    ```
+    AM_DISTCHECK_CONFIGURE_FLAGS=--disable-docs make distcheck
+    ```
+    should complete successfully.
+
+commit 59d65d74ae72bd24fbf78f045592c5168f0b0784
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun Oct 1 12:23:31 2017 +0800
+
+    Include `libtool-version` in the EXTRA_DIST files.
+
+commit 4c6aa78d75f0c426a23c27af74155aa2535021d6
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun Oct 1 11:32:41 2017 +0800
+
+    Add src/x86/asmnames.h to noinst_HEADERS
+    
+    In eaa59755fcbb692a8cb763c7f9f24a350aadbd30, macros from `unix64.S` were extracted into `asmnames.h` to be used with `win64.S` as well. As such these are required by `unix64.S`, which fails to build without them.
+
+commit a1e6ccb67e7d7f2b235016aa6c6733c5743945a1
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun Oct 1 11:28:40 2017 +0800
+
+    Add `configure.host` to the `EXTRA_DIST` files
+    
+    When running `make dist`, `configure.host` would not result in the distribution tarball, however `configure` would try to read it, and as such the tarball would not be buildable.
+
+commit 93d8e7dd17b08ff195af3580584ccd5c2228202f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 21:51:34 2017 -0400
+
+    Fix #265
+
+commit 02a5145abbae2e311d5aeeee606c5b5745a99b55
+Merge: 10099d6 7d504f7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 21:43:03 2017 -0400
+
+    Merge pull request #263 from ksjogo/master
+    
+    fix ios builds
+
+commit 10099d6cad8418a10c1508235d1f458993ac51fe
+Merge: c8f1aa3 ed84883
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 20:54:09 2017 -0400
+
+    Merge pull request #271 from frida/fix/qnx-cache-flushing
+    
+    arm: Fix cache flushing on QNX
+
+commit c8f1aa3d0459c6f1be6884b324b4d2d785ecfd78
+Merge: db4dad9 50e408c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 20:53:50 2017 -0400
+
+    Merge pull request #307 from zw3rk/master
+    
+    Support -ios triple
+
+commit db4dad97e2589ca700d1b5b54eeb332137a152ad
+Merge: 8a16f2f 9c12209
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 20:47:08 2017 -0400
+
+    Merge pull request #312 from fjricci/fix_ub
+    
+    Fix misaligned memory access in ffi_call_int
+
+commit 8a16f2f47fdb6a985d201baa02a1d226562af4d8
+Merge: b230910 0ff9419
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Sep 27 20:45:15 2017 -0400
+
+    Merge pull request #308 from trex58/master
+    
+    This patch enables FFI Go Closure on AIX.
+
+commit a78da73956e4b0af4556f1c0a444bd0f065c3965
+Author: Jean-Luc Jumpertz <jean-luc@celedev.eu>
+Date:   Mon Sep 4 15:55:34 2017 +0200
+
+    Fix macOS build target in Xcode project.
+    
+    - Add missing files for desktop platforms in generate-darwin-source-and-headers.py, and in the Xcode project.
+    - Add a static library target for macOS.
+    - Fix "implicit conversion loses integer precision" warnings for iOS mad macOS targets.
+
+commit 9c12209d2eac40238eefb4255994277918e7eff1
+Author: Francis Ricci <francisjricci@gmail.com>
+Date:   Thu Aug 3 10:46:28 2017 -0700
+
+    Fix misaligned memory access in ffi_call_int
+
+commit b23091069adce469dc38fbcc9fd8ac9085d3c9d7
+Merge: c0cc9f1 9c6cb58
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Jul 12 12:43:06 2017 -0600
+
+    Merge pull request #309 from rurban/oldgcc
+    
+    __attribute__ deprecated (msg) only since gcc 4.5
+
+commit 9c6cb58812aa92a4c56a94b2b51bd85b2aebc2a1
+Author: Reini Urban <rurban@cpan.org>
+Date:   Sun Jun 18 18:26:05 2017 +0200
+
+    __attribute__ deprecated (msg) only since gcc 4.5
+    
+    make it work with older compilers
+
+commit 50e408ce5d9eb6f14bf82bb3894d0e74e5f19c2c
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun May 21 20:44:10 2017 +0800
+
+    add i?86-*-ios -- the iOS simulator (32bit)
+
+commit a08cabe6746343564418383b879d40d3b998c399
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Sun May 21 20:25:16 2017 +0800
+
+    add x86_64-*-ios -- the iOS simulator
+
+commit 0ff9419f2e75652426469e256cb7d0748064ad58
+Author: Tony Reix <tony.reix@bull.net>
+Date:   Wed May 17 14:57:53 2017 +0200
+
+    This patch enables FFI Go Closure on AIX.
+
+commit 19ab448d84223d2992048bce4e926eac2c44f606
+Author: Moritz Angermann <moritz.angermann@gmail.com>
+Date:   Tue May 16 08:32:06 2017 +0800
+
+    Support -ios triple
+    
+    Autoconf hasn’t had an update since 2014, and it doesn’t look like it will soon[1]
+    This updates config.{guess,sub}
+    
+    It adds support for e.g. `-ios`, which allows to have targets like `aarch64-apple-ios`.
+    
+    It basically does exactly what the config.guess script says:
+    > It is advised that you download the most up to date version of the config scripts from
+    
+    The configure.ac script has been updated to relax `*-apple-darwin*` to `*-apple-*`.
+    Similarly the `.gitignore` and `autogen.sh` needed to be updated to respect the
+    newer `config.{sub,guess}`
+    
+    —
+    [1]: http://lists.gnu.org/archive/html/autoconf/2016-07/msg00017.html
+
+commit c0cc9f1df9fd4c5e758470f05d0e48123f0638ae
+Merge: b841ae7 bd72848
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon May 8 15:20:39 2017 -0600
+
+    Merge pull request #302 from gpakosz/align-macros
+    
+    Prefix ALIGN macros with FFI_
+
+commit bd72848c7af9302df50a7a11652c77166d17caa8
+Author: Gregory Pakosz <gregory.pakosz@gmail.com>
+Date:   Thu Apr 27 13:20:36 2017 +0200
+
+    Prefix ALIGN macros with FFI_
+
+commit 7d504f7a8e33f6da27941f5dc5d889fe60b8b9c8
+Author: ksjogo <jogo@kronberger-spiele.de>
+Date:   Thu Mar 30 13:32:58 2017 +0200
+
+    update for xcode 8.3
+
+commit 57d8ff044cd6320d8ebacacf06455569b4aac27d
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Mar 15 01:43:11 2017 +0100
+
+    Simplify iOS trampoline table allocation
+    
+    By using VM_FLAGS_OVERWRITE there is no need for speculatively
+    allocating on a page we just deallocated. This approach eliminates the
+    race-condition and gets rid of the retry logic.
+
+commit 7f558a9ba4e74edf54a3e95e983e8a59ddb0cc7c
+Author: ksjogo <jogo@kronberger-spiele.de>
+Date:   Mon Jul 25 01:18:30 2016 +0200
+
+    set ios deployment target to 7.0
+
+commit e76fa94b6ef9a699ee9edeb85d1731d3bb7abd46
+Author: ksjogo <jogo@kronberger-spiele.de>
+Date:   Thu Jul 14 11:28:18 2016 +0200
+
+    fix ltmain.sh in xcode builds
+
+commit 22b2fd6f18eed7b32ea959f7f3e56ea09b9ac9bf
+Author: ksjogo <jogo@kronberger-spiele.de>
+Date:   Wed Jul 13 14:40:07 2016 +0200
+
+    add valid architectures
+
+commit 0040694505411785ec98e660fe81faad9630f515
+Author: Johannes Goslar <johannes.goslar@kronberger-spiele.de>
+Date:   Tue Jul 12 16:08:42 2016 +0200
+
+    Update Xcodeproj
+    
+    Include all currently relevent files.
+    Call autogen is build script.
+    Fix compiler settings.
+    Fix mach include.
+
+commit b841ae70a05a5e11de1fca1b4551189db0895cf2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 19 07:42:09 2017 -0400
+
+    remove stray quote
+
+commit a94c999ba0d51ed8ec88685233f5b1ae38e894ea
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 19 07:36:07 2017 -0400
+
+    Handle fastcall declaration differently for some Microsoft compilers
+
+commit 69963d39ab7d7f201b4597ed7a24cf438e0a34bf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 19 07:33:39 2017 -0400
+
+    We don't support 32-bit builds with the Microsoft toolchain
+
+commit 073bc9d50c1ce753735944e4228d9a401e964306
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 19 07:25:24 2017 -0400
+
+    Enable appveyor ci support
+
+commit a0b14eea2baf9f18c0d29bc5ce4495422381f917
+Merge: fa5a0fe 1e0d107
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 17 09:20:40 2017 -0400
+
+    Merge pull request #291 from ramon-garcia/visual-studio-build
+    
+    Build with Visual C++ (64 bits)
+
+commit fa5a0fe2c6da906cc7c114c8002e5c7092c4dbee
+Merge: 5b91bbd bfab429
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 16 07:50:07 2017 -0400
+
+    Merge pull request #238 from KubaKaszycki/master
+    
+    Update README with a new port
+
+commit 5b91bbd388213ec19044a392c291505e2c0674b9
+Merge: d754c51 982b89c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 16 00:40:58 2017 -0400
+
+    Merge pull request #288 from yan12125/std-includedir
+    
+    Install public headers in the standard path
+
+commit d754c510f1dd03dc8c2cd7b50bb2a1668715c5cd
+Merge: ebe7f44 41185b5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 16 00:39:07 2017 -0400
+
+    Merge pull request #299 from matijaskala/patch-1
+    
+    detect other x32 hosts
+
+commit ebe7f447abcfbf1a16dbfca26538fff03faf7c6b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 16 00:36:10 2017 -0400
+
+    Remove osx testing.  gcc was symlinked to clang. dejagnu c++ tests fail with clang.
+
+commit c9c2aa24611ec996f45a495f24d690688f3ffed6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 15 09:58:39 2017 -0400
+
+    Revert previous two changes.  clang/MacOS problem can only be solved within dejagnu.
+
+commit 5a8fca94059fbf14ac7352ce487c9250cdd67c63
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 15 09:52:39 2017 -0400
+
+    Fix typo
+
+commit 5b10a0198188d43fc07c271bc29ff1033e2ac9d3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 15 09:34:01 2017 -0400
+
+    Work around dejagnu/clang problems
+
+commit b6751258072fadadd487a6adf4962bf22b44746d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 15 08:54:52 2017 -0400
+
+    Require sudo for installing packages
+
+commit 41185b565fe17a8f107642f480849ef369ad0baa
+Author: Matija Skala <mskala@gmx.com>
+Date:   Wed Mar 15 12:50:41 2017 +0100
+
+    detect other x32 hosts
+    
+    primarily x86_64-pc-linux-muslx32
+    while at it, add x86_64-x32-pc-linux-{gnu,musl} as well
+
+commit 6e2e041b6df6a3c3a5ca8a750dedbbd465e5ca97
+Merge: dabbd14 d42ce7b
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Mar 14 19:37:45 2017 -0700
+
+    Merge pull request #297 from frida/fix/error-path
+    
+    Fix error path so mutex is unlocked before returning
+
+commit 5e4fcdccb3a841f2daaa5834f726eaeb42950511
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Mar 15 01:43:11 2017 +0100
+
+    Simplify iOS trampoline table allocation
+    
+    By using VM_FLAGS_OVERWRITE there is no need for speculatively
+    allocating on a page we just deallocated. This approach eliminates the
+    race-condition and gets rid of the retry logic.
+
+commit d42ce7b95c6d5cba7d976cc0c8c85f7645fa6b8f
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Mar 15 01:23:40 2017 +0100
+
+    Fix error path so mutex is unlocked before returning
+    
+    In the unusual case where ffi_trampoline_table_alloc() fails.
+
+commit dabbd145665ffca6fa676eba551f12107cd81131
+Merge: 60e4250 6caabd1
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon Feb 27 21:10:00 2017 -0700
+
+    Merge pull request #295 from terrillmoore/patch-1
+    
+    Correct typos in libffi.texi
+
+commit 6caabd198ec24d090d85d7eca01150b44003c76b
+Author: Terry Moore <tmm@mcci.com>
+Date:   Sun Feb 26 15:06:53 2017 -0500
+
+    Correct typos in libffi.texi
+    
+    One "it's" should be "its", and one "is" should be "in".
+
+commit 1e0d107b4b237edd11ca3209a9cf59786f752fe5
+Author: Ramón García Fernández <ramon.garcia.f@gmail.com>
+Date:   Sun Jan 8 20:12:59 2017 +0100
+
+    Modify configure.host to detect compilation with Microsoft Visual C++ and use assembly with Intel syntax in that case
+
+commit 982b89c01aca99c7bc229914fc1521f96930919b
+Author: Yen Chi Hsuan <yan12125@gmail.com>
+Date:   Sun Nov 13 19:17:19 2016 +0800
+
+    Install public headers in the standard path
+
+commit 60e4250a77eb3fde500bfd68ec40519fe34b21bd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:34:18 2016 -0400
+
+    make executable
+
+commit c3caf38895252b82febb76c6bb323c67a4e01929
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:21:18 2016 -0400
+
+    Update travis to test linux 32/64 and osx with a mix of gcc and clang
+
+commit c5b408ee78d097a495ea12467cf082f8008c8e17
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 4 09:17:46 2016 -0400
+
+    xfail the unwindtest for osx as per issue #279
+
+commit 256ce51c408766d23b2707cc79b97f673750b3b9
+Merge: 2ded2a4 52a11f6
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Sep 1 13:54:51 2016 -0700
+
+    Merge pull request #273 from wbx-github/master
+    
+    m68k: support ISA-A Coldfire CPUs
+
+commit 2ded2a4f494165c93293afc14ab0be1243cf8c49
+Merge: 408c9c7 e247b56
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Sep 1 13:30:45 2016 -0700
+
+    Merge pull request #272 from yousong/mips64-soft-float
+    
+    Mips64 soft float
+
+commit 408c9c7d5a4cb323c77499b1643858f4bfaf4ca7
+Merge: 06d7c51 b545ff8
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Aug 23 11:32:17 2016 -0600
+
+    Merge pull request #274 from dr-hannibal/ykolerov-unused
+    
+    ARC: Remove unused variable
+
+commit b545ff81f58233284cd6fca97a470aa3218c23e6
+Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+Date:   Tue Aug 23 20:23:37 2016 +0300
+
+    ARC: Remove unused variable
+    
+    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+
+commit 52a11f6d9152a56aa1fb6d04eb40fd76f4cce5ff
+Author: Waldemar Brodkorb <wbx@uclibc-ng.org>
+Date:   Sat Aug 20 00:52:19 2016 +0200
+
+    m68k: support ISA-A Coldfire CPUs
+    
+    Fix compilation for m68k/coldfire CPUs like mcf5208.
+    
+    Signed-off-by: Thorsten Glaser <tg@mirbsd.de>
+    Signed-off-by: Waldemar Brodkorb <wbx@uclibc-ng.org>
+
+commit e247b562ac85565dfac33e676e2915489af04183
+Author: Yousong Zhou <yszhou4tech@gmail.com>
+Date:   Mon Aug 15 17:34:37 2016 +0800
+
+    doc: fix typo
+    
+    Name of last argument to ffi_get_struct_offsets is `offsets`, not `sizes`
+    
+    Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
+
+commit 7a0d2c83bf2b0422e2d0ed297f847fc1eeb88bb3
+Author: Yousong Zhou <yszhou4tech@gmail.com>
+Date:   Mon Aug 15 15:00:13 2016 +0800
+
+    mips: fix MIPS softfloat build issue
+    
+    The patch for o32.S is taken from OpenWrt packages repo 3a7a4bf "libffi:
+    fix MIPS softfloat build issue with current binutils"
+    
+    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+    Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
+
+commit 06d7c5190e910356d4212d2a79056df8b70fd27e
+Merge: aa7ed78 301166b
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Aug 10 15:06:16 2016 -0600
+
+    Merge pull request #269 from frida/fix/aarch64-variadic-closures-on-ios
+    
+    aarch64: Fix handling of variadic closures on iOS
+
+commit aa7ed78c0e0d3fc4daa6a86c35ecbb7c43b5d067
+Merge: 1daa787 4da814b
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Aug 10 15:03:37 2016 -0600
+
+    Merge pull request #268 from frida/fix/aarch64-large-aggregates
+    
+    aarch64: Fix handling of aggregates larger than 16 bytes
+
+commit 4da814b18a1bf1d2013d988e37485e568d6117d1
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Aug 10 22:48:09 2016 +0200
+
+    aarch64: Fix handling of aggregates larger than 16 bytes
+    
+    Instead of allocating stack space for a pointer we would allocate stack
+    space for the actual aggregate size.
+
+commit 1daa78799942c83c905f8d7c5439952e9ffec3bc
+Merge: f03ba20 5e9ac7e
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Aug 10 14:31:09 2016 -0600
+
+    Merge pull request #270 from frida/fix/aarch64-warnings
+    
+    Fix aarch64 warnings
+
+commit ed8488345eaae41c161ab741b0c44299ee99dc6c
+Author: s1341 <github@shmarya.net>
+Date:   Wed Aug 10 14:57:22 2016 +0200
+
+    arm: Fix cache flushing on QNX
+    
+    Use `msync()` directly as `__clear_cache()` is broken in the
+    qnx650_gcc4.8.3 toolchain.
+
+commit 5e9ac7e252dbb0b7025027c1b6e1a4f3ec48943f
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Aug 10 15:22:19 2016 +0200
+
+    aarch64: Fix warning about unused function on iOS
+
+commit 4d1f11f6a9effce05ba51578b142827834d1f699
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Aug 10 15:21:42 2016 +0200
+
+    aarch64: Fix operand size warning reported by Clang
+
+commit 301166b11e913f85d09f67af94264268811f23a9
+Author: Ole André Vadla Ravnås <oleavr@gmail.com>
+Date:   Wed Aug 10 15:59:56 2016 +0200
+
+    aarch64: Fix handling of variadic closures on iOS
+
+commit f03ba2032850545dc6869bb495170a8c6cbf849d
+Merge: 40e4063 ef8be84
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Aug 2 10:23:25 2016 -0600
+
+    Merge pull request #266 from dr-hannibal/arc-pthread
+    
+    Make testing easier outside of build directory and especially for ARC
+
+commit ef8be84de5f9e611add396efe908b772eb1cae1d
+Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+Date:   Fri Jul 29 21:01:38 2016 +0300
+
+    Do not use fabsl() in float2.c test
+    
+    Some targets may support long double variables but in the same
+    time may lack support of long double functions like fabsl().
+    
+    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+
+commit f3201733d54bf26ac40c432f4305499dd3f20215
+Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+Date:   Fri Jul 29 19:18:41 2016 +0300
+
+    Fix output expectations in cls_dbls_struct.c test
+    
+    This test with invalid output expectations may fail on some targets
+    (e.g. ARC processors).
+    
+    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+
+commit f74ea2dc7994b4867f7ab45169e1b2422072cc92
+Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+Date:   Thu Jul 28 20:57:09 2016 +0300
+
+    Allow setting an arbitary value for blddirffi in testsuite
+    
+    It is useful when tests are executed not from build directory. So
+    the path of the build directory may be passed through site.exp or
+    runtest.
+    
+    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+
+commit 31362d785ed1db52516dfe02ebe8b163c53d29d0
+Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+Date:   Thu Jul 28 18:48:23 2016 +0300
+
+    ARC: Link tests with pthread library
+    
+    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
+
+commit 40e4063ab4449c644bc106298805fa8c6cfadbd4
+Merge: c0829e6 cf4b2a5
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Jul 7 23:11:38 2016 -0700
+
+    Merge pull request #261 from tromey/fix-260
+    
+    Don't dereference "ecif" before NULL check
+
+commit cf4b2a50413ecb8931eb1a94437497694f189c47
+Author: Tom Tromey <tom@tromey.com>
+Date:   Fri Jun 17 10:09:44 2016 +0100
+
+    Don't dereference "ecif" before NULL check
+    
+    Fixes #260
+
+commit c0829e62841100c308cc37ddd6537ca69e856de7
+Merge: 96d9bf4 794a54d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Jun 5 15:05:21 2016 -0700
+
+    Merge pull request #259 from rth7680/master
+    
+    Mark win64.S with GNU-stack note
+
+commit 794a54d4a603639adf1a79d5b5bc15da437457e2
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Jun 5 14:57:00 2016 -0700
+
+    Mark win64.S with GNU-stack note
+
+commit 96d9bf4b5517bc49c0129e8cfdee43098d3771a2
+Merge: 02089a1 52fbd12
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Jun 3 23:04:56 2016 -0700
+
+    Merge pull request #253 from iains/darwin-build
+    
+    Some Darwin build fixes
+
+commit 52fbd12dca1bddf0b135a24e7136f10af79a06bd
+Author: Iain Sandoe <iain@codesourcery.com>
+Date:   Thu May 26 09:00:00 2016 +0100
+
+    [Darwin-ppc, build] Fixes for clang build.
+    
+    clang is experimental on powerpc-darwin, but the changes are appropriate to cctools as as well.
+    
+    Use the 'official' simplified cmpwi insn, rather than the implied one accepted by cctools.
+    Do not re-use a set value.
+
+commit 92810b4bc101fccead2234b7385d4fa5e7a3e56a
+Author: Iain Sandoe <iain@codesourcery.com>
+Date:   Thu May 26 08:56:51 2016 +0100
+
+    [Darwin-x86, build] Fix up label prefixes, remove .purgem
+    
+    Darwin uses a label prefix of _.
+    cctools assembler will not accept .purgem as a directive.
+
+commit 30b3440cfd378dc67111b1380f2654334d048659
+Author: Iain Sandoe <iain@codesourcery.com>
+Date:   Thu May 26 08:55:04 2016 +0100
+
+    [Darwin, configure] Allow configure to work for <arch>-*-darwin.
+    
+    The exec configury is appropriate for all current targets (including using older tools on them).
+
+commit 02089a1b5cf3aa1535172c62add454a2e9375066
+Merge: 5d0365c c884551
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon May 23 09:58:51 2016 -0600
+
+    Merge pull request #237 from tschwinge/libffi_feature_test
+    
+    Simplify/fix libffi_feature_test
+
+commit 5d0365c605c472f40d1195cf7ba04ae08e360cb7
+Merge: 584a140 74b3f52
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu May 19 09:35:38 2016 -0700
+
+    Merge pull request #251 from berkerpeksag/delete-test-define
+    
+    Remove unused FFI_CLOSURE_TEST
+
+commit 74b3f5201432c37e40e24386fa193c838596cec8
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Thu May 19 18:05:36 2016 +0300
+
+    Remove unused FFI_CLOSURE_TEST
+    
+    It was here since the first commit c6dddbd (warning: huge diff) and
+    it wasn't defined by the configure script. It was probably used
+    manually during development.
+
+commit 584a140e7558dff6e4ed4009f39d11dd5e3db0ae
+Merge: c617754 b3496de
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu May 19 06:36:38 2016 -0600
+
+    Merge pull request #248 from berkerpeksag/patch-1
+    
+    Delete empty env in .travis.yml
+
+commit b3496dedbbad6c1f4e5bf4cc100e76b86f3c801e
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Thu May 19 10:53:07 2016 +0300
+
+    Delete empty env in .travis.yml
+
+commit c61775497e7bdfc892d865c2eb15415d2da7493b
+Merge: 9edaa69 33d9a31
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed May 18 11:10:33 2016 -0700
+
+    Merge pull request #247 from rth7680/symver
+    
+    Add parent to symbol version LIBFFI_BASE_7.1
+
+commit 33d9a31d34cfba63e1294978114be1bddd2de3fd
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed May 18 11:01:55 2016 -0700
+
+    Add parent to symbol version LIBFFI_BASE_7.1
+
+commit 9edaa695c54daaf58d62e84032d30d33b7484fa8
+Merge: 0969a1c 8a0a4e2
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed May 18 10:56:19 2016 -0700
+
+    Merge pull request #230 from rth7680/symver
+    
+    Use ELF symbol versioning
+
+commit 0969a1c1b339f845202fa7507b70d193220ceb01
+Merge: 571b1ca 4a677a4
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed May 18 10:09:28 2016 -0600
+
+    Merge pull request #232 from berkerpeksag/signcompare
+    
+    Fix -Wsign-compare warnings in x86/ffi64.c
+
+commit 571b1ca6277dbafc1f340a59ea1c5ee4ddb11c94
+Merge: 069d2e4 1e82e1c
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed May 18 10:08:59 2016 -0600
+
+    Merge pull request #233 from berkerpeksag/mremap
+    
+    Define _GNU_SOURCE on Linux for mremap()
+
+commit 069d2e4e16c5570adec9249d642f2a2ae0ffaa1c
+Merge: a44a5b8 1b4f5ee
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed May 18 10:07:31 2016 -0600
+
+    Merge pull request #246 from berkerpeksag/update-github-links
+    
+    Update project URLs to use libffi/libffi
+
+commit 1b4f5ee6a4989d7eda7766c5864908c389586c6f
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Wed May 18 11:12:58 2016 +0300
+
+    Update project URLs to use libffi/libffi
+
+commit 1e82e1cda43dacd8b6ab2d9ac4db33523d86f5dc
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Mon Mar 7 18:38:10 2016 +0200
+
+    Define _GNU_SOURCE on Linux for mremap()
+    
+    This was committed to CPython's libffi copy in
+    https://bugs.python.org/issue10309
+    
+    mremap() documentation says _GNU_SOURCE needs to
+    be defined in order to use mremap(): see the
+    synopsis section at http://linux.die.net/man/2/mremap
+    
+    Original commit: https://hg.python.org/cpython/rev/9986fff720a2
+    
+    Original patch was written by Hallvard B Furuseth.
+
+commit 4a677a425c18eda4bc5357b2485da57f133f908d
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Sat Mar 5 09:58:38 2016 +0200
+
+    Fix -Wsign-compare warnings in x86/ffi64.c
+    
+    This was originally reported on the Python tracker:
+    
+      httpa://bugs.python.org/issue23958
+    
+    The original patch was written by Steve R. Hastings.
+    
+    I've updated it to current master of libffi.
+
+commit a44a5b863aaae98041e11aa3256907bf912ee4d6
+Merge: 9443eae 2627fc9
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue May 17 17:07:27 2016 -0600
+
+    Merge pull request #234 from berkerpeksag/disable-docs
+    
+    Add a note about the --disable-docs switch
+
+commit 9443eaeda867cfdeae92b10bee3cc0506892a4c5
+Merge: 14be9a1 e169ba2
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue May 17 17:04:50 2016 -0600
+
+    Merge pull request #242 from somasis/master
+    
+    Fix usage on musl libc
+
+commit 8a0a4e25ef99f4ec98761f2fc075c2e8409f171b
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed May 4 07:33:41 2016 -1000
+
+    Update symbol versioning for ffi_get_struct_offsets
+    
+    Given that the original symbol versioning patch has shipped
+    with gcc-6, it would be kind to keep that as a valid base ABI
+    and make subsequent changes to version 7.1.
+
+commit c02c3414440e816aa13a2fe8446484173d3edb0e
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Mar 3 13:51:44 2016 -0800
+
+    Use ELF symbol versioning
+    
+    At the same time, we must bump the (major) ABI version.  This needed to be
+    done anyway due to ABI breakage in the AArch64 port (see 12cf89ee and the
+    corresponding GCC PR70024).
+
+commit 14be9a1d0713deb97edb91fe9800afe971a001d5
+Merge: 1cea273 b50eabf
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed May 4 06:45:05 2016 -1000
+
+    Merge pull request #245 from rth7680/tromey-ffi-prep-cif-core-is-private
+    
+    A rebase of #219
+
+commit b50eabf48927ccaf0184c6224992bbb0a125e969
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon Feb 22 16:00:51 2016 -0700
+
+    minor comment cleanup
+    
+    This patch minor cleans up ffi.h.in comments in a minor way.  It fixes
+    some typos and capitalizations, adds some periods, and reformats some
+    comments to a more GNU-ish style.  It also fixes up some stale
+    documentation.
+
+commit 6c07077a61fd0dc5ac11759ea1b4345acf486f3c
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sun Feb 21 20:08:21 2016 -0700
+
+    Change ffi.h.in so that braces match
+    
+    This is a tiny refactoring to make it so brace-matching works in
+    Emacs.
+
+commit 2fbc0369b89a7e6b089e6384b98dba904ec1cf8b
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu Nov 19 16:38:35 2015 -0700
+
+    move ffi_prep_cif_core to ffi_common.h
+
+commit 1cea273758ad862bdc2862af864e4ef5b42f31ae
+Merge: 48bfae1 6aafb56
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue May 3 08:23:51 2016 -0600
+
+    Merge pull request #231 from berkerpeksag/simplfy-oserror
+    
+    Simplify error handling in mkdir_p()
+
+commit 48bfae1f37551b7fc894e6a0ea3b98968d2b5c9f
+Merge: 6d87110 d76975d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon May 2 20:58:57 2016 -1000
+
+    Merge pull request #236 from andreas-schwab/master
+    
+    Define FFI_SIZEOF_JAVA_RAW for aarch64 ILP32
+
+commit 6d8711057bc3a3befa37eed6765231ea5d244078
+Merge: 9de24a3 e5843a3
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun May 1 11:02:40 2016 -1000
+
+    Merge pull request #241 from rth7680/fix-win64
+    
+    Fix win64 abi calling from unix64
+
+commit e169ba2b83c780058fe626856cfdb5903a85cb97
+Author: Kylie McClain <somasis@exherbo.org>
+Date:   Fri Apr 29 21:04:07 2016 -0400
+
+    Fix usage on musl libc
+    
+    A gcc compiled on musl does not define __gnu_linux__, it defines __linux__.
+    Only on glibc does __gnu_linux__ get defined, but both define __linux__, so
+    we should check for that instead.
+    
+    With this patch, libffi works perfectly, and passes its testsuite entirely
+    on musl libc systems.
+
+commit e5843a3a09976f9d8fa77671e9d6c188c890199d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Apr 15 16:10:08 2016 -0700
+
+    x86: Fix calling convention for ffi_closure_win64_inner
+    
+    Also enable testing for the cross-abi calls.
+
+commit d06751979bf0e4c9caabf0bca531d74de8cb9152
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Mar 7 12:14:22 2016 -0500
+
+    x86: Copy fix for clang .org from unix64.S
+    
+    Clang doesn't understand .org with symbolic operands.
+
+commit bfab429ee479723cc65831a7e4327e2866036420
+Author: Jakub Kaszycki <kaszycki@mail.com>
+Date:   Fri Apr 1 21:42:41 2016 +0200
+
+    Update README with a new port
+    
+    This is in fact not a NEW port. Apple Mac devices are generally x86-64 now, x86 rarely. If GCC exists for this CPU, it means that libffi has been built too.
+
+commit c88455178151bea14b8561ab6830724c31af255e
+Author: Thomas Schwinge <thomas@codesourcery.com>
+Date:   Thu Feb 25 20:10:18 2016 +0100
+
+    Simplify/fix libffi_feature_test
+    
+    As detailed in
+    <http://news.gmane.org/find-root.php?message_id=%3C87wppswqqt.fsf%40kepler.schwinge.homeip.net%3E>,
+    the original code (originally added in commit
+    f1301a54bb80e6ae23f7687c68f36875dae69134 as part of pull request #145) does not
+    work (at least not for me, in the GCC environment).
+
+commit d76975dbd2854beca7acbca946c4cbccf9bf7cee
+Author: Andreas Schwab <schwab@suse.de>
+Date:   Wed Mar 16 12:23:07 2016 +0100
+
+    Define FFI_SIZEOF_JAVA_RAW for aarch64 ILP32
+    
+    Like x32, aarch64 ILP32 needs to define FFI_SIZEOF_JAVA_RAW.  This fixes
+    the java interpreter.
+
+commit 9de24a3ff31c7446de29c1adcd9276fd7ba93897
+Merge: ee71806 38a4d72
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Mar 14 13:54:53 2016 -0400
+
+    Merge pull request #212 from tromey/struct-layout
+    
+    add ffi_get_struct_offsets
+
+commit 2627fc98e86e906fd7c9bc16bf345b91ee26d2ba
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Mon Mar 7 18:43:03 2016 +0200
+
+    Add a note about the --disable-docs switch
+    
+    Closes #204
+
+commit 6aafb5654d6741927276efff1af72a5b3614da39
+Author: Berker Peksag <berker.peksag@gmail.com>
+Date:   Sat Mar 5 08:30:31 2016 +0200
+
+    Simplify error handling in mkdir_p()
+
+commit ee718066f763b65d1888f9cc7155d3a1880f80e9
+Merge: f2f234a e59fb55
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 22 20:15:40 2016 -0500
+
+    Merge pull request #227 from tromey/fix-documentation-build
+    
+    Fix documentation build
+
+commit 38a4d72c95936d27cba1ac6e84e3094ffdfaa77c
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Nov 17 21:18:20 2015 -0700
+
+    add ffi_get_struct_offsets
+
+commit e59fb55e09fb8aa846c820a802a03fed408d05a6
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon Feb 22 15:51:27 2016 -0700
+
+    remove and ignore texinfo.tex
+    
+    This file is provided by Automake
+
+commit 6dd5fd5a643c50aff3303ba2add3b6cc7588df78
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon Feb 22 15:34:39 2016 -0700
+
+    fix documentation building
+    
+    An earlier patch added --disable-docs, but went too far, making it
+    impossible to build the docs.
+    
+    It turns out that Automake seemingly has a bug preventing the
+    conditional build of an info file.  So, this patch works around the
+    bug by putting the info_TEXINFOS rule into a new doc/Makefile.am.
+    
+    Tested by building with and without --disable-docs and looking for the
+    existence of doc/libffi.info.
+
+commit f2f234aef203a5e836b83cb772f9473f7ea0d5ce
+Merge: 49b95ed fa7a257
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:50:29 2016 -0500
+
+    Merge pull request #190 from havardgraff/master
+    
+    Add configure-option to disable building docs
+
+commit 49b95edafd712ce27e08b1bb4be2987f14c54ca3
+Merge: 415723b 43fc5bc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:49:40 2016 -0500
+
+    Merge pull request #194 from amodra/master
+    
+    Correct powerpc sysv stack argument accounting
+
+commit 415723b40ba76f4a9df9b709db1cde0c65162072
+Merge: 7c27fcb 1f6b5a9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:49:19 2016 -0500
+
+    Merge pull request #104 from joshtriplett/efi64
+    
+    Support the Windows/EFI calling convention on all x86-64 targets
+
+commit 7c27fcbe09534d261b4098467a3ce258daec2807
+Merge: 69143d0 e061243
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:45:00 2016 -0500
+
+    Merge pull request #199 from Pan7/master
+    
+    Fix configuring msvc compiler
+
+commit 69143d06c6276d09790a4e34f2eb6d37528c08c6
+Merge: 755f1e6 505346e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:44:28 2016 -0500
+
+    Merge pull request #197 from foxsen/mips_go_closure
+    
+    Mips go closure support
+
+commit 755f1e642d97892cb54358d65e06b60d1d6b72a4
+Merge: 183ee6a 4cdedc2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:43:48 2016 -0500
+
+    Merge pull request #193 from rth7680/fix-70
+    
+    Test case from issue #70
+
+commit 183ee6a6729db8f3ee0b1532d7bd54a6ef305443
+Merge: 0bb71b5 877ea9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:43:28 2016 -0500
+
+    Merge pull request #206 from edolnx/master
+    
+    Add configure flag to disable multi-os-directory support
+
+commit 0bb71b52f5a60643ad55f801f1c652855b0e5cc5
+Merge: 296a283 8bec5ca
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:41:10 2016 -0500
+
+    Merge pull request #211 from tromey/move-prep-types-out-of-ffi.h
+    
+    ffi_prep_types is internal-only
+
+commit 296a283a46057a6a643f1f64534324af34b7ed19
+Merge: e7c713a 4805bf9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:40:21 2016 -0500
+
+    Merge pull request #213 from tromey/remove-FFI_TYPE
+    
+    remove FFI_TYPE typedef
+
+commit e7c713a0b64c425b51f3d9437a8db7ca497e6c31
+Merge: 79666ab f45e9e3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:40:03 2016 -0500
+
+    Merge pull request #214 from tromey/document-enum-support
+    
+    document (lack of) enum handling in libffi
+
+commit 79666abca87ac67d2d05b477a3ba71ec18b8af0c
+Merge: 20c7c31 89b7605
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:38:40 2016 -0500
+
+    Merge pull request #205 from filbranden/tool_opts
+    
+    Fix dejagnu test support for --tool_opts
+
+commit 20c7c31ca04350670012b28756d4ebc9e7b67a68
+Merge: 6ba2a49 9c14cbf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 20 06:38:01 2016 -0500
+
+    Merge pull request #225 from ehsan/safeseh
+    
+    Don't clobber safeseh for msvcc.sh -clang-cl in 32-bit mode
+
+commit 89b760503ed017233c98531908dfe8d8affab65e
+Author: Filipe Brandenburger <filbranden@google.com>
+Date:   Mon Oct 19 15:33:23 2015 -0700
+
+    Fix dejagnu test support for --tool_opts
+    
+    Right now it concatenates it with the existing options and then appends
+    it to that list, fix it to simply append it as is, same as it is done
+    with the other variables.
+    
+    Tested by running the following command which includes gcc options:
+      $ make check RUNTESTFLAGS="--tool_opts '-Werror'"
+    
+    Without this patch, all the tests fail. With it, the test succeed.
+    Inspecting the logs shows that -Werror was indeed used when compiling
+    the test sources.
+
+commit 9c14cbfc7ff49c2ceb9b65c548ddaced607f0785
+Author: Ehsan Akhgari <ehsan@mozilla.com>
+Date:   Thu Jan 28 16:57:18 2016 -0500
+
+    Don't clobber safeseh for msvcc.sh -clang-cl in 32-bit mode
+    
+    The commit fb25cd0 went a bit too far and removed safeseh
+    when -clang-cl was passed, but that's only needed in x86-64
+    which is already handled by the -m64 flag.
+    
+    I discovered this when building Firefox x86 with clang-cl.
+
+commit 6ba2a49e226b859ddde9a37c34973cf85380c525
+Merge: 8005600 6a3a6ac
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 2 20:03:41 2016 -0500
+
+    Merge pull request #222 from freakboy3742/t181
+    
+    Fixed #181 -- Corrected problems with ARMv7 build under iOS.
+
+commit 8005600a920f43d89ace7ef3598057392da726e1
+Merge: 70594f7 5e2b18a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 2 16:44:29 2016 -0500
+
+    Merge pull request #224 from plicease/travis
+    
+    update apt-get in travis
+
+commit 5e2b18a65d3f366b2fb02ee27321095c4b5f17ac
+Author: Graham Ollis <plicease@cpan.org>
+Date:   Sat Jan 2 07:56:05 2016 -0500
+
+    update apt-get in travis
+
+commit 6a3a6acd9fdbdac6f9f9294732b9627895b77715
+Merge: bc4fc07 70594f7
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Mon Dec 21 00:37:37 2015 +0800
+
+    Merge branch 'master' into t181
+
+commit bc4fc07aa58df6d7fa90b57d305d58eef96a0416
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Mon Dec 21 00:37:06 2015 +0800
+
+    Fixed #181 -- Corrected problems with ARMv7 build under iOS.
+    
+    Based on a patch from @fealebenpae, with input from @SolaWing and @rth7680,
+    and testing from @superdump.
+
+commit 70594f7f8d7410be47ba9a80a566175d937ab626
+Merge: 88deacd 6affad7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Dec 18 10:24:38 2015 -0500
+
+    Merge pull request #221 from tromey/document-closure-ffi_arg
+    
+    Document closure ffi arg
+
+commit 6affad79111c45982fd29637a46bc756abb128a3
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu Dec 17 16:58:10 2015 -0700
+
+    correctly document closure return promotion
+
+commit 8a7cdeb0412f9ef8bbe0a7833d662dbec40b472f
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu Dec 17 16:51:32 2015 -0700
+
+    fix formatting of ffi_prep_closure_loc arguments
+
+commit f45e9e35700d7c547ba33b02c4186e746dea204a
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu Nov 19 15:21:14 2015 -0700
+
+    document (lack of) enum handling in libffi
+
+commit 4805bf9ccdc176687526e9e7fca0db763cef42fb
+Author: Tom Tromey <tom@tromey.com>
+Date:   Thu Nov 19 14:17:42 2015 -0700
+
+    remove FFI_TYPE typedef
+
+commit 8bec5ca26a9977e6c05d6bfa1bbbc7f6f99af4e7
+Author: Tom Tromey <tom@tromey.com>
+Date:   Wed Nov 11 21:34:43 2015 -0700
+
+    ffi_prep_types is internal-only
+
+commit 88deacdd4220b66805b6ad10abd61fa3640afb67
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 15 08:39:17 2015 -0500
+
+    speling fix
+
+commit 5973dca595f8595a40709f645e74b06990975db3
+Merge: 2a988c4 473bcbc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 15 08:36:48 2015 -0500
+
+    Merge pull request #209 from tromey/documentation-updates
+    
+    documentation fixes
+
+commit 2a988c4455d3926c59997b68f7510be63e10c841
+Merge: e9de7e3 ff33ddd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 15 08:33:46 2015 -0500
+
+    Merge pull request #207 from tromey/deprecate-ffi-prep-closure
+    
+    mark ffi_prep_closure as deprecated
+
+commit 473bcbcad32e9e320a7a5c111cefd0d8ad570245
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sat Nov 7 12:01:06 2015 -0700
+
+    documentation fixes
+    
+    Fixes #78.  Documentation for #33 and #35, but no fix.
+
+commit ff33ddd1abe72b6d02d2769c0379b06eb7dbb931
+Author: Tom Tromey <tom@tromey.com>
+Date:   Sat Nov 7 11:45:04 2015 -0700
+
+    mark ffi_prep_closure as deprecated
+
+commit 877ea9bf9ac2c98cb858c12f5a6aeeec13cf978f
+Author: Carl Perry <caperry@edolnx.net>
+Date:   Thu Oct 29 22:50:42 2015 -0500
+
+    Add configure flag to disable multi-os-directory support
+    
+    In some environments, installing the library to GCC's
+    multi-os-directory is not perferable. This patch adds a switch
+    to configure "--disable-multi-os-directory" which will disable
+    that check, typically falling back to ${libdir} unless
+    cross-compiling.
+    
+    Original patch was written by Stewart Brodie, and was found at
+    https://sourceware.org/ml/libffi-discuss/2013/msg00144.html
+    
+    I've just updated it to work with the current version.
+
+commit 4cdedc279f96aefda24277184594c0ddd56d3402
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Jul 25 14:29:15 2015 -0700
+
+    Tidy call.exp test collection
+    
+    Commit c952a92e20aa6013d8202d0b3fa1d87838c83054 moved all of
+    the complex tests to libffi.complex, but failed to remove the
+    anti-globbing from libffi.call.
+
+commit 609db2fbe41a56c1a8cd5653d248f08b88ea803f
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Jul 25 12:42:04 2015 -0700
+
+    Test case from Issue #70
+
+commit e9de7e35f2339598b16cbb375f9992643ed81209
+Merge: d19b6cc 0ebde2d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 11 10:54:50 2015 -0400
+
+    Merge pull request #202 from tromey/note-prep-cif-var-usage
+    
+    document that there must be ntotalargs types
+
+commit d19b6cc78e956e7ffd48b39fd7c441c22e633ce2
+Merge: 17ffc36 36f3fb9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 11 10:54:22 2015 -0400
+
+    Merge pull request #201 from tromey/fix-texinfo-buglet
+    
+    Add missing "@" to @var{}
+
+commit 0ebde2d24a3deb7b0cdf5cb1e625b55af2834fde
+Author: Tom Tromey <tom@tromey.com>
+Date:   Tue Oct 6 11:42:43 2015 -0600
+
+    document that there must be ntotalargs types
+
+commit 36f3fb91412a6f10bd2c6dde01f4d7afa1f2f2c0
+Author: Tom Tromey <tom@tromey.com>
+Date:   Mon Oct 5 10:20:05 2015 -0600
+
+    Add missing "@" to @var{}
+
+commit e061243958d63080956887e121d275533570f7cc
+Author: Pan7 <panter@gmx.net>
+Date:   Mon Sep 14 08:25:09 2015 +0200
+
+    Fix configuring msvc compiler
+
+commit 505346e18fe20eee7eb69a23a48f6951858c5267
+Author: Zhang Fuxin <zhangfx@lemote.com>
+Date:   Wed Aug 26 09:57:10 2015 +0800
+
+    fix type error in unwind code
+
+commit 5953c66bd7510b048b332b4e7450f3fb8d687f8b
+Author: foxsen <2503799872@qq.com>
+Date:   Thu Aug 20 20:28:13 2015 +0800
+
+    add unwind infor for *go_closure;
+    reorder the labels to make thing more clear
+
+commit f0ecd5d40397d4616ba0bf3e2521da2663b5bd97
+Author: Zhang Fuxin <zhangfx@lemote.com>
+Date:   Tue Aug 11 12:47:36 2015 +0800
+
+    fix O32 stack unwind code
+    add missing 1: label
+
+commit 6f0201c803a9a1f0f9b6fd226a42fb8daa223928
+Author: foxsen <2503799872@qq.com>
+Date:   Tue Aug 4 18:25:34 2015 +0800
+
+    various fixes for go closure support. Now all n64 tests passed.
+
+commit 697dd4e8a03625a9b1448aa696978d8dcc57d438
+Author: foxsen <2503799872@qq.com>
+Date:   Tue Aug 4 12:53:33 2015 +0800
+
+    add support for go closure support on mips
+
+commit 43fc5bca48715a522b34c1124589575063362a90
+Author: Alan Modra <amodra@gmail.com>
+Date:   Mon Aug 3 23:34:05 2015 +0930
+
+    Correct powerpc sysv stack argument accounting
+    
+    ppc32 starts using the stack for integer arg passing when we run out
+    of integer arg passing registers.  Similarly, we start using the stack
+    for floating point args when we run out of floating point registers.
+    The decision on where an integer arg goes does not depend on number of
+    floating point args, nor does the decision on where a floating point
+    arg goes depend on number of integer args.  Alignment of stack args
+    also simply depends on number of stack args.
+    
+    This patch untangles the horrible mess we had, with intarg_count being
+    wrongly used to count both integer args and stack words.
+    
+            * src/powerpc/ffi_sysv.c (ffi_prep_cif_sysv_core): Count fprs,
+            gprs, and stack words separately.
+            (ffi_prep_args_SYSV): Similarly.
+
+commit 1f6b5a91f417ac77d2fe9b0b3eb66293db132e2e
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Jul 26 16:27:34 2015 -0700
+
+    Support the WIN64/EFI64 calling convention on all X86_64 platforms
+    
+    Add a new calling convention FFI_EFI64, alias FFI_WIN64, on all X86_64
+    platforms.  This allows libffi compiled on a 64-bit x86 platform to call
+    EFI functions.
+    
+    Compile in ffiw64.c and win64.S on all X86_64 platforms.  When compiled
+    for a platform other than X86_WIN64, ffiw64.c suffixes its functions
+    with _efi64, to avoid conflict with the platform's actual
+    implementations of those functions.
+
+commit 6de51f3e04e496901ea1bd8f9b44f75c9f01b599
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Jul 26 16:23:55 2015 -0700
+
+    src/x86/ffiw64.c: Don't assign a "char *" to an "unsigned char *"
+    
+    Declare a local variable to match the type of the struct field assigned
+    to it, rather than adding unsigned to the type.  Fixes a -Wpointer-sign
+    warning.
+
+commit eaa59755fcbb692a8cb763c7f9f24a350aadbd30
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Jul 26 17:17:16 2015 -0700
+
+    src/x86/win64.S: Handle name mangling and PIC
+    
+    Move the macros from unix64.S into a shared header asmnames.h and use
+    them in win64.S too.
+
+commit c8e82d9fbffd3eeaef0266a1aac64d7bd13ee9c3
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Jul 26 16:18:57 2015 -0700
+
+    src/x86/win64.S: Support compiling on non-WIN64 platforms
+    
+    Non-WIN64 versions of the GNU assembler don't support the .seh_*
+    directives for structured exception handling, so wrap them in a macro
+    that compiles to nothing.
+    
+    Handle the registers used for the non-Windows x86-64 calling convention
+    when on a non-Windows platform.  Distinguish between cases that should
+    refer to the native argument registers (defined as arg0, arg1, arg2, and
+    arg3) and cases that should always refer to the Windows argument
+    registers.
+
+commit fa7a257113e2cfc963a0be9dca5d7b4c73999dcc
+Author: Havard Graff <havard.graff@gmail.com>
+Date:   Tue May 12 10:45:13 2015 +0200
+
+    Add configure-option to disable building docs
+
+commit e3d2812ce43940aacae5bab2d0e965278cb1e7ea
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Sat Apr 25 19:03:03 2015 +0800
+
+    Modified arm/sysv.S to remove directives not allowed by clang.
+
+commit 17ffc3655a531c116e9eb9cc933e50bb1e5c47f8
+Merge: 173757c a5b3eaa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 29 21:38:26 2015 -0400
+
+    Merge pull request #185 from freakboy3742/t184
+    
+    Fixed #184 -- Corrected source file references in Darwin source generator tool.
+
+commit 173757ce973a2f12ad36ac6cda593581b225f9e3
+Merge: f5ec627 dd9e4c8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 29 21:38:12 2015 -0400
+
+    Merge pull request #186 from freakboy3742/gitignore
+    
+    Added generated source file to .gitignore.
+
+commit dd9e4c8d46b65104a24a9858accd0936ca44b98f
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Fri Mar 13 08:03:13 2015 +0800
+
+    Added generated source file to .gitignore.
+
+commit a5b3eaa279a2e54721d44eeefdfd1962cf63caaf
+Author: Russell Keith-Magee <russell@keith-magee.com>
+Date:   Fri Mar 13 07:59:11 2015 +0800
+
+    Fixed #184 -- Corrected file references in Darwin source generator tool.
+
+commit f5ec6279a4698a8752093247a500cf76096ff157
+Merge: 06747d3 95df379
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 4 13:58:04 2015 -0500
+
+    Merge pull request #178 from rth7680/aa64-ilp32
+    
+    aarch64: Handle ILP32 ABI
+
+commit 95df3791935d934d92b0c852af1e655285157b70
+Author: Andrew Pinski <apinski@cavium.com>
+Date:   Wed Feb 11 08:31:48 2015 -0800
+
+    aarch64: Handle ILP32 ABI
+
+commit 06747d318761884e70dfa433a9548219fd779d7d
+Merge: db1b34b 6c53577
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 29 07:22:23 2015 -0500
+
+    Merge pull request #176 from 0-wiz-0/master
+    
+    Handle NetBSD/powerpc the same as FreeBSD and OpenBSD.
+
+commit 6c5357757f188577fffcd2890ef7a0f53e77de20
+Author: Thomas Klausner <wiz@NetBSD.org>
+Date:   Thu Jan 29 12:32:28 2015 +0100
+
+    Handle NetBSD/powerpc the same as FreeBSD and OpenBSD.
+    
+    Signed-off-by: Thomas Klausner <wiz@NetBSD.org>
+
+commit db1b34b7e1f5e473d17557e454a29933dfecd1af
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 28 18:08:06 2015 -0500
+
+    Remove incomplete sentence
+
+commit 56036a6b58acb9e854719e315a0738f16e354c35
+Merge: 035715b 2104b2a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 28 18:03:57 2015 -0500
+
+    Merge pull request #175 from rth7680/sparc
+    
+    sparc: Re-introduce hand-written unwind info
+
+commit 035715b3330421806df36ec4ac7ccecc86458540
+Merge: 31a6185 b0e9796
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 28 18:03:06 2015 -0500
+
+    Merge pull request #174 from rth7680/fbsd
+    
+    configure: Run HAVE_AS_X86_PCREL for all X86 targets
+
+commit 2104b2a4fc923b8d82647c3fbbd8a8ca20bb24c8
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Jan 26 12:43:57 2015 -0800
+
+    sparc: Re-introduce hand-written unwind info
+    
+    Fixes the build with the Solaris assembler.
+
+commit b0e9796344562ea8e1ef28e9b04db6be26ca29fb
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Jan 27 22:10:12 2015 -0800
+
+    configure: Run HAVE_AS_X86_PCREL for all X86 targets
+
+commit 31a618530737cc8f1666845f8e65a3c097f6d408
+Merge: d6675c1 5363663
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 21 05:55:47 2015 -0500
+
+    Merge pull request #170 from fealebenpae/aarch64-trampoline-table
+    
+    Support closures on ARM64 iOS
+
+commit d6675c16cc2b5a0e32c4538e5a4f555c91e6bb56
+Merge: a25a46a 3ac1610
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 21 05:53:21 2015 -0500
+
+    Merge pull request #172 from rth7680/fixes
+    
+    x86: Fix cygwin32 build
+
+commit 3ac1610aa33c887ea9b14935208943925714a33e
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Jan 19 20:48:40 2015 +0100
+
+    x86: Fix cygwin32 build
+    
+    The section syntax is just that little bit different.
+
+commit a25a46a7fe4f7ae27fbd6e08a2540678899914e9
+Merge: 5cd411a 1ad0b17
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 16 17:32:07 2015 -0500
+
+    Merge pull request #171 from rth7680/fixes
+    
+    Fixes from mainline gcc
+
+commit 1ad0b17177526be86736e245fbcc21eadaf7cb36
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Jan 16 13:30:05 2015 -0800
+
+    sparc: Also mark the return address in unwind info
+
+commit d68c8aed19d459a9fef0847f316dd9473ef263ad
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Jan 16 11:40:33 2015 -0800
+
+    sparc: Solaris fixes, part 2
+    
+    /bin/as seems to only understand single-digit labels
+    /bin/as knows nothing about .rept/.endr
+
+commit b740ab7cc955fc2888325e6387207f34400a6c45
+Author: Rainer Orth <ro@CeBiTec.Uni-Bielefeld.DE>
+Date:   Fri Jan 16 11:32:23 2015 -0800
+
+    sparc: Solaris fixes
+    
+    * /bin/as requires .type fn,#function instead of @function.
+    * /bin/as doesn't support .macro/.endm.  I'm using preprocessor macros
+      instead to implement E in src/sparc/v[89].S.
+
+commit f1560b7bbeb57042a32dfde487c3d21bd9ef6a51
+Author: Rainer Orth <ro@CeBiTec.Uni-Bielefeld.DE>
+Date:   Fri Jan 16 11:31:37 2015 -0800
+
+    x86: Solaris fixes
+    
+    * Solaris/x86 /bin/as doesn't support .org, so I've just disabled the
+      uses in src/x86/{sysv, unix64}.S, as on Darwin.
+    * Solaris/x86 needs to use EH_FRAME_FLAGS so manually and compiler
+      generated .eh_frame sections match, otherwise libffi.so fails to link:
+    * Solaris/x86 /bin/as has different COMDAT syntax; I've disabled it for
+      the moment.
+
+commit 536366349ced9d57c873d64e219ba30992a83c06
+Author: Yavor Georgiev <fealebenpae@gmail.com>
+Date:   Fri Jan 16 15:19:38 2015 +0200
+
+    aarch64: implement the trampoline table workaround for ffi closures on Apple systems
+    
+    This is a direct copy/paste port of the ARM code, with changes because of Aarch64 pc-relative addressing restrictions.
+
+commit 05e65b4e2064f24669e8cc1c1cece1cbb0577548
+Author: Yavor Georgiev <fealebenpae@gmail.com>
+Date:   Fri Jan 16 15:18:04 2015 +0200
+
+    aarch64: rewrite range syntax into list to appease Clang
+    
+    Clang's assembler in Xcode 6 appears to choke when the operand of st4 is a range, but is happy with a list.
+
+commit 5cd411ad5d62b1dadfd02f75f99121801c8be4c9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 13 15:44:03 2015 -0500
+
+    New test case for old aarch64 bug
+
+commit e46842b4149e19106a9eb6066ef022d8b6a7ad5d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Jan 13 07:23:48 2015 -0800
+
+    Remove extra brackets in configure.host
+    
+    This table is no longer in configure.ac, needing
+    protection from m4.
+
+commit f27c4e46734fa1342236b16161e6006a9d2557e9
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Jan 13 07:22:07 2015 -0800
+
+    x86: Fix thinko in ffi_raw_call
+    
+    Missed structure initialization for raw path.
+    Apparently there are no tests for this outside gcc.
+
+commit c82cc159426d8d4402375fa1ae3f045b9cf82e16
+Merge: 1c61e73 e1a5ddb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 10 09:25:26 2015 -0500
+
+    Merge pull request #166 from chevah/master
+    
+    Fix expr error in Solaris 10 when using gcc.
+
+commit 1c61e73ad8e920d6bff337fac02de71f3a66bc38
+Merge: dd0b59a 3fa5d70
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 10 09:23:30 2015 -0500
+
+    Merge pull request #165 from rth7680/pcc
+    
+    Support PCC as producer and consumer
+
+commit dd0b59a5cf63e0f9602c76fc89a4cb62593ff6f1
+Merge: 9131039 b7f6d7a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 10 09:22:55 2015 -0500
+
+    Merge pull request #164 from rth7680/darwin
+    
+    Fix build on darwin
+
+commit 9131039c93b6ecd1c3946905a3b6dafb5dc4ee40
+Merge: 4ca2262 7282d32
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 10 09:22:42 2015 -0500
+
+    Merge pull request #160 from nobu/msvc-no-complex
+    
+    x86: MSVC does not support Complex type
+
+commit 4ca2262ad61189276b2d95aab652a23c8db2a5b9
+Merge: 58bf7d6 5f8881a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jan 10 09:21:37 2015 -0500
+
+    Merge pull request #159 from nobu/fix-void-arith
+    
+    x86: Fix void pointer arithmetic
+
+commit e1a5ddb3067f83563cb8a6b8ac4d0f58d4699262
+Author: Mișu Moldovan <dumol@chevah.com>
+Date:   Wed Jan 7 17:51:07 2015 +0200
+
+    Fix expr error in Solaris 10 when using gcc.
+
+commit 3fa5d70cbb18b39a5e44f1c7984dedf73446bf6c
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Jan 5 13:03:06 2015 -0800
+
+    x86: Avoid fastcall when building with pcc
+    
+    Apparently, PCC doesn't support the fastcall calling convention.
+    Nor does it issue a warning or error for the attribute that it
+    does not understand.
+
+commit a03d2310ed53bb8b3a4610af04015ef9df6ea36c
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Dec 24 16:03:34 2014 -0800
+
+    x86: Load structure return address into eax
+
+commit b7f6d7aa9b0d7b19eec28a945251e09a4b65b275
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Dec 10 13:37:36 2014 -0800
+
+    x86: Reinstate hand-written unwind info for sysv.S
+
+commit 6cedf81ca7cbad01b3fcc2c4475d860095bfb062
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Dec 10 09:43:58 2014 -0800
+
+    x86: Expand FFI_GO_CLOSURE
+    
+    If we're going to have to hand-write unwind info for darwin,
+    these macros make the job harder.
+
+commit ae842a515b6e2a486d73ce8f9dbe5fee6c3fd1ff
+Author: Iain Sandoe <iain@codesourcery.com>
+Date:   Tue Nov 25 11:43:40 2014 +0100
+
+    x86: More Darwin unwind fixups
+    
+    EHFrame{N} IIRC is a special cue to ld64 that it should treat the unwind
+    in the object as "special/legacy" .. [these days everything is .cfi_xxxx
+    (except, cctools-as, as you noted)] .. without that much confusion arises
+    with ld64's atom-isation of the eh_frame section.
+    
+    xxxx.eh labels are not needed for darwin ld64 >= 85.2.1 (i.e. darwin9,
+    xcode 3.1.4) to all intents and purposes, that's all that matters now,
+    since I think that anyone trying to build on 10.4/darwin8/xcode2.5 would
+    have to use a later ld64 (from odcctools) for other reasons.
+
+commit 8fa3c9f24b5ef6da2f24a9f071984d033dd9e00c
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Nov 25 09:27:54 2014 +0100
+
+    x86: Reinstate hand-written unwind info for unix64.S
+    
+    One more try to get default Darwin to work.
+
+commit 5f35e0ffcc05a72ce0aacf228dc06d1262754660
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Nov 24 16:26:50 2014 +0100
+
+    x86: Avoid using gas local labels
+    
+    Which are unsupported by Darwin cctools as.
+    Thankfully this doesn't uglify the source too much.
+
+commit ed1ca2777c35fe2f2751de255df3e16f17bdbd8d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Nov 24 13:02:03 2014 +0100
+
+    x86: Remove use of .cfi_escape
+    
+    The unwind info isn't 100% correct at all points during the epilogue,
+    and not annotating is just as incorrect as the annotation.  This works
+    better on systems that do not support DW_OP_call_frame_cfa.
+
+commit 1b12593d7e595c03e5c06377feaeb8ad1b813681
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Nov 24 12:55:43 2014 +0100
+
+    x86: Honor alignment of arguments
+    
+    Darwin aligns long-double to 16, and thus all of the long double
+    tests were failing due to not honoring that.  We ought to be able
+    to devise a test case for GCC using __attribute__((aligned)) that
+    would have failed too.
+
+commit 042b8dafeeee82667e00660fb1edeab72fd9de47
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Nov 24 11:24:02 2014 +0100
+
+    x86: Use .balign not .align
+    
+    The Apple assembler defaults to power of two alignment, rather than
+    byte alignment like everyone else.  Force byte alignment by using
+    the proper directive.
+
+commit 0172bc029cd943dce99f82b9d857c51e746574e5
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Nov 24 10:42:02 2014 +0100
+
+    x86: Disable .org for Darwin
+
+commit 9f112619c187e135132b765adeedef89ee354eb2
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Nov 22 20:02:43 2014 +0100
+
+    x86: Best guess at update for Darwin
+
+commit 7282d3289c6f6e2cc21e2c2b554c33af00ac3474
+Author: Nobuyoshi Nakada <nobu@ruby-lang.org>
+Date:   Mon Dec 22 17:14:40 2014 +0900
+
+    x86: MSVC does not support Complex type
+
+commit 5f8881a5913a9554cbc2b5fed7057627b9bb9ece
+Author: Nobuyoshi Nakada <nobu@ruby-lang.org>
+Date:   Mon Dec 22 17:08:08 2014 +0900
+
+    x86: Fix void pointer arithmetic
+
+commit 58bf7d65d8896f198624c591cc31e6e01a09cc31
+Merge: 75b2199 7ba30b1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Dec 20 10:20:40 2014 -0500
+
+    Merge pull request #158 from rth7680/s390
+    
+    S390
+
+commit 7ba30b19060dfefefeb91970a862e5b215606602
+Author: Richard Henderson <rth@redhat.com>
+Date:   Fri Dec 19 11:38:17 2014 -0500
+
+    s390: Inline and tidy ffi_prep_args
+    
+    As per discussion with Ulrich Weigand, document the restrictions
+    on the code within ffi_call_int as we simultaneously prepare
+    stack frames for ffi_call_SYSV and the target function.
+
+commit f69ec6f35db93163b7f33e43129d274995c8122d
+Author: Richard Henderson <rth@redhat.com>
+Date:   Thu Dec 18 16:21:07 2014 -0500
+
+    s390: Use pc-relative insns in 31-bit mode
+    
+    It's silly to stick to esa/390 features when the compiler won't.
+    Detect when brasl and larl are used by the compiler and then use
+    them in the assembly.
+
+commit 2f530de168e0253ac06e044c832132c496e8788b
+Author: Richard Henderson <rth@redhat.com>
+Date:   Thu Dec 18 16:01:59 2014 -0500
+
+    s390: Reorganize assembly
+    
+    Avoid using ffi_prep_args as a callback; do all the work setting
+    up the frame within ffi_call_int directly.  Save fewer registers
+    in ffi_closure_SYSV.
+
+commit 97512ded052678993ffcfa3aec0035cce1585138
+Author: Richard Henderson <rth@redhat.com>
+Date:   Thu Dec 18 16:01:15 2014 -0500
+
+    s390: Avoid aliasing warnings
+
+commit c860ca9ac0fc7ee44124c5637dda751f55e4fa3f
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Dec 17 13:24:03 2014 -0500
+
+    s390: Kill trailing whitespace
+
+commit 02b7c89967307cea91714fb6e4e53048e1b5396e
+Author: Dominik Vogt <vogt@linux.vnet.ibm.com>
+Date:   Wed Dec 17 13:20:51 2014 -0500
+
+    s390: Go closure support
+
+commit 75b2199f264f42de814528ccf4bfd2ef427665b5
+Merge: 8a3a272 2f65246
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Dec 12 10:13:56 2014 -0500
+
+    Merge pull request #157 from rth7680/x86
+    
+    Two fixes for x86
+
+commit 8a3a2723aaa615cb95ee1c798469d7a3b2d95d31
+Merge: 9ae3bc8 542e004
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Dec 12 10:13:27 2014 -0500
+
+    Merge pull request #156 from rth7680/sparc
+    
+    sparc: Define FFI_TARGET_SPECIFIC_VARIADIC for v9
+
+commit 2f652469684d6d2b3e54705294c7e81cffe1341f
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Dec 11 14:16:00 2014 -0800
+
+    x86: Handle void arguments as if an empty structure
+    
+    Since libffi currently doesn't allow empty structures, libgo
+    currently maps them to ffi_type_void.  Given that we'll abort
+    on this case, handle it gracefully.
+
+commit 097ccfd6a6b94a3c3b5bfc269a7afd1dc4f7a051
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Dec 10 13:25:14 2014 -0800
+
+    x86: Fix some unwind errors
+
+commit 9ae3bc870ee07820b60d368f137ea3b5daca850e
+Author: James Greenhalgh <james.greenhalgh@arm.com>
+Date:   Sat Dec 6 23:58:41 2014 -0500
+
+    Fix for https://github.com/atgreen/libffi/issues/141
+
+commit a5a40960bb6ccb029d2d9d4e18d37f6e0dacb913
+Merge: 9ca4370 590663b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 19 21:13:50 2014 -0500
+
+    Merge pull request #151 from amodra/master
+    
+    powerpc: go closures for linux
+
+commit 590663b30b1f35b6136cf55d8870a2394ed78c21
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Nov 18 12:56:58 2014 +1030
+
+    powerpc: Fix ffi_go_closure_linux64
+    
+    Unlike ffi_closure_LINUX64, this entry point is called normally,
+    so we already have the TOC in R2 and the closure in R11.
+    
+            * powerpc/linux64_closure.S (ffi_closure_LINUX64): Remove a
+            register dependency chain.
+            (ffi_go_closure_linux64): Don't load r11 or r2.
+
+commit fa1040c111b3e423bc9c7e78d9af89470c0fa2fb
+Author: Alan Modra <amodra@gmail.com>
+Date:   Mon Nov 10 09:42:31 2014 +1030
+
+    GO closures for powerpc linux
+    
+    Plus .cfi async unwind info, rearrangement of ffi_call_linux64 and
+    ffi_call_SYSV function params to avoid register copies, tweaks to
+    trampolines.
+    
+            * src/powerpc/ffitarget.h (FFI_GO_CLOSURES): Define.
+            * src/powerpc/ffi.c (ffi_call_int): New function with extra
+            closure param, and args rearranged on ffi_call_linux64 and
+            ffi_call_SYSV calls, extracted from ..
+            (ffi_call): ..here.
+            (ffi_call_go, ffi_prep_go_closure): New functions.
+            * src/powerpc/ffi_linux64.c (ffi_prep_closure_loc_linux64): Make
+            hidden.  Only flush insn part of ELFv2 trampoline.  Don't shuffle
+            ELFv1 trampoline.
+            (ffi_closure_helper_LINUX64): Replace closure param with cif, fun,
+            user_data params.
+            * src/powerpc/ffi_powerpc.h (ffi_go_closure_sysv): Declare.
+            (ffi_go_closure_linux64): Declare.
+            (ffi_call_SYSV, fi_call_LINUX64): Update.
+            (ffi_prep_closure_loc_sysv, ffi_prep_closure_loc_linux64): Declare.
+            (ffi_closure_helper_SYSV, ffi_closure_helper_LINUX64): Update.
+            * src/powerpc/ffi_sysv.c (ASM_NEEDS_REGISTERS): Increase to 6.
+            (ffi_prep_closure_loc_sysv): Use bcl in trampoline, put data words
+            last, flush just the insn part.
+            (ffi_closure_helper_SYSV): Replace closure param with cif, fun and
+            user_data params.
+            * src/powerpc/linux64.S (ffi_call_LINUX64): Replace hand-written
+            .eh_frame with .cfi directives.  Adjust for changed param order.
+            Pass extra "closure" param to user function in static chain.  Add
+            .cfi directives to describe epilogue.  Don't provide traceback
+            table for ELFv2 or _CALL_LINUX.
+            * src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Replace
+            hand-written .eh_frame with .cfi directives.  Adjust for changed
+            ffi_closure_helper_LINUX64 params.  Add .cfi directives to
+            describe epilogue.  Don't provide traceback table for ELFv2 or
+            _CALL_LINUX.
+            (ffi_go_closure_linux64): New function.
+            * src/powerpc/sysv.S: Remove redundant .globl ffi_prep_args_SYSV.
+            (ffi_call_SYSV): Make hidden.  Replace hand-written .eh_frame with
+            .cfi directives.  Adjust for changed params.  Pass extra "closure"
+            param to user function in static chain.  Add .cfi directives to
+            describe epilogue.
+            * src/powerpc/ppc_closure.S (ffi_closure_SYSV): Make hidden.
+            Replace hand-written .eh_frame with .cfi directives.  Adjust for
+            changed ffi_closure_helper_SYSV params.  Add .cfi directives to
+            describe epilogue.  Don't just use nops in the dead __NO_FPRS__
+            epilogues.
+            (ffi_go_closure_sysv): New function.
+
+commit d3d06f4c94847402a08f0e4e2af2e4d726ed3180
+Author: Alan Modra <amodra@gmail.com>
+Date:   Mon Nov 10 13:50:05 2014 +1030
+
+    Fix powerpc breakage from 6e8a4460
+    
+            * src/powerpc/ffitarget.h: #error on unexpected FFI_TYPE_LAST.
+            (FFI_PPC_TYPE_LAST): Define.
+            (FFI_TYPE_UINT128): Define in terms of FFI_PPC_TYPE_LAST.
+            (FFI_SYSV_TYPE_SMALL_STRUCT, FFI_V2_TYPE_FLOAT_HOMOG): Likewise.
+            (FFI_V2_TYPE_DOUBLE_HOMOG, FFI_V2_TYPE_SMALL_STRUCT): Likewise.
+
+commit 9ca43706f9e59ee3a0b288884c90fd51d8926a9b
+Merge: 5211c72 a9ed0c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 19 11:32:08 2014 -0500
+
+    Merge pull request #148 from gpakosz/dlmalloc-preprocessor-fix
+    
+    dlmalloc: change defined(i386) to defined(__i386__)
+
+commit 542e004710e3f1d7c137bba305a16538cd6257d6
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Nov 18 05:07:00 2014 -0800
+
+    sparc: Define FFI_TARGET_SPECIFIC_VARIADIC for v9
+    
+    This is a port of
+    
+      http://gcc.gnu.org/viewcvs?rev=207763&root=gcc&view=rev
+    
+    aka GCC PR libffi/60073, to the rewritten Sparc codebase.
+    Supposedly, we should have seen failures with the existing
+    libffi.call/cls_double_va.c testcase, but I hadn't.
+    Perhaps a gcc newer than 4.6.3 is required to see that...
+
+commit a9ed0c3a0428f5fd4ed2166fa95a608595e11a4d
+Author: Gregory Pakosz <gpakosz@myscript.com>
+Date:   Tue Nov 18 09:37:07 2014 +0100
+
+    dlmalloc: change defined(i386) to defined(__i386__)
+    
+    When compiling with --std==c99, GCC and clang don't define i386 but __i386__
+
+commit 5211c7207ec81dfdfa9acdcd86b49b9ff66b9d91
+Merge: 3316b66 ccdd7bb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 17 09:07:07 2014 -0500
+
+    Merge pull request #147 from rth7680/go/alpha
+    
+    testsuite: Fix alpha static chain register name
+
+commit ccdd7bb8566b2fd1da5c4b5c8eaa2db43a69e720
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Nov 16 12:12:23 2014 +0100
+
+    testsuite: Fix alpha static chain register name
+
+commit 3316b666e3074fe0eebff4fe0458979961b26651
+Merge: b698638 dea49e2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 15 07:31:41 2014 -0500
+
+    Merge pull request #145 from rth7680/master
+    
+    Configure and testsuite cleanups, v2
+
+commit b698638d7601de994410c5c1b2f5c2c648015b7b
+Merge: a353d5b 771fabc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 15 07:29:58 2014 -0500
+
+    Merge pull request #144 from atrosinenko/testsuite-fp-comparison-fix
+    
+    Floating point number comparison fix for testsuite
+
+commit a353d5b16cfbb60f1a42bdec74b0f272701f3ecb
+Merge: 4aa702a e029c70
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 15 07:27:21 2014 -0500
+
+    Merge pull request #143 from adamkaplan/patch-1
+    
+    Update i386 & armv7 minimum iOS version to 7.0
+
+commit dea49e2020b2fc97ba9293200f316f7a7b3ca73b
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Nov 14 13:05:14 2014 +0100
+
+    x86: Fix typo in ffi_prep_go_closure
+    
+    Used the wrong register for THISCALL and FASTCALL.
+
+commit c9f5b6648b0f052bbca8b50615284dd975e9ed29
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Nov 14 13:04:33 2014 +0100
+
+    testsuite: Add trivial tests for Go closures
+
+commit c952a92e20aa6013d8202d0b3fa1d87838c83054
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Nov 14 11:00:14 2014 +0100
+
+    testsuite: Move complex tests to their own subdirectory
+    
+    It seems a bit silly to isolate them by globbing vs "*complex*"
+    when we can just as easily put them in their own subdirectory.
+
+commit f1301a54bb80e6ae23f7687c68f36875dae69134
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Nov 14 10:50:29 2014 +0100
+
+    testsuite: Use feature test rather than enumeration for complex
+
+commit b5ade2fb5d9ba06519484677a5474e5dad48c2e3
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Nov 13 09:06:10 2014 -0800
+
+    testsuite: Detect clang
+    
+    Clang doesn't like the -Wno-psabi argument that we want to pass to GCC.
+    Since clang is detected as GCC via __GNUC__, use ax_cv_c_compiler_vendor.
+
+commit 5d69d57a053c5049df29242def492159e1fadbae
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Nov 13 13:50:39 2014 +0100
+
+    configure: Move target source selection into configure.host
+    
+    This eliminates the AM_CONDITIONAL ugliness, which eliminates
+    just a bit of extra boilerplate for a new target.
+    
+    At the same time, properly categorize the EXTRA_DIST files
+    into SOURCES and HEADERS, for the generation of ctags.
+
+commit 771fabc6d5379e64e5ab9e5f1ca6eb5960617432
+Author: Anatoly Trosinenko <anatoly.trosinenko@gmail.com>
+Date:   Fri Nov 14 14:21:35 2014 +0300
+
+    Take a float absolute value using fabs() instead of abs().
+    
+    Replace integer abs() by floating point fabs() in the approximate
+    equality check for float values.
+
+commit 9622ede2e24067a09380c63da8d5007ec1f03dc4
+Author: Anatoly Trosinenko <anatoly.trosinenko@gmail.com>
+Date:   Fri Nov 14 13:18:04 2014 +0300
+
+    Fix floating point number comparisons in testsuite/libffi.call/float[123].c.
+    
+    Rewrite the checks for approximate equality of floating point return
+    values to be in the form "fabs(a - b) < EPS" instead of just
+    "a - b < EPS".
+
+commit e029c70fa7da7a489157b2a2a88349aaffb051de
+Author: Adam <adkapx@gmail.com>
+Date:   Thu Nov 13 15:08:16 2014 -0500
+
+    Update i386 & armv7 minimum iOS version to 7.0
+    
+    iOS 5 (and any below 7.1) is deprecated. Apple doesn't distribute the supporting libraries for this platform anymore as of Xcode 6, so it causes a linker error.
+
+commit 57f52484573613e2def21171184f50bd72209cac
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Nov 13 12:42:54 2014 +0100
+
+    configure: Split out configure.host
+    
+    Split out the host case statement to a separate file, so that
+    we don't have to regenerate configure.in for changes therein.
+
+commit f8632815a6515a6709802ad23909585664ba1b9d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Nov 13 12:32:35 2014 +0100
+
+    powerpc: Delete patch output
+    
+    Clearly added by mistake.
+
+commit 4aa702a0e0ffc9b8a672af380103f607d339a822
+Merge: 20562ac 8d5debc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 12 08:08:57 2014 -0500
+
+    Merge branch 'rth7680-go-closure'
+
+commit 8d5debc7904aa5c4f1fbf5d5b26450ec5a5b43c6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 12 08:04:51 2014 -0500
+
+    Update in preparation for next release
+
+commit 56735e05fed77a3920a8cac262666c9eb0e75b66
+Merge: 20562ac 0e303c0
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 12 07:11:53 2014 -0500
+
+    Merge branch 'go-closure' of https://github.com/rth7680/libffi into rth7680-go-closure
+    
+    Conflicts:
+            src/aarch64/ffi.c
+
+commit 20562ac0427c3578250d04c6e34fb0127d4551cf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 12 07:00:59 2014 -0500
+
+    Fix for AArch64. Release as 3.2.1.
+
+commit 0e303c065779afb42cfdb2ea20c0e1a557dc16f0
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 12 03:58:58 2014 -0800
+
+    x86: Work around clang bugs
+    
+    http://llvm.org/bugs/show_bug.cgi?21500
+    http://llvm.org/bugs/show_bug.cgi?21501
+    http://llvm.org/bugs/show_bug.cgi?21515
+
+commit 6eec410f1512d0584276db5f4b83711330e830d7
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Oct 26 15:29:04 2014 -0700
+
+    sparc: Re-add abi compliant structure support
+    
+    The original code, removed in the "rewrite" patch, was incorrect for
+    large structures, and required dynamic allocation of a trampoline on
+    every ffi_call.
+    
+    Instead, allocate a 4k entry table of all possible structure returns.
+    The table is 80k, but is read-only and dynamically paged, which ought
+    to be better than allocating the trampoline.
+    
+    This is difficult to test with gcc.  One can only use -O0 at present.
+    See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63668.
+
+commit 92022496ef7a9439f48a2ef11e460c300ac863d7
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Oct 26 14:48:28 2014 -0700
+
+    sparc: Add support for Go closures
+
+commit ad89c2d9e93d5a713ae4113567b4ca6c4fbbf17c
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sun Oct 26 13:16:03 2014 -0700
+
+    sparc: Add support for complex types
+
+commit 20da5b41324de524ea3ee1f84f402828b7c332dc
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Oct 25 16:24:41 2014 -0700
+
+    sparc: Handle more cases of structure return directly
+
+commit 0686c2e71c8e094cf003f199e3f578bcdede43ba
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Oct 25 14:52:45 2014 -0700
+
+    sparc: Preprocess float point struct return
+    
+    We can eliminate recursion and speed structure return
+    by flattening a nested structure tree into a bitmask.
+
+commit 2b27890ba77db6a23d37fc70897109e4b2803c2d
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 24 16:10:48 2014 -0700
+
+    sparc: Rewrite everything
+    
+    It's impossible to call between v8 and v9 ABIs, because of the stack bias
+    in the v9 ABI.  So let's not pretend it's just not implemented yet.  Split
+    the v9 code out to a separate file.
+    
+    The register windows prevent ffi_call from setting up the entire stack
+    frame the assembly, but we needn't make an indirect call back to prep_args.
+
+commit 5d7b54450582f31d0d5d3ecca7f330b70446f195
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 24 11:45:53 2014 -0700
+
+    sparc: Tidy up symbols
+    
+    Assembly to use local labels, .type annotation, hidden annotation.
+    I do retain the _prefix for the symbols, but given that it wasn't
+    done consistently across all symbols, I doubt it's actually needed.
+
+commit fd4f7cc0cabae66a91e40f8645791740b9416bc1
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 24 11:11:53 2014 -0700
+
+    sparc: Eliminate long double ifdefs
+
+commit ab83cbb90b280195e636976098d3674f5ffc1d0a
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Oct 29 14:38:42 2014 -0400
+
+    arm: Add support for Go closures
+
+commit 6fa617dabc3d99e19d47ac9bc4127c56e3163008
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Oct 21 11:27:11 2014 -0400
+
+    arm: Add argument space for the hidden struct return pointer
+    
+    This should have been failing all along, but it's only
+    exposed by the complex_int test case.
+
+commit a529bec27b64ab846ab2643ecbeb22e01f35c7dc
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Oct 21 11:26:59 2014 -0400
+
+    arm: Add support for complex types
+
+commit 5e88ebe62717b8e1e2f8d96c10f78a7134caa765
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Oct 20 15:10:43 2014 -0400
+
+    arm: Remove internal FFI_TYPE constants
+    
+    These have been replaced by the contents of internal.h.
+
+commit a4b785ea695e929b91d64e1e8b514411ae8bafe8
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 02:07:32 2014 -0400
+
+    arm: Rewrite ffi_closure
+    
+    Move the push of the argument registers into ffi_closure_SYSV,
+    reducing the size of the trampoline.
+
+commit e7f15f60e86ad8931b2c4a516945d0b76b4bda20
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 01:27:16 2014 -0400
+
+    arm: Rewrite ffi_call
+    
+    Use the trick to allocate the stack frame for ffi_call_SYSV
+    within ffi_call itself.
+
+commit a74a3aaddbcc730d9aa0a4787f136c9cc19b82b3
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 01:21:22 2014 -0400
+
+    arm: Rewrite vfp_type_p
+    
+    Do not modify the ffi_type.  Rearrange the tests so that we
+    quickly eliminate structures that cannot match.  Return an
+    encoded value of element count and base type.
+
+commit 0d39b4bb692b1a8e4f3354badcd9e123f8276bd4
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 01:02:52 2014 -0400
+
+    arm: Deref ffi_put_arg arguments
+
+commit 57b24fb3f5471262ce57e1a912774d6e7de5ada7
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 00:53:21 2014 -0400
+
+    arm: Deref ffi_align argument
+
+commit c129bea82a25c9b0f3af3bf48c35c55257092f87
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Oct 15 17:28:53 2014 -0400
+
+    arm: Reindent arm/ffi.c
+
+commit 9761b7bb70b4c47dc11dc74830964a0b3b3176d3
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 21:26:52 2014 -0700
+
+    alpha: Add support for Go closures
+
+commit f41bec3b576aa5ff8915b1188446c2dc086dfe64
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 20:46:48 2014 -0700
+
+    alpha: Add support for complex types
+
+commit 5f917371afcb4d3363fd33b547844c47264f6d4e
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 13:47:26 2014 -0700
+
+    alpha: Clean up conversion of float values
+    
+    Don't use "real" conversion to double, lest we raise
+    exceptions when passing signalling nans.
+
+commit 32a26b75ba92665fa093b539318e83d916e3effb
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 12:33:53 2014 -0700
+
+    alpha: Reorganize cif flags
+    
+    Unties the backend from changes to FFI_TYPE_* constants, and allows
+    compilation to succeed after the addition of FFI_TYPE_COMPLEX.
+    
+    Delete the hand-written unwind info.
+
+commit c6352b664c31835b9527d747f8a29b4754cabb0e
+Author: Richard Henderson <rth@redhat.com>
+Date:   Thu Oct 23 00:26:14 2014 -0400
+
+    aarch64: Add support for Go closures
+
+commit 0e41c73b092064e986d484270a13046479d6bda3
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 23:48:12 2014 -0400
+
+    aarch64: Move x8 out of call_context
+    
+    Reduces stack size.  It was only used by the closure, and there
+    are available argument registers.
+
+commit a992f8789b5202ca180e67b16b47ee834160665c
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 22:58:09 2014 -0400
+
+    aarch64: Add support for complex types
+
+commit 658b2b56001e293848ea22b70068bd7f8daa7205
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 22:36:07 2014 -0400
+
+    aarch64: Remove aarch64_flags
+    
+    This field was useless from the start, since the normal flags
+    field is available for backend use.
+
+commit 4a3cbcaa4f1d3834e0b74c9a841c3f51c5e0454c
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 22:32:13 2014 -0400
+
+    aarch64: Unify scalar fp and hfa handling
+    
+    Since an HFA of a single element is exactly the same as scalar,
+    this tidies things up a bit.
+
+commit 12cf89ee04dc01650f71bc38ce414c953c83199a
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 21:53:30 2014 -0400
+
+    aarch64: Move return value handling into ffi_closure_SYSV
+    
+    As with the change to ffi_call_SYSV, this avoids copying data
+    into a temporary buffer.
+
+commit 4fe1aea1211aaf228c2db867b8ac6f1620de72d4
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 17:06:19 2014 -0400
+
+    aarch64: Move return value handling into ffi_call_SYSV
+    
+    This lets us pass return data directly to the caller of ffi_call
+    in most cases, rather than storing it into temporary storage first.
+
+commit 325471ea6a7bf954943485458a1bd391635dfaa8
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 13:58:59 2014 -0400
+
+    aarch64: Merge prep_args with ffi_call
+    
+    Use the trick to allocate the stack frame for ffi_call_SYSV
+    within ffi_call itself.
+
+commit 8c8161cb623585d5d0c783b9d494b9b74ada6ced
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 12:52:07 2014 -0400
+
+    aarch64: Tidy up abi manipulation
+    
+    Avoid false abstraction, like get_x_addr.  Avoid recomputing data
+    about the type being manipulated.  Use NEON insns for HFA manipulation.
+    
+    Note that some of the inline assembly will go away in a subsequent patch.
+
+commit b55e03665ddf2423df9baee0d3172892ba781c26
+Author: Richard Henderson <rth@redhat.com>
+Date:   Wed Oct 22 12:33:59 2014 -0400
+
+    aarch64: Treat void return as not passed in registers
+    
+    This lets us do less post-processing when there's no return value.
+
+commit 2e32f9bf6ffa6782b70fafe96bdf21c5aa44f534
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 22:49:05 2014 -0400
+
+    aarch64: Use correct return registers
+    
+    There are fewer return registers than argument registers.
+
+commit 95a04af134431ccc8230aca1641541a5e8fcbdc9
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 22:41:07 2014 -0400
+
+    aarch64: Reduce the size of register_context
+    
+    We don't need to store 32 general and vector registers.
+    Only 8 of each are used for parameter passing.
+
+commit 77c4cddca6aeb6e545e21f235e29323e05f5a3a3
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 13:30:40 2014 -0400
+
+    aarch64: Simplify AARCH64_STACK_ALIGN
+    
+    The iOS abi doesn't require padding between arguments, but
+    that's not what AARCH64_STACK_ALIGN meant.  The hardware will
+    in fact trap if the SP register is not 16 byte aligned.
+
+commit b5f147d84761dc673ffe01d6af82bcde4ea47928
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 13:27:57 2014 -0400
+
+    aarch64: Always distinguish LONGDOUBLE
+    
+    Avoid if-deffery by forcing FFI_TYPE_LONGDOUBLE different
+    from FFI_TYPE_DOUBLE.  This will simply be unused on hosts
+    that define them identically.
+
+commit 38b54b9c180af13a3371e70a151a1a97e105b03f
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 13:17:39 2014 -0400
+
+    aarch64: Improve is_hfa
+    
+    The set of functions get_homogeneous_type, element_count, and is_hfa
+    are all intertwined and recompute data.  Return a compound quantity
+    from is_hfa that contains all the data and avoids the recomputation.
+
+commit 18b74ce54afab45fcf2a7d4eb86bb2ce9db8cec8
+Author: Richard Henderson <rth@redhat.com>
+Date:   Tue Oct 21 13:00:34 2014 -0400
+
+    aarch64: Fix non-apple compilation
+
+commit 2650f47fe8388f3281ec00e2d1e3bc777c1d3544
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Nov 6 10:57:04 2014 -0800
+
+    x86: Use win32 name mangling for fastcall functions
+
+commit f8c64e2486c956109bf5255a0c0a85f24cc86c72
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 5 17:04:29 2014 +0100
+
+    x86: Add support for Go closures
+
+commit 198f469e91076f84ab6ac38055ad12a5490101cd
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 5 16:34:41 2014 +0100
+
+    x86: Add support for Complex
+
+commit b21ec1ce783f09335c0e6c6f96ccc7e89da5a1b4
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 5 10:15:25 2014 +0100
+
+    x86: Rewrite closures
+    
+    Move everything into sysv.S, removing win32.S and freebsd.S.
+    Handle all abis with a single ffi_closure_inner function.
+    Move complexity of the raw THISCALL trampoline into assembly
+    instead of the trampoline itself.
+    Only push the context for the REGISTER abi; let the rest
+    receive it in a register.
+
+commit b9ac94f3af9b1ca1853850911b7d3bc058296c71
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Sat Nov 1 15:10:34 2014 -0700
+
+    x86: Rewrite ffi_call
+    
+    Decouple the assembly from FFI_TYPE_*.  Merge prep_args with ffi_call,
+    passing the frame and the stack to the assembly.
+    
+    Note that this patch isn't really standalone, as this breaks closures.
+
+commit 159d3788eb52b89ed6bc5dd6ebb85c02cd150232
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 31 12:07:02 2014 -0700
+
+    x86: Convert to gas generated unwind info
+
+commit e7b0056d60f29675072454a575eed98053fc63d6
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Oct 30 13:57:39 2014 -0700
+
+    x86: Force FFI_TYPE_LONGDOUBLE different from FFI_TYPE_DOUBLE
+    
+    There are few abis that set double = long double.  Eliminate the
+    conditional compilation and let this code simply be unused there.
+
+commit 4b2fad8fd583f1d9c36db0044c4d46316207aa49
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Oct 30 12:41:31 2014 -0700
+
+    x86: Remove some conditional compilation
+    
+    Removal of ifdefs made possible to due to ffi_abi unification.
+
+commit ef76205647bca77796882d31f6ab5e889f461f07
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Oct 30 12:13:31 2014 -0700
+
+    x86: Tidy ffi_abi
+    
+    The x86_64 unix port only handles one ABI; don't define all of the
+    other symbols.  The UNIX64 symbol retains the same value.
+    
+    The i386 ports ought to have the same symbols, even if we can't yet
+    unify the values without incrementing the libffi soname.
+
+commit 7cf841324f3d15c46833e0f2ddf8a98c4b24711e
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Nov 7 06:56:55 2014 -0800
+
+    testsuite: Add two dg-do run markers
+    
+    Caught by clang warning about unused -L parameter.
+
+commit fc501750f41e2ee7f4268f490f590ce97a25a818
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Wed Nov 5 16:33:44 2014 +0100
+
+    testsuite: Fix return_complex2 vs excessive precision
+    
+    Use the previously computed rc2 to validate, rather than
+    recomputing a floating point result with excess precision.
+
+commit 610c90bf7131de70318dc981a529a63ae36981b8
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Oct 28 11:21:50 2014 -0700
+
+    x86_64: Add support for complex types
+
+commit 32c56831636a489a1c5084e42ffbd935902b1033
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Tue Oct 28 11:17:35 2014 -0700
+
+    x86_64: Decouple return types from FFI_TYPE constants
+    
+    We can better support structure returns, and as prep for
+    complex types.
+
+commit 2e9dc1655600eb8928ebab13fa246187b6205109
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Mon Oct 27 13:41:39 2014 -0700
+
+    x86_64: Fixups for x32
+
+commit ebd82769de5fc909ec9678aafca674ece394d173
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Oct 23 23:57:06 2014 -0700
+
+    win64: Remove support from ffi.c
+
+commit 99db4d42acc7ee6d2ad206848be38083d7b5e094
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Thu Oct 23 14:12:18 2014 -0700
+
+    win64: Rewrite
+    
+    It's way too different from the 32-bit ABIs with which it is
+    currently associated. As seen from all of the existing XFAILs.
+
+commit 6b62fb4a26d7363548a92f1a156562cfa648726e
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 11:11:58 2014 -0700
+
+    x86-64: Support go closures
+    
+    Dumps all of the hand-coded unwind info for gas generated.  Move jump
+    table data into .rodata.  Adjust ffi_call_unix64 to load the static
+    chain.  Split out sse portions of ffi_closure_unix64 to
+    ffi_closure_unix64_sse rather than test cif->flags at runtime.
+
+commit 89bbde8b4e802625bdbf830ea14e938beea79835
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 10:55:11 2014 -0700
+
+    Add ffi_cfi.h
+    
+    Have one copy of the HAVE_AS_CFI_PSEUDO_OP code
+    to share between all backends.
+
+commit e951d64c085267a30036907d02f94a70dee4c9d9
+Author: Richard Henderson <rth@twiddle.net>
+Date:   Fri Oct 17 10:12:25 2014 -0700
+
+    Add entry points for interacting with Go
+    
+    A "ffi_go_closure" is intended to be compatible with the
+    function descriptors used by Go, and ffi_call_go sets up
+    the static chain parameter for calling a Go function.
+    
+    The entry points are disabled when a backend has not been
+    updated, much like we do for "normal" closures.
+
+commit a0bdc5250cd36f1d2578358e33299fd2408091ac
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 11 09:43:01 2014 -0500
+
+    Fix typo
+
+commit 67c0c0705318d2e567fd48e680d63dca3619a235
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 11 07:30:49 2014 -0500
+
+    Final 3.2 changes
+
+commit ee826b933bbdeb68ee81876ffb508c3908eed371
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 11 07:29:26 2014 -0500
+
+    Final 3.2 changes
+
+commit c81a705d53be97899d314953987936213244b1ba
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 4 13:29:58 2014 -0500
+
+    Mention OpenRISC
+
+commit 6a17ad540d7ddb7a812687f4380bd0ef2d2865bb
+Merge: 990eb9d 0f316ab
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 28 00:54:00 2014 -0400
+
+    Merge pull request #134 from s-macke/openrisc
+    
+    Add OpenRISC support
+
+commit 990eb9d4c244324771a7d878a168bb8eba1850c0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Sep 28 00:50:29 2014 -0400
+
+    Only run the complex type tests on supported platforms.
+
+commit 0f316ab7c11b8315a838a6ae4645d36ff2c46f4c
+Author: Sebastian Macke <sebastian@macke.de>
+Date:   Sat Sep 27 00:19:15 2014 +0000
+
+    Add OpenRISC support
+    
+    This patch adds support for the OpenRISC architecture.
+    (http://opencores.org/or1k/Main_Page)
+    
+    This patch has been tested under Linux with QEMU-user emulation support.
+    - 32 Bit
+    - big endian
+    - delayed instructions
+    This is the only available configuration under Linux.
+    
+    The description of the ABI can be found on the official website.
+    
+    Is passes the testsuite except of the unwindtest_ffi_call.cc
+    testcase, which seems to be a problem of gcc and not libffi.
+    Some testcases of the gcc testsuite still fail.
+    
+    Signed-off-by: Sebastian Macke <sebastian@macke.de>
+
+commit 6695983d2f0857caab220862de12f3f94a55bcf6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 20 07:44:37 2014 -0400
+
+    Add complex type support. Mostly broken right now
+
+commit fbbf48fbdf9b1491af0aefc00523a1b5d8bb9349
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 20 07:43:51 2014 -0400
+
+    Compile tests with -Wno-psabi when using GCC
+
+commit ae8d2554c5f192be54dadc9f99a1449b4df1b222
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 20 07:08:37 2014 -0400
+
+    Update version to 3.2
+
+commit b2ca59d39d2192021316561ea9dda3d35d8d35d9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 20 07:08:05 2014 -0400
+
+    More README updates for 3.2
+
+commit f920a01ad8eafc79daaf331499ef9a97696c46a7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Sep 20 06:54:06 2014 -0400
+
+    Update release notes.
+
+commit bfcbf329c5e4bebdb32134d4e53260e17e4e66cc
+Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
+Date:   Sat Sep 20 06:51:45 2014 -0400
+
+    2014-05-11  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+    
+            Fix current cygwin-64 build problems.
+            * src/java_raw_api.c: Remove if !defined(FFI_NO_RAW_API).
+            * src/x86/ffi.c: Add if defined(__CYGWIN__).
+            * src/x86/win64.S (ffi_closure_win64, ffi_call_win64): Added
+            handling for FFI_TYPE_UINT64, FFI_TYPE_POINTER and FFI_TYPE_INT.
+            Added SEH information.  Fixed formatting.
+
+commit 32cb2ce81db9457c6bd43a2587d7fa23a2edb9b1
+Author: Jakub Jelinek <jakub@redhat.com>
+Date:   Sat Sep 20 06:39:55 2014 -0400
+
+    2014-09-10  Jakub Jelinek  <jakub@redhat.com>
+    
+            * src/powerpc/linux64.S: Emit .note.GNU-stack even when
+            POWERPC64 is not defined.
+            * src/powerpc/linux64_closure.S: Likewise.  Also test _CALL_ELF == 2.
+
+commit aaf3101ba81af8f488502881648e3f687721671e
+Author: Matthias Klose <doko@ubuntu.com>
+Date:   Sat Sep 20 06:37:04 2014 -0400
+
+    Fix -Werror=declaration-after-statement problem
+
+commit 6e8a4460833594d5af1b4539178025da0077df19
+Author: Dominik Vogt <vogt@linux.vnet.ibm.com>
+Date:   Sat Sep 20 06:21:19 2014 -0400
+
+    2014-07-22  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+    
+            * src/types.c (FFI_TYPEDEF, FFI_NONCONST_TYPEDEF): Merge the macros by
+            adding another argument that controls whether the result is const or not
+            (FFI_LDBL_CONST): Temporary macro to reduce ifdef confusion
+            * src/prep_cif.c (ffi_prep_cif_core): Replace list of systems with new
+            macro FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+            * src/pa/ffitarget.h (FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION):
+            Define.
+            * src/s390/ffitarget.h (FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION):
+            Define.
+            * src/x86/ffitarget.h (FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION):
+            Define.
+    
+    2014-07-22  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+    
+            * doc/libffi.texi (Primitive Types): Document ffi_type_complex_float,
+            ffi_type_complex_double and ffi_type_complex_longdouble
+            (Complex Types): New subsection.
+            (Complex Type Example): Ditto.
+            * testsuite/libffi.call/cls_align_complex_double.c: New
+            FFI_TYPE_COMPLEX test.
+            * testsuite/libffi.call/cls_align_complex_float.c: Ditto.
+            * testsuite/libffi.call/cls_align_complex_longdouble.c: Ditto.
+            * testsuite/libffi.call/cls_complex_double.c: Ditto.
+            * testsuite/libffi.call/cls_complex_float.c: Ditto.
+            * testsuite/libffi.call/cls_complex_longdouble.c: Ditto.
+            * testsuite/libffi.call/cls_complex_struct_double.c: Ditto.
+            * testsuite/libffi.call/cls_complex_struct_float.c: Ditto.
+            * testsuite/libffi.call/cls_complex_struct_longdouble.c: Ditto.
+            * testsuite/libffi.call/cls_complex_va_double.c: Ditto.
+            * testsuite/libffi.call/cls_complex_va_float.c: Ditto.
+            * testsuite/libffi.call/cls_complex_va_longdouble.c: Ditto.
+            * testsuite/libffi.call/complex_double.c: Ditto.
+            * testsuite/libffi.call/complex_defs_double.c: Ditto.
+            * testsuite/libffi.call/complex_float.c: Ditto.
+            * testsuite/libffi.call/complex_defs_float.c: Ditto.
+            * testsuite/libffi.call/complex_longdouble.c: Ditto.
+            * testsuite/libffi.call/complex_defs_longdouble.c: Ditto.
+            * testsuite/libffi.call/complex_int.c: Ditto.
+            * testsuite/libffi.call/many_complex_double.c: Ditto.
+            * testsuite/libffi.call/many_complex_float.c: Ditto.
+            * testsuite/libffi.call/many_complex_longdouble.c: Ditto.
+            * testsuite/libffi.call/return_complex1_double.c: Ditto.
+            * testsuite/libffi.call/return_complex1_float.c: Ditto.
+            * testsuite/libffi.call/return_complex1_longdouble.c: Ditto.
+            * testsuite/libffi.call/return_complex2_double.c: Ditto.
+            * testsuite/libffi.call/return_complex2_float.c: Ditto.
+            * testsuite/libffi.call/return_complex2_longdouble.c: Ditto.
+            * testsuite/libffi.call/return_complex_double.c: Ditto.
+            * testsuite/libffi.call/return_complex_float.c: Ditto.
+            * testsuite/libffi.call/return_complex_longdouble.c: Ditto.
+            * src/raw_api.c (ffi_raw_to_ptrarray): Handle FFI_TYPE_COMPLEX
+            (ffi_ptrarray_to_raw): Ditto.
+            * src/prep_cif.c (ffi_prep_cif_core): Abort if FFI_TYPE_COMPLEX is not
+            implemented in libffi for the target.
+            * src/java_raw_api.c (ffi_java_raw_size): FFI_TYPE_COMPLEX not supported
+            yet (abort).
+            (ffi_java_raw_to_ptrarray): Ditto.
+            (ffi_java_rvalue_to_raw): Ditto.
+            (ffi_java_raw_to_rvalue):  Ditto.
+            * src/debug.c (ffi_type_test): Add debug tests for complex types.
+            * include/ffi.h.in (FFI_TYPE_COMPLEX): Add new FFI_TYPE_COMPLEX.
+            (FFI_TYPE_LAST): Bump.
+            (ffi_type_complex_float): Add new ffi_type_....
+            (ffi_type_complex_double): Ditto.
+            (ffi_type_complex_longdouble): Ditto.
+    
+    2014-07-22  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+    
+            * src/s390/ffitarget.h (FFI_TARGET_HAS_COMPLEX_TYPE): Define to provide
+            FFI_TYPE_COMPLEX support.
+            * src/s390/ffi.c (ffi_check_struct_type): Implement FFI_TYPE_COMPLEX
+            (ffi_prep_args): Ditto.
+            (ffi_prep_cif_machdep): Ditto.
+            (ffi_closure_helper_SYSV): Ditto.
+
+commit 4c5c4088aa3e4d8103ff9ca441937da64fdd849a
+Merge: 862f53d 5d6340e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 18 19:10:54 2014 -0400
+
+    Merge pull request #132 from nielsAD/master
+    
+    Pascal and Register calling convention support on x86
+
+commit 862f53de04ff898a128be7eec592bae60930d6df
+Merge: 5df3840 aebf2c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 18 19:06:08 2014 -0400
+
+    Merge pull request #130 from frida/fix/darwin-aarch64-float-alignment
+    
+    Fix alignment of FFI_TYPE_FLOAT for Apple's ARM64 ABI
+
+commit 5df384077f3633ec8cf2e08f9199e5a44994dbad
+Merge: 7b7a528 0f4e09d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 18 19:05:35 2014 -0400
+
+    Merge pull request #129 from frida/fix/darwin-aarch64-cif-prep
+    
+    Fix non-variadic CIF initialization for Apple/ARM64
+
+commit 7b7a5284de7a99edfcee5ac362dbf76251698e1e
+Merge: 4cd5e84 6172a99
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 18 18:28:05 2014 -0400
+
+    Merge pull request #124 from knuesel/master
+    
+    Fix issue with builddir when calling configure with absolute path
+
+commit 4cd5e840122e22636b5838943372c4ed74618e35
+Merge: 1cee07b 08853e3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Sep 18 18:27:15 2014 -0400
+
+    Merge pull request #123 from ehsan/clang-cl
+    
+    Add support for building with clang-cl
+
+commit 5d6340ef2cf81432da79ac8b0b1b1218ab391438
+Author: nielsAD <niels.a.d@gmail.com>
+Date:   Mon Aug 25 17:29:44 2014 +0200
+
+    Determine whether register arguments (THISCALL/FASTCALL/REGISTER) are really passed via register to closures. Use stack if not.
+
+commit 6e346487b879b4b056a847268e381ae6efec4c21
+Author: nielsAD <niels.a.d@gmail.com>
+Date:   Mon Aug 25 12:23:29 2014 +0200
+
+    Fixed THISCALL/FASTCALL closures and added basic support for PASCAL/REGISTER closures.
+
+commit 098dca6b31e42dd0256ed7d966729e31961f1461
+Author: nielsAD <niels.a.d@gmail.com>
+Date:   Sat Aug 23 00:18:47 2014 +0200
+
+    Support for calling functions with PASCAL and REGISTER calling conventions on x86 Windows/Linux.
+    Also changed indentation to be more consistent throughout the (adjusted) files.
+
+commit 08853e32fb6b750cda664ee6d3290d340429dd4d
+Author: Ehsan Akhgari <ehsan@mozilla.com>
+Date:   Thu Jul 31 20:33:33 2014 -0400
+
+    Enable forcing the usage of the static CRT in libffi's msvc wrapper
+    
+    This is required for AddressSanitizer builds with clang-cl.
+
+commit aebf2c3023b5ff056a708dc34169f7b549b2ec4f
+Author: Ole André Vadla Ravnås <ole.andre.ravnas@tillitech.com>
+Date:   Fri Jul 25 21:40:50 2014 +0200
+
+    Fix alignment of FFI_TYPE_FLOAT for Apple's ARM64 ABI
+
+commit 0f4e09d27dc175ce3e95d070b794351663c7220e
+Author: Ole André Vadla Ravnås <ole.andre.ravnas@tillitech.com>
+Date:   Sat Jul 26 00:11:06 2014 +0200
+
+    Fix non-variadic CIF initialization for Apple/ARM64
+    
+    Turns out `aarch64_nfixedargs` wasn't initialized in the non-variadic
+    case, resulting in undefined behavior when allocating arguments.
+
+commit 6172a995e14bdbc6150aa02a361f710626a5c293
+Author: Jeremie Knuesel <jeremie.knusel@sensefly.com>
+Date:   Wed Jun 25 12:28:17 2014 +0200
+
+    Fix issue with builddir when calling configure with absolute path
+
+commit fb25cd08ed5a87640b02f0feeb10a09b37cfddbe
+Author: Ehsan Akhgari <ehsan@mozilla.com>
+Date:   Wed Jun 11 12:07:24 2014 -0400
+
+    Add support for building with clang-cl
+
+commit 1cee07be4712411baa5eb8af22698bc8443a6d6e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jun 12 06:30:59 2014 -0400
+
+    Remove compiler warning
+
+commit ad0d1d239afc7ad09203847793dcc020856d1035
+Author: Samuli Suominen <ssuominen@gentoo.org>
+Date:   Thu Jun 12 06:30:21 2014 -0400
+
+    Fix paths in libffi.pc.in
+
+commit df31a85103b0cc232bbc340d7e782a3853c7fad5
+Merge: 69289c1 360aa8c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jun 6 08:24:35 2014 -0400
+
+    Merge pull request #122 from rvandermeulen/1014976
+    
+    Don't make --enable-debug imply using the debug CRT in libffi
+
+commit 360aa8ca1ead2fdaefa7b1c6f01ad001d8abae7e
+Author: Mike Hommey <mh+mozilla@glandium.org>
+Date:   Mon Jun 2 09:21:10 2014 -0400
+
+    Bug 1014976 - Don't make --enable-debug imply using the debug CRT in libffi.
+
+commit 69289c10b0acb4b52c8b5df4cf738193c618db40
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 31 08:54:08 2014 -0400
+
+    Prepare for libffi 3.1.1
+
+commit 978c9540154d320525488db1b7049277122f736d
+Author: Samuli Suominen <ssuominen@gentoo.org>
+Date:   Sat May 31 08:53:10 2014 -0400
+
+    Add missing GNU stack markings in win32.S
+
+commit cbc5a3c0200aa6c2cf8d6798d69a21501557c83f
+Author: Ryan Hill <rhill@gentoo.org>
+Date:   Sat May 31 08:26:34 2014 -0400
+
+    Fix typo
+
+commit 9d8e3018ac3d0d338373bff7eefa9f006746f4ec
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat May 24 23:28:42 2014 -0400
+
+    Update current version.
+
+commit 18d56cca5a4ee95ad48b129100adf26231518ed0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 19 18:05:33 2014 -0400
+
+    Increment libtool version number
+
+commit 629f1029c47e522e4331988f02f32c203a070e28
+Merge: 0403f33 c1166d4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 19 18:04:28 2014 -0400
+
+    Merge pull request #120 from l0kod/tmpfile
+    
+    Create temporary file with O_TMPFILE and O_CLOEXEC when available
+
+commit c1166d4f653bf6d17ad8c265cf5e8da84e2e76dc
+Author: Mickaël Salaün <mic@digikod.net>
+Date:   Mon May 12 19:44:08 2014 +0200
+
+    closures: Check for mkostemp(3)
+
+commit 8daeed9570af72eb135c8ded460d2888f05b2e68
+Author: Mickaël Salaün <mic@digikod.net>
+Date:   Sun May 11 22:54:58 2014 +0200
+
+    closures: Create temporary file with O_TMPFILE and O_CLOEXEC when available
+    
+    The open_temp_exec_file_dir function can create a temporary file without
+    file system accessible link. If the O_TMPFILE flag is not defined (old
+    Linux kernel or libc) the behavior is unchanged.
+    
+    The open_temp_exec_file_name function now need a new argument "flags"
+    (like O_CLOEXEC) used for temporary file creation.
+    
+    The O_TMPFILE flag allow temporary file creation without race condition.
+    This feature/fix prevent another process to access the (future)
+    executable file from the file system.
+    
+    The O_CLOEXEC flag automatically close the temporary file for any
+    execve. This avoid transmitting (executable) file descriptor to a child
+    process.
+
+commit 0403f332b1f478696c30d3d8a0e2f6eef24aaf88
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 19 09:41:32 2014 -0400
+
+    Update date. Annoucing 3.1 today.
+
+commit 94ac0c168ee7b115409121d88b25a4979446c8da
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon May 19 09:37:21 2014 -0400
+
+    Increment libtool library revision number
+
+commit 57465744b6e1295d7202de5a7734df589518f1c8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 11 10:30:22 2014 -0400
+
+    Update to version 3.1
+
+commit 0c2251a42df5108b6d9ebe5fe1cf83d0bcdf660e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 11 10:22:30 2014 -0400
+
+    Support versions of git older than 1.8.5
+
+commit 70c303cb88e23aaee91c87c56b108c50ab4f3c2f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun May 11 09:56:40 2014 -0400
+
+    Fix testsuite for GCC 4.9.0
+
+commit 52b3457093ed19b2a7c5fcf243c4014c90ce6225
+Author: Magnus Granberg <zorry@gentoo.org>
+Date:   Sun May 11 09:55:28 2014 -0400
+
+    Check /proc/self/status for PaX status.
+
+commit 7ba4c5d72aa440a4b21fb57e999e67c5957761da
+Author: Dominik Vogt <dominik.vogt@gmx.de>
+Date:   Sun May 11 09:52:47 2014 -0400
+
+    Use to get correct dir
+
+commit 31e0d4ecff6dc2a6c75a066ee099b52a43f6ba27
+Merge: 1c0e9a7 99909eb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Apr 23 19:24:47 2014 -0400
+
+    Merge pull request #119 from joshtriplett/fastcall-fastball
+    
+    src/x86/win32.S: Define ffi_closure_FASTCALL in the MASM section, too
+
+commit 99909eb6184b62408d88b6b4e7ab38e84e6d0bf3
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Tue Apr 22 21:17:52 2014 -0700
+
+    src/x86/win32.S: Define ffi_closure_FASTCALL in the MASM section, too
+
+commit 1c0e9a7297ced15413c2d2d5d35f6c650c4b46c9
+Merge: 93a24f2 d369522
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Apr 21 12:41:56 2014 -0400
+
+    Merge pull request #101 from joshtriplett/fastcall-closures
+    
+    Support closures for fastcall
+
+commit d36952273d4fafbda91ecc205fc0824f7cc65e70
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Apr 20 12:03:25 2014 -0700
+
+    Support fastcall closures
+    
+    libffi on 32-bit x86 now supports closures for all supported ABIs.
+    Thus, rewrite the last remaining duplicated-by-ABI test (closure_stdcall
+    and closure_thiscall) to use the generic ABI_NUM/ABI_ATTR mechanism.
+
+commit 93a24f216bcdd1018b976d697179c6d49004015a
+Merge: dd11a04 2349fec
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 12 19:38:07 2014 -0400
+
+    Merge pull request #80 from ueno/devel
+    
+    Fix typo in doc
+
+commit dd11a04061cb49ce1d702545693c24eb1267d648
+Merge: 8fa2812 03ca880
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 12 19:37:21 2014 -0400
+
+    Merge pull request #86 from joshtriplett/testsuite-CC-CXX
+    
+    testsuite ignores CC parameter supplied to configure or make
+
+commit 8fa2812355e685a42abf9a62fbc674d616b2edee
+Merge: 8a58e6b 419503f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 12 19:32:08 2014 -0400
+
+    Merge pull request #116 from frida/fix/darwin-aarch64-variadic
+    
+    Fix handling of variadic calls on Darwin/AArch64
+
+commit 8a58e6b7805b736def197b8baf8e465a2a3f6913
+Merge: 30b77c5 a539f7f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 12 19:30:18 2014 -0400
+
+    Merge pull request #115 from frida/fix/darwin-aarch64-alignment
+    
+    Fix alignment of AArch64 assembler functions
+
+commit 30b77c56f95c63ecd83399aafdbad7b07330f2fd
+Merge: dc33cb3 3e2b84d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 12 19:29:13 2014 -0400
+
+    Merge pull request #117 from frida/fix/windows-regression
+    
+    Fix Windows regression
+
+commit 3e2b84d295531720917bf46afc532fc6d877e3ec
+Author: Ole André Vadla Ravnås <ole.andre.ravnas@tillitech.com>
+Date:   Sat Apr 12 01:04:04 2014 +0200
+
+    Fix Windows regression
+    
+    Introduced by b5fed601948237037513a9b7f967c8fc6c9ff1f6.
+
+commit 419503f409c321fe31ff59d963ef34bb913420d0
+Author: Ole André Vadla Ravnås <ole.andre.ravnas@tillitech.com>
+Date:   Sun Apr 6 20:54:13 2014 +0200
+
+    Fix handling of variadic calls on Darwin/AArch64
+
+commit a539f7ffd6783aa11353d13265520e453c565fb4
+Author: Ole André Vadla Ravnås <ole.andre.ravnas@tillitech.com>
+Date:   Sun Apr 6 20:53:02 2014 +0200
+
+    Fix alignment of AArch64 assembler functions
+
+commit dc33cb3c998da521a960385c1269c3aef552f69f
+Merge: c860a99 b5fed60
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Apr 5 23:41:22 2014 -0400
+
+    Merge pull request #114 from joshtriplett/bounce-on-a-tiny-trampoline
+    
+    Fix ABI on 32-bit non-Windows x86: go back to trampoline size 10
+
+commit b5fed601948237037513a9b7f967c8fc6c9ff1f6
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Apr 5 17:33:42 2014 -0700
+
+    Fix ABI on 32-bit non-Windows x86: go back to trampoline size 10
+    
+    The trampoline size is part of the ABI, so it cannot change.  Move the
+    logic from the stdcall and thiscall trampolines to the functions they
+    call, to reduce them both to 10 bytes.
+    
+    This drops the previously added support for raw THISCALL closures on
+    non-Windows.  (Non-raw THISCALL closures still work.)
+
+commit 03ca880081b22efab09ba72268270f83017d3d7b
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Thu Mar 27 08:44:34 2014 -0700
+
+    README: Note the testsuite changes to respect $CC and $CXX
+
+commit d74df8c5d8c6722ecb908da98c86cc8e2c755b84
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Thu Mar 27 00:44:12 2014 -0700
+
+    README: Update Windows example to set both CC and CXX
+
+commit 7d698125b1f05173f3656a89755a2eb58813b002
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Wed Mar 26 23:17:56 2014 -0700
+
+    Use the proper C++ compiler to run C++ tests
+    
+    Running the C compiler with -shared-libgcc -lstdc++ does not work on
+    non-GCC compilers.
+
+commit fa5e88f170cb37c7b2b9bb015c8c5b854ffd8a3e
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Wed Mar 26 23:53:57 2014 -0700
+
+    .travis.yml: Make the build command more readable by splitting at &&
+    
+    "script" can contain multiple commands to run in sequence.
+
+commit 0c3824702d3d59d37f8c177d646303f546187683
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Wed Mar 26 14:51:32 2014 -0700
+
+    Always set CC_FOR_TARGET for dejagnu, to make the testsuite respect $CC
+    
+    This fixes cross-compilation and compilation with CC="gcc -m32".
+
+commit 9946a92af31b30cb7760150d1f8ca6c11b01aeea
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Wed Mar 26 20:18:58 2014 -0700
+
+    Stop looking for expect and runtest above top_builddir
+    
+    Users wishing to test hand-compiled versions of expect and runtest can
+    easily enough put them in their path or set EXPECT and RUNTEST
+    themselves.
+
+commit acb202325215058639234efb7af1f04c1c8a1f44
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Wed Mar 26 20:18:41 2014 -0700
+
+    Stop setting an empty AM_RUNTESTFLAGS
+
+commit c860a992fef5d7cd7bb0975b1632d17a9fafe007
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 17:02:51 2014 -0400
+
+    Upgrade version to 3.1-rc1
+
+commit 9837073e6203048a162a226798c5d252600219ed
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 16:24:14 2014 -0400
+
+    Update copyright date and clean up README notes.
+
+commit 18d3baa9f597b026675baa1b4e5a5eeef7577a08
+Merge: afee537 f0c8a31
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 16:12:53 2014 -0400
+
+    Merge pull request #108 from joshtriplett/freebsd
+    
+    [3.1 blocker] Fix FreeBSD support
+
+commit afee53738a995e23bd2f89fd0f7b30b380566106
+Merge: 7d24785 b2d610e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 16:12:35 2014 -0400
+
+    Merge pull request #106 from joshtriplett/darwin-award
+    
+    [3.1 blocker] Update OS X build system to include win32.S on 32-bit
+
+commit 7d2478568ed9f03cbf57627f449a2d2cf4d1571c
+Merge: beab5f3 56be47f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 16:12:17 2014 -0400
+
+    Merge pull request #110 from joshtriplett/w64
+    
+    Fix 64-bit Windows support
+
+commit beab5f334d9ec5b8b91d1cc727d1029b40358e7e
+Merge: 28fb197 ef5890e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 25 16:07:47 2014 -0400
+
+    Merge pull request #105 from joshtriplett/win32-relocations
+    
+    [3.1 blocker] win32.S needs to handle relocations/GOT
+
+commit f0c8a31577172104049283f0a80c723084a5bd77
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Mon Mar 24 22:14:26 2014 -0700
+
+    Compile win32.S on FreeBSD
+
+commit b2d610e028b5ce48d1ad7e5d0debc9c321d891b2
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Fri Mar 21 11:10:13 2014 -0700
+
+    Compile win32.S on 32-bit Darwin as well
+
+commit be50b87a490e794362cb4a27ada2fbaab202adb8
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Mon Mar 24 21:44:13 2014 -0700
+
+    Always use configure to detect whether global symbols need underscores
+    
+    64-bit Windows already used this check; make it universal, and use it in
+    place of an ifdef on X86_WIN32, to handle non-Windows platforms that use
+    the underscore, such as Darwin.
+
+commit 56be47f87629e31afbcb0774aa65735f539ee972
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Mon Mar 24 21:24:53 2014 -0700
+
+    Fix a warning on 64-bit Windows
+    
+    When sizeof(size_t) != sizeof(unsigned), adding a size_t to cif->bytes
+    produces a "possible loss of data" warning.  However, the size_t in
+    question refers to the size of a single parameter.  Use a cast to avoid
+    the warning.
+
+commit 48a8eda74aad8a21b6f26df5df08fe64c043d208
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Mon Mar 24 21:21:12 2014 -0700
+
+    Avoid referencing undefined ABIs on 64-bit Windows builds
+    
+    64-bit Windows does not have FFI_STDCALL, FFI_THISCALL, or FFI_FASTCALL.
+
+commit f0f4138f90345d7d67dfa6783a7e1c7cc30d3c6f
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Mar 22 10:00:53 2014 -0700
+
+    win32.S: Add handling for position-independent code on Darwin
+    
+    Newer versions of Darwin generate the necessary stub functions
+    automatically and just need a call instruction, but accomodating older
+    versions as well requires adding the stub.
+
+commit ef5890ebafb7cd2fbf9acf161edb55fe1382871c
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Fri Mar 21 11:01:39 2014 -0700
+
+    win32.S: Use shifting for multiplication rather than repeated addition
+    
+    The jump table code added a register to itself twice to multiply by 4;
+    shift the register left by 2 instead.
+
+commit 4fca48901e7e4f53bf490ed22607b2d2d8f4bfcc
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Fri Mar 21 11:00:41 2014 -0700
+
+    win32.S: Make the jump tables position-independent
+    
+    Now that non-Windows platforms include win32.S, it needs to support
+    building as position-independent code.  This fixes build failures on
+    target platforms that do not allow text relocations.
+
+commit 2087dcf736274286f76c69d3988fb6d7cc4fd0f5
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Fri Mar 21 10:57:06 2014 -0700
+
+    win32.S: Make calls to ffi_closure_SYSV_inner position-independent
+    
+    Now that non-Windows platforms include win32.S, it needs to support
+    building as position-independent code.  This fixes one source of build
+    failures on target platforms that do not allow text relocations.
+
+commit 28fb197079cf1d11da4eef7c8c243ab05590c528
+Merge: c697472 c3dd0a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Mar 18 12:19:36 2014 -0400
+
+    Merge pull request #107 from rvandermeulen/msvcc
+    
+    Various compatibility fixes and improvements to msvcc.sh.
+
+commit c3dd0a1a0245fc174361a70876e88ae24285f861
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Tue Mar 18 12:09:45 2014 -0400
+
+    Various compatibility fixes and improvements to msvcc.sh.
+    
+    * Don't try to mix incompatible optimization flags in debug builds.
+    * Workaround ax_cc_maxopt.m4 not supporting MSVC and change -O3 to -O2.
+    * Fix MSVC warning by properly passing linker flags to compiler.
+    * Make msvcc.sh return 1 if invalid command line options are used rather than silently eating them.
+    * Add more comments.
+
+commit c697472fccfbb5b87b007c053cda9ef014b346b9
+Merge: 83fd2bc e48918e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Mar 17 00:32:42 2014 -0400
+
+    Merge pull request #102 from joshtriplett/test-generic
+    
+    Add ABIs to the test matrix; unify many bits of the testsuite
+
+commit e48918ecf876bc85d040fc50a232059c566553a8
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 20:29:27 2014 -0700
+
+    testsuite: Add ABIs to the test matrix; unify tests across ABIs
+    
+    This eliminates all the *_win32.c tests in favor of the tests they were
+    branched from, and expands test coverage to run many more tests on
+    stdcall, thiscall, and fastcall.
+    
+    This same mechanism also supports testing any other target that has
+    multiple ABIs.
+
+commit 4d4d368e5a55d9443c4c53b1b70d58ab6d8c941c
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 17:02:05 2014 -0700
+
+    testsuite: Replace ffitestcxx.h with ffitest.h
+    
+    ffitest.h contains a superset of the functionality of ffitestcxx.h;
+    make the C++ tests include ffitest.h instead, and remove ffitestcxx.h.
+
+commit 3f97cf3413c46caf2a79f32ac9cda4620972c2d7
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 16:53:42 2014 -0700
+
+    testsuite: Unify the C and C++ testsuites
+    
+    These two testsuites differ only in the source file glob and a couple of
+    additional compiler options; unify the remaining bits.
+
+commit 0d9cce8edb937bbe771a6cdd25f671edf06d2128
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 16:22:58 2014 -0700
+
+    testsuite: ffitest.h: Parenthesize the CHECK macro
+
+commit 5695ec1444c5323e48fe4314f8c8f027625e67df
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 16:04:58 2014 -0700
+
+    testsuite: Factor out a function to run a matrix of tests
+    
+    This commons up code from libffi.call/call.exp and
+    libffi.special/special.exp, unifies the optimization option matrix
+    between the two, and makes it easier to add more axes to the matrix
+    in the future.
+
+commit dfdb02cc869855d3b68571e5f7aa77ae8c9d254a
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 15:26:26 2014 -0700
+
+    testsuite: Introduce a __THISCALL__ compiler-specific macro
+
+commit 83fd2bce0456224483435d4b764063f4513fd464
+Merge: 3658a07 06ff924
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 22:03:29 2014 -0400
+
+    Merge pull request #99 from joshtriplett/gitignore
+    
+    .gitignore: Ignore more generated files
+
+commit 3658a0700a50d37a2fdba04fd9d79ad2f706d9f5
+Merge: d948d0a 46c5d3c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 21:37:42 2014 -0400
+
+    Merge pull request #100 from rvandermeulen/bug-756740
+    
+    Change double quotes in Makefile.am to single quotes.
+
+commit 46c5d3c30fdc2b43c076ad955078d7c5f1e75b37
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Sun Mar 16 21:16:08 2014 -0400
+
+    Change double quotes in Makefile.am to single quotes.
+    
+    This was originally done in PR #84, except the change was made to Makefile.in instead of Makefile.am and was therefore reverted the next time the files were regenerated.
+
+commit 06ff924215a2f9739efa2c059dc595bc4ec1c851
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 16:19:46 2014 -0700
+
+    .gitignore: Ignore more generated files
+    
+    The build process generates doc/libffi.info and fficonfig.h.in, so add
+    them to .gitignore.
+
+commit bad8948346e9b8813023a0cc78a3b6eb8d9c14c6
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 15:16:18 2014 -0700
+
+    testsuite: Introduce a __STDCALL__ compiler-specific macro
+    
+    Several tests want to use stdcall, which differs in syntax by compiler,
+    so introduce a macro for it in ffitest.h.
+
+commit 98a793fa36a4ab3ba24d059cb80a2891cdb940e1
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 15:20:36 2014 -0700
+
+    testsuite: Common up the ifdef blocks for compiler-specific macros
+
+commit d948d0a729c934b0224749338a3ba0a2c8f51c45
+Merge: b61b472 a86bd31
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 10:53:48 2014 -0400
+
+    Merge pull request #98 from joshtriplett/unconfigure.host
+    
+    Merge configure.host into configure.ac
+
+commit a86bd318e2424d879d784ee7b29d6536d7a17c18
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 06:58:59 2014 -0700
+
+    Merge configure.host into configure.ac
+    
+    configure.host only has a single entry, and shows no signs of needing
+    more added.
+
+commit b61b472bd0647006d6685238721002017f1d119c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 09:45:55 2014 -0400
+
+    Update version to 3.1-rc0.  Clean up README.
+
+commit 7a64e7dbba54e6e9f69954adfb943be1856ff928
+Merge: 11a5c5c eef2e02
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 09:39:08 2014 -0400
+
+    Merge pull request #97 from joshtriplett/remove-more-generated-files
+    
+    Remove more generated files
+
+commit 11a5c5c39f5861011f6c5ddf795da3a32b5f0082
+Merge: 9a62a21 1c68c07
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 09:38:47 2014 -0400
+
+    Merge pull request #96 from joshtriplett/sawing-changelogs
+    
+    Generate ChangeLog from git in make dist; remove it from version control
+
+commit eef2e02a13d7d1c8145d47a64467f654406a3548
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 06:26:03 2014 -0700
+
+    doc: Remove autogenerated info file and stamp
+
+commit 9fb403d3c5d9643e0f561cab6d4a07b1e54907ff
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 06:25:52 2014 -0700
+
+    fficonfig.h.in: Remove, configure generates it
+
+commit 1c68c07217fda78a779778c1480fedef7a58d5b4
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 06:11:58 2014 -0700
+
+    Generate ChangeLog from git in make dist
+    
+    Archive the existing ChangeLog to ChangeLog.libffi-3.1
+
+commit c65ed55e655711e008282edbdd82ce95d008b4f6
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 05:52:00 2014 -0700
+
+    ChangeLog.v1: Fix typo in explanatory header.
+
+commit 9a62a21f5c3a8e1da463229f3170c8ab3031d920
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 09:03:57 2014 -0400
+
+    Add missing ChangeLog entry.  Clean up some entries.
+
+commit 9bc704c58cb7a049d867837e3a11e2e31886ec66
+Merge: 694447a e892e58
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 08:41:00 2014 -0400
+
+    Merge pull request #95 from joshtriplett/news
+    
+    README: Update news for 3.0.14
+
+commit e892e581d1838a06c18c7ecd50ebd79915cff92b
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 05:38:24 2014 -0700
+
+    README: Update news for 3.0.14
+
+commit 694447aa29deadd571efb4e9a26ee3f68ede1493
+Merge: fdc87f3 45a6c21
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 08:32:05 2014 -0400
+
+    Merge pull request #93 from joshtriplett/travis-dist
+    
+    Make Travis check "make dist"
+
+commit 45a6c21efa944b520842e631dc54919b04884744
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 05:29:08 2014 -0700
+
+    .travis.yml: Test "make dist" too.
+
+commit fdc87f3b2ea37b58a4a9ae6c35083f544909fe3c
+Merge: 7412b83 e1911f7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 08:05:51 2014 -0400
+
+    Merge pull request #85 from joshtriplett/stdcall
+    
+    stdcall support on Linux
+
+commit e1911f78df113ca58738b66089a070d4cf747de7
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 03:25:53 2014 -0700
+
+    Add support for stdcall, thiscall, and fastcall on non-Windows x86-32
+    
+    Linux supports the stdcall calling convention, either via functions
+    explicitly declared with the stdcall attribute, or via code compiled
+    with -mrtd which effectively makes stdcall the default.
+    
+    This introduces FFI_STDCALL, FFI_THISCALL, and FFI_FASTCALL on
+    non-Windows x86-32 platforms, as non-default calling conventions.
+
+commit 7412b838d543aae4fa925862bd5702d3dacbc29a
+Merge: c0cc5fd 9531d05
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:58:16 2014 -0400
+
+    Merge pull request #90 from joshtriplett/win32-unifdef
+    
+    prep_cif.c: Remove unnecessary ifdef for X86_WIN32
+
+commit c0cc5fdaa237b67e86f22d2f6e13f3b42d9aae33
+Merge: 98b5296 b3a5da0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:57:59 2014 -0400
+
+    Merge pull request #89 from joshtriplett/travis32
+    
+    .travis.yml: Test on both 32-bit and 64-bit
+
+commit 9531d05f64c2a674e0197158ffad68d69f177bd0
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 01:50:02 2014 -0700
+
+    prep_cif.c: Remove unnecessary ifdef for X86_WIN32
+    
+    ffi_prep_cif_core had a special case for X86_WIN32, checking for
+    FFI_THISCALL in addition to the FFI_FIRST_ABI-to-FFI_LAST_ABI range
+    before returning FFI_BAD_ABI.  However, on X86_WIN32, FFI_THISCALL
+    already falls in that range, making the special case unnecessary.
+    Remove it.
+
+commit b3a5da068abd2f2983d9e67adbf41b0e0f34e37f
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Mar 15 23:27:56 2014 -0700
+
+    .travis.yml: Test on both 32-bit and 64-bit
+
+commit 98b52960485a261399f081915f36063de3854a5f
+Merge: 134ce4c f6dd184
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:51:33 2014 -0400
+
+    Merge pull request #94 from joshtriplett/esp-extra-stackery-perception
+    
+    ChangeLog: Document testsuite changes to remove fragile stack pointer checks
+
+commit f6dd1845434dd53e22129becdfa092c082df307c
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 04:49:36 2014 -0700
+
+    ChangeLog: Document testsuite changes to remove fragile stack pointer checks
+
+commit 134ce4c0266bf994f07518fc534de53f1d3c8de8
+Merge: 2680e9e 9c27932
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:47:17 2014 -0400
+
+    Merge pull request #91 from joshtriplett/esp-extra-stackery-perception
+    
+    testsuite: Remove fragile stack pointer checks
+
+commit 9c279328ee12fc869adff63ca81f1230977bd42b
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 02:31:19 2014 -0700
+
+    testsuite: Remove fragile stack pointer checks
+    
+    testsuite/libffi.call/closure_stdcall.c and
+    testsuite/libffi.call/closure_thiscall.c include inline assembly to save
+    the stack pointer before and after the call, and compare the values.
+    However, compilers can and do leave the stack in different states for
+    these two pieces of inline assembly, such as by saving a temporary value
+    on the stack across the call; observed with gcc -Os, and verified as
+    spurious through careful inspection of disassembly.
+
+commit 2680e9ea9b4c87ea8042a61e551bd667493d4bd3
+Merge: 071eab3 82f8cb2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:44:08 2014 -0400
+
+    Merge pull request #88 from joshtriplett/such-precision-many-fail-wow
+    
+    testsuite/libffi.call/many.c: Avoid spurious failure due to excess precision
+
+commit 82f8cb24a1d976db35ae31a4b86cec8926da327d
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 04:27:32 2014 -0700
+
+    ChangeLog: Document many.c and many_win32.c changes to avoid spurious failures
+
+commit 88d562a8b5912e99306063fe3bc289bab6ca6ebe
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Mar 15 22:08:19 2014 -0700
+
+    testsuite/libffi.call/many_win32.c: Avoid spurious failure due to excess precision
+    
+    The test case testsuite/libffi.call/many_win32.c can spuriously fail due
+    to excess floating-point precision.  Instrumenting it with some printf
+    calls shows differences well above FLT_EPSILON.  (Note when
+    instrumenting it that multiple computations of the difference, such as
+    one in a print and another in the conditional, may produce different
+    results.)
+    
+    Rather than complicating the test suite with architecture-specific flags
+    to avoid excess precision, just simplify the floating-point computation
+    to avoid a dependency on potential excess precision.
+
+commit c00a49ecd165b2d06c1c9b249d212dc843fa116f
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Mar 15 22:08:19 2014 -0700
+
+    testsuite/libffi.call/many.c: Avoid spurious failure due to excess precision
+    
+    The test case testsuite/libffi.call/many.c can spuriously fail due to
+    excess floating-point precision.  Instrumenting it with some printf
+    calls shows differences well above FLT_EPSILON.  (Note when
+    instrumenting it that multiple computations of the difference, such as
+    one in a print and another in the conditional, may produce different
+    results.)
+    
+    Rather than complicating the test suite with architecture-specific flags
+    to avoid excess precision, just simplify the floating-point computation
+    to avoid a dependency on potential excess precision.
+
+commit 071eab32a7f9fbbef46c0d8f37d9985bc9cceb37
+Merge: 2228c7a 2f44952
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:36:52 2014 -0400
+
+    Merge pull request #92 from joshtriplett/autogen
+    
+    Re-add libtool-ldflags
+
+commit 2f44952c95765c1486fad66f57235f8d459a9748
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sun Mar 16 04:35:12 2014 -0700
+
+    Re-add libtool-ldflags
+
+commit 2228c7ab190f3c529b9018495467b841fa21cba2
+Merge: 76d19d0 35634db
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 16 07:25:18 2014 -0400
+
+    Merge pull request #87 from joshtriplett/autogen
+    
+    Remove autogenerated files from the repository
+
+commit 35634dbceaac0a1544f7385addc01d21ef1ef6a8
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Sat Mar 15 18:11:16 2014 -0700
+
+    Remove autogenerated files from the repository
+    
+    Add an autogen.sh to regenerate them.
+
+commit 76d19d004e36e99d261ee78261e2f52cea5e4ab1
+Merge: c86d9b6 a1a6f71
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 14 16:54:31 2014 -0400
+
+    Ensure the linker supports @unwind sections in libffi.
+
+commit c86d9b6cc6e16ee262844a33b40441374400758c
+Merge: 4efb7db f8cdf11
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 14 16:51:20 2014 -0400
+
+    Fix merge
+
+commit 4efb7dbfd9427c478a948cd0d464210123db8de8
+Merge: 634a475 18eb81d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 14 16:47:57 2014 -0400
+
+    Merge pull request #81 from rvandermeulen/bug-756740
+    
+    Allow building for mipsel with Android NDK r8.
+
+commit a1a6f71bfe4199293043b2e4cfb4c8d3cb1112f9
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Mon Mar 10 15:12:47 2014 -0400
+
+    Remove stray hunk that shouldn't have been included in this patch.
+
+commit f8cdf11467181f2a9a6b7e748167569aa58e3a81
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Mon Mar 10 15:04:58 2014 -0400
+
+    Replace double quotes with single quotes in Makefile.in to improve compatibility between some versions of MSYS and gmake. From Mozilla bug 943728.
+    https://bugzilla.mozilla.org/show_bug.cgi?id=943728
+
+commit dfa3738732e1bc3a7f4130395ae4bab55fcebb99
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Mon Mar 10 14:53:48 2014 -0400
+
+    Ensure the linker supports @unwind sections in libffi. From Mozilla bug 756740.
+    https://bugzilla.mozilla.org/show_bug.cgi?id=778414
+    
+    Also tracked as issue #42.
+    https://github.com/atgreen/libffi/issues/42
+
+commit 18eb81d032f29d645d0498ba92bddfd651f009ae
+Author: Ryan VanderMeulen <ryanvm@gmail.com>
+Date:   Mon Mar 10 14:43:37 2014 -0400
+
+    Allow building for mipsel with Android NDK r8. From Mozilla bug 756740.
+    https://bugzilla.mozilla.org/show_bug.cgi?id=756740
+
+commit 2349fec9a818fb52fd2f294bcbc7b3156cd113de
+Author: Daiki Ueno <ueno@gnu.org>
+Date:   Wed Mar 5 17:53:02 2014 +0900
+
+    Fix typo in doc
+
+commit 634a475eaf1bee31c09f7d519e31c13b64cd24df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 1 18:37:29 2014 -0500
+
+    Update Makefile for new darwin scripts
+
+commit c7b67e874bb89859f9a07d1cf9606052b6c0dcc1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 1 18:34:18 2014 -0500
+
+    Add README note
+
+commit a04e30ba3dc303133d459c1ac273ceefe4d49b32
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 17:20:59 2014 -0500
+
+    Add missing -DFFI_DEBUG flag
+
+commit 934dc1b5c8d6a9e727bedc72342831eb7d62c35f
+Merge: 11d7aa9 67fbef3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 01:10:17 2014 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 11d7aa9d7a4bbe642944edc0f07cf96db9b270b6
+Merge: b40aeda 3b44d41
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 01:06:48 2014 -0500
+
+    Merge pull request #46 from makotokato/android-clang
+    
+    Fix build failure when using clang for Android
+
+commit 67fbef3b56ff0ef88f9b1a7fe48cb77222fa6cec
+Merge: b40aeda 3b44d41
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 01:06:48 2014 -0500
+
+    Merge pull request #46 from makotokato/android-clang
+    
+    Fix build failure when using clang for Android
+
+commit b40aeda31a74d95a37c723b6243aabac466e67c4
+Merge: 20698ab 53ceaf1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 01:01:29 2014 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 53ceaf14c5eeb16ba09745f0ca87cca367d41a90
+Merge: 860fe66 cc9b518
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 01:01:02 2014 -0500
+
+    Merge pull request #40 from wojdyr/master
+    
+    Correct the -L flag in libffi.pc.in
+
+commit 20698abc6a00092fd7fd3e434a3a29dc0f048f1e
+Merge: 64bd069 1a0b01e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:56:27 2014 -0500
+
+    Merge pull request #66 from ppizarro/master
+    
+    BlackFin fixes - Fatal error when calling a function defined in a shared library from within the function called by FFI
+
+commit 860fe6646f5ae603e99a8d1d722ddddba8b75769
+Merge: 64bd069 1a0b01e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:56:27 2014 -0500
+
+    Merge pull request #66 from ppizarro/master
+    
+    BlackFin fixes - Fatal error when calling a function defined in a shared library from within the function called by FFI
+
+commit 64bd06990a7accf72271516a2110b86cdccd8df4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:52:56 2014 -0500
+
+    Add ChangeLog entry for Josh's change
+
+commit edf29c5169b06fcfc241445e152e325bc3c50e0e
+Merge: 33c9954 3998d26
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:50:25 2014 -0500
+
+    Merge pull request #75 from joshtriplett/longdouble
+    
+    Fix build error on x86 without distinct long double
+
+commit 33c9954f2eec539011a0f93270aaf013318837ae
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:38:41 2014 -0500
+
+    Rebuilt with new libtool
+
+commit 926b6989fbd08488b9105943293353d45ac527e0
+Merge: 5a88c85 cc82051
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:26:57 2014 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+    
+    Conflicts:
+            ChangeLog
+
+commit 5a88c85fde304052bed1581ed0b6452ac2c68838
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:23:04 2014 -0500
+
+    Fix spelling errors
+
+commit cc82051c7e80cea772c4b72da026eb7e68d598fc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:23:04 2014 -0500
+
+    Fix spelling errors
+
+commit 001aaf4b1b56349596bb6f6b5c1613dcbbd84ea8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:20:17 2014 -0500
+
+    When no VFP arguments are present the IP register is used
+    uninitialized. Initialize it to the value of FP.
+    
+    This fixes a number of testsuite failures when configured for
+    armv7l-unknown-linux-gnueabihf
+
+commit 49f7729c3ce697c12408c42ccb29cdf4eb66bb85
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 28 00:17:16 2014 -0500
+
+    aarch64 fix
+
+commit 447483d51c6aa9df7116f346a73fc1cf795f4c2b
+Merge: 51377bd b4df9cf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 27 15:42:41 2014 -0500
+
+    Fix ChangeLog merge
+
+commit 3998d2604b5c0d45a098ff3119a9fd9710ef429d
+Author: Josh Triplett <josh@joshtriplett.org>
+Date:   Mon Feb 17 11:20:33 2014 -0800
+
+    Fix build error on x86 without distinct long double
+    
+    src/x86/ffi64.c: In function 'classify_argument':
+    src/x86/ffi64.c:205:5: error: duplicate case value
+         case FFI_TYPE_LONGDOUBLE:
+         ^
+    src/x86/ffi64.c:202:5: error: previously used here
+         case FFI_TYPE_DOUBLE:
+         ^
+
+commit 51377bda9aed0b2c1309c818460cab9d9ab3d46e
+Merge: f08da54 40927bd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 15 08:06:29 2014 -0500
+
+    Merge pull request #72 from heiher/devel
+    
+    MIPS N32: Fix call floating point va function
+
+commit f08da5465463e60a28f5e921f23ebf2ba984c148
+Merge: 3dc3f32 fa5f25c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 15 08:06:11 2014 -0500
+
+    Merge pull request #68 from zeldin/master
+    
+    Linux/ppc64: Remove assumption on contents of r11 in closure
+
+commit 40927bd3e1e7c6007025ba10854fd8a0664e47df
+Author: Heiher <r@hev.cc>
+Date:   Tue Jan 21 23:18:27 2014 +0800
+
+    Fix call floating point va function
+    
+    I'm not sure floating-point arguments in GPR or FPR before calling
+    variable number arguments function. so, load all arguments to GPR and
+    FPR.
+
+commit b4df9cf9cc4a9a9401a53fd6bea1f3c2c283b97b
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Wed Feb 5 14:22:52 2014 -0500
+
+    AArch64: Fix void fall-through case when assertions are enabled
+
+commit f466aad0d91a117e42571d1d6fb434fa0433c930
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Tue Jan 21 16:38:31 2014 -0500
+
+    AArch64: Fix missing semicolons when assertions are enabled
+
+commit 7ea677733bd98917241852b8901a6b7580728895
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 20:58:31 2013 -0500
+
+    Remove build-ios from Makefile
+    
+    Conflicts:
+            ChangeLog
+
+commit 6ae046cc59c12b2cd40158d6bcb96f4a59886159
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 21:06:51 2013 -0500
+
+    Mention Aarch64 on iOS
+
+commit bfc06b3fdb32abe90ce0749aedfec649df85a7ef
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 17:36:39 2013 -0500
+
+    Update ChangeLog
+
+commit 0a0f12ce1f7be81006b08a3c81a636926d283a9b
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:50:17 2014 -0500
+
+    AArch64: Remove duplicitous element_count call.
+    
+    This inhibits an analyzer warning by Clang.
+
+commit 4330fdcd92e67c816288d64ab230237065768206
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:53:30 2014 -0500
+
+    Darwin/aarch64: Respect iOS ABI re: stack argument alignment
+
+commit 0a333d6c3973935d4fe02aae76b10e39d3c88e07
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 14:03:29 2014 -0500
+
+    Darwin/aarch64: Fix size_t assumptions
+
+commit 2c18e3c76aad1b426617db05a4384e7c3a920176
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 16:14:02 2013 -0500
+
+    Darwin/aarch64: Fix "shadows declaration" warnings
+
+commit 1b8a8e20e344f3c55495ab6eb46bd14e843d4b3e
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:55:21 2014 -0500
+
+    Darwin/aarch64: Use Clang cache invalidation builtin
+
+commit 6030cdcae776f8fb5876a53168f7d1e75d28a242
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 15:45:51 2013 -0500
+
+    Darwin/aarch64: Account for long double being equal to double
+
+commit 5658b0892683d2e24e4d5842978c184a7ad33858
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 16:33:47 2013 -0500
+
+    Darwin/aarch64: Use CNAME, restrict .size like ARM
+
+commit 07175780802acec5dc49fdedd6d20a62409a6707
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 17:48:22 2013 -0500
+
+    Darwin/aarch64: Fix invalid reference in assembly
+
+commit 9da28b44277fea3aeb827c35dd63d609d2524a8b
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 16:23:21 2013 -0500
+
+    Darwin/x86_64: Fix 64-bit type shortening warnings
+
+commit 821d398f08bd1d540a5b235507812ffeee49b580
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:15:06 2014 -0500
+
+    Darwin: Merge build scripts, redo project, incl. arm64
+
+commit 6eff9ff9e72463b9783be2514f944b6f05692054
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 17:48:10 2013 -0500
+
+    Darwin/iOS: Improve unified syntax use for LLVM
+
+commit ba0ea99c82aadd5957386a031e3122011bd36d52
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 15:27:44 2013 -0500
+
+    Fix dlmalloc warnings due to set_segment_flags, sizeof(size_t)
+
+commit 994be3a5c1d0d17b19103396103e128517fd62f9
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 15:27:14 2013 -0500
+
+    Darwin/iOS: Fix mis-typing of vfp_reg_free
+
+commit a8e0a835ab1f62d03ad6391760e3e8b7732d24f8
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Mon Dec 30 15:26:20 2013 -0500
+
+    Darwin/ARM: Assert on NULL dereference
+    
+    This inhibits an analyzer warning by Clang on all platforms.
+
+commit 13675341581c489ed9df8ba390c8e08a732decb2
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:42:08 2014 -0500
+
+    Darwin/i386: Inhibit Clang previous prototype warnings
+
+commit 66469c381e2e2cc96e7d409266dea0ffe177eeca
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:41:45 2014 -0500
+
+    Darwin/ARM: Inhibit Clang previous prototype warnings
+
+commit 5bfe62a00d2d659eec9f19b39802b6e69844fc27
+Author: Zachary Waldowski <zach@waldowski.me>
+Date:   Thu Jan 9 13:41:27 2014 -0500
+
+    Darwin/AArch64: Inhibit Clang previous prototype warnings
+
+commit fa5f25c20f76a6ef5e950a7ccbce826672c8a620
+Author: Marcus Comstedt <marcus@mc.pp.se>
+Date:   Sat Jan 4 19:00:08 2014 +0100
+
+    Linux/ppc64: Remove assumption on contents of r11 in closure
+
+commit 1a0b01e171e9c750437cef2f18917f5a6e32c498
+Author: Paulo Pizarro <paulo.pizarro@gmail.com>
+Date:   Thu Jan 2 16:17:59 2014 -0200
+
+    When the function called by the ffi called a function defined in a shared library generate a fatal error
+    The correction was to take into consideration the GOT.
+
+commit 3dc3f32c35db5ab995a835225f6815369735ceb7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Dec 5 16:23:25 2013 -0500
+
+    Undo iOS ARM64 changes.
+
+commit 356b2cbc304bfe5bdc28b8d1c68d1ff084e9ec37
+Merge: 484a758 07345a3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 22:38:13 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 484a7584260e2fbb399ce90083046834271bf9ff
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 21:06:51 2013 -0500
+
+    Mention Aarch64 on iOS
+
+commit 07345a30ec0a2fa45a7c363d301f57723690cfa0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 21:06:51 2013 -0500
+
+    Mention Aarch64 on iOS
+
+commit d4b931c1b872378c35f12ddbb9a6d55e7f17c65e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 20:58:31 2013 -0500
+
+    Remove build-ios from Makefile
+
+commit dfbf236d70fc1ec68e6ff193584a154353508e2f
+Merge: 852ac3b bb9740e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 20:54:54 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+    Add ChangeLog entry.
+
+commit bb9740e545205f93a525c77aa6d1cbf4ca9371f3
+Merge: ac75368 4d701e0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 30 17:54:39 2013 -0800
+
+    Merge pull request #60 from zwaldowski/ios-redo
+    
+    Mac/iOS support, including aarch64 port
+
+commit 4d701e03faa475a5eb3b54b90046114a1e27b813
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 13:25:27 2013 -0500
+
+    Darwin: Properly export headers from Xcode project
+
+commit 022f12eb9ad2264e838fa5fb453733f5177888f4
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 12:21:38 2013 -0500
+
+    Darwin: Freshen gen scripts, remove old build-ios.sh
+
+commit e820fe2025d7ad3df7584407946dfaad2af69599
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 12:03:51 2013 -0500
+
+    Darwin/iOS: Include x86_64+aarch64 pieces in library
+
+commit 0278284e470ec91db7cdc15ac3dcd64683305848
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 03:03:37 2013 -0500
+
+    Darwin/aarch64: size_t assumptions
+
+commit 9775446b6441c91cd9059215c106aa3bcf949767
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:39:34 2013 -0500
+
+    Darwin/aarch64: Fix “shadows declaration” warnings
+
+commit 4260badc37705d3618e774dfe61184ac709881c1
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:08:14 2013 -0500
+
+    Darwin/aarch64: Use Clang cache invalidation builtin
+
+commit 9fa7998d5f9250908cbf12a671479852ebadf9d1
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:07:48 2013 -0500
+
+    Darwin/aarch64: Inhibit Xcode warning
+
+commit 0e832048a93830575b0976406444e134e649a4f7
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:07:34 2013 -0500
+
+    Darwin/aarch64: double == long double
+
+commit 602dc22d76931092610234cf063f9f1b8dbc1a51
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:06:00 2013 -0500
+
+    Darwin/iOS prep script: try and compile for arm64
+
+commit b513dfe79de4725e8a717325a9e3b5b9f69f63dc
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:05:22 2013 -0500
+
+    Darwin/aarch64: Restrict .size to ELF like arm32.
+
+commit bc978099bf2812de755c076b67ef9c2547607572
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:04:57 2013 -0500
+
+    Darwin/aarch64: Potentially(?) fix compile error
+
+commit d6bb9314467c6e0683156559d23ca341c43fa3c8
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:04:22 2013 -0500
+
+    Darwin/aarch64: Use CNAME refs
+
+commit 33c46ce5680eea28d3437c8771ec1d137e226b45
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 04:13:42 2013 -0500
+
+    Darwin/Mac: Fix 64/32 shortening warnings
+
+commit 0612081e6c161d9d820742f995975d35da2adbc2
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 03:03:00 2013 -0500
+
+    Darwin: Misc size_t warnings
+
+commit 6a6247d179ec3859311c2d8775841b884f309f66
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 02:55:48 2013 -0500
+
+    Darwin: Fix dlmalloc warnings due to sizeof(size_t)
+
+commit 4d60d9e1e32de6166ffd63bbe9ce54cf961c78fc
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 04:09:30 2013 -0500
+
+    Darwin: Rebuild Xcode project
+
+commit cb719a5c1c2eb391d6a5f5e02484ba4aa990a51b
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 04:09:18 2013 -0500
+
+    Darwin/iOS: Fix LLVM 3.3 warning re: memcpy.
+
+commit 21bde92c9abb378f9c456a9d95e6f9b99ef8c920
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 03:43:42 2013 -0500
+
+    Darwin: Clean up, modernize generator scripts
+
+commit fd54eab74cef7891e4acaaafb71e783142ecb69e
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Sat Nov 30 03:38:02 2013 -0500
+
+    Darwin/Mac: Also exclude OS X generated source
+
+commit 953b6f14c655141f9e7d82550a312c3eeb961091
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Tue Apr 24 11:16:20 2012 -0400
+
+    Darwin/iOS: More unified syntax support w/ Clang.
+    
+    Signed-off-by: Zachary Waldowski <zwaldowski@gmail.com>
+
+commit c713a55379481c339877f2e0003d97cb8d9ed80e
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Tue Apr 24 10:25:29 2012 -0400
+
+    Darwin/iOS: Simplify RETLDM arguments for LLVM 3.1
+    
+    Signed-off-by: Zachary Waldowski <zwaldowski@gmail.com>
+
+commit 16ba1b80028db5cb71cf86e5f79f5e48317f83c8
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Wed Apr 11 23:26:04 2012 -0400
+
+    Darwin: Silence Clang warnings.
+
+commit 852ac3bd302d6ed97b1ef65f4cbed69c258a48df
+Merge: ab79d6e ac75368
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 21 21:25:44 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+    
+    Conflicts:
+            ChangeLog
+
+commit ab79d6e21992dd86139ba07530ff888833b78a04
+Author: Alan Modra <amodra@gmail.com>
+Date:   Thu Nov 21 06:12:35 2013 -0500
+
+    This separates the 32-bit sysv/linux/bsd code from the 64-bit linux
+    code, and makes it possible to link code compiled with different
+    options to those used to compile libffi.  For example, a
+    -mlong-double-128 libffi can be used with -mlong-double-64 code.
+    
+    Using the return value area as a place to pass parameters wasn't such
+    a good idea, causing a failure of cls_ulonglong.c.  I didn't see this
+    when running the mainline gcc libffi testsuite because that version of
+    the test is inferior to the upstreamm libffi test.
+    
+    Using NUM_FPR_ARG_REGISTERS rather than NUM_FPR_ARG_REGISTERS64 meant
+    that a parameter save area could be allocated before it was strictly
+    necessary.  Wrong but harmless.  Found when splitting apart ffi.c
+    into 32-bit and 64-bit support.
+
+commit ac7536889334d4be50709006d7e23536364d7891
+Author: Alan Modra <amodra@gmail.com>
+Date:   Thu Nov 21 06:12:35 2013 -0500
+
+    This separates the 32-bit sysv/linux/bsd code from the 64-bit linux
+    code, and makes it possible to link code compiled with different
+    options to those used to compile libffi.  For example, a
+    -mlong-double-128 libffi can be used with -mlong-double-64 code.
+    
+    Using the return value area as a place to pass parameters wasn't such
+    a good idea, causing a failure of cls_ulonglong.c.  I didn't see this
+    when running the mainline gcc libffi testsuite because that version of
+    the test is inferior to the upstreamm libffi test.
+    
+    Using NUM_FPR_ARG_REGISTERS rather than NUM_FPR_ARG_REGISTERS64 meant
+    that a parameter save area could be allocated before it was strictly
+    necessary.  Wrong but harmless.  Found when splitting apart ffi.c
+    into 32-bit and 64-bit support.
+
+commit 69df91cfb4fa6bcb644350a80bff970f27478a6a
+Merge: 2f45082 aa1f62c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 06:34:04 2013 -0800
+
+    Merge pull request #59 from iains/powerpc-darwin-unwind-fix
+    
+    Fix PowerPC Darwin FDE encodings to use pcrel correctly.  Modernise the picbase labels.
+
+commit aa1f62c0a093c30325dff1d4d2b6b4b22eb96929
+Author: Iain Sandoe <iain@codesourcery.com>
+Date:   Mon Nov 18 13:11:56 2013 +0000
+
+    Fix PowerPC Darwin FDE encodings to use pcrel correctly.  Modernise the picbase labels.
+
+commit 2f450822a8698ba88441c56d152c7dc8924b127f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 18 06:52:29 2013 -0500
+
+    Clean up code to appease modern GCC compiler.
+
+commit 16d56c51aded374730920a4acde76ff3d2860ae1
+Author: Alan Modra <amodra@gmail.com>
+Date:   Mon Nov 18 06:36:03 2013 -0500
+
+    An #endif in the wrong place would cause compile failure on powerpcle.
+    Using bl instead of b doesn't cause runtime failures as you might think,
+    but does mess the processor branch prediction.
+
+commit 34f878a5ef28663f6b1d7fd26fb099429ea1579e
+Merge: 83f65b6 1fd0457
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 16 06:57:54 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+    
+    Conflicts:
+            ChangeLog
+            src/powerpc/ffi.c
+
+commit 83f65b63d9764a9cc7688fc5cda5ee2bd23faf54
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:53:50 2013 -0500
+
+    Finally, this adds _CALL_ELF == 2 support.  ELFv1 objects can't be
+    linked with ELFv2 objects, so this is one case where preprocessor
+    tests in ffi.c are fine.  Also, there is no need to define a new
+    FFI_ELFv2 or somesuch value in enum ffi_abi.  FFI_LINUX64 will happily
+    serve both ABIs.
+
+commit 1fd045784cac874b5d76b7fa931f67209a8280d3
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:53:50 2013 -0500
+
+    Finally, this adds _CALL_ELF == 2 support.  ELFv1 objects can't be
+    linked with ELFv2 objects, so this is one case where preprocessor
+    tests in ffi.c are fine.  Also, there is no need to define a new
+    FFI_ELFv2 or somesuch value in enum ffi_abi.  FFI_LINUX64 will happily
+    serve both ABIs.
+
+commit 362851379a49ce07d3e36e82c4e5c7b6cc16a352
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:52:43 2013 -0500
+
+    Andreas' 2013-02-08 change reverted some breakage for struct return
+    values from 2011-11-12, but in so doing reintroduced string
+    instructions to sysv.S that are not supported on all powerpc variants.
+    This patch properly copies the bounce buffer to destination in C code
+    rather than in asm.
+    
+    I have tested this on powerpc64-linux, powerpc-linux and
+    powerpc-freebsd.  Well, the last on powerpc-linux by lying to
+    configure with
+    
+    CC="gcc -m32 -msvr4-struct-return -mlong-double-64" \
+    CXX="g++ -m32 -msvr4-struct-return -mlong-double-64" \
+    /src/libffi-current/configure --build=powerpc-freebsd
+    
+    and then
+    
+    make && make CC="gcc -m32" CXX="g++ -m32" \
+    RUNTESTFLAGS=--target_board=unix/-m32/-msvr4-struct-return/-mlong-double-64\
+     check
+
+commit 1c06515d927d9de1582438d4eb5953890e79c5c7
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:41:36 2013 -0500
+
+    The powerpc64 ABIs align structs passed by value, a fact ignored by
+    gcc for quite some time.  Since gcc now does the correct alignment,
+    libffi needs to follow suit.  This ought to be made selectable via
+    a new abi value, and the #ifdefs removed from ffi.c along with many
+    other #ifdefs present there and in assembly.  I'll do that with a
+    followup patch sometime.
+    
+    This is a revised version of
+    https://sourceware.org/ml/libffi-discuss/2013/msg00162.html
+
+commit a97cf1fae575d8bfd5259c5c422025ad43911326
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:40:13 2013 -0500
+
+    This patch prepares for ELFv2, where sizes of these areas change.  It
+    also makes some minor changes to improve code efficiency.
+
+commit 164283f4ac5972ce2ab5e015cc2ab1014c23276c
+Author: Alan Modra <amodra@gmail.com>
+Date:   Sat Nov 16 06:38:55 2013 -0500
+
+    The powerpc64 support opted to pass floating point values both in the
+    fpr area and the parameter save area, necessary when the backend
+    doesn't know if a function argument corresponds to the ellipsis
+    arguments of a variadic function.  This patch adds powerpc support for
+    variadic functions, and changes the code to only pass fp in the ABI
+    mandated area.  ELFv2 needs this change since the parameter save area
+    may not exist there.
+    
+    This also fixes two faulty tests that used a non-variadic function
+    cast to call a variadic function, and spuriously reasoned that this is
+    somehow necessary for static functions..
+
+commit 31257b3189f81a199bc2902c22bc5f2d7c54ccde
+Author: Andrew Haley <aph@redhat.com>
+Date:   Sat Nov 16 06:35:51 2013 -0500
+
+    Fix sample closure code
+
+commit db0ace3a38496af73eae3df02ef353736d16909f
+Author: Andrew Haley <aph@redhat.com>
+Date:   Sat Nov 16 06:29:25 2013 -0500
+
+    Fix broken test cases
+
+commit de10f5039ed7a53382ddcc95c368d03e535edb98
+Merge: 58c2577 f3657da
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Nov 14 10:56:29 2013 -0500
+
+    Merge branch 'master' of https://github.com/bivab/libffi
+    
+    Conflicts:
+            ChangeLog
+
+commit f3657da278dd63afcdd8762894a9bdaea8ef028a
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Thu Nov 14 13:02:16 2013 +0100
+
+    update Changelog
+
+commit 58c2577a3ff80e7416ef0434769e2af23365719c
+Author: Alan Modra <amodra@gmail.com>
+Date:   Wed Nov 13 16:55:36 2013 -0500
+
+    This enshrines the current testsuite practice of using ffi_arg for
+    returned values.  It would be reasonable and logical to use the actual
+    return argument type as passed to ffi_prep_cif, but this would mean
+    changing a large number of tests that use ffi_arg and all backends
+    that write results to an ffi_arg.
+
+commit 8af42f9944f7ed72c81ae360aac6a84dc11f89dc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 13 16:40:28 2013 -0500
+
+    Respect HAVE_ALLOCA_H
+
+commit cdf405d574f479b782454516366bd4f4b9b3415e
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Wed Nov 13 15:50:21 2013 +0100
+
+    add a testcase for the double/float issue on ARMHF
+
+commit 77f823e31ffb557a466b24f7fba845fbf7831798
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Wed Nov 13 14:26:57 2013 +0100
+
+    stop trying to assing vfp regs once we are done with the registers
+
+commit 37067ec5036f2a6ed7a4799f83f8f53160460344
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Nov 12 19:49:01 2013 +0100
+
+    mark all vfp registers as used when done.
+    
+    To avoid assigning registers the would fit, once arguments have been on
+    the stack, we mark all registers as used once we do not find a free
+    register for the first time.
+
+commit 2f5b7ce545473a7f6e41193edc29407cbebe82d5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 9 06:16:32 2013 -0500
+
+    UltraSPARC IIi fix.  Update README and build configury.
+
+commit becd754434173032f426d22ffcbfe24f55b3c137
+Author: Mark Kettenis <kettenis@gnu.org>
+Date:   Wed Nov 6 06:43:49 2013 -0500
+
+    Align the stack pointer to 16-bytes.
+
+commit 05c31093409f7b3e6d795fac21d2c954313d8162
+Author: Konstantin Belousov <kib@freebsd.org>
+Date:   Wed Nov 6 06:40:58 2013 -0500
+
+    Mark executable as not requiring executable stack.
+
+commit cf6bf9818e8394cfcdb07a40c6a5e2ee6b01d333
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 17:23:59 2013 -0400
+
+    Fix up docs
+
+commit 02177176854d16fc0f1a5958aa34da2f306630ee
+Merge: c242217 c265b4c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 17:11:22 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit c2422174b3edc0de0b148dfd6b67087bb881c4a6
+Merge: f4b843f d918d47
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 14:08:23 2013 -0700
+
+    Merge pull request #45 from foss-for-synopsys-dwc-arc-processors/arc_support
+    
+    arc: Fix build error
+
+commit c265b4cacb9130f042699a85de9c7242b3f49cc3
+Merge: f4b843f d918d47
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 14:08:23 2013 -0700
+
+    Merge pull request #45 from foss-for-synopsys-dwc-arc-processors/arc_support
+    
+    arc: Fix build error
+
+commit f4b843f83710ac378c48abd87fe66bb519d30d2e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 17:01:15 2013 -0400
+
+    Don't align stack for win32
+
+commit f3cd39345713db8e414cf642b6cb65a4cfe6018c
+Merge: 666f3e7 6aa1590
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 2 13:17:57 2013 -0700
+
+    Merge pull request #51 from vbudovski/for_upstream
+    
+    Don't use 16 byte aligned stack for WIN32
+
+commit 666f3e71b56d92c49fcd2d7f349b8f8ebca0f8a3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Oct 26 09:12:42 2013 -0400
+
+    Add more credits to README.  Tidy up.
+
+commit 73ada14e756bad97fad0e6915a821a3c7e079f81
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Oct 26 09:09:45 2013 -0400
+
+    Update README
+
+commit d3372c54ce7117e80d389ba875dc5b6b2213c71e
+Author: Mark H Weaver <mhw@netris.org>
+Date:   Sat Oct 26 08:30:06 2013 -0400
+
+    Fix N32 ABI issue for MIPS.
+
+commit d6716aba8118eb0513885cfe557bedebb7016e8b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 15 15:42:49 2013 -0400
+
+    Update travis-ci build dependencies to include texinfo
+
+commit 16b93a211bcfbe4bd0efdcf94de225a71aa0ee02
+Author: Sandra Loosemore <sandra@codesourcery.com>
+Date:   Tue Oct 15 15:33:59 2013 -0400
+
+    Add nios2 port.
+
+commit 2f5626ce02fce8267ab48ceb6d7d0ed7d672a75e
+Author: Sandra Loosemore <sandra@codesourcery.com>
+Date:   Tue Oct 15 15:32:16 2013 -0400
+
+    Fix testsuite bug
+
+commit f64e4a865557e440774436b4c2b2fd7374290e97
+Author: Marcus Shawcroft <marcus.shawcroft@arm.com>
+Date:   Tue Oct 15 15:20:14 2013 -0400
+
+    Fix many.c testcase for Aarch64
+
+commit 128cd1d2f358f26d9fa75a27cf2b30356f5dd903
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 8 06:45:51 2013 -0400
+
+    Fix spelling errors
+
+commit ff06269d707cafbfef2a88afb07a79c9d1480c5f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 8 06:32:18 2013 -0400
+
+    Update README for M88K and VAX
+
+commit d2fcbcdfbea750d1f6a9f493e2e6c4d5ffa71b34
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 8 06:27:46 2013 -0400
+
+    Add m88k and VAX support. Update some configury bits.
+
+commit 6aa15900accc0a648cdebf11ec11d11697ebfffd
+Author: Vitaly Budovski <vbudovski@gmail.com>
+Date:   Thu Sep 5 12:05:06 2013 +1000
+
+    Don't use 16 byte aligned stack for WIN32
+    
+    This fixes a crash when accessing __stdcall functions in Python ctypes.
+
+commit 3b44d41156149af8da2a58825fefdfa23274ae7a
+Author: Makoto Kato <m_kato@ga2.so-net.ne.jp>
+Date:   Wed Jul 10 15:34:53 2013 +0900
+
+    Fix build failure when using clang for Android
+    
+    clang for Android generates __gnu_linux__ define, but gcc for Android doesn't.  So we should add check it for Android
+
+commit d918d47809c174d62283306b282749f8db93661f
+Author: Mischa Jonker <mjonker@synopsys.com>
+Date:   Mon Jul 8 15:51:36 2013 +0200
+
+    arc: Fix build error
+    
+    One part of the patch for ARC support was missing in the upstreamed
+    version.
+    
+    Signed-off-by: Mischa Jonker <mjonker@synopsys.com>
+
+commit d3d099b40c122550279789200263346f120f6909
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 16:11:38 2013 -0400
+
+    little-endian ppc64 support
+
+commit 0f8690a84c874ec09a090c8c6adfb93c594acac6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 15:54:40 2013 -0400
+
+    Rebuild for ARC additions
+
+commit f88118b345f27c46f5445d6e4832c498ff9a6d85
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 15:51:27 2013 -0400
+
+    Revert "Merge pull request #36 from abergmeier/emscripten_fix"
+    
+    This reverts commit 6a4d901dde7b3f87984c563505717cde3113d16e, reversing
+    changes made to b50a13b9c07ec09af4b9697e482acdad571e6961.
+
+commit 6a4d901dde7b3f87984c563505717cde3113d16e
+Merge: b50a13b 587002c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 12:12:34 2013 -0700
+
+    Merge pull request #36 from abergmeier/emscripten_fix
+    
+    Fixes for building with Emscripten
+
+commit b50a13b9c07ec09af4b9697e482acdad571e6961
+Merge: 767f1f9 b082e15
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 12:10:26 2013 -0700
+
+    Merge pull request #44 from foss-for-synopsys-dwc-arc-processors/arc_support
+    
+    Add ARC support
+
+commit 767f1f96e5282da44d7340e6815e9820a3f78e39
+Merge: c3c40e0 b8a91d8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jul 2 12:08:04 2013 -0700
+
+    Merge pull request #43 from JensTimmerman/__m128
+    
+    added include for xmmintrin.h
+
+commit b8a91d81be77d479327fdb6bdd9fdae6d18e6e63
+Author: Jens Timmerman <jens.timmerman@ugent.be>
+Date:   Tue Jul 2 10:57:37 2013 +0200
+
+    added include for xmmintrin.h
+
+commit b082e15091961373c03d10ed0251f619ebb6ed76
+Author: Mischa Jonker <mjonker@synopsys.com>
+Date:   Mon Jun 10 16:19:33 2013 +0200
+
+    Add ARC support
+    
+    This adds support for the ARC architecture to libffi. DesignWare ARC
+    is a family of processors from Synopsys, Inc.
+    
+    This patch has been tested on a little-endian system and passes
+    the testsuite.
+    
+    Signed-off-by: Mischa Jonker <mjonker@synopsys.com>
+
+commit cc9b518687e46b0d1acafdd4bc3f3b281c25a3d9
+Author: Marcin Wojdyr <wojdyr@gmail.com>
+Date:   Tue May 14 15:01:23 2013 +0200
+
+    Update libffi.pc.in
+    
+    use -L${toolexeclibdir} instead of -L${libdir}
+    to be consistent with Makefile.am
+
+commit 587002c092cffe6e7a8d7028f246c241d03b738c
+Author: Andreas Bergmeier <andreas.bergmeier@gmx.net>
+Date:   Fri Apr 19 17:12:24 2013 +0200
+
+    Enable disabling of libtool on platforms where it does not work (e.g. LLVM).
+    Build libraries normally then.
+
+commit c3c40e0290377d7cf948b072eedd8317c4bf215e
+Merge: ede96e4 4750e3c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 30 05:24:14 2013 -0700
+
+    Merge pull request #34 from davidsch/armhf
+    
+    Fix ARM hard-float support for large numbers of VFP arguments
+
+commit 4750e3c662fd9569cb3e2d28f539685fd1ca8caf
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Thu Mar 28 16:56:36 2013 +0100
+
+    update changelog
+
+commit 9708e7cf09f1bf815f4d6485eb1f180fabb35804
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Wed Mar 27 19:31:04 2013 +0100
+
+    folow the ARM hard-float ABI in ffi_prep_incoming_args_VFP
+
+commit b41120981e5e49ca2da10b94b154775f50da5f36
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Wed Mar 27 16:38:35 2013 +0100
+
+    create separated versions of ffi_prep_incoming_args_* for SYSV and VFP ABIs.
+    
+    The different versions will be called depending on the value of cif->abi
+
+commit dd26f1f39c54861c5b91931f0f37a72942c2a072
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Thu Mar 28 15:39:01 2013 +0100
+
+    add a failing test for closures on ARM hardfloat
+
+commit 3c1608613ab3c2184222b98c5482cddedd6b559b
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Mar 26 19:24:47 2013 +0100
+
+    extend ffi_prepare_args for FFI_VFP (hard-float ABI), fixing an issue with passing VFP arguments in VFP registers and the stack, while at the same time not using all core registers.
+
+commit 0f2ff2d4c92719be8936179f9ab674f4d1a3fd14
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Mar 26 19:22:02 2013 +0100
+
+    separate ARM ffi_prepare_args in a version implementing the simple SYSV calling convention and one for the hard-float calling convention
+
+commit 3a352b8a8252400a83de22c7c424bf1887b4a2ef
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Mar 26 14:24:04 2013 +0100
+
+    move the hardfloat specific argument copying code to the helper function
+
+commit 5df6b7944a4225b6eb329f3886be64e04e966f29
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Mar 26 14:02:21 2013 +0100
+
+    extract setting of arguments to be passed to a helper function
+
+commit 7d1048c471bb4b1f9d67a9e9f8e95f9a1d2e6d45
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Tue Mar 26 11:33:33 2013 +0100
+
+    extract code to align the argument storage pointer to a helper function
+
+commit b9f013788f0f384c423ad963475aaacb55598135
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Mon Mar 25 13:27:36 2013 +0100
+
+    add a testcase, that on ARM hardfloat needs more than the 8  VFP argument registers to pass arguments to a call
+
+commit 2fbdb0f231cafdb77b025d3cd8afe90cda99b3ba
+Author: David Schneider <david.schneider@bivab.de>
+Date:   Mon Mar 25 13:26:02 2013 +0100
+
+    use the absolute value to check the test result against an epsilon
+
+commit ede96e4eb660bbf3e0fe048135efa8106f48af5d
+Merge: f22ab3c 9e34992
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 18:38:21 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit f22ab3c6877cbdd07f058b68816b0086b1cb0e1e
+Merge: 12b1886 d08124b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 18:34:54 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 9e34992a5ea2fda1dba5875bf96dc91a7230f51f
+Merge: 12b1886 d08124b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 18:34:54 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 12b1886d7b1f8aa264b1d348bfa47a0e14712df4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 18:32:12 2013 -0400
+
+    cygwin fix & updates for 3.0.13
+
+commit d08124bedf2c6d61874fe215404783aeb9f6f1ac
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 18:32:12 2013 -0400
+
+    cygwin fix & updates for 3.0.13
+
+commit cb32c812d04d1dfa72002cc04924e7e4fef89e02
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Mar 17 09:27:55 2013 -0400
+
+    Fix lib install dir
+
+commit efd7866a361a6f636bae8400d26c6811e56ca207
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:35:57 2013 -0400
+
+    2.0.13rc1
+
+commit ff647ad4dff2f07dd153f295a1f70b1d906cd6ca
+Merge: 4acf005 d9dd417
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:20:40 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+    
+    Conflicts:
+            ChangeLog
+
+commit 4acf0056f55c757490dae6c29a65b0321327ea8a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:18:45 2013 -0400
+
+    Build fix for soft-float power targets
+
+commit 675c9839224e4268187f1ec6f512127f9db555d0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:12:38 2013 -0400
+
+    Documentation fix
+
+commit 8a286f570ccd41db81f74ea7f248da62241d898a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:01:19 2013 -0400
+
+    Fix for m68000 systems
+
+commit d9dd417b09566af55b7b3000bb53ccaf2e1d6c92
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 08:01:19 2013 -0400
+
+    Fix for m68000 systems
+
+commit 215763d012a944d95406b394d6013b80d220e870
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 07:57:35 2013 -0400
+
+    Update configury.
+
+commit 9180d8f39c9b6afe17b78277c2711a5d9948e824
+Merge: 2fb527a 7e1b326
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 07:46:55 2013 -0400
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 2fb527a017a4943e176a489ff103231b86464b59
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 07:46:38 2013 -0400
+
+    Add Meta processor support
+
+commit 211a9ebf4d1a9801e15e103566aed2b8c42790be
+Merge: f308faf ee18766
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 04:24:40 2013 -0700
+
+    Merge pull request #32 from alex/patch-1
+    
+    Fix for a crasher due to misaligned stack on x86-32.
+
+commit 7e1b32649efd24814e86172e196f390566f9e970
+Merge: f308faf ee18766
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 16 04:24:40 2013 -0700
+
+    Merge pull request #32 from alex/patch-1
+    
+    Fix for a crasher due to misaligned stack on x86-32.
+
+commit ee18766b169811426c14b011fbb46d81e344f926
+Author: Alex Gaynor <alex.gaynor@gmail.com>
+Date:   Thu Mar 14 15:00:33 2013 -0700
+
+    Fix for a crasher due to misaligned stack on x86-32.
+    
+    Full information on reproduction (using Python's ctypes available here: http://bugs.python.org/issue17423)
+
+commit f308faf1eabaf8dc24966ab17fbf94368f46b9c7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 11 14:25:13 2013 -0500
+
+    Add moxie support.  Release 3.0.12.
+
+commit 4ea22e54e3b143fe05c413f6dddd236af6bcbfb2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Feb 10 08:48:38 2013 -0500
+
+    Update README
+
+commit 10e77227b6ae85f46f28590bfb09ca3608554358
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Feb 10 08:47:26 2013 -0500
+
+    mend
+
+commit a9521411a53d58f2bf88199242200ceb0d4dae3a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 9 06:54:40 2013 -0500
+
+    sparc v8 and testsuite fixes
+
+commit 70b11b47eea93bf43627588d494d0b3b0d062481
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 16:12:19 2013 -0500
+
+    Fix small struct passing on ppc
+
+commit 63ba1fa79f7c4ce42de848debe233aab31aecb51
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 15:18:19 2013 -0500
+
+    Remove xfail for arm*-*-*.
+
+commit 24fbca4c1d57d4ea628c0a8ba643684daf54a37e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 14:19:56 2013 -0500
+
+    Fix typo
+
+commit b0fa11cb0a94ce6baca058eab9b10e40475e71d6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 14:17:13 2013 -0500
+
+    More man page cleanup
+
+commit 8bd15d139a58a6e46dc90a1cb2d89f59f32f06c7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 13:56:37 2013 -0500
+
+    Fix many.c testcase for ppc
+
+commit 7aab825cf198be85490d3cd80e778d415d85ad9b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 13:26:21 2013 -0500
+
+    Add missing files to dist
+
+commit cb03ea8f4eb08024e44abe4392edc77b89fbfbad
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 12:25:18 2013 -0500
+
+    sparc v9 fixes for sun tools
+
+commit 35ee8d44f31dd3d3b88083c837dc351593e13cc2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 8 07:12:41 2013 -0500
+
+    Fix microblaze big-endian struct issue
+
+commit 9db7e1a958fc484ba149efe027008b9a170395fb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 21:06:08 2013 -0500
+
+    Fix botched sparc patch. Update version.
+
+commit ce0138e61455f268af326e26908b9680ec2c4bea
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 18:04:01 2013 -0500
+
+    Update bug report address. rc2.
+
+commit fd07c9e40451e0ec1d0475cd54a83d45ccaea2c0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 18:00:36 2013 -0500
+
+    Add cache flushing routine for sun compiler on sparc solaris 2.8
+
+commit ed6ae9501b2bab45daf93b4935eb0c977635b763
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 16:43:36 2013 -0500
+
+    Add libtool-ldflags. Define toolexeclibdir for non-GCC builds.
+
+commit ffef2e046aaec853be356f0b8770a335185ea9cf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 15:47:01 2013 -0500
+
+    x32 and libtool fixes
+
+commit 95eecebb2858dc6f1495a61072ff36d0a8127144
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 15:32:46 2013 -0500
+
+    Remove a.out cruft from dist
+
+commit 176aa9d2e23d9cd57d6f250692d910b408f9a651
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 15:29:22 2013 -0500
+
+    Fix GCC usage test and update README
+
+commit f3a4f3fdde89b04d66983a42a25d09161c5d4d54
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 7 09:57:20 2013 -0500
+
+    Fixes for AIX xlc compiler.
+
+commit 522f8fef49848927482bc63c94afaea5b84e5ec1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 6 20:31:31 2013 -0500
+
+    Fix man page. Clean out junk.
+
+commit c4dfa259eb4e8e6f4c397868d7fee80aa0bb6a12
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 6 17:43:24 2013 -0500
+
+    Bump soversion
+
+commit f62bd63fe6123cadedb8b2b2c72eb549c40fbce9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 6 17:38:32 2013 -0500
+
+    Release candidate 1
+
+commit f7cd61e9e68a4a51147df04d75bfe5b91b9d9286
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 6 17:38:04 2013 -0500
+
+    Fix pkgconfig install bits
+
+commit 6a790129427121f7db2d876e7218a3104e6d2741
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 6 17:37:15 2013 -0500
+
+    Work around LLVM ABI problem on x86-64
+
+commit 370112938e705128fd5dd4017fc1a1210bd0271a
+Merge: bada2e3 bcc0c28
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Jan 27 05:09:04 2013 -0800
+
+    Merge pull request #28 from jralls/master
+    
+    Reorder x86_64 checks
+
+commit bcc0c28001b6d427d5cd8037d2e3c892babc6b4c
+Author: John Ralls <jralls@ceridwen.us>
+Date:   Sat Jan 26 15:21:14 2013 -0800
+
+    Reorder x86_64 tests
+    
+    So that darwin and cygwin/mingw are tested before the generic check --
+    which allows them to actually be set.
+
+commit bada2e326d9a9acf3ae40cfa4f5d7a9ba97b2ea8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 08:02:07 2013 -0500
+
+    Update README
+
+commit 655bb8f3690feba8e840a5f1854b1d78ed08f692
+Merge: 1035ffb 840f975
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 08:01:24 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit 1035ffb2f468e1a1c401d58cff7e7abb69838e68
+Merge: aeb8719 4086024
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:55:53 2013 -0500
+
+    Update README
+
+commit 840f975866052fdd91b2c224d56e01ae5900b60d
+Merge: aeb8719 4086024
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:55:53 2013 -0500
+
+    Merge branch 'master' of github.com:/atgreen/libffi
+
+commit aeb8719a34756969970603fca4568530d56708af
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:37:30 2013 -0500
+
+    New microblaze support
+
+commit 40860245a4fd91a1b88adc9171ec993c549e45d5
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:37:30 2013 -0500
+
+    New microblaze support
+
+commit 20cae32b152b43679ae65a85db9a1c6bb8a143dd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:07:38 2013 -0500
+
+    Xtensa support
+
+commit 9742f91782faef4a15941508a22c408fb7d1d227
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 21 07:03:41 2013 -0500
+
+    Mention IBM XL compiler support on AIX.
+
+commit f03eab08248f122ce3b623a18df9e19fae1b6e98
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 17:14:11 2013 -0500
+
+    Remove obsolete inline test functions
+
+commit 05fbe1faedc7b2580d5f14010d00e9e3cee73951
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 16:54:40 2013 -0500
+
+    xlc compiler support
+
+commit 0b4986a7889ed1864674192228f1162c1b5770a8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 11:19:52 2013 -0500
+
+    [travis] install dejagnu with sudo
+
+commit 3c337eef51ab9a4993fc875bfa26289dd6a08881
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 11:18:14 2013 -0500
+
+    [travis] install dejagnu
+
+commit 90720962ce1baf9fc35d1bde1738102bcd5bd5ed
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 10:57:30 2013 -0500
+
+    Add first travis config file
+
+commit bff052d9cd5be41ba9e47c76114054af487d3c30
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 11 10:24:32 2013 -0500
+
+    32-bit x86 fix and more
+
+commit cd41aeab6176f839167955c016ecc19f65f75df3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 17:25:45 2013 -0500
+
+    Add compiler column to table
+
+commit 8bf987d4df7c4d21435b9211f6cc86abf5904b42
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 17:24:51 2013 -0500
+
+    Fix for sunpro compiler on Solaris
+
+commit 3ee74fd6dc8ccd32b608bbff73526838fc34f70b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 17:15:03 2013 -0500
+
+    Update documentation version.
+
+commit 13e2d7b92557a9511a0414df82bf2df3edc55cba
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 10:52:02 2013 -0500
+
+    Handle both 32 and 64-bit x86 builds regardless of target triple
+
+commit 5141543000fc86a3d49a907a2313713ee79e504d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 07:35:53 2013 -0500
+
+    Don't run EH tests with non-GNU compiler
+
+commit 56ba8d86f47937a0afb81a2b9e77c9d235d9db45
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 07:25:10 2013 -0500
+
+    Don't use warning checking macro with sun compiler
+
+commit 6a028caec1b2c7904feb4c4f9cb7e1125e1d1b60
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Jan 10 01:19:43 2013 -0500
+
+    Don't use GCCisms to define types when
+    +       building with the SUNPRO compiler.
+
+commit 2d9b3939751b3ef9739049509d353ade10b32a8f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 9 21:14:54 2013 -0500
+
+    Fix for closures with sunpro compiler
+
+commit 8308984e479e3274a36e98e8272b5adbb6b774c2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 15:14:21 2013 -0500
+
+    Make sure we're running dejagnu tests with the right compiler.
+
+commit f26c7ca67147450db2fe25ea932944e6cf145d5c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 14:47:05 2013 -0500
+
+    Make compiler options in dejagnu runs compiler specific
+
+commit 74c776e21907fc2e59257c021f23077f8b7966cb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 12:25:54 2013 -0500
+
+    Switch x86 Solaris to X86 from X86_64
+
+commit 8962c8c8d06803e310bac0ffc8e84ea15daeff3f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 12:22:24 2013 -0500
+
+    Fix read-only eh_frame test
+
+commit 35ddb69c2b49746d940e919ca226ecc1be94f14a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 07:53:37 2013 -0500
+
+    Only emit DWARF unwind info when building with GCC
+
+commit f7879bc3f3a8d0bbfcc38771732c160a58ba9cd8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Jan 8 07:30:28 2013 -0500
+
+    Testsuite fix for Solaris vendor compiler
+
+commit 67cea90fc0897021466fd102671019d30db474cd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 7 06:30:24 2013 -0500
+
+    mend
+
+commit 0de3277b18cf54be3b81d509b9be9b47d9bc1e82
+Author: Thorsten Glaser <tg@mirbsd.de>
+Date:   Mon Dec 3 00:02:31 2012 +0000
+
+    Testsuite fixes (was Re: [PATCH] Fix libffi on m68k-linux-gnu, completely)
+    
+    Dixi quod…
+    
+    >although I believe some 3.0.11 checks to be broken:
+    
+    And indeed, with a few minor changes on top of git master,
+    I still get a full run of PASS plus one XPASS on amd64-linux!
+    
+    With the other patches (from this message’s parent) and
+    these applied, I get a full PASS on m68k-linux as well.
+    
+    So, please git am these three diffs ☺
+    
+    bye,
+    //mirabilos
+    --
+    FWIW, I'm quite impressed with mksh interactively. I thought it was much
+    *much* more bare bones. But it turns out it beats the living hell out of
+    ksh93 in that respect. I'd even consider it for my daily use if I hadn't
+    wasted half my life on my zsh setup. :-) -- Frank Terbeck in #!/bin/mksh
+    From 5cb15a3bad1f0fb360520dd48bfc938c821cdcca Mon Sep 17 00:00:00 2001
+    From: Thorsten Glaser <tg@mirbsd.org>
+    Date: Sun, 2 Dec 2012 23:20:56 +0000
+    Subject: [PATCH 1/2] Fix tests writing to a closure retval via pointer casts
+    
+    As explained in <Pine.BSM.4.64L.1212022014490.23442@herc.mirbsd.org>
+    all other tests that do the same cast to an ffi_arg pointer instead.
+    
+    PASS on amd64-linux (Xen domU) and m68k-linux (ARAnyM)
+    
+    Signed-off-by: Thorsten Glaser <tg@mirbsd.org>
+
+commit 8f4772f383abd71cfa141c8a70ba11c1aa4ebe2c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 7 06:14:53 2013 -0500
+
+    m68k fixes for signed 8 and 16-bit calls.
+
+commit ea7f8440d58afbebb181e295ff564fdf3d6590a0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jan 4 09:09:32 2013 -0500
+
+    remove gcc-ism
+
+commit f06c0f10377ac04eeba5e632dbe5c62c629df4e6
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 09:39:17 2013 -0500
+
+    Add missing ChangeLog entry and generated files.
+
+commit 1f8675d4c101d19d67ca0a55ff2ba973349558ad
+Merge: 335f419 f6b58d2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 06:34:38 2013 -0800
+
+    Merge pull request #26 from rofl0r/master
+    
+    fix build error on ppc when long double == double
+
+commit 335f419a86090cda9f215d149572f9481c3ad034
+Merge: 53236d5 6d6f711
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 06:30:03 2013 -0800
+
+    Merge pull request #23 from rurban/master
+    
+    cygwin/mingw shared libs need libtool LDFLAGS = -no-undefined
+
+commit 53236d5061034cc0a7f4647fc1bd05ba1aeb3d2a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 09:24:55 2013 -0500
+
+    Regenerate files
+
+commit 72222ca3fbe560e13c8dc89ca441b28b7cc74daf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 09:06:38 2013 -0500
+
+    Update texinfo.tex
+
+commit 1e326c95431fc9896422fa36659f3e833852579c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 09:05:02 2013 -0500
+
+    Update config.guess and config.sub
+
+commit cb6671f5b8a9596ff968c6b6c304f70adf71b368
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:56:07 2013 -0500
+
+    Missing .gitignore changes for xcode support
+
+commit ebbe77966855395a2a47ed2c09a38f93eb0481cf
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:54:05 2013 -0500
+
+    missed x32 libtool patch.
+
+commit 4394096da0aca0dd422b479a043c18b4f05c5770
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:51:35 2013 -0500
+
+    missed trampoline_table patch. Move to GCC.
+
+commit ed7a59c3ff7c84bd95c374a5aff21599f705e6dc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:48:01 2013 -0500
+
+    Windows symbol export fix.  Move to GCC.
+
+commit ccee09a4ff843b11c7d8b6819776f57d187305c7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:41:55 2013 -0500
+
+    +2012-03-21  Peter Rosin  <peda@lysator.liu.se>
+    +
+    +       * testsuite/lib/target-libpath.exp [*-*-cygwin*, *-*-mingw*]
+    +       (set_ld_library_path_env_vars): Add the library search dir to PATH
+    +       (and save PATH for later).
+    +       (restore_ld_library_path_env_vars): Restore PATH.
+
+commit 089dbce7cc0889eb26444d89ae062c73c69f26f0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:37:35 2013 -0500
+
+    med
+
+commit 980a334c42b4b0eff32e55929ec6727d1326b05d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 07:36:42 2013 -0500
+
+    Test GCC update
+
+commit 8bad679ade5000e57cdc9cacde22e8b99840930f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 08:28:35 2013 -0500
+
+    New stand-alone patch
+
+commit 981c32ee115e9f0d6546a74592875e138222a9d1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Jan 2 07:34:03 2013 -0500
+
+    Merge with GCC.  Eliminate quilt bits.
+
+commit 61a054929517fb80c437ba71c91f3e20cfff581a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Nov 28 06:07:41 2012 -0500
+
+    Refresh config.guess and config.sub
+
+commit f6b58d2bdc0a24ce94dedce59802f091979df265
+Author: rofl0r <retnyg@gmx.net>
+Date:   Thu Nov 22 16:26:21 2012 +0100
+
+    fix build on ppc when long double == double
+
+commit 69da33a0761aeac73f9e9646269da61c906d6020
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 12 15:25:47 2012 -0500
+
+    Pull in config.sub for aarch64 support and more
+
+commit f680b598b7bdde325ac9349e8c35151c228bf2df
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Nov 6 16:00:40 2012 -0500
+
+    Add missing aarch64 configury bits
+
+commit dfadfb19853c57c8623c436d0ef2bdafab24b433
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Oct 31 06:46:41 2012 -0400
+
+    Rebase for ppc64 fix
+
+commit e944b8c7eb1e2eeb9c0f3b9742b4d7f476860ce1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 14:06:09 2012 -0400
+
+    Add PaX work-around
+
+commit 9ccd51be1fdeb99f8b4f42f905166c2abbba8ac0
+Merge: f342996 fa5d747
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 13:37:37 2012 -0400
+
+    Fix commit conflicts
+
+commit f342996cb50eb23b868afcff5ac0cdbb6b505d63
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 07:42:27 2012 -0400
+
+    Darwin12 fix
+
+commit 58e8b66f70cef2e3c9b0e5a707b45d634cbbf5d9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 07:07:19 2012 -0400
+
+    AArch64 port
+
+commit fa5d747905472571fd472c07d4726017624f66b3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 07:07:19 2012 -0400
+
+    AArch64 port
+
+commit 6993a6686f43f2313b18142c1e96189a27db2aa3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Oct 30 06:59:32 2012 -0400
+
+    Fix autoconf macros
+
+commit 70084e70ddb13b29dd05c751b1904de206bbe790
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Oct 12 23:55:06 2012 -0400
+
+    Update Tile* port info
+
+commit 9c00a3f6742d61404b31268cc773e7130ff43331
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Oct 12 16:46:06 2012 -0400
+
+    TILE-Gx/TILEPro support
+
+commit 048d2f41c3a6664b4b64bf21e804686662da4160
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Oct 11 10:55:25 2012 -0400
+
+    Rebase
+
+commit 6d6f71108064f5069edd7bf771059d3b82640135
+Author: Reini Urban <rurban@cpanel.net>
+Date:   Sat Jul 7 12:42:00 2012 -0500
+
+    cygwin/mingw shared libs need libtool LDFLAGS = -no-undefined
+    
+    otherwise only static libs are created.
+
+commit d330f19292da8f39a78a9e2b0ba08df8094e3bc5
+Author: Nicolas Lelong <rotoglup>
+Date:   Sat May 5 09:37:02 2012 -0400
+
+    iOS build fixes.
+
+commit 09b23cfc1d6d15361eee18818851fd3cacb26559
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 27 08:29:48 2012 -0400
+
+    Update README with Blackfin/uClinux support
+
+commit 213ed15c70e72d666154c08e2b41dae3f61f20d3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 27 01:34:15 2012 -0400
+
+    Add blackfin supprt from Alexandre Keunecke.
+
+commit ff3d76fd427382ce7d2b2ed54acdd0bce470ca4f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Apr 11 23:16:48 2012 -0400
+
+    3.0.11
+
+commit 7e0a412c4fd9cbe77b467a9bf86f56aea62632c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Apr 11 22:47:44 2012 -0400
+
+    Update files to ship
+
+commit 39e6a5860416f7bad992149817e1da1ba7c460d4
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Wed Apr 11 22:39:46 2012 -0400
+
+    More mac/ios build improvements
+
+commit 853cc722a16f8d1254573ef3bb73c7b8f3d8a110
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Apr 10 06:33:33 2012 -0400
+
+    Fix typo for darwin targets
+
+commit 3f5023068cda07a3dd6dacbaa875a5b5fc96d4bb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 20:34:51 2012 -0400
+
+    mend
+
+commit ebb8e8945681ce0af7a5c47a980287e8ece84b84
+Author: Mike Lewis <mikelikespie@gmail.com>
+Date:   Fri Apr 6 20:02:08 2012 -0400
+
+    Build iOS library with xcode
+
+commit a098b44f4c592c2192fcdef4fad6108eb3f4301c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 17:04:35 2012 -0400
+
+    Reapply missing testsuite changes for arm
+
+commit 10d1e51393f08c14045db85843208f44f9f1e9ba
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 11:57:14 2012 -0400
+
+    Update to rc4.  Upgrade autoconf version.
+
+commit 9bcc884276dc0a807b2605e510b11b1740dd9aa2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 11:53:07 2012 -0400
+
+    Fix Linux/x32 reference in README
+
+commit a044a56b1cd2a0924f5ec0d6b5a5089d14fcd1a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 10:39:10 2012 -0400
+
+    Linux/x32 libtool fix
+
+commit 59bb61a36661b972e8443531d3b7bc736e131a4b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Apr 6 08:26:14 2012 -0400
+
+    Update libtool version, README, tests dists
+
+commit f2981454cbe25cf9411b710f46c5f5552003a123
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Apr 5 15:45:19 2012 -0400
+
+    Revert debug code changes
+
+commit 39dccddb606f6fdb8dcb177d416e884041da6e30
+Author: Zachary Waldowski <zwaldowski@gmail.com>
+Date:   Thu Apr 5 12:32:41 2012 -0400
+
+    Fix building with Clang for Darwin (OS X 10.6+ and iOS
+     4.0+)
+
+commit 3afaa9a34a81a305227ae8cf4f12b9d0484d055e
+Author: Peter Rosin <peda@lysator.liu.se>
+Date:   Tue Apr 3 07:40:31 2012 -0400
+
+    Fix return_uc.c test case on windows.
+
+commit 65f40c35a2873d8328359ec4512bd0736dbe32c7
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Apr 3 07:35:59 2012 -0400
+
+    Repair ppc build regression.
+
+commit 0a1ab12a8d15caa894116a82249551f23ef65612
+Author: Peter Rosin <peda@lysator.liu.se>
+Date:   Fri Mar 30 08:14:08 2012 -0400
+
+    Various MSVC-related changes.
+
+commit e1539266e6c6dde3c99832323586f33f977d1dc0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Mar 30 00:40:18 2012 -0400
+
+    ARM VFP fix for old toolchains
+
+commit 7c5e60b5f47d725036a72162f136272bc407e3a1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Mar 29 08:48:22 2012 -0400
+
+    Rebase on fixed GCC sources
+
+commit e72ed5eeaa9cfb0fdc86f6b3422734177b659f96
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 21 09:52:28 2012 -0400
+
+    Fix vararg float test
+
+commit bd78c9c3311244dd5f877c915b0dff91621dd253
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 21 08:09:30 2012 -0400
+
+    More cygwin fixes
+
+commit 84d3253f86dad6b4f261231935675d35fd964b05
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Mar 19 23:07:35 2012 -0400
+
+    Rebase post GCC merge
+
+commit 964c5b93f80dcaacf73056b7d15a4d2b4b7a217c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 3 14:46:20 2012 -0500
+
+    abi check fixes and Linux/x32 support
+
+commit 6c194233a5f6f1d274669afc5924a9e1f69d4876
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Mar 3 14:17:54 2012 -0500
+
+    Add -no-undefined for both 32- and 64-bit x86
+    windows-like hosts.
+
+commit 8360bf1cd0aba8db5582266da70467de7e89a57a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 23 07:01:13 2012 -0500
+
+    Ensure that users don't include ffitarget.h directly
+
+commit d578b89619cf3d2baff027b203619dc307fc12e3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 15 00:18:18 2012 -0500
+
+    Fix ABI check regression
+
+commit dee20f8e45c486f5018f31e09bb362992aa498c3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 10 13:06:46 2012 -0500
+
+    Rebased from gcc
+
+commit 4130e1972d001143e5e9f3c6b65f2a6f9524169e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 3 13:18:27 2012 -0600
+
+    Refresh autoconf-archive m4 scripts
+
+commit 1ff9c604bb214b5a305064af1049577ef783730a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 1 16:34:30 2012 -0600
+
+    Rebase from GCC
+
+commit 211060eb8f714af0e935430efa6bb45e8e3ffc5d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 14:24:01 2012 -0500
+
+    Alpha fix
+
+commit 78d9c638ba0de6edfbc603fd65d19c6562663248
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 14:17:24 2012 -0500
+
+    mend
+
+commit afaf3381604bd81803d8a5f3bf4d462299f1aac3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 14:17:13 2012 -0500
+
+    mend
+
+commit 9e9c4aeb77de5608d602109f22100c1c0c79faad
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 14:11:23 2012 -0500
+
+    Add Amiga support
+
+commit 8efc0b1f4027d5a3cbf205e55d422d94e60f3226
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 13:47:38 2012 -0500
+
+    Unlikely fixes
+
+commit 1df51398ae183dc208ba4599ee867278b04d13d3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 13:43:59 2012 -0500
+
+    mend
+
+commit cd2277cc796b96b149cd284ae85326529fe7fb9c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 13:43:38 2012 -0500
+
+    mend
+
+commit 164e6fe04b189746c8bd5810c6e3e919770bb9d4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 12:41:06 2012 -0500
+
+    m68k fixes
+
+commit c365ee7577bef00cb3c2c0b5224147aea04138d8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jan 23 11:13:18 2012 -0500
+
+    Refresh
+
+commit f22c38bbd93bcc0c04bf26c3e414556b3177c385
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 18 15:13:41 2011 -0500
+
+    Update variadic patch
+
+commit 03e9ee321a3c208f88d2432587ce40b2bb2430ba
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Nov 18 15:13:00 2011 -0500
+
+    Fix cls_double_va.c and update docs
+
+commit 95f31151ec792809cfb80d385350f9f56d95aa25
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 23:46:05 2011 -0500
+
+    Rerun automake
+
+commit 198ed1ef85cf18342627f8d44bc3f12c9975a49d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 23:45:20 2011 -0500
+
+    Update version number
+
+commit 4f17e1f142e805b13959ba2594ee735eae439f4e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 17:22:24 2011 -0500
+
+    Fix last patch
+
+commit ff9454da44859716a5bd4eaa344499288c79694f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 17:18:51 2011 -0500
+
+    Add David Gilbert's variadic function call support
+
+commit ea14ae85e8f54ff046b7fb8a9cfe349475272044
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:36:59 2011 -0500
+
+    clean up
+
+commit 52891f8a93f9b8de801cca4cf05639422dc9773e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:35:55 2011 -0500
+
+    Add powerpc soft float support
+
+commit c8f1bde8e2566c5a87474b4d08aa934d6d28ee75
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:21:02 2011 -0500
+
+    Remove junk file
+
+commit 6a6e7f862f3cc677e19131587caa619e7f9c7ffd
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:20:42 2011 -0500
+
+    Fix kfreebsd
+
+commit d52fbed05ccbdee9ed8b9c911cbb4f85b0ff0f2a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:13:41 2011 -0500
+
+    Add missing ChangeLog entry
+
+commit 322052ce65c4fdac85bedc24726fd0e0094ba521
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 16:11:49 2011 -0500
+
+    Fix arm wince alignment issue
+
+commit af18df2bc2f52df81e7b5c619bd86db8489dc873
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 15:52:08 2011 -0500
+
+    Remove use of ppc string instructions
+
+commit 236c9391321f83ad40daf03f40c35c9ebc1da6b3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 07:37:40 2011 -0500
+
+    Fix darwin11 build problem
+
+commit c411f140f305ebb00d33c92b7cb2742bcd241b6a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 07:32:36 2011 -0500
+
+    Fix ax_enable_builddir macro on BSD systems
+
+commit 3d56106b07735abef6ae9f032e94f560a0ed2f30
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Nov 12 07:20:24 2011 -0500
+
+    Rebase
+
+commit 8c01954c50bf8ef2e00a3db166060a1b8f83a20d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 14:26:32 2011 -0400
+
+    Build assembly files with debug info
+
+commit fed646a2078969f4ce89c29107f1e72e03f4a977
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 6 09:50:20 2011 -0400
+
+    Regenerate configury with missing m4 macros
+
+commit d76441cf71216f8f1e62e7ec852a7f4e21371ec8
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Aug 24 10:14:23 2011 -0400
+
+    Update list of supported OpenBSD systems
+
+commit ee6696fdf4768ba6dd037fb6dd99435afa13816e
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Aug 23 12:30:29 2011 -0400
+
+    3.0.11-rc1. soname bump.
+
+commit c6265c36a91eab8175d0e72db84d8225418f2379
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Aug 23 10:31:33 2011 -0400
+
+    Version 3.0.10
+
+commit cc5e41bf32d18a14dbdd653d52eacdbdc934c392
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Aug 22 16:34:24 2011 -0400
+
+    Fix use of autoconf macros
+
+commit 049d8386ff52399e69a530b55b9feedc8a2589d2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Aug 22 14:50:10 2011 -0400
+
+    Many new patches
+
+commit 3b7efa4e74f0dcebf70b447391987aedd3473306
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Aug 15 13:25:13 2011 -0400
+
+    Revert remove-debug-code patch temporarily (for ARM Fedora release)
+
+commit d992ac54a2a9e7e064ffebcb91e05e7cb86185c7
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jul 29 17:32:53 2011 -0400
+
+    Refresh from GCC
+
+commit 2d3fb36420e09304220ee6c0652bae5eccdb965d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Mar 30 16:54:42 2011 -0400
+
+    Fix darwin EH
+
+commit 30ff28e1d8cd9ed5319f1fbe9c7cccacc8161fb3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 28 15:36:23 2011 -0500
+
+    Fix permissions
+
+commit 09f8f310f4f53a24289682d3d28f4399d7bafc3b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 28 15:36:07 2011 -0500
+
+    More AIX fixes. rc9.
+
+commit 53d7b165642c220aa5166ba350b490802f359b54
+Merge: 18dd85d 3000dc2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 28 15:23:31 2011 -0500
+
+    Merge branch 'master' of https://github.com/landonf/libffi-ios
+
+commit 18dd85d6cb9f3f3eea2a3b70eb4e150045905c55
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 25 16:23:04 2011 -0500
+
+    rc8. fix last patch.
+
+commit 74ee6ea8b42e60d44a3ae8938b1e42a38c1e66b4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 25 15:52:14 2011 -0500
+
+    rc7.  More AIX fixes.
+
+commit 2541679dbd3db0014890f42192dbf8008ab923fa
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 25 15:09:13 2011 -0500
+
+    Fix ppc32 bug
+
+commit cbb062cc35c518004f1ab45c847f8ec4f66069ad
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Feb 17 20:39:21 2011 -0500
+
+    Another non-GCC configury fix
+
+commit 8cf8878425e9971866fa6b27a3e4914729ad3960
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 15 15:19:49 2011 -0500
+
+    Fix ax_cc_maxopt.m4
+
+commit 24b72070c0937f9000744c77a636f07e04786b6a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Feb 14 15:30:57 2011 -0500
+
+    Fix warning and msvcc patches
+
+commit d72c49e556a8c516e97f6722d1be2f1209c21207
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Feb 13 11:41:05 2011 -0500
+
+    Add missing msvcc.sh
+
+commit 3000dc237f6017a7445d8404097a4f46b73fdd29
+Merge: 55e4a5a 1fbf9dc
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Feb 13 08:55:53 2011 -0500
+
+    Merge remote branch 'upstream/master'
+
+commit 1fbf9dc44feea564e84ad7406d17c5d5906ce0e0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Feb 13 08:06:39 2011 -0500
+
+    Fix bad_abi test. rc5.
+
+commit 90af15ef5c1614b76370c4d13954586fabf9e8e3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 12 12:29:36 2011 -0500
+
+    iOS fixes
+
+commit 55e4a5aa1568558a04aa40f16fc022e459af53e3
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 12:13:46 2011 -0500
+
+    Add support for building a full armv6/armv7/i386 universal iOS library
+
+commit a0c80f279b8733d001cb5e5c5a3289ecb7a6e56a
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 11:43:49 2011 -0500
+
+    Update my e-mail address.
+
+commit 8195e0e11df7a53fa474caa9375f73ca1136ed66
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 11:27:00 2011 -0500
+
+    Fix symbol prefixes on Darwin.
+
+commit 56b3f8cef0f28cefaa0f40fe0cf7c524adef131d
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 11:14:54 2011 -0500
+
+    Modify the ffi_closure structures to hold table/table entry pointers instead of a code buffer.
+    
+    This re-integrates commit da2773e02ab26cc11a7f.
+
+commit 28a00f61ff3f64c4eb2269ce2aea3d493274469e
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 11:01:48 2011 -0500
+
+    Apple assembler support; fixed most gas/ELF-isms.
+
+commit 7f2ea33a80bfced5e48ed7292f3b8f057d54ff8f
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 10:39:18 2011 -0500
+
+    Replace RETLDM macro.
+    
+    The macro is incompatible with Apple's assembler; switch to
+    a simple inline version.
+
+commit 92ff23e77fa586455b427b71f49e1d9502470e6e
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 10:24:49 2011 -0500
+
+    Switch to the current iOS 4.2 SDK.
+
+commit 58fb8ca2dfb89ad70284bb9678d3d4dbb658c8a7
+Merge: cc3fbd9 71c792f
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 10:23:19 2011 -0500
+
+    Merge remote branch 'upstream/master'
+
+commit cc3fbd975ce9366d4c40a6ff6c108f664867bd7c
+Merge: e449a43 f6ab3ed
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 10:21:02 2011 -0500
+
+    Merge branch 'master' of github.com:landonf/libffi-ios
+
+commit e449a43bbe12f8119399928db1ae26adc71dde14
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Feb 12 10:20:42 2011 -0500
+
+    Allow specification of the minimum supported iOS version.
+
+commit 71c792f51bcf3e2f334e5ea1fb1a8b667cb3aedb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 12 09:33:11 2011 -0500
+
+    rc4
+
+commit 7c7c9f327299331022f6000603a35f2310dfe308
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Feb 12 09:29:29 2011 -0500
+
+    ungccify parts of the build
+
+commit ed62e48b95a0fa60b685f647cb73c9e190eec35c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 11 12:23:58 2011 -0500
+
+    Fix permissions
+
+commit 17d9e9e68ddb1b915a0b9751713033861b598575
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 11 12:23:20 2011 -0500
+
+    Use newer autotools.  Only build debug.c when --enable-debug.
+
+commit 6972a4ffda75761eaab7dfbe0fb1516b255e8e0c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 11 07:32:51 2011 -0500
+
+    Fix xlc build on AIX
+
+commit 1833aa0fb9831eb0725b63e35886c0f6d35df480
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Feb 11 07:11:04 2011 -0500
+
+    sparc ABI test fix.
+
+commit f1fb139b4e283fffdcf205a903943d5e9d2bb2a2
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 18:30:02 2011 -0500
+
+    Fix tests
+
+commit 5cb470331d181c84d5d621e88868327a324a5898
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 15:23:06 2011 -0500
+
+    Fix permissions
+
+commit 269deef6dbbb426695919d3398357fada3bb288c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 15:22:23 2011 -0500
+
+    rc3
+
+commit 42695e72504f647444b8e8e9b90bd24f1e3220e1
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 15:12:35 2011 -0500
+
+    Fix IRIX support
+
+commit a6e56b97f62a3feeb3301c24a2e4cae55e546021
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 15:00:42 2011 -0500
+
+    Add powerpc64-*-darwin* support
+
+commit 747d6c32d4abb07c10c3a1f93579c3929aaa2487
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 14:56:23 2011 -0500
+
+    Add Interix support
+
+commit eab6e41cde382aa07de6c011d514a14c0d62eb47
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 10:15:02 2011 -0500
+
+    Remove README.markdown form libffi-ios
+
+commit 69dbe845f4ee3e6ce8999f17a1e4f2179ef7da89
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 07:38:43 2011 -0500
+
+    Fix xfails
+
+commit f498318c07b95137fe259d86bdbe15347588b84a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 06:26:46 2011 -0500
+
+    Update README for iOS again
+
+commit 630b9c0ac43c7edcbfd892e23c09fb26724f4ac0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 06:24:23 2011 -0500
+
+    Update to rc2
+
+commit 0cad4386fa4c9ea5f8ca88b16247db4e5c8fea90
+Author: Anthony Green <green@moxielogic.com>
+Date:   Wed Feb 9 06:11:46 2011 -0500
+
+    Add ChangeLog entry.  Fix copyright headers.
+
+commit 09cb76f2645bd2c151846e9249d8ea707ba01e8c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 20:39:51 2011 -0500
+
+    Add missing change
+
+commit 2e3a48ccdd54340983c46a29a0b41985e3e789ac
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 20:37:26 2011 -0500
+
+    Fix make dist
+
+commit 5e4814d9928e236a2a4afe84d6e1d4fdaa473206
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 19:46:28 2011 -0500
+
+    fix permissions
+
+commit 5c0cc6f1536aa1738795a97303810a823c7fa2cb
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 19:45:59 2011 -0500
+
+    3.0.10rc1
+
+commit 857fe3de46d2286afa2fe772920ecf4aefa1688f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 19:39:20 2011 -0500
+
+    Clean ups
+
+commit e2214f8adb5577c247452e2cc9f4cbe304d7ca9f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 19:22:56 2011 -0500
+
+    Update README
+
+commit 1106229a5721a659da5c231ec0e8211119615394
+Merge: bc9d0be f6ab3ed
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 19:20:09 2011 -0500
+
+    Add iOS support
+
+commit bc9d0be2958ce475757f34dd2c878948aa77a39f
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 17:04:26 2011 -0500
+
+    3.0.10rc0 changes
+
+commit 3b836249feae6d08d3e6887486e4b9961ddafa09
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 14:28:59 2011 -0500
+
+    Rebase from GCC
+
+commit a26e3940619faeba6de54824c9540c90b1aab513
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 13:56:12 2011 -0500
+
+    copyright updates patch
+
+commit b8099539f00e224107594101e9760b6dc081a056
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 13:50:43 2011 -0500
+
+    Fix msvcc.sh botch
+
+commit dc411e8f99113a34656bfd2d3ae51259972488cc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:49:29 2011 -0500
+
+    Fix HP-UX build
+
+commit 404585d1348e30ac58203bbd876d9131e5aed874
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:44:36 2011 -0500
+
+    Fix sparc v8 aggregate type returns for sun's compiler
+
+commit 19ce713188e193e4522740d24c20170411883d2d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:34:23 2011 -0500
+
+    grammar fix
+
+commit 89284fe55f1a8ad3bddbea796ee00d0e3ba411ce
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:19:19 2011 -0500
+
+    Fix AIX build with IBM XLC
+
+commit ba022c338af97cb18d9f8ed5a607fd483a61c09c
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:12:48 2011 -0500
+
+    fix win64-underscore patch
+
+commit 097e5f3924ee92a3ba6cd72f787da8a3eb14fea3
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:11:00 2011 -0500
+
+    x86 pcrel test part 2
+
+commit ed2c518d960b91d444be74e5a55779a9c4602f3b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 10:10:07 2011 -0500
+
+    x86 pcrel test
+
+commit 0e5843995f46900ef212531281e08b224464f413
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Feb 8 07:52:40 2011 -0500
+
+    Refresh from GCC
+
+commit 5b9cd52784339a42e417174a55e310e214d435f9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Nov 22 15:19:57 2010 -0500
+
+    win64-underscore patch
+
+commit 2db72615b50eb5c0f29725c02c740a2f0d7fc7d9
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Nov 21 10:50:56 2010 -0500
+
+    Rebase
+
+commit f6ab3edc23dc8fc7c47a31c896044150c23f04b5
+Author: Landon Fuller <landonf@plausible.coop>
+Date:   Wed Oct 27 19:34:51 2010 -0400
+
+    Include the license header in the generated output.
+
+commit cef619462887fa0f360e3ee702d1e04f112b5b38
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Wed Oct 27 13:59:30 2010 -0400
+
+    Add missing copyright/license header.
+
+commit 53f387b203413c9aa6e31f49dbb70d37d816330b
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 19:57:17 2010 -0700
+
+    Minor README fix.
+
+commit 4fbcb5b5fbce11f4b168060e00639db33c85b75b
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 19:50:37 2010 -0700
+
+    Minor README fix.
+
+commit 8e7652ef6acab5db7a29f786686a54f05cdbdc7d
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 19:49:39 2010 -0700
+
+    Add a libffi-ios-specific github README.
+
+commit 83038cf24aa1a92b62b91ffee1dcc25d79243484
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 14:36:45 2010 -0700
+
+    Implement FFI_EXEC_TRAMPOLINE_TABLE allocator for iOS/ARM.
+    
+    This provides working closure support on iOS/ARM devices where
+    PROT_WRITE|PROT_EXEC is not permitted. The code passes basic
+    smoke tests, but requires further review.
+
+commit b00ff3e98fdde622cef617030e14d5356dff988f
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 14:22:26 2010 -0700
+
+    Rename the generated symbol
+
+commit da2773e02ab26cc11a7fe87e985599f35cdf0649
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 14:21:37 2010 -0700
+
+    Modify the ffi_closure structures to hold table/table entry pointers instead of a code buffer.
+
+commit 01d71b7bed41844f80cb9feef20dcc5ece5ba2d0
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 14:21:14 2010 -0700
+
+    Regenerated the autoconf script
+
+commit 19afda0069c42e51c81dca7b10a5cf884b4cdce0
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 14:20:52 2010 -0700
+
+    Enable AC_SUBST for FFI_EXEC_TRAMPOLINE_TABLE
+
+commit 9e1196444e78aef20028c18891f44ebe39a815fd
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 10:43:06 2010 -0700
+
+    Add a hard-coded FFI_EXEC_TRAMPOLINE_TABLE arm implementation.
+    
+    This implements support for re-mapping a shared table of executable
+    trampolines directly in front of a writable configuration page, working
+    around PROT_WRITE restrictions for sandboxed applications on Apple's
+    iOS.
+    
+    This implementation is for testing purposes; a proper allocator is still
+    necessary, and ARM-specific code needs to be moved out of
+    src/closures.c.
+
+commit f38364b399184e682fc3e785084bd497827bc5af
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 10:42:36 2010 -0700
+
+    Fix symbol prefix for ffi_closure_SYSV_inner on Darwin.
+
+commit 36849e7716b77aa25e4175d1f4be1b93dbf47aac
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 09:35:04 2010 -0700
+
+    Whitespace/comment fixes.
+
+commit b764162526854686e579a48b6ac5981f4eb886a3
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 09:04:34 2010 -0700
+
+    Fix the script name (build-iphone.sh -> build-ios.sh)
+
+commit a3d9aa85013341451ea97766485b7a11852d32b2
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 09:03:52 2010 -0700
+
+    Update the autogenerated autoconf/automake files.
+
+commit c71480eaf839f26bbdfcd8965f65ac4d8defddc0
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 09:02:05 2010 -0700
+
+    Update automake/autoconf to conditionally build src/arm/trampoline.S if FFI_EXEC_TRAMPOLINE_TABLE is enabled.
+
+commit 9af9291b73bc5e27ecd949bec8157f20426d65b8
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 08:52:33 2010 -0700
+
+    Add the trampoline table generated by gentramp.sh
+
+commit 68ce0c383ece84f69945d1c8c3fed03f7f9cb5d6
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sun Sep 19 08:38:19 2010 -0700
+
+    Add a shell script that generates the ARM trampoline page.
+    
+    This generates a page of 340 trampolines, aligned within one page. The
+    trampolines use pc-relative addressing to reference config data
+    (context, jump address) from a page placed directly prior to the
+    trampoline page. This can be used on systems -- such as iOS -- that do not
+    support writable, executable memory by remapping the executable page
+    containing the trampolines directly above a newly allocated writable
+    config page.
+
+commit 75af086be8830a8eafe9b1ebda199d788bcb0c62
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 18:12:19 2010 -0700
+
+    Update autoconf files
+
+commit 1ac92cca9b02ef8d6a769f0de1adccd5c9630355
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 18:08:14 2010 -0700
+
+    Add autoconf check for W^X platforms that require a trampoline table.
+    
+    This adds the FFI_EXEC_TRAMPOLINE_TABLE. The flag is enabled for
+    arm-apple-darwin, where PROT_EXEC on writable (or formerly writable) pages is
+    not permitted for sandboxed binaries.
+
+commit be72fbab29b7190c702d8e1ac3d149855e95879d
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 18:02:25 2010 -0700
+
+    Use the correct host triple for arm/darwin
+
+commit 70150bdf4509269965c72f2032bf74f285767afe
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 16:38:03 2010 -0700
+
+    Add missing UNWIND entry; disables .pad on non-EABI targets.
+
+commit 6b452bafaec498df975ba8ac4c99de174e5f74f7
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 16:21:32 2010 -0700
+
+    Apple assembler support; fixed most gas/ELF-isms.
+
+commit 8ddac835b6f8b54ede764d0ea977dee4c82e2d67
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 15:38:06 2010 -0700
+
+    Fix placement of the __APPLE__ macro.
+
+commit 69043d02936bb0579ac59b4ee1ed8dec38c38db7
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 15:32:08 2010 -0700
+
+    Work-around libffi's FP ABI detection.
+    
+    On iOS, we must use the AAPCS floating point return value calling
+    conventions. libffi's ARM implementation will only use these conventions
+    if __SOFTFP__ is defined, which is not the case when GCC's
+    -mfloat-abi defaults to 'softfp' instead of 'soft'. To work around this
+    we manually define __SOFTFP__ for Apple platforms in the ARM-specific
+    sysv.S.
+    
+    See also:
+      http://developer.apple.com/library/ios/#documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html
+      http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042d/IHI0042D_aapcs.pdf
+
+commit a82e6c354ea805114642a6e440abd0832cb1d23f
+Author: Landon Fuller <landonf@bikemonkey.org>
+Date:   Sat Sep 18 14:44:24 2010 -0700
+
+    Add a stub iOS build script to drive autoconf
+
+commit 84e8de6e9fc19388f6f1102c013b7d0d52940ecc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Aug 6 01:35:12 2010 -0400
+
+    Restore execute permissions
+
+commit 3aeecc9eb1a6feba6549849cdd335c926415a4fc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 15:19:00 2010 -0400
+
+    Fix win64-struct-args patch
+
+commit 00d0b59cd13f89ab8b44bd894eb7f0a131fcb472
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 14:56:53 2010 -0400
+
+    Fix debug build for windows
+
+commit bda487e87064f27965155459a62dc52a744778d0
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 09:02:41 2010 -0400
+
+    Don't use -safeseh with ml64
+
+commit c1d28ba8d5029795af313ffeb81c97efc6d4c847
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 08:48:16 2010 -0400
+
+    stdcall-x86-closure-fix
+
+commit 5feacad4a56c85b3f23a267a30b2cf424cd59548
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 08:30:04 2010 -0400
+
+    define generic symbols carefully
+
+commit 10ea848900bc3018ac213cef52b44cacbe5cbebc
+Author: Anthony Green <green@moxielogic.com>
+Date:   Thu Aug 5 08:24:27 2010 -0400
+
+    don't copy win64 struct args
+
+commit d14178be4c49c3ada44a9fe9efe11d444372ddab
+Author: Anthony Green <green@moxielogic.com>
+Date:   Fri Jul 23 09:14:00 2010 -0400
+
+    FFI_LAST_ABI fix
+
+commit 3f5b1375ab1e2b8e3d593e21b27097a4a50f9b83
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Jul 12 14:39:18 2010 -0400
+
+    rebase
+
+commit eaf444eabc4c78703c0f98ac0197b1619c1b1bef
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sat Jul 10 08:59:09 2010 -0400
+
+    Fix selinux test
+
+commit 630974152247f100ece4d44f10c3721bb4599fbf
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Wed May 5 20:14:56 2010 -0400
+
+    Micharl Kohler's spelling fixes
+
+commit 9dc9a293f3d4589fcaf02dd4288c8cebaefa508e
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Apr 13 10:33:52 2010 -0400
+
+    Rebase to latest GCC sources
+
+commit f2c2a4fce9b3eca9f39b4f3545118bc256da4a73
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Apr 13 10:19:28 2010 -0400
+
+    Remove warnings and add OS/2 support
+
+commit c0b69e57d529e33d18b658cc5572a21e3663247c
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Mar 30 08:30:22 2010 -0400
+
+    Dan Witte's windows build fixes.
+
+commit 59a259f4d348f593b45f452309f4d020a28051c4
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Mon Mar 15 05:57:51 2010 -0400
+
+    Remove junk file
+
+commit 3de1eb36d37a66829e606421939874d0d60d816d
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Mon Mar 15 05:57:24 2010 -0400
+
+    fix-comments patch
+
+commit c3813b6d7f8a777700f4c5862190c0db148d4de8
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Jan 26 16:48:56 2010 -0500
+
+    Rebuild Makefiles with automake 1.11.1 for CVE-2009-4029.
+
+commit 8d27f68baa365bf883b6053c5f6bc819646d5434
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 15 11:35:37 2010 -0500
+
+    Mention recent changes in README
+
+commit ff3cd68b8cf2d9a28cad7aa9beff46236eacec8c
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 15 11:27:24 2010 -0500
+
+    Add msvc.sh wrapper
+
+commit cadeba6cb53414a1253582f1719c286665de7b6c
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 15 10:46:51 2010 -0500
+
+    Microsoft Visual C port
+
+commit 0739e7dc00db766eb64f502ec4137b817638c9a1
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 15 09:48:33 2010 -0500
+
+    Add x86 Sun Studio compiler support
+
+commit edfdfd2e85b8d01d2455934f1d7f4d7eb2f3cf1c
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Wed Jan 13 02:56:19 2010 -0500
+
+    Add closure example doc
+
+commit 7b7a42f221cf171e8d09df34cac6dc1fd8458cc3
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Jan 12 09:14:14 2010 -0500
+
+    Rebase from GCC
+
+commit 4b18d1f73dc7733137869e4ab5725cb90c1c8fde
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 1 10:24:27 2010 -0500
+
+    Add x86-64 MingW to README
+
+commit c3042afaf3f84abbbe9c91bf9bc9896b0d9eb003
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Jan 1 08:08:02 2010 -0500
+
+    Reset quilt patches post 3.0.9 merge with GCC
+
+commit b0304e9679bdfec6ac45a57b5c96542697249418
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 31 11:32:40 2009 -0500
+
+    Update version
+
+commit 2e7e03d014d9c9bf40e97ce75cba089ad052fa6b
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 31 07:43:22 2009 -0500
+
+    Final updates before 3.0.9
+
+commit aea706c52825c8eee677ffa7fdbdd3aed1725492
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Dec 29 10:09:31 2009 -0500
+
+    really 3.0.9rc12
+
+commit 0cfe60e9d13f132b88995cfee41f2156344f6fa2
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Tue Dec 29 10:06:04 2009 -0500
+
+    3.0.9rc12
+
+commit 14e2e92e8645804b6940b3e96c98e9f7f384a6b2
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sun Dec 27 21:03:33 2009 -0500
+
+    3.0.9rc11
+
+commit 884402787bf8eaf7ec207085037cf8ace2f660ec
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 12:57:23 2009 -0500
+
+    HPUX support and avr32 test fixes.
+
+commit 01c78756aff22efb1f122f8e93e068d7bf2185c7
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 10:05:18 2009 -0500
+
+    3.0.9rc9
+
+commit 70868464651320268d79c6894db5a50fdc11032a
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 09:58:03 2009 -0500
+
+    Remove xfails for mips and arm
+
+commit 838d4ad920ec85cf5ca3b511221d67f6d9a99024
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 09:57:27 2009 -0500
+
+    Remove a bunch of xfails.
+
+commit 7e37eaaf772f48906e69618c773b0a36c3927de9
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 07:46:50 2009 -0500
+
+    Fix huge_struct for solaris
+
+commit 07cc7a37194bc34064ebed7f2724333a798411c8
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 07:23:04 2009 -0500
+
+    3.0.9rc8
+
+commit 2b9be16ffabc81326128bc1bbdddff8ddc5d13d3
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 07:04:45 2009 -0500
+
+    3.0.9rc8
+
+commit 9458d88f676e9a21ab8993a54e16754b11687419
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 07:02:27 2009 -0500
+
+    Rebase from GCC
+
+commit 6a3412417593f068a04dc6163f4269cb295ad5ca
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Sat Dec 26 06:51:33 2009 -0500
+
+    Add Andreas Schwab's powerpc fix
+
+commit 39c8792ece1043f41f4c395a2ce71f4cf0ff4674
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 21:52:28 2009 -0500
+
+    3.0.9rc7
+
+commit 1d04af52e3e24db69f742064694c22f8df5cc70e
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 09:50:36 2009 -0500
+
+    Updated some mips XFAILs
+
+commit 26e9509c9b7929bc4fcf697071699051a652b1fd
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 02:19:23 2009 -0500
+
+    Clean up ChangeLog.libffi for older patches.
+
+commit 9c157d3215e4393777f83eb6fa801df6528f40d7
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 02:15:40 2009 -0500
+
+    Clean up undefine_AC_ARG_VAR_PRECIOUS patch.
+
+commit d22de05b0bfc480766bc1240615ce2830eee71b8
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 02:04:23 2009 -0500
+
+    Fix patches
+
+commit 1fe3dc7c20dc4dbd8fed0d19c8618027d44ed971
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 01:39:00 2009 -0500
+
+    Add windows support patch.
+
+commit f7c0bc613a88f7dbc2d18b345c10fa438833c170
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Fri Dec 25 01:22:11 2009 -0500
+
+    3.0.9rc6
+
+commit c7fa2da8260258c11ab1dc7ac06fb611a2c1b50f
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 24 07:22:44 2009 -0500
+
+    3.0.9rc6
+
+commit da11bece0fde66fc0268db3a01207dda857e25d2
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 24 05:34:46 2009 -0500
+
+    Release 3.0.9rc5
+
+commit e3399b11edeab546b066bfc18574f3edb905d0dc
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 24 01:09:32 2009 -0500
+
+    Update README
+
+commit 115ab36fceee69740a01ce49bc27e1908cc237b1
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Thu Dec 24 00:22:00 2009 -0500
+
+    Update missing changes for 3.0.9r4.
+
+commit f8c7a245bf5a80bd7e730ec03fcad17c8dcfcb07
+Author: Anthony Green <green@gmachine.(none)>
+Date:   Wed Dec 23 23:46:22 2009 -0500
+
+    Switch to quilt. Rebase to latest GCC.
+
+commit ce806772f02387b9a74f6496a263a368bccd5d59
+Merge: cd98813 dcc1f6b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 5 00:41:35 2009 -0400
+
+    Merge branch 'master' of git@github.com:atgreen/libffi
+
+commit dcc1f6b4f1ffd2713bf68b791a13f85d455c8b1b
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 5 00:29:33 2009 -0400
+
+    More clean up.
+
+commit 2829f5941a223b9d851d8ab6318318e6197d7e01
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 5 00:28:03 2009 -0400
+
+    Clean up
+
+commit cd98813de517ea64041637e3e78d27a001d6d3b4
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 5 00:25:29 2009 -0400
+
+    From Jens Rehsack.  Fix for 64-bit AIX.
+
+commit e4a91de766acc47f6c50f13cc11719a65e23ecba
+Author: Anthony Green <green@moxielogic.com>
+Date:   Mon Oct 5 00:16:17 2009 -0400
+
+    From Abdulaziz Ghuloum.  Adds special case for Snow Leopard.
+
+commit 3425a763bcdaadb8b430226f427ec833afdcc96a
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 4 23:57:29 2009 -0400
+
+    Fix detection of free/openbsd.  From Alexis Ballier.
+
+commit 2340e7a777902de61499d47823ad8d5e0eeb6203
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 4 23:53:17 2009 -0400
+
+    AVR support
+
+commit 5cbe2058c128e848446ae79fe15ee54260a90559
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 4 23:53:11 2009 -0400
+
+    Initial stand-alone patch.
+
+commit c6dddbd02bad9654ed58cdb0feb360934d105dec
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 4 08:11:33 2009 -0400
+
+    Initial commit
+
+commit 5ffc0c37486fb1538bccc0ca7acc807d4f1af932
+Author: Anthony Green <green@moxielogic.com>
+Date:   Sun Oct 4 07:58:22 2009 -0400
+
+    Update version to 3.0.9rc1.  Add more useful things to .gitignore.
+
+commit bd29f83ee9f6fa6b65adee9d3f57834f364d9887
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 29 12:07:26 2009 -0400
+
+    Add .gitignore
+
+commit 9474f853f83e3f0167c1b306177321bfcc93e56d
+Author: Anthony Green <green@moxielogic.com>
+Date:   Tue Sep 29 11:13:02 2009 -0400
+
+    Remove old CVSROOT files.
+
+commit 0c25275ec24bfe2c2c25a000465f0950ef9dd51b
+Author: twall <twall>
+Date:   Wed Aug 19 12:57:34 2009 +0000
+
+    Apply Dave Korn's cygwin/GCC changes
+
+commit 39228c27ed3f677a95b46380a8d31602b5777e1a
+Author: aph <aph>
+Date:   Tue Jun 16 18:00:47 2009 +0000
+
+    2009-06-16  Wim Lewis  <wiml@hhhh.org>
+    
+            * src/powerpc/ffi.c: Avoid clobbering cr3 and cr4, which are
+            supposed to be callee-saved.
+            * src/powerpc/sysv.S (small_struct_return_value): Fix overrun of
+            return buffer for odd-size structs.
+
+commit 5e93cc704d127c2c8ae7f5d2cef621145d43e777
+Author: aph <aph>
+Date:   Tue Jun 16 17:41:47 2009 +0000
+
+    2009-06-16  Andreas Tobler  <a.tobler@schweiz.org>
+    
+            PR libffi/40444
+            * testsuite/lib/libffi-dg.exp (libffi_target_compile): Add
+            allow_stack_execute for Darwin.
+
+commit b509af8959dc371b92392c623522ea6f4946a71d
+Author: aph <aph>
+Date:   Tue Jun 16 16:17:52 2009 +0000
+
+    2009-06-16  Andrew Haley  <aph@redhat.com>
+    
+            * configure.ac (TARGETDIR): Add missing blank lines.
+            * configure: Regenerate.
+
+commit d57e96dc56ee76fbbb9b59d73aeaa92354db5ecb
+Author: aph <aph>
+Date:   Tue Jun 16 09:59:02 2009 +0000
+
+    2009-06-16  Andrew Haley  <aph@redhat.com>
+    
+            * testsuite/libffi.call/cls_align_sint64.c,
+            testsuite/libffi.call/cls_align_uint64.c,
+            testsuite/libffi.call/cls_longdouble_va.c,
+            testsuite/libffi.call/cls_ulonglong.c,
+            testsuite/libffi.call/return_ll1.c,
+            testsuite/libffi.call/stret_medium2.c: Fix printf format
+            specifiers.
+            * testsuite/libffi.call/huge_struct.c: Ad x86 XFAILs.
+            * testsuite/libffi.call/float2.c: Fix dg-excess-errors.
+            * testsuite/libffi.call/ffitest.h,
+            testsuite/libffi.special/ffitestcxx.h (PRIdLL, PRIuLL): Define.
+
+commit b01d6d1982c9e020507029bfd5a58a8c60d111fa
+Author: aph <aph>
+Date:   Tue Jun 16 09:44:54 2009 +0000
+
+    2009-06-16  Andrew Haley  <aph@redhat.com>
+    
+            * testsuite/libffi.call/err_bad_typedef.c: xfail everywhere.
+            * testsuite/libffi.call/err_bad_abi.c: Likewise.
+
+commit 35b6ded138591900a88055a8a8ac1fadc29a76d6
+Author: aph <aph>
+Date:   Fri Jun 12 15:29:20 2009 +0000
+
+    2009-06-11  Kaz Kojima  <kkojima@gcc.gnu.org>
+    
+            * testsuite/libffi.call/cls_longdouble_va.c: Add xfail sh*-*-linux-*.
+            * testsuite/libffi.call/err_bad_abi.c: Add xfail sh*-*-*.
+            * testsuite/libffi.call/err_bad_typedef.c: Likewise.
+
+commit acc46605f2d95d67d69398e7644610f10a157ce3
+Author: aph <aph>
+Date:   Fri Jun 12 14:21:28 2009 +0000
+
+    2009-06-12  Andrew Haley  <aph@redhat.com>
+    
+            * ChangeLog.libffi: testsuite/libffi.call/cls_align_sint64.c,
+            testsuite/libffi.call/cls_align_uint64.c,
+            testsuite/libffi.call/cls_ulonglong.c,
+            testsuite/libffi.call/return_ll1.c,
+            testsuite/libffi.call/stret_medium2.c: Fix printf format
+            specifiers.
+            testsuite/libffi.special/unwindtest.cc: include stdint.h.
+
+commit 16d1996ed0797bd7c11aca2b0fe7e7748751aaf6
+Author: twall <twall>
+Date:   Thu Jun 11 14:27:42 2009 +0000
+
+    update changelog
+
+commit 92a515c33efe91be3cb0258f01c63aff208489c7
+Author: twall <twall>
+Date:   Thu Jun 11 14:27:28 2009 +0000
+
+    use ffi_closure_alloc instead of stack-based closure
+
+commit e4363160ba9e50167f9ca0a7399d537a1d2cd0ce
+Author: twall <twall>
+Date:   Thu Jun 11 14:26:23 2009 +0000
+
+    remove unused extern
+
+commit 1dc2781d2ba38f5f000ff70069d617fb21e1d2af
+Author: twall <twall>
+Date:   Thu Jun 11 11:36:16 2009 +0000
+
+    remove not-yet-applied changelog entries
+
+commit bb27735fe689dac97ec0dc847ed8d3d519620109
+Author: twall <twall>
+Date:   Wed Jun 10 10:42:36 2009 +0000
+
+    add win64 support
+
+commit b2a54c100c74854a409820817d54617fdda39eb8
+Author: aph <aph>
+Date:   Mon Jun 8 16:50:49 2009 +0000
+
+    2009-06-08  Andrew Haley  <aph@redhat.com>
+    
+            * testsuite/libffi.call/err_bad_abi.c: Add xfails.
+            * testsuite/libffi.call/cls_longdouble_va.c: Add xfails.
+            * testsuite/libffi.call/cls_dbls_struct.c: Add xfail x86_64-*-linux-*.
+            * testsuite/libffi.call/err_bad_typedef.c: Add xfails.
+    
+            * testsuite/libffi.call/stret_medium2.c: Add __UNUSED__ to args.
+            * testsuite/libffi.call/stret_medium.c: Likewise.
+            * testsuite/libffi.call/stret_large2.c: Likewise.
+            * testsuite/libffi.call/stret_large.c:  Likewise.
+
+commit 25723e7141f73d3736d7244b980c89d97db852b6
+Author: aph <aph>
+Date:   Fri Jun 5 13:03:40 2009 +0000
+
+    2009-06-05  Andrew Haley  <aph@redhat.com>
+    
+            * src/x86/win32.S (_ffi_closure_STDCALL): Import from gcc.
+
+commit 70758199c7cd41f411987360ccb302b497a56dc9
+Author: aph <aph>
+Date:   Thu Jun 4 16:29:58 2009 +0000
+
+     2009-06-04  Andrew Haley  <aph@redhat.com>
+    
+            * src/powerpc/ffitarget.h: Fix misapplied merge from gcc.
+
+commit e8bb12563f9aa23ddf36fa6a5b92b16b5c3e1a7f
+Author: aph <aph>
+Date:   Thu Jun 4 14:59:18 2009 +0000
+
+    2009-06-04  Andrew Haley  <aph@redhat.com>
+    
+            * src/mips/o32.S,
+            src/mips/n32.S: Fix licence formatting.
+
+commit d66a8e32c3671479e3ce0f6819673e5932ba6b7f
+Author: aph <aph>
+Date:   Thu Jun 4 14:43:40 2009 +0000
+
+    2009-06-04  Andrew Haley  <aph@redhat.com>
+    
+            * src/x86/darwin.S: Fix licence formatting.
+            src/x86/win32.S: Likewise.
+            src/sh64/sysv.S: Likewise.
+            src/sh/sysv.S: Likewise.
+
+commit 7c3b7fd6b5db746b5b09a718f3044f811372f941
+Author: aph <aph>
+Date:   Thu Jun 4 14:39:20 2009 +0000
+
+    2009-06-04  Andrew Haley  <aph@redhat.com>
+    
+            * src/sh64/ffi.c: Remove lint directives.  Was missing from merge
+            of Andreas Tobler's patch from 2006-04-22.
+
+commit 1a2f93a8b362db13638afd9fcb3f2650180bfa17
+Author: aph <aph>
+Date:   Thu Jun 4 10:45:51 2009 +0000
+
+    2009-06-04  Andrew Haley  <aph@redhat.com>
+    
+            * src/sh/ffi.c: Apply missing hunk from Alexandre Oliva's patch of
+            2007-03-07.
+
+commit 944c95cf7aaaaf7c5fa368cda4673dd38f45020e
+Author: aph <aph>
+Date:   Wed Jun 3 17:42:56 2009 +0000
+
+    2009-05-22  Dave Korn  <dave.korn.cygwin@gmail.com>
+    
+           * src/x86/win32.S (_ffi_closure_STDCALL):  New function.
+           (.eh_frame):  Add FDE for it.
+    
+    2009-05-22  Dave Korn  <dave.korn.cygwin@gmail.com>
+    
+           * configure.ac:  Also check if assembler supports pc-relative
+           relocs on X86_WIN32 targets.
+           * configure:  Regenerate.
+           * src/x86/win32.S (ffi_prep_args):  Declare extern, not global.
+           (_ffi_call_SYSV):  Add missing function type symbol .def and
+           add EH markup labels.
+           (_ffi_call_STDCALL):  Likewise.
+           (_ffi_closure_SYSV):  Likewise.
+           (_ffi_closure_raw_SYSV):  Likewise.
+           (.eh_frame):  Add hand-crafted EH data.
+    
+    2008-11-21  Eric Botcazou  <ebotcazou@adacore.com>
+    
+           * src/sparc/ffi.c (ffi_prep_cif_machdep): Add support for
+           signed/unsigned int8/16 return values.
+           * src/sparc/v8.S (ffi_call_v8): Likewise.
+           (ffi_closure_v8): Likewise.
+    
+    2008-03-26  Kaz Kojima  <kkojima@gcc.gnu.org>
+    
+           * src/sh/sysv.S: Add .note.GNU-stack on Linux.
+           * src/sh64/sysv.S: Likewise.
+    
+    2008-03-26  Daniel Jacobowitz  <dan@debian.org>
+    
+           * src/arm/sysv.S: Fix ARM comment marker.
+
+commit 00fa972430bb1535a4b34bf029ebcad500027b0c
+Author: twall <twall>
+Date:   Sat Dec 27 16:59:05 2008 +0000
+
+    properly glob-match
+
+commit f5179e6794ac35af26fe86e468b8508a7a570c55
+Author: twall <twall>
+Date:   Fri Dec 26 19:06:28 2008 +0000
+
+    Mark XFAIL on longdouble tests for x86_64/mingw
+
+commit 80e2b5a749208c8a18f994ec5bee84594d051cc8
+Author: twall <twall>
+Date:   Mon Dec 22 15:21:15 2008 +0000
+
+    clean up tests for win64 use
+
+commit 7063d9996f742576095c7b0eb5016c0f9a670aec
+Author: green <green>
+Date:   Fri Dec 19 16:13:46 2008 +0000
+
+    Version 3.0.8 with x86-solaris support
+
+commit bdfeb13f0df0a63b19d62597517237b54d92228b
+Author: green <green>
+Date:   Fri Dec 19 15:47:44 2008 +0000
+
+    Bump to 3.0.7
+
+commit 69205de17d6ac4c11d4ba92d6a5b40a0c5f246b2
+Author: green <green>
+Date:   Thu Jul 24 18:03:48 2008 +0000
+
+    Many test fixes (failures due to excessive compiler warnings).
+
+commit 260d513fea00b3613fe957a44a157fe72c4ca29e
+Author: green <green>
+Date:   Thu Jul 17 13:13:52 2008 +0000
+
+    Version 3.0.6.  sh/sh64 fixes.
+
+commit 3704031875feabb74e3655ed03cff4c2b3c76ac6
+Author: green <green>
+Date:   Thu Apr 3 18:57:57 2008 +0000
+
+    Rev 3.0.5.
+
+commit 8406f5f48f7f58a1c982a93a95d521cf82b3241f
+Author: green <green>
+Date:   Thu Apr 3 18:57:34 2008 +0000
+
+    3.0.5
+
+commit 23a9e73212b62f9684cedb0ce70e92c59cfdaffa
+Author: green <green>
+Date:   Wed Mar 5 00:07:02 2008 +0000
+
+    2008-03-04  Anthony Green  <green@redhat.com>
+                Blake Chaffin
+                hos@tamanegi.org
+    
+            * testsuite/libffi.call/cls_align_longdouble_split2.c
+              testsuite/libffi.call/cls_align_longdouble_split.c
+              testsuite/libffi.call/cls_dbls_struct.c
+              testsuite/libffi.call/cls_double_va.c
+              testsuite/libffi.call/cls_longdouble.c
+              testsuite/libffi.call/cls_longdouble_va.c
+              testsuite/libffi.call/cls_pointer.c
+              testsuite/libffi.call/cls_pointer_stack.c
+              testsuite/libffi.call/err_bad_abi.c
+              testsuite/libffi.call/err_bad_typedef.c
+              testsuite/libffi.call/huge_struct.c
+              testsuite/libffi.call/stret_large2.c
+              testsuite/libffi.call/stret_large.c
+              testsuite/libffi.call/stret_medium2.c
+              testsuite/libffi.call/stret_medium.c: New tests from Apple.
+
+commit 429e37d3ad653e52e75bf725c883ab79e859f89a
+Author: green <green>
+Date:   Thu Feb 28 04:50:19 2008 +0000
+
+    clicky
+
+commit 51e79c428348c033314f54bcb30f7e388c59e347
+Author: green <green>
+Date:   Thu Feb 28 04:47:35 2008 +0000
+
+    getclicky
+
+commit affcab04e280efeace45a72c4dc6152c0e4f1b7f
+Author: green <green>
+Date:   Tue Feb 26 19:01:53 2008 +0000
+
+    2008-02-26  Jakub Jelinek  <jakub@redhat.com>
+                Anthony Green  <green@redhat.com>
+    
+            * src/alpha/osf.S: Add .note.GNU-stack on Linux.
+            * src/s390/sysv.S: Likewise.
+            * src/powerpc/linux64.S: Likewise.
+            * src/powerpc/linux64_closure.S: Likewise.
+            * src/powerpc/ppc_closure.S: Likewise.
+            * src/powerpc/sysv.S: Likewise.
+            * src/x86/unix64.S: Likewise.
+            * src/x86/sysv.S: Likewise.
+            * src/sparc/v8.S: Likewise.
+            * src/sparc/v9.S: Likewise.
+            * src/m68k/sysv.S: Likewise.
+            * src/ia64/unix.S: Likewise.
+            * src/arm/sysv.S: Likewise.
+
+commit 59689d5522c159a3ac967adb6b891cf5f22c890f
+Author: green <green>
+Date:   Tue Feb 26 17:40:51 2008 +0000
+
+    2008-02-26  Anthony Green  <green@redhat.com>
+                Thomas Heller  <theller@ctypes.org>
+    
+            * src/x86/ffi.c (ffi_closure_SYSV_inner): Change C++ comment to C
+            comment.
+
+commit b13c84cf4668828ff8429ba4a2f94cd1eb574ae0
+Author: green <green>
+Date:   Tue Feb 26 17:38:15 2008 +0000
+
+    2008-02-26  Anthony Green  <green@redhat.org>
+                Thomas Heller <theller@ctypes.org>
+    
+            * include/ffi.h.in: Change void (*)() to void (*)(void).
+
+commit 265289f679ffd24a88ae1aa2cef0e4aa14703cd8
+Author: green <green>
+Date:   Tue Feb 26 17:34:36 2008 +0000
+
+    2008-02-26  Anthony Green  <green@spindazzle.org>
+    
+            * src/alpha/ffi.c: Change void (*)() to void (*)(void).
+            src/alpha/osf.S, src/arm/ffi.c, src/frv/ffi.c, src/ia64/ffi.c,
+            src/ia64/unix.S, src/java_raw_api.c, src/m32r/ffi.c,
+            src/mips/ffi.c, src/pa/ffi.c, src/pa/hpux32.S, src/pa/linux.S,
+            src/powerpc/ffi.c, src/powerpc/ffi_darwin.c, src/raw_api.c,
+            src/s390/ffi.c, src/sh/ffi.c, src/sh64/ffi.c, src/sparc/ffi.c,
+            src/x86/ffi.c, src/x86/unix64.S, src/x86/darwin64.S,>         src/x86/ffi64.c: Ditto.
+
+commit fb5036cd6d0f909918e90f7d2d9fd80d46682d5d
+Author: green <green>
+Date:   Sun Feb 24 17:25:25 2008 +0000
+
+    fix date
+
+commit 40bec108e7d0181e6c9928aa7a33187bcc0f3d6f
+Author: green <green>
+Date:   Sun Feb 24 17:25:02 2008 +0000
+
+    New release
+
+commit b922048fa82ea109a4af269ee47bbc2a586bbac2
+Author: green <green>
+Date:   Sun Feb 24 17:24:00 2008 +0000
+
+    2008-02-24  Anthony Green  <green@spindazzle.org>
+    
+            * configure.ac: Accept openbsd*, not just openbsd.
+            Bump version to 3.0.4.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+            * libtool-version: Increment revision.
+            * README: Update for new release.
+
+commit affca4b92d06e5554784c7e9b233029ef83f7d8a
+Author: green <green>
+Date:   Fri Feb 22 21:53:29 2008 +0000
+
+    sync readme with web page.
+
+commit 3e53d8752ea74859b4c64fbbf935e62a937c4d78
+Author: green <green>
+Date:   Fri Feb 22 21:52:38 2008 +0000
+
+    New release
+
+commit 4d92f6c8e78fe084be65f3e8b58b859901ba796d
+Author: green <green>
+Date:   Fri Feb 22 21:49:46 2008 +0000
+
+    2008-02-22  Anthony Green  <green@redhat.com>
+    
+            * configure.ac: Bump version to 3.0.3.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+            * libtool-version: Increment revision.
+            * README: Update for new release.  Clean up test docs.
+
+commit 0e185fa11a01f816824ba2687ed3715ab6219bef
+Author: green <green>
+Date:   Fri Feb 22 21:43:18 2008 +0000
+
+    Update configure script.
+
+commit f73986bd211cfbbaa593d1309504d0dc68626191
+Author: green <green>
+Date:   Fri Feb 22 21:40:53 2008 +0000
+
+    2008-02-22  Bjoern Koenig  <bkoenig@alpha-tierchen.de>
+                Andreas Tobler  <a.tobler@schweiz.org>
+    
+            * configure.ac: Add amd64-*-freebsd* target.
+            * configure: Regenerate.
+
+commit 0208f68fe5de30c33e7f70ebc281635917013f5a
+Author: green <green>
+Date:   Fri Feb 22 21:15:44 2008 +0000
+
+    2008-02-22  Thomas Heller <theller@ctypes.org>
+    
+            * configure.ac: Add x86 OpenBSD support.
+            * configure: Rebuilt.
+
+commit 01adb0e638a86cf0d5e668ed8e08be9b0cd2505f
+Author: green <green>
+Date:   Thu Feb 21 16:17:26 2008 +0000
+
+    Fix README.
+
+commit 1edd4563225981a14f7d4fb9919b1ed88e38082f
+Author: green <green>
+Date:   Thu Feb 21 13:39:01 2008 +0000
+
+    3.0.2
+
+commit c9b542800864e2204db6e83f3843a17813ba6165
+Author: green <green>
+Date:   Thu Feb 21 13:36:43 2008 +0000
+
+    add missing file
+
+commit d5fa5633d5c8d3c212a2267cfa38fba4091baa2c
+Author: green <green>
+Date:   Thu Feb 21 13:36:19 2008 +0000
+
+    2008-02-21  Anthony Green  <green@redhat.com>
+    
+            * configure.ac: Bump version to 3.0.2.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+            * libtool-version: Increment revision.
+            * README: Update for new release.
+    
+    2008-02-21  Björn König <bkoenig@alpha-tierchen.de>
+    
+            * src/x86/freebsd.S: New file.
+            * configure.ac: Add x86 FreeBSD support.
+            * Makefile.am: Ditto.
+
+commit ac35bfc6fcadd8880c1efce36724820f9074b318
+Author: green <green>
+Date:   Sat Feb 16 01:03:56 2008 +0000
+
+    Updated
+
+commit f7942975fee7b0162647dd79e2652615b737e98e
+Author: green <green>
+Date:   Sat Feb 16 01:02:00 2008 +0000
+
+    2008-02-15  Anthony Green  <green@redhat.com>
+    
+            * configure.ac: Bump version to 3.0.1.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+            * libtool-version: Increment revision.
+            * README: Update for new release.
+    
+    2008-02-15  David Daney  <ddaney@avtrex.com>
+    
+            * src/mips/ffi.c: Remove extra '>' from include directive.
+            (ffi_prep_closure_loc): Use clear_location instead of tramp.
+
+commit 59aa6bb1bfc86a610ac1a8b123443efd75854dd1
+Author: green <green>
+Date:   Fri Feb 15 20:52:26 2008 +0000
+
+    Add more platforms.
+
+commit 45a45ab99074448be0ae1a8d2ade50d28b60f8de
+Author: green <green>
+Date:   Fri Feb 15 19:16:36 2008 +0000
+
+    3.0 notes
+
+commit 4db74cbea888c9f1251b85baf00d99b83d3b994d
+Author: green <green>
+Date:   Fri Feb 15 19:10:26 2008 +0000
+
+    Update
+
+commit c3e1101ffabf44d8a2ee46e03ba9ab582050a825
+Author: green <green>
+Date:   Fri Feb 15 18:43:40 2008 +0000
+
+    2008-02-15  Anthony Green  <green@redhat.com>
+    
+            * configure.ac: Bump version to 3.0.0,
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+    
+    2008-02-15  David Daney  <ddaney@avtrex.com>
+    
+            * src/mips/ffi.c (USE__BUILTIN___CLEAR_CACHE):
+            Define (conditionally), and use it to include cachectl.h.
+            (ffi_prep_closure_loc): Fix cache flushing.
+            * src/mips/ffitarget.h (_ABIN32, _ABI64, _ABIO32): Define.
+
+commit 7e0cc12e9233ad285db41ce8dbdda61ed2a7fb06
+Author: green <green>
+Date:   Fri Feb 15 15:51:03 2008 +0000
+
+    New release
+
+commit 2d7dc885ec40d53866f29984d595511942c8b686
+Author: green <green>
+Date:   Fri Feb 15 15:30:26 2008 +0000
+
+            * man/ffi_call.3, man/ffi_prep_cif.3, man/ffi.3:
+            Update dates and remove all references to ffi_prep_closure.
+            * configure.ac: Bump version to 2.99.9.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+commit a0525f03eeaaed33b1eac80e0c016455cee3615d
+Author: green <green>
+Date:   Fri Feb 15 15:14:30 2008 +0000
+
+    New release.
+
+commit 2b30dfb3146ee26ad956d00ee05eb835ca1a95b4
+Author: green <green>
+Date:   Fri Feb 15 15:12:43 2008 +0000
+
+            * man/ffi_prep_closure.3: Delete.
+            * man/Makefile.am (EXTRA_DIST): Remove ffi_prep_closure.3.
+            (man_MANS): Ditto.
+            * man/Makefile.in: Rebuilt.
+            * configure.ac: Bump version to 2.99.8.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+commit bf41e64840ebcb6cc31a6f028253c1fde82705d8
+Author: green <green>
+Date:   Fri Feb 15 01:56:50 2008 +0000
+
+    Update.
+
+commit 4d39ddee677bbb61d621893b91e11eac5e7c4af7
+Author: green <green>
+Date:   Fri Feb 15 01:24:06 2008 +0000
+
+    * configure.ac: Bump version to 2.99.7.
+            * configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+            * include/ffi.h.in LICENSE src/debug.c src/closures.c
+              src/ffitest.c src/s390/sysv.S src/s390/ffitarget.h
+              src/types.c src/m68k/ffitarget.h src/raw_api.c src/frv/ffi.c
+              src/frv/ffitarget.h src/sh/ffi.c src/sh/sysv.S
+              src/sh/ffitarget.h src/powerpc/ffitarget.h src/pa/ffi.c
+              src/pa/ffitarget.h src/pa/linux.S src/java_raw_api.c
+              src/cris/ffitarget.h src/x86/ffi.c src/x86/sysv.S
+              src/x86/unix64.S src/x86/win32.S src/x86/ffitarget.h
+              src/x86/ffi64.c src/x86/darwin.S src/ia64/ffi.c
+              src/ia64/ffitarget.h src/ia64/ia64_flags.h src/ia64/unix.S
+              src/sparc/ffi.c src/sparc/v9.S src/sparc/ffitarget.h
+              src/sparc/v8.S src/alpha/ffi.c src/alpha/ffitarget.h
+              src/alpha/osf.S src/sh64/ffi.c src/sh64/sysv.S
+              src/sh64/ffitarget.h src/mips/ffi.c src/mips/ffitarget.h
+              src/mips/n32.S src/mips/o32.S src/arm/ffi.c src/arm/sysv.S
+              src/arm/ffitarget.h src/prep_cif.c: Update license text.
+
+commit d58b032b41a12bd3d72148da6822ab59dd698ff9
+Author: green <green>
+Date:   Fri Feb 15 00:59:25 2008 +0000
+
+    New release
+
+commit 91e5478df6d5ac63efbb10f025807b4606afab56
+Author: green <green>
+Date:   Fri Feb 15 00:50:30 2008 +0000
+
+    Update supported platforms.  Bump version.
+
+commit bd0768f877c8f7fd0d36af2191b203d4d057b1ce
+Author: green <green>
+Date:   Fri Feb 15 00:45:33 2008 +0000
+
+    * configure.ac: Bump version to 2.99.5.
+            * configure: Rebuilt.
+            * Makefile.am (EXTRA_DIST): Add darwin64.S
+            * Makefile.in: Rebuilt.
+            * testsuite/lib/libffi-dg.exp: Remove libstdc++ bits from GCC tree.
+            * LICENSE: Update WARRANTY.
+
+commit 49d345f767bd2cfee951bceaab6a1a07986cf293
+Author: green <green>
+Date:   Thu Feb 14 23:43:27 2008 +0000
+
+    update license reference
+
+commit 12ac48fc79b515db7c9accd9fcaa87b0dcefccdb
+Author: green <green>
+Date:   Thu Feb 14 23:42:08 2008 +0000
+
+    Update WARRANTY
+
+commit 6b91c41da87e78552f2990dfc504a0a3349f340b
+Author: green <green>
+Date:   Thu Feb 14 23:38:27 2008 +0000
+
+    fix tarball reference
+
+commit 2b59579e3533334bee4788e076b4e520c2ab518c
+Author: green <green>
+Date:   Thu Feb 14 23:35:58 2008 +0000
+
+    First update in 5 years!
+
+commit 6cbdf3f3a3777a93382a2d508ddef1c353ff0955
+Author: green <green>
+Date:   Thu Feb 14 22:44:06 2008 +0000
+
+    Fix .pc file bug and bump version
+
+commit 1d1dc81104b209df3cfef0840735c59efae2f655
+Author: green <green>
+Date:   Thu Feb 14 22:03:37 2008 +0000
+
+    Add man files and info file. Update README.  Tag as 2.99.3.
+
+commit f045a2367f793fa8b01534cf2e25bcc46afc8fa1
+Author: tromey <tromey>
+Date:   Thu Feb 14 20:46:57 2008 +0000
+
+    Move entry from ChangeLog to ChangeLog.libffi
+
+commit 6257f07d1a9efd27fa83639cfba281f5d3188731
+Author: tromey <tromey>
+Date:   Thu Feb 14 20:33:17 2008 +0000
+
+            * aclocal.m4, Makefile.in, configure, fficonfig.h.in: Rebuilt.
+            * mdate-sh, texinfo.tex: New files.
+            * Makefile.am (info_TEXINFOS): New variable.
+            * doc/libffi.texi: New file.
+            * doc/version.texi: Likewise.
+
+commit 4232af563c5509c3760a33e3684a2b958be755e1
+Author: green <green>
+Date:   Thu Feb 14 16:19:21 2008 +0000
+
+            * Makefile.am (AM_CFLAGS): Don't compile with -D.
+            (lib_LTLIBRARIES): Define.
+            (toolexeclib_LIBRARIES): Undefine.
+            * Makefile.in: Rebuilt.
+            * configure.ac: Reset version to 2.99.1.
+            * configure.in: Rebuilt.
+
+commit 961543615c31f092b578a4b4cda914db64f9d0fa
+Author: green <green>
+Date:   Thu Feb 14 15:57:40 2008 +0000
+
+    Fix typo.
+
+commit aeb0abab87222f637fbf352d4effd3b76b52ed26
+Author: green <green>
+Date:   Thu Feb 14 15:54:27 2008 +0000
+
+          * libffi.pc.in: Usse @PACKAGE_NAME@ and @PACKAGE_VERSION@.
+            * configure.ac: Reset version to 2.99.1.
+            * configure.in: Rebuilt.
+            * Makefile.am (EXTRA_DIST): Add ChangeLog.libffi.
+            * Makefile.in: Rebuilt.
+            * LICENSE: Update copyright notice.
+
+commit 77fe243556433eae119d8bd7469bfccdd5bd8a1a
+Author: green <green>
+Date:   Thu Feb 14 15:37:00 2008 +0000
+
+    Fix make dist again
+
+commit d4970cf4529459bf0f0e43c602cac396786c6802
+Author: green <green>
+Date:   Thu Feb 14 15:18:56 2008 +0000
+
+    Fix make dist
+
+commit f0b1462f2d3024922ad71421bd5c4311fcb16da5
+Author: green <green>
+Date:   Thu Feb 14 15:01:41 2008 +0000
+
+    Use pkgconfig.  Increment libtool CURRENT version.
+
+commit 27e52f33baa069012a5adb2a3807f9ca1f2165ab
+Author: green <green>
+Date:   Sun Feb 3 13:59:48 2008 +0000
+
+    Fix header installs when using DESTDIR.
+
+commit fadab28eb6e33fb6dcdd7b9323e147142216d548
+Author: twall <twall>
+Date:   Sun Feb 3 12:32:22 2008 +0000
+
+    update changelog
+
+commit b5e44c8dfa92c87b99762c303cf5574a16db8f27
+Author: twall <twall>
+Date:   Sun Feb 3 01:12:32 2008 +0000
+
+    offset from code base address, not data base address
+
+commit f359848d1a995c0e44566d815f218729dc996e22
+Author: green <green>
+Date:   Fri Feb 1 21:29:43 2008 +0000
+
+    Fix header installs.
+
+commit c30df49e157c7bfc8e19e3f8a72b9464fe225e54
+Author: green <green>
+Date:   Fri Feb 1 21:13:55 2008 +0000
+
+    Revert my broken changes to twall's patch.
+
+commit 675561bb9aa0732c76698df10dd3007b5d0ec759
+Author: green <green>
+Date:   Thu Jan 31 13:44:25 2008 +0000
+
+    Fix make dist .
+
+commit abc0bbf3813dc43e23d4c23e6fe794dbf287639b
+Author: green <green>
+Date:   Thu Jan 31 11:58:57 2008 +0000
+
+    Add Tim Wall's x86 windows patch.
+
+commit e332366d15a31198735b593ec8f7fc0558d783b8
+Author: green <green>
+Date:   Wed Jan 30 13:21:02 2008 +0000
+
+    Add HJ's -fomit-frame-pointer struct return fix
+
+commit d4204240392af5b7750a08671b08e9c22dff5e93
+Author: green <green>
+Date:   Wed Jan 30 12:42:34 2008 +0000
+
+    Clean up for new automake.
+
+commit f4932dd020df574637c9fb3fc1bb18e5a8f304cc
+Author: green <green>
+Date:   Wed Jan 30 12:40:25 2008 +0000
+
+    Fixes to run testsuite
+
+commit 085520ddc8db6a916bfc416b871fcb2d00074d40
+Author: green <green>
+Date:   Tue Jan 29 15:16:43 2008 +0000
+
+    New files from gcc tree.
+
+commit 77175b3f7234e4875a4ef554ed1fe9fdc4133794
+Author: green <green>
+Date:   Tue Jan 29 15:15:20 2008 +0000
+
+    Latest gcc svn sources
+
+commit 2544e45a0b2b634053df02da3a2ed9680eeed2a1
+Author: green <green>
+Date:   Tue Jan 29 14:28:13 2008 +0000
+
+    Install ffitarget.h in $prefix/include.
+
+commit 6002211b1cc4daeb587d054b4f83968bda2c981e
+Author: green <green>
+Date:   Tue Jan 29 12:30:10 2008 +0000
+
+    Add new files.
+
+commit ccabd2b16be883cd03e5f0cd88ccfdd6ca39239d
+Author: green <green>
+Date:   Tue Jan 29 12:28:15 2008 +0000
+
+    Merge from gcc
+
+commit e680ecfbfca1da8d1823e48bc89b8375e66e128b
+Author: tromey <tromey>
+Date:   Sun Dec 24 23:12:15 2006 +0000
+
+    Pulled in libffi from gcc trunk.
+    Fixed build and install for standalone use.
+
+commit e7ba08965942ce872fdbc69f70f9848cc3d0bad6
+Author: root <root>
+Date:   Sun Jun 4 23:22:24 2006 +0000
+
+    sourcware.org
+
+commit 0cd4aa24e21aaa964dfbdebc25ec5c8188049375
+Author: root <root>
+Date:   Sun May 30 01:51:57 2004 +0000
+
+    Add LockDir
+
+commit 5826120fbd940d26cca76ed2522187505581e1ed
+Author: green <green>
+Date:   Tue Nov 4 06:09:08 2003 +0000
+
+    Add link to Gianni's web site.
+
+commit 220aa4b27db42d7ffaac5056000d5179f00d5ea3
+Author: jsm <jsm>
+Date:   Tue Jan 21 08:07:42 2003 +0000
+
+    Newer, better, increased from before!  (list of acceptable anon usernames)
+
+commit 1c3adc892cc1403dc4d3d7003a2385899836612e
+Author: green <green>
+Date:   Fri Dec 6 01:28:03 2002 +0000
+
+    Fixed Cygnus references.
+
+commit 4af66bb62fab9a8e318af3bf01e5486596a0c8d4
+Author: green <green>
+Date:   Sun Oct 21 19:18:42 2001 +0000
+
+    Testsuite fixes.
+
+commit 5435965f9015ce40584c98d3816c3d05e7de1d21
+Author: green <green>
+Date:   Mon Apr 23 00:32:03 2001 +0000
+
+            * include/ffi_common.h: Delete, after moving contents to...
+            * include/ffi_private.h: Subsume contents of ffi_common.h.
+            * include/Makefile.am (noinst_HEADERS): Remove ffi_common.h.
+            * include/Makefile.in: Rebuilt.
+            * arm/ffi.c, m68k/ffi.c, mips/ffi.c, powerpc/ffi.c, s390/ffi.c,
+            ia64/ffi.c: Include ffi_private.h, not ffi_common.h.
+            * alpha/ffi.c, sparc/ffi.c, x86/ffi.c: Don't include ffi_common.h.
+            * types.c, raw_api.c, java_raw_api.c, prep_cif.c: Don't include
+            ffi_common.h.
+            * debug.c: Include ffi_private.h instead of ffi_common.h.
+    
+            * mips/ffi.c (calc_n32_struct_flags): Make static.
+            (FIX_ARGP): Remove call to debugging routine ffi_stop_here.
+    
+            * mips/n32.S: Include ffi_private.h.
+            * mips/o32.S: Include ffi_private.h.
+
+commit 6fdb7de0fe3b7385e1fd78812ae69d9b3069d994
+Author: green <green>
+Date:   Sun Apr 22 19:38:34 2001 +0000
+
+            * README: Update some comments.
+    
+            * Makefile.am (SUBDIRS): Add include so ffi.h gets installed.
+            * Makefile.in: Rebuilt.
+    
+            * include/ffi.h: Change ALPHA to __alpha__ and SPARC to __sparc__.
+            * types.c: Ditto.
+            * prep_cif.c (ffi_prep_cif): Ditto.
+    
+            * alpha/ffi.c, alpha/osf.S, sparc/ffi.c, sparc/v8.S, sparc/v9.S:
+            Include ffi_private.h.
+    
+            * include/ffi_private.h (FFI_TYPE_LAST): Define.
+
+commit bc7144b01b9707ef35f1a2e3e6996e005e82953a
+Author: green <green>
+Date:   Sun Apr 22 18:28:36 2001 +0000
+
+    Moved files from old home
+
+commit e57279831e20368c1aa1d2b35462b8629be73959
+Author: green <green>
+Date:   Sun Apr 22 18:23:47 2001 +0000
+
+    These are dead.
+
+commit 7247436b5fe71767b29dc02b4da0fe18b08082e6
+Author: green <green>
+Date:   Sun Apr 22 18:22:43 2001 +0000
+
+    All these files live somewhere else now.
+
+commit a8b0d40ff908e275028f676870c31d0d70274a98
+Author: green <green>
+Date:   Sun Apr 22 18:17:14 2001 +0000
+
+    Many changes.  Not quite there yet.
+
+commit f893d2273355710a290a26faebf5f12c3a34d0e3
+Author: green <green>
+Date:   Sun Apr 22 18:13:22 2001 +0000
+
+    Moved m68k files
+
+commit 688ddfeced89cbb9d37b53005e1f7f2b9c78a8d7
+Author: green <green>
+Date:   Sun Apr 22 18:12:33 2001 +0000
+
+    New, target indepentent, header
+
+commit f9e40776d488d5ecf43b3ae21444a1a2f6eca528
+Author: green <green>
+Date:   Sun Apr 22 18:11:57 2001 +0000
+
+    Many changes.
+
+commit 8c1d2eb47f6bc314c431b75c85c107e8e43c4a76
+Author: green <green>
+Date:   Sun Apr 22 18:10:47 2001 +0000
+
+    Many changes
+
+commit 1359dfc6582680a158b3caa3efb7a368da4aa12d
+Author: green <green>
+Date:   Sun Apr 22 18:10:20 2001 +0000
+
+    Moved ia64 files
+
+commit 6e2de5eee316a4579869aff50c7c5f6f478582d8
+Author: green <green>
+Date:   Sun Apr 22 18:08:11 2001 +0000
+
+    Moved arm files
+
+commit 8807355af34cba8ffe87aee51152dfccec2771fa
+Author: green <green>
+Date:   Mon Apr 9 00:58:38 2001 +0000
+
+    Many many updates.  Merge from gcc and then some.
+
+commit f7e9f91adec4ff1c2e7a13b3de81d2c5a3f55e7e
+Author: green <green>
+Date:   Mon Apr 17 03:32:37 2000 +0000
+
+    Mnay fixes.
+
+commit c4860de618f4956283f5c8230a2544e403dfe390
+Author: green <green>
+Date:   Mon Apr 17 03:18:46 2000 +0000
+
+    Merge from libgcj.  Merged patches from net.  See ChangeLog for details.
+
+commit c578b58314990c3853429297c38ba14015fec5fa
+Author: jsm <jsm>
+Date:   Sat Oct 9 20:18:16 1999 +0000
+
+    1999-10-09  Jason Molenda  (jsm@bugshack.cygnus.com)
+    
+            * CVSROOT/auto_checkout, CVSROOT/commit_prep, CVSROOT/log_accum:
+            Deleted; generic versions now used for all repositories.
+    
+            * CVSROOT/commitinfo, CVSROOT/loginfo:  Change pathnames to
+            generic versions.
+    
+            * CVSROOT/checkoutlist:  Don't try to check out the removed
+            files any longer.
+
+commit acdb20051207fed7652dd9f122f65de5458c474c
+Author: jsm <jsm>
+Date:   Sat Oct 9 20:18:15 1999 +0000
+
+    1999-10-09  Jason Molenda  (jsm@bugshack.cygnus.com)
+    
+            * CVSROOT/auto_checkout, CVSROOT/commit_prep, CVSROOT/log_accum:
+            Deleted; generic versions now used for all repositories.
+    
+            * CVSROOT/commitinfo, CVSROOT/loginfo:  Change pathnames to
+            generic versions.
+    
+            * CVSROOT/checkoutlist:  Don't try to check out the removed
+            files any longer.
+
+commit e75be655ceedf7ab24c4e99d75eec9efeb979bc7
+Author: green <green>
+Date:   Sun Aug 8 13:16:41 1999 +0000
+
+    New configury
+
+commit d6669a0dd5b266005325bbf6d5a8ff34574d809e
+Author: green <green>
+Date:   Sun Aug 8 13:05:12 1999 +0000
+
+            * include/ffi.h.in: Try to work around messy header problem
+            with PACKAGE and VERSION.
+    
+            * configure: Rebuilt.
+            * configure.in: Change version to 2.00-beta.
+    
+            * fficonfig.h.in: Rebuilt.
+            * acconfig.h (FFI_NO_STRUCTS, FFI_NO_RAW_API): Define.
+    
+            * src/x86/ffi.c (ffi_raw_call): Rename.
+
+commit 4819d52b007934a40d6d29a75ee30e857c4a93ae
+Author: green <green>
+Date:   Wed Aug 4 18:02:34 1999 +0000
+
+    New file for Kresten's closure work
+
+commit 2dbf801eb427cbf5021a9e1e512b5fc523524700
+Author: green <green>
+Date:   Wed Aug 4 18:00:05 1999 +0000
+
+    Kresten's closure work. Initial checkin.
+
+commit d170961701b0f2bf7e824d7caba2ebe10002ed84
+Author: green <green>
+Date:   Thu Jul 8 14:36:52 1999 +0000
+
+            * configure.in: Add x86 and powerpc BeOS configurations.
+            From Makoto Kato <m_kato@ga2.so-net.ne.jp>.
+
+commit c7747d976924ec6f2229cbcfbbdb98d364e10de9
+Author: jsm <jsm>
+Date:   Wed May 12 23:32:16 1999 +0000
+
+    1999-05-12  Jason Molenda  (jsm@bugshack.cygnus.com)
+            * index.html: Add links to libffi* mail list archives.
+
+commit dd2aa9a8de22e26df3bbc85d068358641f6202f7
+Author: green <green>
+Date:   Thu May 6 05:34:36 1999 +0000
+
+            * configure.in: Add warning about this being beta code.
+            Remove src/Makefile.am from the picture.
+            * configure: Rebuilt.
+            * Makefile.am: Move logic from src/Makefile.am.  Add changes
+            to support libffi as a target library.
+            * Makefile.in: Rebuilt.
+            * aclocal.m4, config.guess, config.sub, ltconfig, ltmain.sh:
+            Upgraded to new autoconf, automake, libtool.
+            * README: Tweaks.
+            * LICENSE: Update copyright date.
+            * src/Makefile.am, src/Makefile.in: Removed.
+
+commit 4e9452abed58a3058ccdb446f96a29d50dda1f34
+Author: green <green>
+Date:   Wed May 5 22:06:13 1999 +0000
+
+    Updated to new automake, libtool, autoconf - nothing works :-)
+
+commit 6d3b2bddaf4967fba8b8656c01bfc77ec0f2800c
+Author: jsm <jsm>
+Date:   Mon Apr 26 15:55:28 1999 +0000
+
+    1999-04-26  Jason Molenda  (jsm@bugshack.cygnus.com)
+            * index.html: Missed a reference to libffi-discuss@cygnus.com.  Fixed.
+
+commit ebc6a9c28af831d3d187af8ff17319f0f309bd98
+Author: jsm <jsm>
+Date:   Mon Apr 26 15:53:29 1999 +0000
+
+    1999-04-26  Jason Molenda  (jsm@bugshack.cygnus.com)
+            * index.html: Change links to ftp directory to point to sourceware
+            directory.
+            Change mailing list subscription forms to point to sourceware lists.
+
+commit 78ffc52a8b257061348c576ccb6fbbf8b48b0fff
+Author: jsm <jsm>
+Date:   Sun Apr 18 01:33:21 1999 +0000
+
+    Standard sourceware setup.
+
+commit b4d77e827d7ebef7e57ebcd71e71c15c62f1e0a8
+Author: jsm <jsm>
+Date:   Mon Nov 30 11:11:25 1998 +0000
+
+    Small typeo.  (I wouldn't bother except that it made the sentence hard
+    for me to parse on a casual read.)
+
+commit bfb73f08fdc987e37070c5fb0b196fbd28872888
+Author: jsm <jsm>
+Date:   Mon Nov 30 10:44:55 1998 +0000
+
+    A few cleanups.  Most notably, point to the correct subscribe cgi-bin
+    script.
+
+commit af8b7f037ccee3b7939ee226a1a2bbc2f057b35c
+Author: green <green>
+Date:   Mon Nov 30 06:20:05 1998 +0000
+
+            * index.html: Reformatted and updated to reflect hosting on
+            sourceware.cygnus.com (new mailing lists, etc).
+
+commit 334f0b060942aff8d26badaf7dde7830450dc5da
+Author: green <green>
+Date:   Sun Nov 29 16:56:12 1998 +0000
+
+    initial snapshot of documentation
+
+commit 3ab5cb4a1dcc7ecd7e773c97582b0099976c4753
+Author: green <green>
+Date:   Sun Nov 29 16:56:10 1998 +0000
+
+    Initial revision
+
+commit d2a9eb5a8b7cbc8b769809cad59c82b975c178e2
+Merge: d3782ec bc75c54
+Author: green <green>
+Date:   Sun Nov 29 16:48:16 1998 +0000
+
+    This commit was generated by cvs2svn to compensate for changes in r7, which
+    included commits to RCS files with non-trunk default branches.
+
+commit bc75c54bd311658005b065f1bf201b204c81cbca
+Author: green <green>
+Date:   Sun Nov 29 16:48:16 1998 +0000
+
+    Import of v1 code.
+
+commit d3782ec8160c644421dcea17b605fec6e328f14e
+Author: jsm <jsm>
+Date:   Fri Nov 20 20:18:00 1998 +0000
+
+    Send commit messages to mailing lists.
+
+commit 8d8d3843c484c2bb70d8375b2b799f75eb03f709
+Author: jsm <jsm>
+Date:   Thu Oct 1 22:08:36 1998 +0000
+
+    initial checkin
+
+commit 49634f3bf221cc1939abafc788f7e4e31293fe73
+Author: jsm <jsm>
+Date:   Thu Oct 1 22:08:35 1998 +0000
+
+    Add standard setup.
+
+commit c64a84c7693f8cd400fb94bba3c9bcfd9ad1fc36
+Author: jsm <jsm>
+Date:   Thu Oct 1 22:08:34 1998 +0000
+
+    Add readers and standard modules file.
+
+commit 9813273b07fd082da573b3b6bfb8d23809b59eea
+Author: jsm <jsm>
+Date:   Thu Oct 1 22:08:33 1998 +0000
+
+    initial checkin
Index: libffi-3.4.6/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/README.md b/libffi-3.4.6/README.md
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/README.md	
@@ -0,0 +1,529 @@
+
+libffi-3.4.6 was released on February 18, 2024.  Check the libffi web
+page for updates: <URL:http://sourceware.org/libffi/>.
+
+
+What is libffi?
+===============
+
+Compilers for high level languages generate code that follow certain
+conventions. These conventions are necessary, in part, for separate
+compilation to work. One such convention is the "calling
+convention". The "calling convention" is essentially a set of
+assumptions made by the compiler about where function arguments will
+be found on entry to a function. A "calling convention" also specifies
+where the return value for a function is found.
+
+Some programs may not know at the time of compilation what arguments
+are to be passed to a function. For instance, an interpreter may be
+told at run-time about the number and types of arguments used to call
+a given function. Libffi can be used in such programs to provide a
+bridge from the interpreter program to compiled code.
+
+The libffi library provides a portable, high level programming
+interface to various calling conventions. This allows a programmer to
+call any function specified by a call interface description at run
+time.
+
+FFI stands for Foreign Function Interface.  A foreign function
+interface is the popular name for the interface that allows code
+written in one language to call code written in another language. The
+libffi library really only provides the lowest, machine dependent
+layer of a fully featured foreign function interface. A layer must
+exist above libffi that handles type conversions for values passed
+between the two languages.
+
+
+Supported Platforms
+===================
+
+Libffi has been ported to many different platforms.
+
+At the time of release, the following basic configurations have been
+tested:
+
+| Architecture    | Operating System | Compiler                |
+| --------------- | ---------------- | ----------------------- |
+| AArch64 (ARM64) | iOS              | Clang                   |
+| AArch64         | Linux            | GCC                     |
+| AArch64         | Windows          | MSVC                    |
+| Alpha           | Linux            | GCC                     |
+| Alpha           | Tru64            | GCC                     |
+| ARC             | Linux            | GCC                     |
+| ARC32           | Linux            | GCC                     |
+| ARC64           | Linux            | GCC                     |
+| ARM             | Linux            | GCC                     |
+| ARM             | iOS              | GCC                     |
+| ARM             | Windows          | MSVC                    |
+| AVR32           | Linux            | GCC                     |
+| Blackfin        | uClinux          | GCC                     |
+| CSKY            | Linux            | GCC                     |
+| HPPA            | HPUX             | GCC                     |
+| HPPA64          | HPUX             | GCC                     |
+| KVX             | Linux            | GCC                     |
+| IA-64           | Linux            | GCC                     |
+| LoongArch64     | Linux            | GCC                     |
+| M68K            | FreeMiNT         | GCC                     |
+| M68K            | Linux            | GCC                     |
+| M68K            | RTEMS            | GCC                     |
+| M88K            | OpenBSD/mvme88k  | GCC                     |
+| Meta            | Linux            | GCC                     |
+| MicroBlaze      | Linux            | GCC                     |
+| MIPS            | IRIX             | GCC                     |
+| MIPS            | Linux            | GCC                     |
+| MIPS            | RTEMS            | GCC                     |
+| MIPS64          | Linux            | GCC                     |
+| Moxie           | Bare metal       | GCC                     |
+| Nios II         | Linux            | GCC                     |
+| OpenRISC        | Linux            | GCC                     |
+| PowerPC 32-bit  | AIX              | GCC                     |
+| PowerPC 32-bit  | AIX              | IBM XL C                |
+| PowerPC 64-bit  | AIX              | IBM XL C                |
+| PowerPC         | AMIGA            | GCC                     |
+| PowerPC         | Linux            | GCC                     |
+| PowerPC         | Mac OSX          | GCC                     |
+| PowerPC         | FreeBSD          | GCC                     |
+| PowerPC 64-bit  | FreeBSD          | GCC                     |
+| PowerPC 64-bit  | Linux ELFv1      | GCC                     |
+| PowerPC 64-bit  | Linux ELFv2      | GCC                     |
+| RISC-V 32-bit   | Linux            | GCC                     |
+| RISC-V 64-bit   | Linux            | GCC                     |
+| S390            | Linux            | GCC                     |
+| S390X           | Linux            | GCC                     |
+| SPARC           | Linux            | GCC                     |
+| SPARC           | Solaris          | GCC                     |
+| SPARC           | Solaris          | Oracle Solaris Studio C |
+| SPARC64         | Linux            | GCC                     |
+| SPARC64         | FreeBSD          | GCC                     |
+| SPARC64         | Solaris          | Oracle Solaris Studio C |
+| TILE-Gx/TILEPro | Linux            | GCC                     |
+| VAX             | OpenBSD/vax      | GCC                     |
+| WASM32          | Emscripten       | EMCC                    |
+| X86             | FreeBSD          | GCC                     |
+| X86             | GNU HURD         | GCC                     |
+| X86             | Interix          | GCC                     |
+| X86             | kFreeBSD         | GCC                     |
+| X86             | Linux            | GCC                     |
+| X86             | OpenBSD          | GCC                     |
+| X86             | OS/2             | GCC                     |
+| X86             | Solaris          | GCC                     |
+| X86             | Solaris          | Oracle Solaris Studio C |
+| X86             | Windows/Cygwin   | GCC                     |
+| X86             | Windows/MinGW    | GCC                     |
+| X86-64          | FreeBSD          | GCC                     |
+| X86-64          | Linux            | GCC                     |
+| X86-64          | Linux/x32        | GCC                     |
+| X86-64          | OpenBSD          | GCC                     |
+| X86-64          | Solaris          | Oracle Solaris Studio C |
+| X86-64          | Windows/Cygwin   | GCC                     |
+| X86-64          | Windows/MinGW    | GCC                     |
+| X86-64          | Mac OSX          | GCC                     |
+| Xtensa          | Linux            | GCC                     |
+
+Please send additional platform test results to
+libffi-discuss@sourceware.org.
+
+Installing libffi
+=================
+
+First you must configure the distribution for your particular
+system. Go to the directory you wish to build libffi in and run the
+"configure" program found in the root directory of the libffi source
+distribution.  Note that building libffi requires a C99 compatible
+compiler.
+
+If you're building libffi directly from git hosted sources, configure
+won't exist yet; run ./autogen.sh first.  This will require that you
+install autoconf, automake and libtool.
+
+You may want to tell configure where to install the libffi library and
+header files. To do that, use the ``--prefix`` configure switch.  Libffi
+will install under /usr/local by default.
+
+If you want to enable extra run-time debugging checks use the the
+``--enable-debug`` configure switch. This is useful when your program dies
+mysteriously while using libffi.
+
+Another useful configure switch is ``--enable-purify-safety``. Using this
+will add some extra code which will suppress certain warnings when you
+are using Purify with libffi. Only use this switch when using
+Purify, as it will slow down the library.
+
+If you don't want to build documentation, use the ``--disable-docs``
+configure switch.
+
+It's also possible to build libffi on Windows platforms with
+Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh
+wrapper script during configuration like so:
+
+    path/to/configure CC=path/to/msvcc.sh CXX=path/to/msvcc.sh LD=link CPP="cl -nologo -EP" CXXCPP="cl -nologo -EP" CPPFLAGS="-DFFI_BUILDING_DLL"
+
+For 64-bit Windows builds, use ``CC="path/to/msvcc.sh -m64"`` and
+``CXX="path/to/msvcc.sh -m64"``.  You may also need to specify
+``--build`` appropriately.
+
+It is also possible to build libffi on Windows platforms with the LLVM
+project's clang-cl compiler, like below:
+
+    path/to/configure CC="path/to/msvcc.sh -clang-cl" CXX="path/to/msvcc.sh -clang-cl" LD=link CPP="clang-cl -EP"
+
+When building with MSVC under a MingW environment, you may need to
+remove the line in configure that sets 'fix_srcfile_path' to a 'cygpath'
+command.  ('cygpath' is not present in MingW, and is not required when
+using MingW-style paths.)
+
+To build static library for ARM64 with MSVC using visual studio solution, msvc_build folder have
+   aarch64/Ffi_staticLib.sln
+   required header files in aarch64/aarch64_include/
+
+
+SPARC Solaris builds require the use of the GNU assembler and linker.
+Point ``AS`` and ``LD`` environment variables at those tool prior to
+configuration.
+
+For iOS builds, the ``libffi.xcodeproj`` Xcode project is available.
+
+Configure has many other options. Use ``configure --help`` to see them all.
+
+Once configure has finished, type "make". Note that you must be using
+GNU make.  You can ftp GNU make from ftp.gnu.org:/pub/gnu/make .
+
+To ensure that libffi is working as advertised, type "make check".
+This will require that you have DejaGNU installed.
+
+To install the library and header files, type ``make install``.
+
+
+History
+=======
+
+See the git log for details at http://github.com/libffi/libffi.
+
+    3.4.6 Feb-18-2024
+        Fix long double regression on mips64 and alpha.
+
+    3.4.5 Feb-15-2024
+        Add support for wasm32.
+        Add support for aarch64 branch target identification (bti).
+        Add support for ARCv3: ARC32 & ARC64.
+        Add support for HPPA64, and many HPPA fixes.
+        Add support for Haikuos on PowerPC.
+        Fixes for AIX, loongson, MIPS, power, sparc64, and x86 Darwin.
+
+    3.4.4 Oct-23-2022
+        Important aarch64 fixes, including support for linux builds
+          with Link Time Optimization (-flto).
+        Fix x86 stdcall stack alignment.
+        Fix x86 Windows msvc assembler compatibility.
+        Fix moxie and or1k small structure args.
+
+    3.4.3 Sep-19-2022
+        All struct args are passed by value, regardless of size, as per ABIs.
+        Enable static trampolines for Cygwin.
+        Add support for Loongson's LoongArch64 architecture.
+        Fix x32 static trampolines.
+        Fix 32-bit x86 stdcall stack corruption.
+        Fix ILP32 aarch64 support.
+
+    3.4.2 Jun-28-2021
+        Add static trampoline support for Linux on x86_64 and ARM64.
+        Add support for Alibaba's CSKY architecture.
+        Add support for Kalray's KVX architecture.
+        Add support for Intel Control-flow Enforcement Technology (CET).
+        Add support for ARM Pointer Authentication (PA).
+        Fix 32-bit PPC regression.
+        Fix MIPS soft-float problem.
+        Enable tmpdir override with the $LIBFFI_TMPDIR environment variable.
+        Enable compatibility with MSVC runtime stack checking.
+        Reject float and small integer argument in ffi_prep_cif_var().
+          Callers must promote these types themselves.
+
+    3.3 Nov-23-2019
+        Add RISC-V support.
+        New API in support of GO closures.
+        Add IEEE754 binary128 long double support for 64-bit Power
+        Default to Microsoft's 64 bit long double ABI with Visual C++.
+        GNU compiler uses 80 bits (128 in memory) FFI_GNUW64 ABI.
+        Add Windows on ARM64 (WOA) support.
+        Add Windows 32-bit ARM support.
+        Raw java (gcj) API deprecated.
+        Add pre-built PDF documentation to source distribution.
+        Many new test cases and bug fixes.
+
+    3.2.1 Nov-12-2014
+        Build fix for non-iOS AArch64 targets.
+
+    3.2 Nov-11-2014
+        Add C99 Complex Type support (currently only supported on
+          s390).
+        Add support for PASCAL and REGISTER calling conventions on x86
+          Windows/Linux.
+        Add OpenRISC and Cygwin-64 support.
+        Bug fixes.
+
+    3.1 May-19-2014
+        Add AArch64 (ARM64) iOS support.
+        Add Nios II support.
+        Add m88k and DEC VAX support.
+        Add support for stdcall, thiscall, and fastcall on non-Windows
+          32-bit x86 targets such as Linux.
+        Various Android, MIPS N32, x86, FreeBSD and UltraSPARC IIi
+          fixes.
+        Make the testsuite more robust: eliminate several spurious
+          failures, and respect the $CC and $CXX environment variables.
+        Archive off the manually maintained ChangeLog in favor of git
+          log.
+
+    3.0.13 Mar-17-2013
+        Add Meta support.
+        Add missing Moxie bits.
+        Fix stack alignment bug on 32-bit x86.
+        Build fix for m68000 targets.
+        Build fix for soft-float Power targets.
+        Fix the install dir location for some platforms when building
+          with GCC (OS X, Solaris).
+        Fix Cygwin regression.
+
+    3.0.12 Feb-11-2013
+        Add Moxie support.
+        Add AArch64 support.
+        Add Blackfin support.
+        Add TILE-Gx/TILEPro support.
+        Add MicroBlaze support.
+        Add Xtensa support.
+        Add support for PaX enabled kernels with MPROTECT.
+        Add support for native vendor compilers on
+          Solaris and AIX.
+        Work around LLVM/GCC interoperability issue on x86_64.
+
+    3.0.11 Apr-11-2012
+        Lots of build fixes.
+        Add support for variadic functions (ffi_prep_cif_var).
+        Add Linux/x32 support.
+        Add thiscall, fastcall and MSVC cdecl support on Windows.
+        Add Amiga and newer MacOS support.
+        Add m68k FreeMiNT support.
+        Integration with iOS' xcode build tools.
+        Fix Octeon and MC68881 support.
+        Fix code pessimizations.
+
+    3.0.10 Aug-23-2011
+        Add support for Apple's iOS.
+        Add support for ARM VFP ABI.
+        Add RTEMS support for MIPS and M68K.
+        Fix instruction cache clearing problems on
+          ARM and SPARC.
+        Fix the N64 build on mips-sgi-irix6.5.
+        Enable builds with Microsoft's compiler.
+        Enable x86 builds with Oracle's Solaris compiler.
+        Fix support for calling code compiled with Oracle's Sparc
+          Solaris compiler.
+        Testsuite fixes for Tru64 Unix.
+        Additional platform support.
+
+    3.0.9 Dec-31-2009
+        Add AVR32 and win64 ports.  Add ARM softfp support.
+        Many fixes for AIX, Solaris, HP-UX, *BSD.
+        Several PowerPC and x86-64 bug fixes.
+        Build DLL for windows.
+
+    3.0.8 Dec-19-2008
+        Add *BSD, BeOS, and PA-Linux support.
+
+    3.0.7 Nov-11-2008
+        Fix for ppc FreeBSD.
+        (thanks to Andreas Tobler)
+
+    3.0.6 Jul-17-2008
+        Fix for closures on sh.
+        Mark the sh/sh64 stack as non-executable.
+        (both thanks to Kaz Kojima)
+
+    3.0.5 Apr-3-2008
+        Fix libffi.pc file.
+        Fix #define ARM for IcedTea users.
+        Fix x86 closure bug.
+
+    3.0.4 Feb-24-2008
+        Fix x86 OpenBSD configury.
+
+    3.0.3 Feb-22-2008
+        Enable x86 OpenBSD thanks to Thomas Heller, and
+          x86-64 FreeBSD thanks to Björn König and Andreas Tobler.
+        Clean up test instruction in README.
+
+    3.0.2 Feb-21-2008
+        Improved x86 FreeBSD support.
+        Thanks to Björn König.
+
+    3.0.1 Feb-15-2008
+        Fix instruction cache flushing bug on MIPS.
+        Thanks to David Daney.
+
+    3.0.0 Feb-15-2008
+        Many changes, mostly thanks to the GCC project.
+        Cygnus Solutions is now Red Hat.
+
+      [10 years go by...]
+
+    1.20 Oct-5-1998
+        Raffaele Sena produces ARM port.
+
+    1.19 Oct-5-1998
+        Fixed x86 long double and long long return support.
+        m68k bug fixes from Andreas Schwab.
+        Patch for DU assembler compatibility for the Alpha from Richard
+          Henderson.
+
+    1.18 Apr-17-1998
+        Bug fixes and MIPS configuration changes.
+
+    1.17 Feb-24-1998
+        Bug fixes and m68k port from Andreas Schwab. PowerPC port from
+        Geoffrey Keating. Various bug x86, Sparc and MIPS bug fixes.
+
+    1.16 Feb-11-1998
+        Richard Henderson produces Alpha port.
+
+    1.15 Dec-4-1997
+        Fixed an n32 ABI bug. New libtool, auto* support.
+
+    1.14 May-13-97
+        libtool is now used to generate shared and static libraries.
+        Fixed a minor portability problem reported by Russ McManus
+        <mcmanr@eq.gs.com>.
+
+    1.13 Dec-2-1996
+        Added --enable-purify-safety to keep Purify from complaining
+          about certain low level code.
+        Sparc fix for calling functions with < 6 args.
+        Linux x86 a.out fix.
+
+    1.12 Nov-22-1996
+        Added missing ffi_type_void, needed for supporting void return
+          types. Fixed test case for non MIPS machines. Cygnus Support
+          is now Cygnus Solutions.
+
+    1.11 Oct-30-1996
+        Added notes about GNU make.
+
+    1.10 Oct-29-1996
+        Added configuration fix for non GNU compilers.
+
+    1.09 Oct-29-1996
+        Added --enable-debug configure switch. Clean-ups based on LCLint
+        feedback. ffi_mips.h is always installed. Many configuration
+        fixes. Fixed ffitest.c for sparc builds.
+
+    1.08 Oct-15-1996
+        Fixed n32 problem. Many clean-ups.
+
+    1.07 Oct-14-1996
+        Gordon Irlam rewrites v8.S again. Bug fixes.
+
+    1.06 Oct-14-1996
+        Gordon Irlam improved the sparc port.
+
+    1.05 Oct-14-1996
+        Interface changes based on feedback.
+
+    1.04 Oct-11-1996
+        Sparc port complete (modulo struct passing bug).
+
+    1.03 Oct-10-1996
+        Passing struct args, and returning struct values works for
+        all architectures/calling conventions. Expanded tests.
+
+    1.02 Oct-9-1996
+        Added SGI n32 support. Fixed bugs in both o32 and Linux support.
+        Added "make test".
+
+    1.01 Oct-8-1996
+        Fixed float passing bug in mips version. Restructured some
+        of the code. Builds cleanly with SGI tools.
+
+    1.00 Oct-7-1996
+        First release. No public announcement.
+
+Authors & Credits
+=================
+
+libffi was originally written by Anthony Green <green@moxielogic.com>.
+
+The developers of the GNU Compiler Collection project have made
+innumerable valuable contributions.  See the ChangeLog file for
+details.
+
+Some of the ideas behind libffi were inspired by Gianni Mariani's free
+gencall library for Silicon Graphics machines.
+
+The closure mechanism was designed and implemented by Kresten Krab
+Thorup.
+
+Major processor architecture ports were contributed by the following
+developers:
+
+    aarch64             Marcus Shawcroft, James Greenhalgh
+    alpha               Richard Henderson
+    arc                 Hackers at Synopsis
+    arm                 Raffaele Sena
+    avr32               Bradley Smith
+    blackfin            Alexandre Keunecke I. de Mendonca
+    cris                Simon Posnjak, Hans-Peter Nilsson
+    csky                Ma Jun, Zhang Wenmeng
+    frv                 Anthony Green
+    ia64                Hans Boehm
+    kvx                 Yann Sionneau
+    loongarch64         Cheng Lulu, Xi Ruoyao, Xu Hao,
+                        Zhang Wenlong, Pan Xuefeng
+    m32r                Kazuhiro Inaoka
+    m68k                Andreas Schwab
+    m88k                Miod Vallat
+    metag               Hackers at Imagination Technologies
+    microblaze          Nathan Rossi
+    mips                Anthony Green, Casey Marshall
+    mips64              David Daney
+    moxie               Anthony Green
+    nios ii             Sandra Loosemore
+    openrisc            Sebastian Macke
+    pa                  Randolph Chung, Dave Anglin, Andreas Tobler
+    pa64                Dave Anglin
+    powerpc             Geoffrey Keating, Andreas Tobler,
+                        David Edelsohn, John Hornkvist
+    powerpc64           Jakub Jelinek
+    riscv               Michael Knyszek, Andrew Waterman, Stef O'Rear
+    s390                Gerhard Tonn, Ulrich Weigand
+    sh                  Kaz Kojima
+    sh64                Kaz Kojima
+    sparc               Anthony Green, Gordon Irlam
+    tile-gx/tilepro     Walter Lee
+    vax                 Miod Vallat
+    wasm32              Hood Chatham, Brion Vibber, Kleis Auke Wolthuizen
+    x86                 Anthony Green, Jon Beniston
+    x86-64              Bo Thorsen
+    xtensa              Chris Zankel
+
+Jesper Skov and Andrew Haley both did more than their fair share of
+stepping through the code and tracking down bugs.
+
+Thanks also to Tom Tromey for bug fixes, documentation and
+configuration help.
+
+Thanks to Jim Blandy, who provided some useful feedback on the libffi
+interface.
+
+Andreas Tobler has done a tremendous amount of work on the testsuite.
+
+Alex Oliva solved the executable page problem for SElinux.
+
+The list above is almost certainly incomplete and inaccurate.  I'm
+happy to make corrections or additions upon request.
+
+If you have a problem, or have found a bug, please file an issue on
+our issue tracker at https://github.com/libffi/libffi/issues.
+
+The author can be reached at green@moxielogic.com.
+
+To subscribe/unsubscribe to our mailing lists, visit:
+https://sourceware.org/mailman/listinfo/libffi-announce
+https://sourceware.org/mailman/listinfo/libffi-discuss
Index: libffi-3.4.6/testsuite/lib/libffi.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/lib/libffi.exp b/libffi-3.4.6/testsuite/lib/libffi.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/lib/libffi.exp	
@@ -0,0 +1,682 @@
+#   Copyright (C) 2003, 2005, 2008, 2009, 2010, 2011, 2014, 2019, 2022 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+proc load_gcc_lib { filename } {
+    global srcdir
+    load_file $srcdir/lib/$filename
+}
+
+load_lib dg.exp
+load_lib libgloss.exp
+load_gcc_lib target-libpath.exp
+load_gcc_lib wrapper.exp
+
+proc check_effective_target_gccbug { } {
+    global has_gccbug
+    return $has_gccbug
+}
+
+# Return 1 if the target matches the effective target 'arg', 0 otherwise.
+# This can be used with any check_* proc that takes no argument and
+# returns only 1 or 0.  It could be used with check_* procs that take
+# arguments with keywords that pass particular arguments.
+
+proc is-effective-target { arg } {
+    global et_index
+    set selected 0
+    if { ![info exists et_index] } {
+	# Initialize the effective target index that is used in some
+	# check_effective_target_* procs.
+	set et_index 0
+    }
+    if { [info procs check_effective_target_${arg}] != [list] } {
+	set selected [check_effective_target_${arg}]
+    } else {
+	error "unknown effective target keyword `$arg'"
+    }
+    verbose "is-effective-target: $arg $selected" 2
+    return $selected
+}
+
+proc is-effective-target-keyword { arg } {
+    if { [info procs check_effective_target_${arg}] != [list] } {
+	return 1
+    } else {
+	return 0
+    }
+}
+
+# Intercept the call to the DejaGnu version of dg-process-target to
+# support use of an effective-target keyword in place of a list of
+# target triplets to xfail or skip a test.
+#
+# The argument to dg-process-target is the keyword "target" or "xfail"
+# followed by a selector:
+#    target-triplet-1 ...
+#    effective-target-keyword
+#    selector-expression
+#
+# For a target list the result is "S" if the target is selected, "N" otherwise.
+# For an xfail list the result is "F" if the target is affected, "P" otherwise.
+
+# In contexts that allow either "target" or "xfail" the argument can be
+#    target selector1 xfail selector2
+# which returns "N" if selector1 is not selected, otherwise the result of
+# "xfail selector2".
+#
+# A selector expression appears within curly braces and uses a single logical
+# operator: !, &&, or ||.  An operand is another selector expression, an
+# effective-target keyword, or a list of target triplets within quotes or
+# curly braces.
+
+if { [info procs saved-dg-process-target] == [list] } {
+    rename dg-process-target saved-dg-process-target
+
+    # Evaluate an operand within a selector expression.
+    proc selector_opd { op } {
+	set selector "target"
+	lappend selector $op
+	set answer [ expr { [dg-process-target $selector] == "S" } ]
+	verbose "selector_opd: `$op' $answer" 2
+	return $answer
+    }
+
+    # Evaluate a target triplet list within a selector expression.
+    # Unlike other operands, this needs to be expanded from a list to
+    # the same string as "target".
+    proc selector_list { op } {
+	set selector "target [join $op]"
+	set answer [ expr { [dg-process-target $selector] == "S" } ]
+	verbose "selector_list: `$op' $answer" 2
+	return $answer
+    }
+
+    # Evaluate a selector expression.
+    proc selector_expression { exp } {
+	if { [llength $exp] == 2 } {
+	    if [string match "!" [lindex $exp 0]] {
+		set op1 [lindex $exp 1]
+		set answer [expr { ! [selector_opd $op1] }]
+	    } else {
+		# Assume it's a list of target triplets.
+		set answer [selector_list $exp]
+	    }
+	} elseif { [llength $exp] == 3 } {
+	    set op1 [lindex $exp 0]
+	    set opr [lindex $exp 1]
+	    set op2 [lindex $exp 2]
+	    if [string match "&&" $opr] {
+		set answer [expr { [selector_opd $op1] && [selector_opd $op2] }]
+	    } elseif [string match "||" $opr] {
+		set answer [expr { [selector_opd $op1] || [selector_opd $op2] }]
+	    } else {
+		# Assume it's a list of target triplets.
+		set answer [selector_list $exp]
+	    }
+	} else {
+	    # Assume it's a list of target triplets.
+	    set answer [selector_list $exp]
+	}
+
+	verbose "selector_expression: `$exp' $answer" 2
+	return $answer
+    }
+
+    # Evaluate "target selector" or "xfail selector".
+
+    proc dg-process-target-1 { args } {
+	verbose "dg-process-target-1: `$args'" 2
+
+	# Extract the 'what' keyword from the argument list.
+	set selector [string trim [lindex $args 0]]
+	if [regexp "^xfail " $selector] {
+	    set what "xfail"
+	} elseif [regexp "^target " $selector] {
+	    set what "target"
+	} else {
+	    error "syntax error in target selector \"$selector\""
+	}
+
+	# Extract the rest of the list, which might be a keyword.
+	regsub "^${what}" $selector "" rest
+	set rest [string trim $rest]
+
+	if [is-effective-target-keyword $rest] {
+	    # The selector is an effective target keyword.
+	    if [is-effective-target $rest] {
+		return [expr { $what == "xfail" ? "F" : "S" }]
+	    } else {
+		return [expr { $what == "xfail" ? "P" : "N" }]
+	    }
+	}
+
+	if [string match "{*}" $rest] {
+	    if [selector_expression [lindex $rest 0]] {
+		return [expr { $what == "xfail" ? "F" : "S" }]
+	    } else {
+		return [expr { $what == "xfail" ? "P" : "N" }]
+	    }
+	}
+
+	# The selector is not an effective-target keyword, so process
+	# the list of target triplets.
+	return [saved-dg-process-target $selector]
+    }
+
+    # Intercept calls to the DejaGnu function.  In addition to
+    # processing "target selector" or "xfail selector", handle
+    # "target selector1 xfail selector2".
+
+    proc dg-process-target { args } {
+	verbose "replacement dg-process-target: `$args'" 2
+
+	set selector [string trim [lindex $args 0]]
+
+	# If the argument list contains both 'target' and 'xfail',
+	# process 'target' and, if that succeeds, process 'xfail'.
+	if [regexp "^target .* xfail .*" $selector] {
+	    set xfail_index [string first "xfail" $selector]
+	    set xfail_selector [string range $selector $xfail_index end]
+	    set target_selector [string range $selector 0 [expr $xfail_index-1]]
+	    set target_selector [string trim $target_selector]
+	    if { [dg-process-target-1 $target_selector] == "N" } {
+		return "N"
+	    }
+	    return [dg-process-target-1 $xfail_selector]
+
+	}
+	return [dg-process-target-1 $selector]
+    }
+}
+
+# Define libffi callbacks for dg.exp.
+
+proc libffi-dg-test-1 { target_compile prog do_what extra_tool_flags } {
+
+    # To get all \n in dg-output test strings to match printf output
+    # in a system that outputs it as \015\012 (i.e. not just \012), we
+    # need to change all \n into \r?\n.  As there is no dejagnu flag
+    # or hook to do that, we simply change the text being tested.
+    # Unfortunately, we have to know that the variable is called
+    # dg-output-text and lives in the caller of libffi-dg-test, which
+    # is two calls up.  Overriding proc dg-output would be longer and
+    # would necessarily have the same assumption.
+    upvar 2 dg-output-text output_match
+
+    if { [llength $output_match] > 1 } {
+	regsub -all "\n" [lindex $output_match 1] "\r?\n" x
+	set output_match [lreplace $output_match 1 1 $x]
+    }
+
+    if { [ istarget "wasm32-*-*" ] } {
+        # emscripten will get confused if told to build as .exe
+        set exec_suffix ""
+    } else {
+        set exec_suffix ".exe"
+    }
+
+    # Set up the compiler flags, based on what we're going to do.
+
+    set options [list]
+    switch $do_what {
+	"compile" {
+	    set compile_type "assembly"
+	    set output_file "[file rootname [file tail $prog]].s"
+	}
+	"link" {
+	    set compile_type "executable"
+	    set output_file "[file rootname [file tail $prog]]$exec_suffix"
+	    # The following line is needed for targets like the i960 where
+	    # the default output file is b.out.  Sigh.
+	}
+	"run" {
+	    set compile_type "executable"
+	    # FIXME: "./" is to cope with "." not being in $PATH.
+	    # Should this be handled elsewhere?
+	    # YES.
+	    set output_file "./[file rootname [file tail $prog]]$exec_suffix"
+	    # This is the only place where we care if an executable was
+	    # created or not.  If it was, dg.exp will try to run it.
+	    remote_file build delete $output_file;
+	}
+	default {
+	    perror "$do_what: not a valid dg-do keyword"
+	    return ""
+	}
+    }
+
+    if { $extra_tool_flags != "" } {
+	lappend options "additional_flags=$extra_tool_flags"
+    }
+
+    set comp_output [libffi_target_compile "$prog" "$output_file" "$compile_type" $options];
+
+
+    return [list $comp_output $output_file]
+}
+
+
+proc libffi-dg-test { prog do_what extra_tool_flags } {
+    return [libffi-dg-test-1 target_compile $prog $do_what $extra_tool_flags]
+}
+
+proc libffi-dg-prune { target_triplet text } {
+    # We get this with some qemu emulated systems (eg. ppc64le-linux-gnu)
+    regsub -all "(^|\n)\[^\n\]*unable to perform all requested operations" $text "" text
+    # We get this from sparc64 linux systems
+    regsub -all "(^|\n)\[^\n\]*warning: .* has a LOAD segment with RWX permissions" $text "" text
+    # Ignore Emscripten INFO messages
+    regsub -all "(^|\n)(cache|shared):INFO:\[^\n\]*" $text "" text
+    return $text
+}
+
+proc libffi-init { args } {
+    global gluefile wrap_flags;
+    global srcdir
+    global blddirffi
+    global objdir
+    global TOOL_OPTIONS
+    global tool
+    global libffi_include
+    global libffi_link_flags
+    global tool_root_dir
+    global ld_library_path
+    global compiler_vendor
+
+    if ![info exists blddirffi] {
+	set blddirffi [pwd]/..
+    }
+
+    verbose "libffi $blddirffi"
+
+    # Which compiler are we building with?
+    if { [string match $compiler_vendor "gnu"] } {
+        set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]
+        if {$gccdir != ""} {
+	    set gccdir [file dirname $gccdir]
+        }
+        verbose "gccdir $gccdir"
+
+        set ld_library_path "."
+        append ld_library_path ":${gccdir}"
+
+        set compiler "${gccdir}/xgcc"
+        if { [is_remote host] == 0 && [which $compiler] != 0 } {
+	    foreach i "[exec $compiler --print-multi-lib]" {
+	        set mldir ""
+	        regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
+	        set mldir [string trimright $mldir "\;@"]
+	        if { "$mldir" == "." } {
+		    continue
+	        }
+	        if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] >= 1 } {
+		    append ld_library_path ":${gccdir}/${mldir}"
+	        }
+	    }
+        }
+    }
+
+    # add the library path for libffi.
+    append ld_library_path ":${blddirffi}/.libs"
+
+    verbose "ld_library_path: $ld_library_path"
+
+    # Point to the Libffi headers in libffi.
+    set libffi_include "${blddirffi}/include"
+    verbose "libffi_include $libffi_include"
+
+    set libffi_dir  "${blddirffi}/.libs"
+    verbose "libffi_dir $libffi_dir"
+    if { $libffi_dir != "" } {
+	set libffi_dir [file dirname ${libffi_dir}]
+	set libffi_link_flags "-L${libffi_dir}/.libs"
+    }
+
+    set_ld_library_path_env_vars
+    libffi_maybe_build_wrapper "${objdir}/testglue.o"
+}
+
+proc libffi_exit { } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+
+proc libffi_target_compile { source dest type options } {
+    global gluefile wrap_flags;
+    global srcdir
+    global blddirffi
+    global TOOL_OPTIONS
+    global libffi_link_flags
+    global libffi_include
+    global target_triplet
+    global compiler_vendor
+
+    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=$wrap_flags"
+    }
+
+    # TOOL_OPTIONS must come first, so that it doesn't override testcase
+    # specific options.
+    if [info exists TOOL_OPTIONS] {
+	lappend  options "additional_flags=$TOOL_OPTIONS"
+    }
+
+    # search for ffi_mips.h in srcdir, too
+    lappend options "additional_flags=-I${libffi_include} -I${srcdir}/../include  -I${libffi_include}/.."
+    lappend options "additional_flags=${libffi_link_flags}"
+
+    # Darwin needs a stack execution allowed flag.
+
+    if { [istarget "*-*-darwin9*"] || [istarget "*-*-darwin1*"]
+	 || [istarget "*-*-darwin2*"] } {
+	# lappend options "additional_flags=-Wl,-allow_stack_execute"
+        lappend options "additional_flags=-Wno-unused-command-line-argument"
+        lappend options "additional_flags=-Wl,-search_paths_first"
+    }
+
+    # If you're building the compiler with --prefix set to a place
+    # where it's not yet installed, then the linker won't be able to
+    # find the libgcc used by libffi.dylib.  We could pass the
+    # -dylib_file option, but that's complicated, and it's much easier
+    # to just make the linker find libgcc using -L options.
+    if { [string match "*-*-darwin*" $target_triplet] } {
+	lappend options "libs= -shared-libgcc"
+    }
+
+    if { [string match "*-*-openbsd*" $target_triplet] } {
+	lappend options "libs= -lpthread"
+    }
+
+    lappend options "libs= -lffi"
+
+    if { ![string match "*android*" $target_triplet] } {
+
+        if { [string match "aarch64*-*-linux*" $target_triplet] } {
+            lappend options "libs= -lpthread"
+        }
+
+        # this may be required for g++, but just confused clang.
+        if { [string match "*.cc" $source] } {
+            lappend options "c++"
+            if { [string match "*-*-darwin*" $target_triplet] } {
+                lappend options "libs= -lc++"
+            }
+        }
+
+        if { [string match "arc*-*-linux*" $target_triplet] } {
+            lappend options "libs= -lpthread"
+        }
+    }
+
+    # emscripten emits this warning while building the feature test
+    # which causes it to be seen as unsupported.
+    if { [string match "wasm32-*" $target_triplet] } {
+        lappend options "additional_flags=-Wno-unused-command-line-argument"
+    }
+
+    verbose "options: $options"
+    return [target_compile $source $dest $type $options]
+}
+
+# TEST should be a preprocessor condition.  Returns true if it holds.
+proc libffi_feature_test { test } {
+    set src "ffitest[pid].c"
+
+    set f [open $src "w"]
+    puts $f "#include <ffi.h>"
+    puts $f $test
+    puts $f "/* OK */"
+    puts $f "#else"
+    puts $f "# error Failed $test"
+    puts $f "#endif"
+    close $f
+
+    set lines [libffi_target_compile $src /dev/null assembly ""]
+    file delete $src
+
+    return [string match "" $lines]
+}
+
+# Utility routines.
+
+#
+# search_for -- looks for a string match in a file
+#
+proc search_for { file pattern } {
+    set fd [open $file r]
+    while { [gets $fd cur_line]>=0 } {
+	if [string match "*$pattern*" $cur_line] then {
+	    close $fd
+	    return 1
+	}
+    }
+    close $fd
+    return 0
+}
+
+# Modified dg-runtest that can cycle through a list of optimization options
+# as c-torture does.
+proc libffi-dg-runtest { testcases default-extra-flags } {
+    global runtests
+
+    foreach test $testcases {
+	# If we're only testing specific files and this isn't one of
+	# them, skip it.
+	if ![runtest_file_p $runtests $test] {
+	    continue
+	}
+
+	# Look for a loop within the source code - if we don't find one,
+	# don't pass -funroll[-all]-loops.
+	global torture_with_loops torture_without_loops
+	if [expr [search_for $test "for*("]+[search_for $test "while*("]] {
+	    set option_list $torture_with_loops
+	} else {
+	    set option_list $torture_without_loops
+	}
+
+	set nshort [file tail [file dirname $test]]/[file tail $test]
+
+	foreach flags $option_list {
+	    verbose "Testing $nshort, $flags" 1
+	    dg-test $test $flags ${default-extra-flags}
+	}
+    }
+}
+
+proc run-many-tests { testcases extra_flags } {
+    global compiler_vendor
+    global has_gccbug
+    global env
+    switch $compiler_vendor {
+      "clang" {
+        set common "-W -Wall"
+        if [info exists env(LIBFFI_TEST_OPTIMIZATION)] {
+	  set optimizations [ list $env(LIBFFI_TEST_OPTIMIZATION) ]
+        } else {
+          set optimizations { "-O0" "-O2" }
+        }
+      }
+      "gnu" {
+        set common "-W -Wall -Wno-psabi"
+        if [info exists env(LIBFFI_TEST_OPTIMIZATION)] {
+	  set optimizations [ list $env(LIBFFI_TEST_OPTIMIZATION) ]
+        } else {
+          set optimizations { "-O0" "-O2" }
+        }
+      }
+      default {
+        # Assume we are using the vendor compiler.
+        set common ""
+        if [info exists env(LIBFFI_TEST_OPTIMIZATION)] {
+	  set optimizations [ list $env(LIBFFI_TEST_OPTIMIZATION) ]
+        } else {
+          set optimizations { "" }
+        }
+      }
+    }
+
+    info exists env(LD_LIBRARY_PATH)
+
+    set targetabis { "" }
+    if [string match $compiler_vendor "gnu"] {
+        if [libffi_feature_test "#ifdef __i386__"] {
+            set targetabis {
+                ""
+                "-DABI_NUM=FFI_STDCALL -DABI_ATTR=__STDCALL__"
+                "-DABI_NUM=FFI_THISCALL -DABI_ATTR=__THISCALL__"
+                "-DABI_NUM=FFI_FASTCALL -DABI_ATTR=__FASTCALL__"
+            }
+        } elseif { [istarget "x86_64-*-*"] \
+		   && [libffi_feature_test "#if !defined __ILP32__  \
+						&& !defined __i386__"] } {
+            set targetabis {
+                ""
+                "-DABI_NUM=FFI_GNUW64 -DABI_ATTR=__MSABI__"
+            }
+        }
+    }
+
+    set common [ concat $common $extra_flags ]
+    foreach test $testcases {
+        set testname [file tail $test]
+        if [search_for $test "ABI_NUM"] {
+            set abis $targetabis
+        } else {
+            set abis { "" }
+        }
+        foreach opt $optimizations {
+            foreach abi $abis {
+                set options [concat $common $opt $abi]
+		set has_gccbug false;
+		if { [string match $compiler_vendor "gnu"] \
+			 && [string match "*MSABI*" $abi] \
+			 && ( ( [string match "*DGTEST=57 *" $common] \
+				    && [string match "*call.c*" $testname] ) \
+				  || ( [string match "*DGTEST=54 *" $common] \
+					   && [string match "*callback*" $testname] ) \
+				  || [string match "*DGTEST=55 *" $common] \
+				  || [string match "*DGTEST=56 *" $common] ) } then {
+		    if [libffi_feature_test "#if (__GNUC__ < 9) || ((__GNUC__ == 9) && (__GNUC_MINOR__ < 3))"] {
+			set has_gccbug true;
+		    }
+		}
+		verbose "Testing $testname, $options" 1
+		verbose "has_gccbug = $has_gccbug" 1
+		dg-test $test $options ""
+            }
+        }
+    }
+}
+
+# Like check_conditional_xfail, but callable from a dg test.
+
+proc dg-xfail-if { args } {
+    set args [lreplace $args 0 0]
+    set selector "target [join [lindex $args 1]]"
+    if { [dg-process-target $selector] == "S" } {
+	global compiler_conditional_xfail_data
+	set compiler_conditional_xfail_data $args
+    }
+}
+
+proc check-flags { args } {
+
+    # The args are within another list; pull them out.
+    set args [lindex $args 0]
+
+    # The next two arguments are optional.  If they were not specified,
+    # use the defaults.
+    if { [llength $args] == 2 } {
+	lappend $args [list "*"]
+    }
+    if { [llength $args] == 3 } {
+	lappend $args [list ""]
+    }
+
+    # If the option strings are the defaults, or the same as the
+    # defaults, there is no need to call check_conditional_xfail to
+    # compare them to the actual options.
+    if { [string compare [lindex $args 2] "*"] == 0
+	 && [string compare [lindex $args 3] "" ] == 0 } {
+	set result 1
+    } else {
+	# The target list might be an effective-target keyword, so replace
+	# the original list with "*-*-*", since we already know it matches.
+	set result [check_conditional_xfail [lreplace $args 1 1 "*-*-*"]]
+    }
+
+    return $result
+}
+
+proc dg-skip-if { args } {
+    # Verify the number of arguments.  The last two are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+        error "dg-skip-if 2: need 2, 3, or 4 arguments"
+    }
+
+    # Don't bother if we're already skipping the test.
+    upvar dg-do-what dg-do-what
+    if { [lindex ${dg-do-what} 1] == "N" } {
+      return
+    }
+
+    set selector [list target [lindex $args 1]]
+    if { [dg-process-target $selector] == "S" } {
+        if [check-flags $args] {
+            upvar dg-do-what dg-do-what
+            set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+        }
+    }
+}
+
+# We need to make sure that additional_files and additional_sources
+# are both cleared out after every test.  It is not enough to clear
+# them out *before* the next test run because gcc-target-compile gets
+# run directly from some .exp files (outside of any test).  (Those
+# uses should eventually be eliminated.)
+
+# Because the DG framework doesn't provide a hook that is run at the
+# end of a test, we must replace dg-test with a wrapper.
+
+if { [info procs saved-dg-test] == [list] } {
+    rename dg-test saved-dg-test
+
+    proc dg-test { args } {
+	global additional_files
+	global additional_sources
+	global errorInfo
+
+	if { [ catch { eval saved-dg-test $args } errmsg ] } {
+	    set saved_info $errorInfo
+	    set additional_files ""
+	    set additional_sources ""
+	    error $errmsg $saved_info
+	}
+	set additional_files ""
+	set additional_sources ""
+    }
+}
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/lib/wrapper.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/lib/wrapper.exp b/libffi-3.4.6/testsuite/lib/wrapper.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/lib/wrapper.exp	
@@ -0,0 +1,45 @@
+#   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# This file contains GCC-specifics for status wrappers for test programs.
+
+# ${tool}_maybe_build_wrapper -- Build wrapper object if the target
+# needs it.  FILENAME is the path to the wrapper file.  If there are
+# additional arguments, they are command-line options to provide to
+# the compiler when compiling FILENAME.
+
+proc ${tool}_maybe_build_wrapper { filename args } {
+    global gluefile wrap_flags
+
+    if { [target_info needs_status_wrapper] != "" \
+ 	 && [target_info needs_status_wrapper] != "0" \
+	 && ![info exists gluefile] } {
+	set saved_wrap_compile_flags [target_info wrap_compile_flags]
+	set flags [join $args " "]
+	# The wrapper code may contain code that gcc objects on.  This
+	# became true for dejagnu-1.4.4.  The set of warnings and code
+	# that gcc objects on may change, so just make sure -w is always
+	# passed to turn off all warnings.
+	set_currtarget_info wrap_compile_flags \
+	    "$saved_wrap_compile_flags -w $flags"
+	set result [build_wrapper $filename]
+	set_currtarget_info wrap_compile_flags "$saved_wrap_compile_flags"
+	if { $result != "" } {
+	    set gluefile [lindex $result 0]
+	    set wrap_flags [lindex $result 1]
+	}
+    }
+}
Index: libffi-3.4.6/testsuite/lib/target-libpath.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/lib/target-libpath.exp b/libffi-3.4.6/testsuite/lib/target-libpath.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/lib/target-libpath.exp	
@@ -0,0 +1,283 @@
+# Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# This file was contributed by John David Anglin (dave.anglin@nrc-cnrc.gc.ca)
+
+set orig_environment_saved 0
+set orig_ld_library_path_saved 0
+set orig_ld_run_path_saved 0
+set orig_shlib_path_saved 0
+set orig_ld_libraryn32_path_saved 0
+set orig_ld_library64_path_saved 0
+set orig_ld_library_path_32_saved 0
+set orig_ld_library_path_64_saved 0
+set orig_dyld_library_path_saved 0
+set orig_path_saved 0
+
+#######################################
+# proc set_ld_library_path_env_vars { }
+#######################################
+
+proc set_ld_library_path_env_vars { } {
+  global ld_library_path
+  global orig_environment_saved
+  global orig_ld_library_path_saved
+  global orig_ld_run_path_saved
+  global orig_shlib_path_saved
+  global orig_ld_libraryn32_path_saved
+  global orig_ld_library64_path_saved
+  global orig_ld_library_path_32_saved
+  global orig_ld_library_path_64_saved
+  global orig_dyld_library_path_saved
+  global orig_path_saved
+  global orig_ld_library_path
+  global orig_ld_run_path
+  global orig_shlib_path
+  global orig_ld_libraryn32_path
+  global orig_ld_library64_path
+  global orig_ld_library_path_32
+  global orig_ld_library_path_64
+  global orig_dyld_library_path
+  global orig_path
+  global GCC_EXEC_PREFIX
+
+  # Set the relocated compiler prefix, but only if the user hasn't specified one.
+  if { [info exists GCC_EXEC_PREFIX] && ![info exists env(GCC_EXEC_PREFIX)] } {
+    setenv GCC_EXEC_PREFIX "$GCC_EXEC_PREFIX"
+  }
+
+  # Setting the ld library path causes trouble when testing cross-compilers.
+  if { [is_remote target] } {
+    return
+  }
+
+  if { $orig_environment_saved == 0 } {
+    global env
+
+    set orig_environment_saved 1
+
+    # Save the original environment.
+    if [info exists env(LD_LIBRARY_PATH)] {
+      set orig_ld_library_path "$env(LD_LIBRARY_PATH)"
+      set orig_ld_library_path_saved 1
+    }
+    if [info exists env(LD_RUN_PATH)] {
+      set orig_ld_run_path "$env(LD_RUN_PATH)"
+      set orig_ld_run_path_saved 1
+    }
+    if [info exists env(SHLIB_PATH)] {
+      set orig_shlib_path "$env(SHLIB_PATH)"
+      set orig_shlib_path_saved 1
+    }
+    if [info exists env(LD_LIBRARYN32_PATH)] {
+      set orig_ld_libraryn32_path "$env(LD_LIBRARYN32_PATH)"
+      set orig_ld_libraryn32_path_saved 1
+    }
+    if [info exists env(LD_LIBRARY64_PATH)] {
+      set orig_ld_library64_path "$env(LD_LIBRARY64_PATH)"
+      set orig_ld_library64_path_saved 1
+    }
+    if [info exists env(LD_LIBRARY_PATH_32)] {
+      set orig_ld_library_path_32 "$env(LD_LIBRARY_PATH_32)"
+      set orig_ld_library_path_32_saved 1
+    }
+    if [info exists env(LD_LIBRARY_PATH_64)] {
+      set orig_ld_library_path_64 "$env(LD_LIBRARY_PATH_64)"
+      set orig_ld_library_path_64_saved 1
+    }
+    if [info exists env(DYLD_LIBRARY_PATH)] {
+      set orig_dyld_library_path "$env(DYLD_LIBRARY_PATH)"
+      set orig_dyld_library_path_saved 1
+    }
+    if [info exists env(PATH)] {
+      set orig_path "$env(PATH)"
+      set orig_path_saved 1
+    }
+  }
+
+  # We need to set ld library path in the environment.  Currently,
+  # unix.exp doesn't set the environment correctly for all systems.
+  # It only sets SHLIB_PATH and LD_LIBRARY_PATH when it executes a
+  # program.  We also need the environment set for compilations, etc.
+  #
+  # On IRIX 6, we have to set variables akin to LD_LIBRARY_PATH, but
+  # called LD_LIBRARYN32_PATH (for the N32 ABI) and LD_LIBRARY64_PATH
+  # (for the 64-bit ABI).  The same applies to Darwin (DYLD_LIBRARY_PATH),
+  # Solaris 32 bit (LD_LIBRARY_PATH_32), Solaris 64 bit (LD_LIBRARY_PATH_64),
+  # and HP-UX (SHLIB_PATH).  In some cases, the variables are independent
+  # of LD_LIBRARY_PATH, and in other cases LD_LIBRARY_PATH is used if the
+  # variable is not defined.
+  #
+  # Doing this is somewhat of a hack as ld_library_path gets repeated in
+  # SHLIB_PATH and LD_LIBRARY_PATH when unix_load sets these variables.
+  if { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARY_PATH "$ld_library_path:$orig_ld_library_path"
+  } else {
+    setenv LD_LIBRARY_PATH "$ld_library_path"
+  }
+  if { $orig_ld_run_path_saved } {
+    setenv LD_RUN_PATH "$ld_library_path:$orig_ld_run_path"
+  } else {
+    setenv LD_RUN_PATH "$ld_library_path"
+  }
+  # The default shared library dynamic path search for 64-bit
+  # HP-UX executables searches LD_LIBRARY_PATH before SHLIB_PATH.
+  # LD_LIBRARY_PATH isn't used for 32-bit executables.  Thus, we
+  # set LD_LIBRARY_PATH and SHLIB_PATH as if they were independent.
+  if { $orig_shlib_path_saved } {
+    setenv SHLIB_PATH "$ld_library_path:$orig_shlib_path"
+  } else {
+    setenv SHLIB_PATH "$ld_library_path"
+  }
+  if { $orig_ld_libraryn32_path_saved } {
+    setenv LD_LIBRARYN32_PATH "$ld_library_path:$orig_ld_libraryn32_path"
+  } elseif { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARYN32_PATH "$ld_library_path:$orig_ld_library_path"
+  } else {
+    setenv LD_LIBRARYN32_PATH "$ld_library_path"
+  }
+  if { $orig_ld_library64_path_saved } {
+    setenv LD_LIBRARY64_PATH "$ld_library_path:$orig_ld_library64_path"
+  } elseif { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARY64_PATH "$ld_library_path:$orig_ld_library_path"
+  } else {
+    setenv LD_LIBRARY64_PATH "$ld_library_path"
+  }
+  if { $orig_ld_library_path_32_saved } {
+    setenv LD_LIBRARY_PATH_32 "$ld_library_path:$orig_ld_library_path_32"
+  } elseif { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARY_PATH_32 "$ld_library_path:$orig_ld_library_path"
+  } else {
+    setenv LD_LIBRARY_PATH_32 "$ld_library_path"
+  }
+  if { $orig_ld_library_path_64_saved } {
+    setenv LD_LIBRARY_PATH_64 "$ld_library_path:$orig_ld_library_path_64"
+  } elseif { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARY_PATH_64 "$ld_library_path:$orig_ld_library_path"
+  } else {
+    setenv LD_LIBRARY_PATH_64 "$ld_library_path"
+  }
+  if { $orig_dyld_library_path_saved } {
+    setenv DYLD_LIBRARY_PATH "$ld_library_path:$orig_dyld_library_path"
+  } else {
+    setenv DYLD_LIBRARY_PATH "$ld_library_path"
+  }
+  if { [istarget *-*-cygwin*] || [ istarget *-*-msys* ] || [istarget *-*-mingw*] } {
+    if { $orig_path_saved } {
+      setenv PATH "$ld_library_path:$orig_path"
+    } else {
+      setenv PATH "$ld_library_path"
+    }
+  }
+
+  verbose -log "set_ld_library_path_env_vars: ld_library_path=$ld_library_path"
+}
+
+#######################################
+# proc restore_ld_library_path_env_vars { }
+#######################################
+
+proc restore_ld_library_path_env_vars { } {
+  global orig_environment_saved
+  global orig_ld_library_path_saved
+  global orig_ld_run_path_saved
+  global orig_shlib_path_saved
+  global orig_ld_libraryn32_path_saved
+  global orig_ld_library64_path_saved
+  global orig_ld_library_path_32_saved
+  global orig_ld_library_path_64_saved
+  global orig_dyld_library_path_saved
+  global orig_path_saved
+  global orig_ld_library_path
+  global orig_ld_run_path
+  global orig_shlib_path
+  global orig_ld_libraryn32_path
+  global orig_ld_library64_path
+  global orig_ld_library_path_32
+  global orig_ld_library_path_64
+  global orig_dyld_library_path
+  global orig_path
+
+  if { $orig_environment_saved == 0 } {
+    return
+  }
+
+  if { $orig_ld_library_path_saved } {
+    setenv LD_LIBRARY_PATH "$orig_ld_library_path"
+  } elseif [info exists env(LD_LIBRARY_PATH)] {
+    unsetenv LD_LIBRARY_PATH
+  }
+  if { $orig_ld_run_path_saved } {
+    setenv LD_RUN_PATH "$orig_ld_run_path"
+  } elseif [info exists env(LD_RUN_PATH)] {
+    unsetenv LD_RUN_PATH
+  }
+  if { $orig_shlib_path_saved } {
+    setenv SHLIB_PATH "$orig_shlib_path"
+  } elseif [info exists env(SHLIB_PATH)] {
+    unsetenv SHLIB_PATH
+  }
+  if { $orig_ld_libraryn32_path_saved } {
+    setenv LD_LIBRARYN32_PATH "$orig_ld_libraryn32_path"
+  } elseif [info exists env(LD_LIBRARYN32_PATH)] {
+    unsetenv LD_LIBRARYN32_PATH
+  }
+  if { $orig_ld_library64_path_saved } {
+    setenv LD_LIBRARY64_PATH "$orig_ld_library64_path"
+  } elseif [info exists env(LD_LIBRARY64_PATH)] {
+    unsetenv LD_LIBRARY64_PATH
+  }
+  if { $orig_ld_library_path_32_saved } {
+    setenv LD_LIBRARY_PATH_32 "$orig_ld_library_path_32"
+  } elseif [info exists env(LD_LIBRARY_PATH_32)] {
+    unsetenv LD_LIBRARY_PATH_32
+  }
+  if { $orig_ld_library_path_64_saved } {
+    setenv LD_LIBRARY_PATH_64 "$orig_ld_library_path_64"
+  } elseif [info exists env(LD_LIBRARY_PATH_64)] {
+    unsetenv LD_LIBRARY_PATH_64
+  }
+  if { $orig_dyld_library_path_saved } {
+    setenv DYLD_LIBRARY_PATH "$orig_dyld_library_path"
+  } elseif [info exists env(DYLD_LIBRARY_PATH)] {
+    unsetenv DYLD_LIBRARY_PATH
+  }
+  if { $orig_path_saved } {
+    setenv PATH "$orig_path"
+  } elseif [info exists env(PATH)] {
+    unsetenv PATH
+  }
+}
+
+#######################################
+# proc get_shlib_extension { }
+#######################################
+
+proc get_shlib_extension { } {
+    global shlib_ext
+
+    if { [ istarget *-*-darwin* ] } {
+	set shlib_ext "dylib"
+    } elseif { [ istarget *-*-cygwin* ] || [ istarget *-*-msys* ] || [ istarget *-*-mingw* ] } {
+	set shlib_ext "dll"
+    } elseif { [ istarget hppa*-*-hpux* ] } {
+	set shlib_ext "sl"
+    } else {
+	set shlib_ext "so"
+    }
+    return $shlib_ext
+}
+
Index: libffi-3.4.6/testsuite/config/default.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/config/default.exp b/libffi-3.4.6/testsuite/config/default.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/config/default.exp	
@@ -0,0 +1,1 @@
+load_lib "standard.exp"
Index: libffi-3.4.6/testsuite/libffi.go/go.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.go/go.exp b/libffi-3.4.6/testsuite/libffi.go/go.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.go/go.exp	
@@ -0,0 +1,36 @@
+# Copyright (C) 2003, 2006, 2009, 2010, 2014 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+dg-init
+libffi-init
+
+global srcdir subdir
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.{c,cc}]]
+
+if { [libffi_feature_test "#ifdef FFI_GO_CLOSURES"] } {
+    run-many-tests $tlist ""
+} else {
+    foreach test $tlist {
+	unsupported "$test"
+    }
+}
+
+dg-finish
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/libffi.go/ffitest.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.go/ffitest.h b/libffi-3.4.6/testsuite/libffi.go/ffitest.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.go/ffitest.h	
@@ -0,0 +1,1 @@
+#include "../libffi.call/ffitest.h"
Index: libffi-3.4.6/testsuite/libffi.go/closure1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.go/closure1.c b/libffi-3.4.6/testsuite/libffi.go/closure1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.go/closure1.c	
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+void doit(ffi_cif *cif, void *rvalue, void **avalue, void *closure)
+{
+  (void)cif;
+  (void)avalue;
+  *(void **)rvalue = closure;
+}
+
+typedef void * (*FN)(void);
+
+int main()
+{
+  ffi_cif cif;
+  ffi_go_closure cl;
+  void *result;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 0, &ffi_type_pointer, NULL) == FFI_OK);
+  CHECK(ffi_prep_go_closure(&cl, &cif, doit) == FFI_OK);
+
+  ffi_call_go(&cif, FFI_FN(*(FN *)&cl), &result, NULL, &cl);
+
+  CHECK(result == &cl);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.go/aa-direct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.go/aa-direct.c b/libffi-3.4.6/testsuite/libffi.go/aa-direct.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.go/aa-direct.c	
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+
+#include "static-chain.h"
+
+#if defined(__GNUC__) && !defined(__clang__) && defined(STATIC_CHAIN_REG)
+
+#include "ffitest.h"
+
+/* Blatent assumption here that the prologue doesn't clobber the
+   static chain for trivial functions.  If this is not true, don't
+   define STATIC_CHAIN_REG, and we'll test what we can via other tests.  */
+void *doit(void)
+{
+  register void *chain __asm__(STATIC_CHAIN_REG);
+  return chain;
+}
+
+int main()
+{
+  ffi_cif cif;
+  void *result;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 0, &ffi_type_pointer, NULL) == FFI_OK);
+
+  ffi_call_go(&cif, FFI_FN(doit), &result, NULL, &result);
+
+  CHECK(result == &result);
+
+  return 0;
+}
+
+#else /* UNSUPPORTED */
+int main() { return 0; }
+#endif
Index: libffi-3.4.6/testsuite/libffi.go/static-chain.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.go/static-chain.h b/libffi-3.4.6/testsuite/libffi.go/static-chain.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.go/static-chain.h	
@@ -0,0 +1,19 @@
+#ifdef __aarch64__
+# define STATIC_CHAIN_REG  "x18"
+#elif defined(__alpha__)
+# define STATIC_CHAIN_REG  "$1"
+#elif defined(__arm__)
+# define STATIC_CHAIN_REG  "ip"
+#elif defined(__sparc__)
+# if defined(__arch64__) || defined(__sparcv9)
+#  define STATIC_CHAIN_REG "g5"
+# else
+#  define STATIC_CHAIN_REG "g2"
+# endif
+#elif defined(__x86_64__)
+# define STATIC_CHAIN_REG  "r10"
+#elif defined(__i386__)
+# ifndef ABI_NUM
+#  define STATIC_CHAIN_REG  "ecx"	/* FFI_DEFAULT_ABI only */
+# endif
+#endif
Index: libffi-3.4.6/testsuite/emscripten/build.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/build.sh b/libffi-3.4.6/testsuite/emscripten/build.sh
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/build.sh	
@@ -0,0 +1,63 @@
+#!/usr/bin/env bash
+command -v emcc >/dev/null 2>&1 || {
+  echo >&2 "emsdk could not be found.  Aborting."
+  exit 1
+}
+
+set -e
+
+SOURCE_DIR=$PWD
+
+# Working directories
+TARGET=$SOURCE_DIR/target
+mkdir -p "$TARGET"
+
+# Define default arguments
+
+# JS BigInt to Wasm i64 integration, disabled by default
+# This needs to test false if there exists an environment variable called
+# WASM_BIGINT whose contents are empty. Don't use +x.
+if [ -n "${WASM_BIGINT}" ]; then
+  WASM_BIGINT=true
+else
+  WASM_BIGINT=false
+fi
+
+# Parse arguments
+while [ $# -gt 0 ]; do
+  case $1 in
+  --wasm-bigint) WASM_BIGINT=true ;;
+  --debug) DEBUG=true ;;
+  *)
+    echo "ERROR: Unknown parameter: $1" >&2
+    exit 1
+    ;;
+  esac
+  shift
+done
+
+# Common compiler flags
+export CFLAGS="-O3 -fPIC"
+if [ "$WASM_BIGINT" = "true" ]; then
+  # We need to detect WASM_BIGINT support at compile time
+  export CFLAGS+=" -DWASM_BIGINT"
+fi
+if [ "$DEBUG" = "true" ]; then
+  export CFLAGS+=" -DDEBUG_F"
+fi
+export CXXFLAGS="$CFLAGS"
+
+# Build paths
+export CPATH="$TARGET/include"
+export PKG_CONFIG_PATH="$TARGET/lib/pkgconfig"
+export EM_PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
+
+# Specific variables for cross-compilation
+export CHOST="wasm32-unknown-linux" # wasm32-unknown-emscripten
+
+autoreconf -fiv
+emconfigure ./configure --host=$CHOST --prefix="$TARGET" --enable-static --disable-shared --disable-dependency-tracking \
+  --disable-builddir --disable-multi-os-directory --disable-raw-api --disable-docs
+make install
+cp fficonfig.h target/include/
+cp include/ffi_common.h target/include/
Index: libffi-3.4.6/testsuite/emscripten/test.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/test.html b/libffi-3.4.6/testsuite/emscripten/test.html
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/test.html	
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <script src="test.js"></script>
+  </head>
+  <body></body>
+</html>
Index: libffi-3.4.6/testsuite/emscripten/conftest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/conftest.py b/libffi-3.4.6/testsuite/emscripten/conftest.py
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/conftest.py	
@@ -0,0 +1,86 @@
+from pathlib import Path
+from pytest import fixture
+from pytest_pyodide.server import spawn_web_server
+from pytest_pyodide import runner
+
+import logging
+
+TEST_PATH = Path(__file__).parents[1].resolve()
+
+
+class BaseRunner(runner._BrowserBaseRunner):
+    def __init__(
+        self,
+        *args,
+        test_dir,
+        **kwargs,
+    ):
+        self.test_dir = test_dir
+        super().__init__(
+            *args,
+            **kwargs,
+            load_pyodide=False,
+        )
+
+    def prepare_driver(self):
+        self.base_url = (
+            f"http://{self.server_hostname}:{self.server_port}/{self.test_dir}/"
+        )
+        self.goto(f"{self.base_url}/test.html")
+
+    def javascript_setup(self):
+        self.run_js("globalThis.TestModule = await globalThis.Module();")
+
+
+class FirefoxRunner(BaseRunner, runner.SeleniumFirefoxRunner):
+    pass
+
+
+class ChromeRunner(BaseRunner, runner.SeleniumChromeRunner):
+    pass
+
+
+# TODO: Figure out how to get NodeRunner to work.
+
+RUNNER_DICT = {x.browser: x for x in [FirefoxRunner, ChromeRunner]}
+
+
+@fixture(params=list(RUNNER_DICT), scope="class")
+def selenium_class_scope(request, web_server_main):
+    server_hostname, server_port, server_log = web_server_main
+    assert request.param in RUNNER_DICT
+
+    logger = logging.getLogger('selenium')
+    logger.setLevel(logging.DEBUG)
+
+    cls = RUNNER_DICT[request.param]
+    selenium = cls(
+        test_dir=request.cls.TEST_BUILD_DIR,
+        server_port=server_port,
+        server_hostname=server_hostname,
+        server_log=server_log,
+    )
+    request.cls.call_number = 0
+    try:
+        yield selenium
+    finally:
+        print(selenium.logs)
+        selenium.driver.quit()
+
+
+@fixture(scope="function")
+def selenium(selenium_class_scope, request):
+    selenium = selenium_class_scope
+    request.cls.call_number += 1
+    # Refresh page every 50 calls to prevent firefox out of memory errors
+    if request.cls.call_number % 50 == 0:
+        selenium.driver.refresh()
+        selenium.javascript_setup()
+    selenium.clean_logs()
+    yield selenium
+
+
+@fixture(scope="session")
+def web_server_main(request):
+    with spawn_web_server(TEST_PATH) as output:
+        yield output
Index: libffi-3.4.6/testsuite/emscripten/node-tests.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/node-tests.sh b/libffi-3.4.6/testsuite/emscripten/node-tests.sh
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/node-tests.sh	
@@ -0,0 +1,48 @@
+#!/bin/bash
+
+# JS BigInt to Wasm i64 integration, disabled by default
+WASM_BIGINT=false
+
+emcc_exists="$(command -v emcc)"
+if [ ! "${emcc_exists}" ]; then
+  echo "Emscripten not on path"
+  exit 1
+fi
+
+# Parse arguments
+while [ $# -gt 0 ]; do
+  case $1 in
+  --wasm-bigint) WASM_BIGINT=true ;;
+  *)
+    echo "ERROR: Unknown parameter: $1" >&2
+    exit 1
+    ;;
+  esac
+  shift
+done
+
+# Common compiler flags
+export CFLAGS="-fPIC $EXTRA_CFLAGS"
+if [ "$WASM_BIGINT" = "true" ]; then
+  # We need to detect WASM_BIGINT support at compile time
+  export CFLAGS+=" -DWASM_BIGINT"
+fi
+export CXXFLAGS="$CFLAGS -sNO_DISABLE_EXCEPTION_CATCHING $EXTRA_CXXFLAGS"
+export LDFLAGS="-sEXPORTED_FUNCTIONS=_main,_malloc,_free -sALLOW_TABLE_GROWTH -sASSERTIONS -sNO_DISABLE_EXCEPTION_CATCHING"
+if [ "$WASM_BIGINT" = "true" ]; then
+  export LDFLAGS+=" -sWASM_BIGINT"
+else
+  export LDFLAGS+=" -sEXPORTED_RUNTIME_METHODS='getTempRet0,setTempRet0'"
+fi
+
+# Specific variables for cross-compilation
+export CHOST="wasm32-unknown-linux" # wasm32-unknown-emscripten
+
+autoreconf -fiv
+emconfigure ./configure --prefix="$(pwd)/target" --host=$CHOST --enable-static --disable-shared \
+  --disable-builddir --disable-multi-os-directory --disable-raw-api --disable-docs ||
+  (cat config.log && exit 1)
+make
+
+EMMAKEN_JUST_CONFIGURE=1 emmake make check \
+  RUNTESTFLAGS="LDFLAGS_FOR_TARGET='$LDFLAGS'" || (cat testsuite/libffi.log && exit 1)
Index: libffi-3.4.6/testsuite/emscripten/build-tests.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/build-tests.sh b/libffi-3.4.6/testsuite/emscripten/build-tests.sh
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/build-tests.sh	
@@ -0,0 +1,54 @@
+#!/usr/bin/env bash
+emcc_exists="$(command -v emcc)"
+if [ ! "${emcc_exists}" ]; then
+  echo "Emscripten not on path"
+  exit 1
+fi
+
+set -e
+
+cd "$1"
+shift
+
+# Parse arguments
+while [ $# -gt 0 ]; do
+  case $1 in
+  --wasm-bigint) WASM_BIGINT=true ;;
+  *)
+    echo "ERROR: Unknown parameter: $1" >&2
+    exit 1
+    ;;
+  esac
+  shift
+done
+
+
+export CFLAGS="-fPIC -O2 -I../../target/include $EXTRA_CFLAGS"
+export CXXFLAGS="$CFLAGS -sNO_DISABLE_EXCEPTION_CATCHING $EXTRA_CXXFLAGS"
+export LDFLAGS=" \
+    -L../../target/lib/ -lffi \
+    -sEXPORT_ALL \
+    -sMODULARIZE \
+    -sMAIN_MODULE \
+    -sNO_DISABLE_EXCEPTION_CATCHING \
+    $EXTRA_LD_FLAGS \
+"
+
+# This needs to test false if there exists an environment variable called
+# WASM_BIGINT whose contents are empty. Don't use +x.
+if [ -n "${WASM_BIGINT}" ] ; then
+  export LDFLAGS+=" -sWASM_BIGINT"
+else
+  export LDFLAGS+=" -sEXPORTED_RUNTIME_METHODS='getTempRet0,setTempRet0'"
+fi
+
+# Rename main functions to test__filename so we can link them together
+ls *c | sed 's!\(.*\)\.c!sed -i "s/main/test__\1/g" \0!g' | bash
+
+# Compile
+ls *.c | sed 's/\(.*\)\.c/emcc $CFLAGS -c \1.c -o \1.o /g' | bash
+ls *.cc | sed 's/\(.*\)\.cc/em++ $CXXFLAGS -c \1.cc -o \1.o /g' | bash
+
+# Link
+em++ $LDFLAGS *.o -o test.js
+cp ../emscripten/test.html .
Index: libffi-3.4.6/testsuite/emscripten/test_libffi.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/emscripten/test_libffi.py b/libffi-3.4.6/testsuite/emscripten/test_libffi.py
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/emscripten/test_libffi.py	
@@ -0,0 +1,51 @@
+import subprocess
+import pathlib
+import pytest
+
+TEST_PATH = pathlib.Path(__file__).parents[1].resolve()
+
+xfails = {}
+
+
+def libffi_tests(self, selenium, libffi_test):
+    if libffi_test in xfails:
+        pytest.xfail(f'known failure with code "{xfails[libffi_test]}"')
+    res = selenium.run_js(
+        """
+        window.TestModule = await Module();
+        """
+    )
+    selenium.run_js(
+        f"""
+        try {{
+            TestModule._test__{libffi_test}();
+        }} catch(e){{
+            if(e.name !== "ExitStatus"){{
+                throw e;
+            }}
+            if(e.status !== 0){{
+                throw new Error(`Terminated with nonzero status code ${{e.status}}: ` + e.message);
+            }}
+        }}
+        """
+    )
+
+
+class TestCall:
+    TEST_BUILD_DIR = "libffi.call.test"
+    test_call = libffi_tests
+
+
+class TestClosures:
+    TEST_BUILD_DIR = "libffi.closures.test"
+    test_closures = libffi_tests
+
+
+def pytest_generate_tests(metafunc):
+    test_build_dir = metafunc.cls.TEST_BUILD_DIR
+    test_names = [x.stem for x in (TEST_PATH / test_build_dir).glob("*.o")]
+    metafunc.parametrize("libffi_test", test_names)
+
+
+if __name__ == "__main__":
+    subprocess.call(["build-tests.sh", "libffi.call"])
Index: libffi-3.4.6/testsuite/libffi.call/s55.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/s55.c b/libffi-3.4.6/testsuite/libffi.call/s55.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/s55.c	
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  float f;
+} s55;
+
+static s55 ABI_ATTR f55(s55 ts, float f)
+{
+  s55 r;
+  r.f = ts.f + f;
+  printf ("f55>> %g + %g = %g\n", ts.f, f, r.f);
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  s55 F, Fr;
+  float f;
+  void *values[] = { &F, &f };
+  ffi_type s55_type;
+  ffi_type *args[] = { &s55_type, &ffi_type_float };
+  ffi_type *s55_type_elements[] = { &ffi_type_float, NULL };
+
+  /* This is a hack to get a properly aligned result buffer */
+  s55 *s55_result =
+    (s55 *) malloc (sizeof(s55));
+
+  s55_type.size = 0;
+  s55_type.alignment = 0;
+  s55_type.type = FFI_TYPE_STRUCT;
+  s55_type.elements = s55_type_elements;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &s55_type, args) == FFI_OK);
+
+  F.f = 1;
+  Fr = f55(F, 2.14);
+  printf ("%g\n", Fr.f);
+
+  F.f = 1;
+  f = 2.14;
+  ffi_call(&cif, FFI_FN(f55), s55_result, values);
+  printf ("%g\n", s55_result->f);
+
+  fflush(0);
+
+  CHECK(fabs(Fr.f - s55_result->f) < FLT_EPSILON);
+
+  free (s55_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/many.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/many.c b/libffi-3.4.6/testsuite/libffi.call/many.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/many.c	
@@ -0,0 +1,59 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+static float ABI_ATTR many(float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8, float f9, float f10, float f11, float f12, float f13)
+{
+#if 0
+  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
+	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
+	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
+	 (double) f11, (double) f12, (double) f13);
+#endif
+
+  return f1+f2+f3+f4+f5+f6+f7+f8+f9+f10+f11+f12+f13;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[13];
+  void *values[13];
+  float fa[13];
+  float f, ff;
+  int i;
+
+  for (i = 0; i < 13; i++)
+    {
+      args[i] = &ffi_type_float;
+      values[i] = &fa[i];
+      fa[i] = (float) i;
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, ABI_NUM, 13,
+		       &ffi_type_float, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1],
+	       fa[2], fa[3],
+	       fa[4], fa[5],
+	       fa[6], fa[7],
+	       fa[8], fa[9],
+	       fa[10],fa[11],fa[12]);
+
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_1.c b/libffi-3.4.6/testsuite/libffi.call/va_1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_1.c	
@@ -0,0 +1,78 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	        ARM Ltd. */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+int
+main (void)
+{
+  ffi_cif cif;
+  ffi_type* arg_types[15];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = &ffi_type_uchar;
+  arg_types[5] = &ffi_type_schar;
+  arg_types[6] = &ffi_type_ushort;
+  arg_types[7] = &ffi_type_sshort;
+  arg_types[8] = &ffi_type_uint;
+  arg_types[9] = &ffi_type_sint;
+  arg_types[10] = &ffi_type_ulong;
+  arg_types[11] = &ffi_type_slong;
+  arg_types[12] = &ffi_type_double;
+  arg_types[13] = &ffi_type_double;
+  arg_types[14] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 14, &ffi_type_sint, arg_types) == FFI_BAD_ARGTYPE);
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_2.c b/libffi-3.4.6/testsuite/libffi.call/va_2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_2.c	
@@ -0,0 +1,220 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	        ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* m68k-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+
+static int
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+  unsigned char uc;
+  signed char sc;
+  unsigned short us;
+  signed short ss;
+  unsigned int ui;
+  signed int si;
+  unsigned long ul;
+  signed long sl;
+  float f;
+  double d;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+
+  uc = va_arg (ap, unsigned);
+  sc = va_arg (ap, signed);
+
+  us = va_arg (ap, unsigned);
+  ss = va_arg (ap, signed);
+
+  ui = va_arg (ap, unsigned int);
+  si = va_arg (ap, signed int);
+
+  ul = va_arg (ap, unsigned long);
+  sl = va_arg (ap, signed long);
+
+  f = va_arg (ap, double);	/* C standard promotes float->double
+				   when anonymous */
+  d = va_arg (ap, double);
+
+  printf ("%u %u %u %u %u %u %u %u %u uc=%u sc=%d %u %d %u %d %lu %ld %f %f\n",
+	  s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, s2.b,
+	  uc, sc,
+	  us, ss,
+	  ui, si,
+	  ul, sl,
+	  f, d);
+
+  va_end (ap);
+
+  CHECK(s1.a == 5);
+  CHECK(s1.b == 6);
+  CHECK(l.a == 10);
+  CHECK(l.b == 11);
+  CHECK(l.c == 12);
+  CHECK(l.d == 13);
+  CHECK(l.e == 14);
+  CHECK(s2.a == 7);
+  CHECK(s2.b == 8);
+  CHECK(uc == 9);
+  CHECK(sc == 10);
+  CHECK(us == 11);
+  CHECK(ss == 12);
+  CHECK(ui == 13);
+  CHECK(si == 14);
+  CHECK(ul == 15);
+  CHECK(sl == 16);
+  CHECK((int)f == 2);
+  CHECK((int)d == 3);
+
+  return n + 1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[15];
+  ffi_type* arg_types[15];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  ffi_arg res;
+
+  unsigned int uc;
+  signed int sc;
+  unsigned int us;
+  signed int ss;
+  unsigned int ui;
+  signed int si;
+  unsigned long ul;
+  signed long sl;
+  double d1;
+  double f1;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = &ffi_type_uint;
+  arg_types[5] = &ffi_type_sint;
+  arg_types[6] = &ffi_type_uint;
+  arg_types[7] = &ffi_type_sint;
+  arg_types[8] = &ffi_type_uint;
+  arg_types[9] = &ffi_type_sint;
+  arg_types[10] = &ffi_type_ulong;
+  arg_types[11] = &ffi_type_slong;
+  arg_types[12] = &ffi_type_double;
+  arg_types[13] = &ffi_type_double;
+  arg_types[14] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 14, &ffi_type_sint, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  uc = 9;
+  sc = 10;
+  us = 11;
+  ss = 12;
+  ui = 13;
+  si = 14;
+  ul = 15;
+  sl = 16;
+  f1 = 2.12;
+  d1 = 3.13;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = &uc;
+  args[5] = &sc;
+  args[6] = &us;
+  args[7] = &ss;
+  args[8] = &ui;
+  args[9] = &si;
+  args[10] = &ul;
+  args[11] = &sl;
+  args[12] = &f1;
+  args[13] = &d1;
+  args[14] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+  CHECK(res == 42);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_3.c b/libffi-3.4.6/testsuite/libffi.call/va_3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_3.c	
@@ -0,0 +1,154 @@
+/* Area:		ffi_call
+   Purpose:		Test function with multiple fixed args and variable argument list.
+   Limitations:	none.
+   PR:			none.
+   Originator:	        ARM Ltd., Oracle */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* m68k-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+/*
+ * This is a modified version of va_2.c that has fixed arguments with "small" types that
+ * are not allowed as variable arguments, but they should be still allowed as fixed args.
+ */
+
+static int
+test_fn (char a1, float a2, int n, ...)
+{
+  va_list ap;
+  unsigned char uc;
+  signed char sc;
+  unsigned short us;
+  signed short ss;
+  unsigned int ui;
+  signed int si;
+  unsigned long ul;
+  signed long sl;
+  float f;
+  double d;
+
+  va_start (ap, n);
+
+  uc = va_arg (ap, unsigned);
+  sc = va_arg (ap, signed);
+
+  us = va_arg (ap, unsigned);
+  ss = va_arg (ap, signed);
+
+  ui = va_arg (ap, unsigned int);
+  si = va_arg (ap, signed int);
+
+  ul = va_arg (ap, unsigned long);
+  sl = va_arg (ap, signed long);
+
+  f = va_arg (ap, double);	/* C standard promotes float->double
+				   when anonymous */
+  d = va_arg (ap, double);
+
+  printf ("%d %f uc=%u sc=%d %u %d %u %d %lu %ld %f %f\n",
+	  a1, a2,
+	  uc, sc,
+	  us, ss,
+	  ui, si,
+	  ul, sl,
+	  f, d);
+
+  va_end (ap);
+
+  CHECK(a1 == 1);
+  CHECK((int)a2 == 2);
+  CHECK(uc == 9);
+  CHECK(sc == 10);
+  CHECK(us == 11);
+  CHECK(ss == 12);
+  CHECK(ui == 13);
+  CHECK(si == 14);
+  CHECK(ul == 15);
+  CHECK(sl == 16);
+  CHECK((int)f == 2);
+  CHECK((int)d == 3);
+
+  return n + 1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[14];
+  ffi_type* arg_types[14];
+
+  char a1;
+  float a2;
+  int n;
+  ffi_arg res;
+
+  unsigned int uc;
+  signed int sc;
+  unsigned int us;
+  signed int ss;
+  unsigned int ui;
+  signed int si;
+  unsigned long ul;
+  signed long sl;
+  double d1;
+  double f1;
+
+  arg_types[0] = &ffi_type_schar;
+  arg_types[1] = &ffi_type_float;
+  arg_types[2] = &ffi_type_sint;
+  arg_types[3] = &ffi_type_uint;
+  arg_types[4] = &ffi_type_sint;
+  arg_types[5] = &ffi_type_uint;
+  arg_types[6] = &ffi_type_sint;
+  arg_types[7] = &ffi_type_uint;
+  arg_types[8] = &ffi_type_sint;
+  arg_types[9] = &ffi_type_ulong;
+  arg_types[10] = &ffi_type_slong;
+  arg_types[11] = &ffi_type_double;
+  arg_types[12] = &ffi_type_double;
+  arg_types[13] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 3, 13, &ffi_type_sint, arg_types) == FFI_OK);
+
+  a1 = 1;
+  a2 = 2.0f;
+  n = 41;
+
+  uc = 9;
+  sc = 10;
+  us = 11;
+  ss = 12;
+  ui = 13;
+  si = 14;
+  ul = 15;
+  sl = 16;
+  f1 = 2.12;
+  d1 = 3.13;
+
+  args[0] = &a1;
+  args[1] = &a2;
+  args[2] = &n;
+  args[3] = &uc;
+  args[4] = &sc;
+  args[5] = &us;
+  args[6] = &ss;
+  args[7] = &ui;
+  args[8] = &si;
+  args[9] = &ul;
+  args[10] = &sl;
+  args[11] = &f1;
+  args[12] = &d1;
+  args[13] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "1 2.000000 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+  CHECK(res == 42);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float.c b/libffi-3.4.6/testsuite/libffi.call/float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float.c	
@@ -0,0 +1,59 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static int floating(int a, float b, double c, long double d)
+{
+  int i;
+
+  i = (int) ((float)a/b + ((float)c/(float)d));
+
+  return i;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+
+  float f;
+  signed int si1;
+  double d;
+  long double ld;
+
+  args[0] = &ffi_type_sint;
+  values[0] = &si1;
+  args[1] = &ffi_type_float;
+  values[1] = &f;
+  args[2] = &ffi_type_double;
+  values[2] = &d;
+  args[3] = &ffi_type_longdouble;
+  values[3] = &ld;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_sint, args) == FFI_OK);
+
+  si1 = 6;
+  f = 3.14159;
+  d = (double)1.0/(double)3.0;
+  ld = 2.71828182846L;
+
+  floating (si1, f, d, ld);
+
+  ffi_call(&cif, FFI_FN(floating), &rint, values);
+
+  printf ("%d vs %d\n", (int)rint, floating (si1, f, d, ld));
+
+  CHECK((int)rint == floating(si1, f, d, ld));
+
+  exit (0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/many2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/many2.c b/libffi-3.4.6/testsuite/libffi.call/many2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/many2.c	
@@ -0,0 +1,57 @@
+/* Area:        ffi_call
+   Purpose:     Check uint8_t arguments.
+   Limitations: none.
+   PR:          PR45677.
+   Originator:  Dan Witte <dwitte@gmail.com> 20100916  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+#define NARGS 7
+
+typedef unsigned char u8;
+
+#ifdef __GNUC__
+__attribute__((noinline))
+#endif
+uint8_t
+foo (uint8_t a, uint8_t b, uint8_t c, uint8_t d,
+     uint8_t e, uint8_t f, uint8_t g)
+{
+  return a + b + c + d + e + f + g;
+}
+
+uint8_t ABI_ATTR
+bar (uint8_t a, uint8_t b, uint8_t c, uint8_t d,
+     uint8_t e, uint8_t f, uint8_t g)
+{
+  return foo (a, b, c, d, e, f, g);
+}
+
+int
+main (void)
+{
+  ffi_type *ffitypes[NARGS];
+  int i;
+  ffi_cif cif;
+  ffi_arg result = 0;
+  uint8_t args[NARGS];
+  void *argptrs[NARGS];
+
+  for (i = 0; i < NARGS; ++i)
+    ffitypes[i] = &ffi_type_uint8;
+
+  CHECK (ffi_prep_cif (&cif, ABI_NUM, NARGS,
+		       &ffi_type_uint8, ffitypes) == FFI_OK);
+
+  for (i = 0; i < NARGS; ++i)
+    {
+      args[i] = i;
+      argptrs[i] = &args[i];
+    }
+  ffi_call (&cif, FFI_FN (bar), &result, argptrs);
+
+  CHECK (result == 21);
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/call.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/call.exp b/libffi-3.4.6/testsuite/libffi.call/call.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/call.exp	
@@ -0,0 +1,54 @@
+# Copyright (C) 2003, 2006, 2009, 2010, 2014 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+dg-init
+libffi-init
+
+global srcdir subdir
+
+if { [string match $compiler_vendor "microsoft"] } {
+    # -wd4005  macro redefinition
+    # -wd4244  implicit conversion to type of smaller size
+    # -wd4305  truncation to smaller type
+    # -wd4477  printf %lu of uintptr_t
+    # -wd4312  implicit conversion to type of greater size
+    # -wd4311  pointer truncation to unsigned long
+    # -EHsc    C++ Exception Handling (no SEH exceptions)
+    set additional_options "-wd4005 -wd4244 -wd4305 -wd4477 -wd4312 -wd4311 -EHsc";
+} else {
+    set additional_options "";
+}
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.c]]
+
+run-many-tests $tlist $additional_options
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.cc]]
+
+# No C++ for or1k
+if { [istarget "or1k-*-*"] } {
+    foreach test $tlist {
+        unsupported "$test"
+    }
+} else {
+    run-many-tests $tlist $additional_options
+}
+
+dg-finish
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/libffi.call/float1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float1.c b/libffi-3.4.6/testsuite/libffi.call/float1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float1.c	
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+#include "float.h"
+
+#include <math.h>
+
+typedef union
+{
+  double d;
+  unsigned char c[sizeof (double)];
+} value_type;
+
+#define CANARY 0xba
+
+static double dblit(float f)
+{
+  return f/3.0;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float f;
+  value_type result[2];
+  unsigned int i;
+
+  args[0] = &ffi_type_float;
+  values[0] = &f;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, args) == FFI_OK);
+
+  f = 3.14159;
+
+  /* Put a canary in the return array.  This is a regression test for
+     a buffer overrun.  */
+  memset(result[1].c, CANARY, sizeof (double));
+
+  ffi_call(&cif, FFI_FN(dblit), &result[0].d, values);
+
+  /* These are not always the same!! Check for a reasonable delta */
+
+  CHECK(fabs(result[0].d - dblit(f)) < DBL_EPSILON);
+
+  /* Check the canary.  */
+  for (i = 0; i < sizeof (double); ++i)
+    CHECK(result[1].c[i] == CANARY);
+
+  exit(0);
+
+}
Index: libffi-3.4.6/testsuite/libffi.call/float2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float2.c b/libffi-3.4.6/testsuite/libffi.call/float2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float2.c	
@@ -0,0 +1,61 @@
+/* Area:	ffi_call
+   Purpose:	Check return value long double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+/* { dg-do run } */
+
+#include "ffitest.h"
+#include "float.h"
+
+#include <math.h>
+
+static long double ldblit(float f)
+{
+  return (long double) (((long double) f)/ (long double) 3.0);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float f;
+  long double ld;
+  long double original;
+
+  args[0] = &ffi_type_float;
+  values[0] = &f;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_longdouble, args) == FFI_OK);
+
+  f = 3.14159;
+
+#if defined(__sun) && defined(__GNUC__)
+  /* long double support under SunOS/gcc is pretty much non-existent.
+     You'll get the odd bus error in library routines like printf() */
+#else
+  printf ("%Lf\n", ldblit(f));
+#endif
+
+  ld = 666;
+  ffi_call(&cif, FFI_FN(ldblit), &ld, values);
+
+#if defined(__sun) && defined(__GNUC__)
+  /* long double support under SunOS/gcc is pretty much non-existent.
+     You'll get the odd bus error in library routines like printf() */
+#else
+  printf ("%Lf, %Lf, %Lf, %Lf\n", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);
+#endif
+
+  /* These are not always the same!! Check for a reasonable delta */
+  original = ldblit(f);
+  if (((ld > original) ? (ld - original) : (original - ld)) < LDBL_EPSILON)
+    puts("long double return value tests ok!");
+  else
+    CHECK(0);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/float3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float3.c b/libffi-3.4.6/testsuite/libffi.call/float3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float3.c	
@@ -0,0 +1,74 @@
+/* Area:	ffi_call
+   Purpose:	Check float arguments with different orders.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+#include "float.h"
+
+#include <math.h>
+
+static double floating_1(float a, double b, long double c)
+{
+  return (double) a + b + (double) c;
+}
+
+static double floating_2(long double a, double b, float c)
+{
+  return (double) a + b + (double) c;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double rd;
+
+  float f;
+  double d;
+  long double ld;
+
+  args[0] = &ffi_type_float;
+  values[0] = &f;
+  args[1] = &ffi_type_double;
+  values[1] = &d;
+  args[2] = &ffi_type_longdouble;
+  values[2] = &ld;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &ffi_type_double, args) == FFI_OK);
+
+  f = 3.14159;
+  d = (double)1.0/(double)3.0;
+  ld = 2.71828182846L;
+
+  floating_1 (f, d, ld);
+
+  ffi_call(&cif, FFI_FN(floating_1), &rd, values);
+
+  CHECK(fabs(rd - floating_1(f, d, ld)) < DBL_EPSILON);
+
+  args[0] = &ffi_type_longdouble;
+  values[0] = &ld;
+  args[1] = &ffi_type_double;
+  values[1] = &d;
+  args[2] = &ffi_type_float;
+  values[2] = &f;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &ffi_type_double, args) == FFI_OK);
+
+  floating_2 (ld, d, f);
+
+  ffi_call(&cif, FFI_FN(floating_2), &rd, values);
+
+  CHECK(fabs(rd - floating_2(ld, d, f)) < DBL_EPSILON);
+
+  exit (0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/float4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float4.c b/libffi-3.4.6/testsuite/libffi.call/float4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float4.c	
@@ -0,0 +1,62 @@
+/* Area:	ffi_call
+   Purpose:	Check denorm double value.
+   Limitations:	none.
+   PR:		PR26483.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+/* { dg-options "-mieee" { target alpha*-*-* } } */
+
+#include "ffitest.h"
+#include "float.h"
+
+typedef union
+{
+  double d;
+  unsigned char c[sizeof (double)];
+} value_type;
+
+#define CANARY 0xba
+
+static double dblit(double d)
+{
+  return d;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double d;
+  value_type result[2];
+  unsigned int i;
+
+  args[0] = &ffi_type_double;
+  values[0] = &d;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, args) == FFI_OK);
+  
+  d = DBL_MIN / 2;
+  
+  /* Put a canary in the return array.  This is a regression test for
+     a buffer overrun.  */
+  memset(result[1].c, CANARY, sizeof (double));
+
+  ffi_call(&cif, FFI_FN(dblit), &result[0].d, values);
+  
+  /* The standard delta check doesn't work for denorms.  Since we didn't do
+     any arithmetic, we should get the original result back, and hence an
+     exact check should be OK here.  */
+ 
+  CHECK(result[0].d == dblit(d));
+
+  /* Check the canary.  */
+  for (i = 0; i < sizeof (double); ++i)
+    CHECK(result[1].c[i] == CANARY);
+
+  exit(0);
+
+}
Index: libffi-3.4.6/testsuite/libffi.call/negint.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/negint.c b/libffi-3.4.6/testsuite/libffi.call/negint.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/negint.c	
@@ -0,0 +1,52 @@
+/* Area:	ffi_call
+   Purpose:	Check that negative integers are passed correctly.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static int checking(int a, short b, signed char c)
+{
+
+  return (a < 0 && b < 0 && c < 0);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+
+  signed int si;
+  signed short ss;
+  signed char sc;
+
+  args[0] = &ffi_type_sint;
+  values[0] = &si;
+  args[1] = &ffi_type_sshort;
+  values[1] = &ss;
+  args[2] = &ffi_type_schar;
+  values[2] = &sc;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &ffi_type_sint, args) == FFI_OK);
+
+  si = -6;
+  ss = -12;
+  sc = -1;
+
+  checking (si, ss, sc);
+
+  ffi_call(&cif, FFI_FN(checking), &rint, values);
+
+  printf ("%d vs %d\n", (int)rint, checking (si, ss, sc));
+
+  CHECK(rint != 0);
+
+  exit (0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/strlen.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/strlen.c b/libffi-3.4.6/testsuite/libffi.call/strlen.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/strlen.c	
@@ -0,0 +1,43 @@
+/* Area:	ffi_call
+   Purpose:	Check strlen function call.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static unsigned int ABI_ATTR my_strlen(char *s)
+{
+  return (unsigned int) (strlen(s));
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  char *s;
+
+  args[0] = &ffi_type_pointer;
+  values[0] = (void*) &s;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ffi_type_uint, args) == FFI_OK);
+
+  s = "a";
+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
+  CHECK(rint == 1);
+
+  s = "1234567";
+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
+  CHECK(rint == 7);
+
+  s = "1234567890123456789012345";
+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
+  CHECK(rint == 25);
+
+  exit (0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/ffitest.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/ffitest.h b/libffi-3.4.6/testsuite/libffi.call/ffitest.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/ffitest.h	
@@ -0,0 +1,163 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ffi.h>
+#include "fficonfig.h"
+
+#include <float.h>
+#include <math.h>
+
+#if defined HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+#if defined HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+
+#define MAX_ARGS 256
+
+#define CHECK(x) \
+   do { \
+      if(!(x)){ \
+         printf("Check failed:\n%s\n", #x); \
+         abort(); \
+      } \
+   } while(0)
+
+#define CHECK_FLOAT_EQ(x, y) \
+   do { \
+      if(fabs((x) - (y)) > FLT_EPSILON){ \
+         printf("Check failed CHECK_FLOAT_EQ(%s, %s)\n", #x, #y); \
+         abort(); \
+      } \
+   } while(0)
+
+#define CHECK_DOUBLE_EQ(x, y) \
+   do { \
+      if(fabs((x) - (y)) > DBL_EPSILON){ \
+         printf("Check failed CHECK_FLOAT_EQ(%s, %s)\n", #x, #y); \
+         abort(); \
+      } \
+   } while(0)
+
+/* Define macros so that compilers other than gcc can run the tests.  */
+#undef __UNUSED__
+#if defined(__GNUC__)
+#define __UNUSED__ __attribute__((__unused__))
+#define __STDCALL__ __attribute__((stdcall))
+#define __THISCALL__ __attribute__((thiscall))
+#define __FASTCALL__ __attribute__((fastcall))
+#define __MSABI__ __attribute__((ms_abi))
+#else
+#define __UNUSED__
+#define __STDCALL__ __stdcall
+#define __THISCALL__ __thiscall
+#define __FASTCALL__ __fastcall
+#endif
+
+#ifndef ABI_NUM
+#define ABI_NUM FFI_DEFAULT_ABI
+#define ABI_ATTR
+#endif
+
+/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a
+   file open.  */
+#ifdef HAVE_MMAP_ANON
+# undef HAVE_MMAP_DEV_ZERO
+
+# include <sys/mman.h>
+# ifndef MAP_FAILED
+#  define MAP_FAILED -1
+# endif
+# if !defined (MAP_ANONYMOUS) && defined (MAP_ANON)
+#  define MAP_ANONYMOUS MAP_ANON
+# endif
+# define USING_MMAP
+
+#endif
+
+#ifdef HAVE_MMAP_DEV_ZERO
+
+# include <sys/mman.h>
+# ifndef MAP_FAILED
+#  define MAP_FAILED -1
+# endif
+# define USING_MMAP
+
+#endif
+
+/* msvc kludge.  */
+#if defined(_MSC_VER)
+#define PRIdLL "I64d"
+#define PRIuLL "I64u"
+#else
+#define PRIdLL "lld"
+#define PRIuLL "llu"
+#endif
+
+/* Tru64 UNIX kludge.  */
+#if defined(__alpha__) && defined(__osf__)
+/* Tru64 UNIX V4.0 doesn't support %lld/%lld, but long is 64-bit.  */
+#undef PRIdLL
+#define PRIdLL "ld"
+#undef PRIuLL
+#define PRIuLL "lu"
+#define PRId8 "hd"
+#define PRIu8 "hu"
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#define PRIuPTR "lu"
+#endif
+
+/* PA HP-UX kludge.  */
+#if defined(__hppa__) && defined(__hpux__) && !defined(PRIuPTR)
+#define PRIuPTR "lu"
+#endif
+
+/* IRIX kludge.  */
+#if defined(__sgi)
+/* IRIX 6.5 <inttypes.h> provides all definitions, but only for C99
+   compilations.  */
+#define PRId8 "hhd"
+#define PRIu8 "hhu"
+#if (_MIPS_SZLONG == 32)
+#define PRId64 "lld"
+#define PRIu64 "llu"
+#endif
+/* This doesn't match <inttypes.h>, which always has "lld" here, but the
+   arguments are uint64_t, int64_t, which are unsigned long, long for
+   64-bit in <sgidefs.h>.  */
+#if (_MIPS_SZLONG == 64)
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#endif
+/* This doesn't match <inttypes.h>, which has "u" here, but the arguments
+   are uintptr_t, which is always unsigned long.  */
+#define PRIuPTR "lu"
+#endif
+
+/* Solaris < 10 kludge.  */
+#if defined(__sun__) && defined(__svr4__) && !defined(PRIuPTR)
+#if defined(__arch64__) || defined (__x86_64__)
+#define PRIuPTR "lu"
+#else
+#define PRIuPTR "u"
+#endif
+#endif
+
+/* MSVC kludge.  */
+#if defined _MSC_VER
+#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)
+#define PRIuPTR "lu"
+#define PRIu8 "u"
+#define PRId8 "d"
+#define PRIu64 "I64u"
+#define PRId64 "I64d"
+#endif
+#endif
+
+#ifndef PRIuPTR
+#define PRIuPTR "u"
+#endif
Index: libffi-3.4.6/testsuite/libffi.call/offsets.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/offsets.c b/libffi-3.4.6/testsuite/libffi.call/offsets.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/offsets.c	
@@ -0,0 +1,46 @@
+/* Area:		Struct layout
+   Purpose:		Test ffi_get_struct_offsets
+   Limitations:		none.
+   PR:			none.
+   Originator: 		Tom Tromey. */
+
+/* { dg-do run } */
+#include "ffitest.h"
+#include <stddef.h>
+
+struct test_1
+{
+  char c;
+  float f;
+  char c2;
+  int i;
+};
+
+int
+main (void)
+{
+  ffi_type test_1_type;
+  ffi_type *test_1_elements[5];
+  size_t test_1_offsets[4];
+
+  test_1_elements[0] = &ffi_type_schar;
+  test_1_elements[1] = &ffi_type_float;
+  test_1_elements[2] = &ffi_type_schar;
+  test_1_elements[3] = &ffi_type_sint;
+  test_1_elements[4] = NULL;
+
+  test_1_type.size = 0;
+  test_1_type.alignment = 0;
+  test_1_type.type = FFI_TYPE_STRUCT;
+  test_1_type.elements = test_1_elements;
+
+  CHECK (ffi_get_struct_offsets (FFI_DEFAULT_ABI, &test_1_type, test_1_offsets)
+	 == FFI_OK);
+  CHECK (test_1_type.size == sizeof (struct test_1));
+  CHECK (offsetof (struct test_1, c) == test_1_offsets[0]);
+  CHECK (offsetof (struct test_1, f) == test_1_offsets[1]);
+  CHECK (offsetof (struct test_1, c2) == test_1_offsets[2]);
+  CHECK (offsetof (struct test_1, i) == test_1_offsets[3]);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/strlen2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/strlen2.c b/libffi-3.4.6/testsuite/libffi.call/strlen2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/strlen2.c	
@@ -0,0 +1,49 @@
+/* Area:	ffi_call
+   Purpose:	Check strlen function call with additional arguments.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static int ABI_ATTR my_f(char *s, float a)
+{
+  return (int) strlen(s) + (int) a;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  char *s;
+  float v2;
+  args[0] = &ffi_type_pointer;
+  args[1] = &ffi_type_float;
+  values[0] = (void*) &s;
+  values[1] = (void*) &v2;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		       &ffi_type_sint, args) == FFI_OK);
+  
+  s = "a";
+  v2 = 0.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 1);
+  
+  s = "1234567";
+  v2 = -1.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 6);
+  
+  s = "1234567890123456789012345";
+  v2 = 1.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 26);
+  
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/strlen3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/strlen3.c b/libffi-3.4.6/testsuite/libffi.call/strlen3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/strlen3.c	
@@ -0,0 +1,49 @@
+/* Area:	ffi_call
+   Purpose:	Check strlen function call with additional arguments.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static int ABI_ATTR my_f(float a, char *s)
+{
+  return (int) strlen(s) + (int) a;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  char *s;
+  float v2;
+  args[1] = &ffi_type_pointer;
+  args[0] = &ffi_type_float;
+  values[1] = (void*) &s;
+  values[0] = (void*) &v2;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		       &ffi_type_sint, args) == FFI_OK);
+  
+  s = "a";
+  v2 = 0.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 1);
+  
+  s = "1234567";
+  v2 = -1.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 6);
+  
+  s = "1234567890123456789012345";
+  v2 = 1.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 26);
+  
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/strlen4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/strlen4.c b/libffi-3.4.6/testsuite/libffi.call/strlen4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/strlen4.c	
@@ -0,0 +1,55 @@
+/* Area:	ffi_call
+   Purpose:	Check strlen function call with additional arguments.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static int ABI_ATTR my_f(float a, char *s, int i)
+{
+  return (int) strlen(s) + (int) a + i;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  char *s;
+  int v1;
+  float v2;
+  args[2] = &ffi_type_sint;
+  args[1] = &ffi_type_pointer;
+  args[0] = &ffi_type_float;
+  values[2] = (void*) &v1;
+  values[1] = (void*) &s;
+  values[0] = (void*) &v2;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 3,
+		       &ffi_type_sint, args) == FFI_OK);
+  
+  s = "a";
+  v1 = 1;
+  v2 = 0.0;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 2);
+  
+  s = "1234567";
+  v2 = -1.0;
+  v1 = -2;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 4);
+  
+  s = "1234567890123456789012345";
+  v2 = 1.0;
+  v1 = 2;
+  ffi_call(&cif, FFI_FN(my_f), &rint, values);
+  CHECK(rint == 28);
+  
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct1.c b/libffi-3.4.6/testsuite/libffi.call/struct1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct1.c	
@@ -0,0 +1,67 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+  
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct2.c b/libffi-3.4.6/testsuite/libffi.call/struct2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct2.c	
@@ -0,0 +1,67 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  double d1;
+  double d2;
+} test_structure_2;
+
+static test_structure_2 ABI_ATTR struct2(test_structure_2 ts)
+{
+  ts.d1--;
+  ts.d2--;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  test_structure_2 ts2_arg;
+  ffi_type ts2_type;
+  ffi_type *ts2_type_elements[3];
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_2 *ts2_result =
+    (test_structure_2 *) malloc (sizeof(test_structure_2));
+
+  ts2_type.size = 0;
+  ts2_type.alignment = 0;
+  ts2_type.type = FFI_TYPE_STRUCT;
+  ts2_type.elements = ts2_type_elements;
+  ts2_type_elements[0] = &ffi_type_double;
+  ts2_type_elements[1] = &ffi_type_double;
+  ts2_type_elements[2] = NULL;
+
+  args[0] = &ts2_type;
+  values[0] = &ts2_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts2_type, args) == FFI_OK);
+  
+  ts2_arg.d1 = 5.55;
+  ts2_arg.d2 = 6.66;
+  
+  printf ("%g\n", ts2_arg.d1);
+  printf ("%g\n", ts2_arg.d2);
+  
+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
+  
+  printf ("%g\n", ts2_result->d1);
+  printf ("%g\n", ts2_result->d2);
+  
+  CHECK(ts2_result->d1 == 5.55 - 1);
+  CHECK(ts2_result->d2 == 6.66 - 1);
+  
+  free (ts2_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct3.c b/libffi-3.4.6/testsuite/libffi.call/struct3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct3.c	
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  int si;
+} test_structure_3;
+
+static test_structure_3 ABI_ATTR struct3(test_structure_3 ts)
+{
+  ts.si = -(ts.si*2);
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  int compare_value;
+  ffi_type ts3_type;
+  ffi_type *ts3_type_elements[2];
+
+  test_structure_3 ts3_arg;
+  test_structure_3 *ts3_result =
+    (test_structure_3 *) malloc (sizeof(test_structure_3));
+
+  ts3_type.size = 0;
+  ts3_type.alignment = 0;
+  ts3_type.type = FFI_TYPE_STRUCT;
+  ts3_type.elements = ts3_type_elements;
+  ts3_type_elements[0] = &ffi_type_sint;
+  ts3_type_elements[1] = NULL;
+
+  args[0] = &ts3_type;
+  values[0] = &ts3_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts3_type, args) == FFI_OK);
+  
+  ts3_arg.si = -123;
+  compare_value = ts3_arg.si;
+  
+  ffi_call(&cif, FFI_FN(struct3), ts3_result, values);
+  
+  printf ("%d %d\n", ts3_result->si, -(compare_value*2));
+  
+  CHECK(ts3_result->si == -(compare_value*2));
+ 
+  free (ts3_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct4.c b/libffi-3.4.6/testsuite/libffi.call/struct4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct4.c	
@@ -0,0 +1,64 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned ui1;
+  unsigned ui2;
+  unsigned ui3;
+} test_structure_4;
+
+static test_structure_4 ABI_ATTR struct4(test_structure_4 ts)
+{
+  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts4_type;
+  ffi_type *ts4_type_elements[4];  
+
+  test_structure_4 ts4_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_4 *ts4_result =
+    (test_structure_4 *) malloc (sizeof(test_structure_4));
+
+  ts4_type.size = 0;
+  ts4_type.alignment = 0;
+  ts4_type.type = FFI_TYPE_STRUCT;
+  ts4_type.elements = ts4_type_elements;
+  ts4_type_elements[0] = &ffi_type_uint;
+  ts4_type_elements[1] = &ffi_type_uint;
+  ts4_type_elements[2] = &ffi_type_uint;
+  ts4_type_elements[3] = NULL;
+
+  args[0] = &ts4_type;
+  values[0] = &ts4_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts4_type, args) == FFI_OK);
+  
+  ts4_arg.ui1 = 2;
+  ts4_arg.ui2 = 3;
+  ts4_arg.ui3 = 4;
+  
+  ffi_call (&cif, FFI_FN(struct4), ts4_result, values);
+  
+  CHECK(ts4_result->ui3 == 2U * 3U * 4U);
+ 
+  
+  free (ts4_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct5.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct5.c b/libffi-3.4.6/testsuite/libffi.call/struct5.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct5.c	
@@ -0,0 +1,66 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  char c1;
+  char c2;
+} test_structure_5;
+
+static test_structure_5 ABI_ATTR struct5(test_structure_5 ts1, test_structure_5 ts2)
+{
+  ts1.c1 += ts2.c1;
+  ts1.c2 -= ts2.c2;
+  
+  return ts1;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts5_type;
+  ffi_type *ts5_type_elements[3];
+
+  test_structure_5 ts5_arg1, ts5_arg2;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_5 *ts5_result =
+    (test_structure_5 *) malloc (sizeof(test_structure_5));
+
+  ts5_type.size = 0;
+  ts5_type.alignment = 0;
+  ts5_type.type = FFI_TYPE_STRUCT;
+  ts5_type.elements = ts5_type_elements;
+  ts5_type_elements[0] = &ffi_type_schar;
+  ts5_type_elements[1] = &ffi_type_schar;
+  ts5_type_elements[2] = NULL;
+
+  args[0] = &ts5_type;
+  args[1] = &ts5_type;
+  values[0] = &ts5_arg1;
+  values[1] = &ts5_arg2;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &ts5_type, args) == FFI_OK);
+  
+  ts5_arg1.c1 = 2;
+  ts5_arg1.c2 = 6;
+  ts5_arg2.c1 = 5;
+  ts5_arg2.c2 = 3;
+  
+  ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
+  
+  CHECK(ts5_result->c1 == 7); 
+  CHECK(ts5_result->c2 == 3);
+  
+  
+  free (ts5_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct6.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct6.c b/libffi-3.4.6/testsuite/libffi.call/struct6.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct6.c	
@@ -0,0 +1,64 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  float f;
+  double d;
+} test_structure_6;
+
+static test_structure_6 ABI_ATTR struct6 (test_structure_6 ts)
+{
+  ts.f += 1;
+  ts.d += 1;
+  
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts6_type;
+  ffi_type *ts6_type_elements[3];
+
+  test_structure_6 ts6_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_6 *ts6_result =
+    (test_structure_6 *) malloc (sizeof(test_structure_6));
+
+  ts6_type.size = 0;
+  ts6_type.alignment = 0;
+  ts6_type.type = FFI_TYPE_STRUCT;
+  ts6_type.elements = ts6_type_elements;
+  ts6_type_elements[0] = &ffi_type_float;
+  ts6_type_elements[1] = &ffi_type_double;
+  ts6_type_elements[2] = NULL;
+
+  args[0] = &ts6_type;
+  values[0] = &ts6_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts6_type, args) == FFI_OK);
+  
+  ts6_arg.f = 5.55f;
+  ts6_arg.d = 6.66;
+  
+  printf ("%g\n", ts6_arg.f);
+  printf ("%g\n", ts6_arg.d);
+
+  ffi_call(&cif, FFI_FN(struct6), ts6_result, values);
+    
+  CHECK(ts6_result->f == 5.55f + 1);
+  CHECK(ts6_result->d == 6.66 + 1);
+    
+  free (ts6_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct7.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct7.c b/libffi-3.4.6/testsuite/libffi.call/struct7.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct7.c	
@@ -0,0 +1,74 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  float f1;
+  float f2;
+  double d;
+} test_structure_7;
+
+static test_structure_7 ABI_ATTR struct7 (test_structure_7 ts)
+{
+  ts.f1 += 1;
+  ts.f2 += 1;
+  ts.d += 1;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts7_type;
+  ffi_type *ts7_type_elements[4];
+
+  test_structure_7 ts7_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_7 *ts7_result =
+    (test_structure_7 *) malloc (sizeof(test_structure_7));
+
+  ts7_type.size = 0;
+  ts7_type.alignment = 0;
+  ts7_type.type = FFI_TYPE_STRUCT;
+  ts7_type.elements = ts7_type_elements;
+  ts7_type_elements[0] = &ffi_type_float;
+  ts7_type_elements[1] = &ffi_type_float;
+  ts7_type_elements[2] = &ffi_type_double;
+  ts7_type_elements[3] = NULL;
+
+  args[0] = &ts7_type;
+  values[0] = &ts7_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts7_type, args) == FFI_OK);
+  
+  ts7_arg.f1 = 5.55f;
+  ts7_arg.f2 = 55.5f;
+  ts7_arg.d = 6.66;
+
+  printf ("%g\n", ts7_arg.f1);
+  printf ("%g\n", ts7_arg.f2);
+  printf ("%g\n", ts7_arg.d);
+  
+  ffi_call(&cif, FFI_FN(struct7), ts7_result, values);
+
+  printf ("%g\n", ts7_result->f1);
+  printf ("%g\n", ts7_result->f2);
+  printf ("%g\n", ts7_result->d);
+  
+  CHECK(ts7_result->f1 == 5.55f + 1);
+  CHECK(ts7_result->f2 == 55.5f + 1);
+  CHECK(ts7_result->d == 6.66 + 1);
+  
+  free (ts7_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct8.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct8.c b/libffi-3.4.6/testsuite/libffi.call/struct8.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct8.c	
@@ -0,0 +1,81 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  float f1;
+  float f2;
+  float f3;
+  float f4;
+} test_structure_8;
+
+static test_structure_8 ABI_ATTR struct8 (test_structure_8 ts)
+{
+  ts.f1 += 1;
+  ts.f2 += 1;
+  ts.f3 += 1;
+  ts.f4 += 1;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts8_type;
+  ffi_type *ts8_type_elements[5];
+
+  test_structure_8 ts8_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_8 *ts8_result =
+    (test_structure_8 *) malloc (sizeof(test_structure_8));
+
+  ts8_type.size = 0;
+  ts8_type.alignment = 0;
+  ts8_type.type = FFI_TYPE_STRUCT;
+  ts8_type.elements = ts8_type_elements;
+  ts8_type_elements[0] = &ffi_type_float;
+  ts8_type_elements[1] = &ffi_type_float;
+  ts8_type_elements[2] = &ffi_type_float;
+  ts8_type_elements[3] = &ffi_type_float;
+  ts8_type_elements[4] = NULL;
+
+  args[0] = &ts8_type;
+  values[0] = &ts8_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts8_type, args) == FFI_OK);
+  
+  ts8_arg.f1 = 5.55f;
+  ts8_arg.f2 = 55.5f;
+  ts8_arg.f3 = -5.55f;
+  ts8_arg.f4 = -55.5f;
+
+  printf ("%g\n", ts8_arg.f1);
+  printf ("%g\n", ts8_arg.f2);
+  printf ("%g\n", ts8_arg.f3);
+  printf ("%g\n", ts8_arg.f4);
+  
+  ffi_call(&cif, FFI_FN(struct8), ts8_result, values);
+
+  printf ("%g\n", ts8_result->f1);
+  printf ("%g\n", ts8_result->f2);
+  printf ("%g\n", ts8_result->f3);
+  printf ("%g\n", ts8_result->f4);
+  
+  CHECK(ts8_result->f1 == 5.55f + 1);
+  CHECK(ts8_result->f2 == 55.5f + 1);
+  CHECK(ts8_result->f3 == -5.55f + 1);
+  CHECK(ts8_result->f4 == -55.5f + 1);
+  
+  free (ts8_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct9.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct9.c b/libffi-3.4.6/testsuite/libffi.call/struct9.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct9.c	
@@ -0,0 +1,68 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  float f;
+  int i;
+} test_structure_9;
+
+static test_structure_9 ABI_ATTR struct9 (test_structure_9 ts)
+{
+  ts.f += 1;
+  ts.i += 1;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts9_type;
+  ffi_type *ts9_type_elements[3];
+
+  test_structure_9 ts9_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_9 *ts9_result =
+    (test_structure_9 *) malloc (sizeof(test_structure_9));
+
+  ts9_type.size = 0;
+  ts9_type.alignment = 0;
+  ts9_type.type = FFI_TYPE_STRUCT;
+  ts9_type.elements = ts9_type_elements;
+  ts9_type_elements[0] = &ffi_type_float;
+  ts9_type_elements[1] = &ffi_type_sint;
+  ts9_type_elements[2] = NULL;
+
+  args[0] = &ts9_type;
+  values[0] = &ts9_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts9_type, args) == FFI_OK);
+  
+  ts9_arg.f = 5.55f;
+  ts9_arg.i = 5;
+  
+  printf ("%g\n", ts9_arg.f);
+  printf ("%d\n", ts9_arg.i);
+  
+  ffi_call(&cif, FFI_FN(struct9), ts9_result, values);
+
+  printf ("%g\n", ts9_result->f);
+  printf ("%d\n", ts9_result->i);
+  
+  CHECK(ts9_result->f == 5.55f + 1);
+  CHECK(ts9_result->i == 5 + 1);
+
+  free (ts9_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/callback.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/callback.c b/libffi-3.4.6/testsuite/libffi.call/callback.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/callback.c	
@@ -0,0 +1,99 @@
+/* Area:	ffi_call
+   Purpose:	Check structures with array and callback.
+   Limitations:	none.
+   PR:		none.
+   Originator:	David Tenty <daltenty@ibm.com>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+int i=5;
+
+void callback(void) { i++; }
+
+typedef struct
+{
+  unsigned char c1;
+  double s[2];
+  unsigned char c2;
+} test_structure_12;
+
+static test_structure_12 ABI_ATTR struct12 (test_structure_12 ts, void (*func)(void))
+{
+  ts.c1 += 1;
+  ts.c2 += 1;
+  ts.s[0] += 1;
+  ts.s[1] += 1;
+
+  func();
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts12_type,ts12a_type;
+  ffi_type *ts12_type_elements[4];
+  ffi_type *ts12a_type_elements[3];
+
+  test_structure_12 ts12_arg;
+  void (*ptr)(void)=&callback;
+
+  test_structure_12 *ts12_result =
+    (test_structure_12 *) malloc (sizeof(test_structure_12));
+
+  ts12a_type.size = 0;
+  ts12a_type.alignment = 0;
+  ts12a_type.type = FFI_TYPE_STRUCT;
+  ts12a_type.elements = ts12a_type_elements;
+  ts12a_type_elements[0] = &ffi_type_double;
+  ts12a_type_elements[1] = &ffi_type_double;
+  ts12a_type_elements[2] = NULL;
+
+  ts12_type.size = 0;
+  ts12_type.alignment = 0;
+  ts12_type.type = FFI_TYPE_STRUCT;
+  ts12_type.elements = ts12_type_elements;
+  ts12_type_elements[0] = &ffi_type_uchar;
+  ts12_type_elements[1] = &ts12a_type;
+  ts12_type_elements[2] = &ffi_type_uchar;
+  ts12_type_elements[3] = NULL;
+
+
+  args[0] = &ts12_type;
+  args[1] = &ffi_type_pointer;
+  values[0] = &ts12_arg;
+  values[1] = &ptr;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &ts12_type, args) == FFI_OK);
+
+  ts12_arg.c1 = 5;
+  ts12_arg.c2 = 6;
+  ts12_arg.s[0] = 7.77;
+  ts12_arg.s[1] = 8.88;
+
+  printf ("%u\n", ts12_arg.c1);
+  printf ("%u\n", ts12_arg.c2);
+  printf ("%g\n", ts12_arg.s[0]);
+  printf ("%g\n", ts12_arg.s[1]);
+  printf ("%d\n", i);
+
+  ffi_call(&cif, FFI_FN(struct12), ts12_result, values);
+
+  printf ("%u\n", ts12_result->c1);
+  printf ("%u\n", ts12_result->c2);
+  printf ("%g\n", ts12_result->s[0]);
+  printf ("%g\n", ts12_result->s[1]);
+  printf ("%d\n", i);
+  CHECK(ts12_result->c1 == 5 + 1);
+  CHECK(ts12_result->c2 == 6 + 1);
+  CHECK(ts12_result->s[0] == 7.77 + 1);
+  CHECK(ts12_result->s[1] == 8.88 + 1);
+  CHECK(i == 5 + 1);
+  CHECK(ts12_type.size == sizeof(test_structure_12));
+
+  free (ts12_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/float_va.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/float_va.c b/libffi-3.4.6/testsuite/libffi.call/float_va.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/float_va.c	
@@ -0,0 +1,110 @@
+/* Area:        fp and variadics
+   Purpose:     check fp inputs and returns work on variadics, even the fixed params
+   Limitations: None
+   PR:          none
+   Originator:  <david.gilbert@linaro.org> 2011-01-25
+
+   Intended to stress the difference in ABI on ARM vfp
+*/
+
+/* { dg-do run } */
+
+#include <stdarg.h>
+
+#include "ffitest.h"
+
+/* prints out all the parameters, and returns the sum of them all.
+ * 'x' is the number of variadic parameters all of which are double in this test
+ */
+double float_va_fn(unsigned int x, double y,...)
+{
+  double total=0.0;
+  va_list ap;
+  unsigned int i;
+
+  total+=(double)x;
+  total+=y;
+
+  printf("%u: %.1f :", x, y);
+
+  va_start(ap, y);
+  for(i=0;i<x;i++)
+  {
+    double arg=va_arg(ap, double);
+    total+=arg;
+    printf(" %d:%.1f ", i, arg);
+  }
+  va_end(ap);
+
+  printf(" total: %.1f\n", total);
+
+  return total;
+}
+
+int main (void)
+{
+  ffi_cif    cif;
+
+  ffi_type    *arg_types[5];
+  void        *values[5];
+  double        doubles[5];
+  unsigned int firstarg;
+  double        resfp;
+
+  /* First test, pass float_va_fn(0,2.0) - note there are no actual
+   * variadic parameters, but it's declared variadic so the ABI may be
+   * different. */
+  /* Call it statically and then via ffi */
+  resfp=float_va_fn(0,2.0);
+  /* { dg-output "0: 2.0 : total: 2.0" } */
+  printf("compiled: %.1f\n", resfp);
+  /* { dg-output "\ncompiled: 2.0" } */
+
+  arg_types[0] = &ffi_type_uint;
+  arg_types[1] = &ffi_type_double;
+  arg_types[2] = NULL;
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 2, 2,
+        &ffi_type_double, arg_types) == FFI_OK);
+
+  firstarg = 0;
+  doubles[0] = 2.0;
+  values[0] = &firstarg;
+  values[1] = &doubles[0];
+  ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);
+  /* { dg-output "\n0: 2.0 : total: 2.0" } */
+  printf("ffi: %.1f\n", resfp);
+  /* { dg-output "\nffi: 2.0" } */
+  CHECK_DOUBLE_EQ(resfp, 2);
+
+  /* Second test, float_va_fn(2,2.0,3.0,4.0), now with variadic params */
+  /* Call it statically and then via ffi */
+  resfp=float_va_fn(2,2.0,3.0,4.0);
+  /* { dg-output "\n2: 2.0 : 0:3.0  1:4.0  total: 11.0" } */
+  printf("compiled: %.1f\n", resfp);
+  /* { dg-output "\ncompiled: 11.0" } */
+  CHECK_DOUBLE_EQ(resfp, 11);
+
+  arg_types[0] = &ffi_type_uint;
+  arg_types[1] = &ffi_type_double;
+  arg_types[2] = &ffi_type_double;
+  arg_types[3] = &ffi_type_double;
+  arg_types[4] = NULL;
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 2, 4,
+        &ffi_type_double, arg_types) == FFI_OK);
+
+  firstarg = 2;
+  doubles[0] = 2.0;
+  doubles[1] = 3.0;
+  doubles[2] = 4.0;
+  values[0] = &firstarg;
+  values[1] = &doubles[0];
+  values[2] = &doubles[1];
+  values[3] = &doubles[2];
+  ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);
+  /* { dg-output "\n2: 2.0 : 0:3.0  1:4.0  total: 11.0" } */
+  printf("ffi: %.1f\n", resfp);
+  /* { dg-output "\nffi: 11.0" } */
+  CHECK_DOUBLE_EQ(resfp, 11);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct10.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct10.c b/libffi-3.4.6/testsuite/libffi.call/struct10.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct10.c	
@@ -0,0 +1,57 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	Sergei Trofimovich <slyfox@gentoo.org>
+
+   The test originally discovered in ruby's bindings
+   for ffi in https://bugs.gentoo.org/634190  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+struct s {
+  int s32;
+  float f32;
+  signed char s8;
+};
+
+struct s ABI_ATTR make_s(void) {
+  struct s r;
+  r.s32 = 0x1234;
+  r.f32 = 7.0;
+  r.s8  = 0x78;
+  return r;
+}
+
+int main() {
+  ffi_cif cif;
+  struct s r;
+  ffi_type rtype;
+  ffi_type* s_fields[] = {
+    &ffi_type_sint,
+    &ffi_type_float,
+    &ffi_type_schar,
+    NULL,
+  };
+
+  rtype.size      = 0;
+  rtype.alignment = 0,
+  rtype.type      = FFI_TYPE_STRUCT,
+  rtype.elements  = s_fields,
+
+  r.s32 = 0xbad;
+  r.f32 = 999.999;
+  r.s8  = 0x51;
+
+  // Here we emulate the following call:
+  //r = make_s();
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0, &rtype, NULL) == FFI_OK);
+  ffi_call(&cif, FFI_FN(make_s), &r, NULL);
+
+  CHECK(r.s32 == 0x1234);
+  CHECK(r.f32 == 7.0);
+  CHECK(r.s8  == 0x78);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/bpo_38748.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/bpo_38748.c b/libffi-3.4.6/testsuite/libffi.call/bpo_38748.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/bpo_38748.c	
@@ -0,0 +1,41 @@
+/* Area:	bpo-38748
+   Purpose:	test for stdcall alignment problem
+   Source:      github.com/python/cpython/pull/26204 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+#include "ffi_common.h"
+
+static UINT32 ABI_ATTR align_arguments(UINT32 l1,
+				       UINT64 l2)
+{
+  return l1 + (UINT32) l2;
+}
+
+int main(void)
+{
+  ffi_cif cif;
+  ffi_type *args[4] = {
+    &ffi_type_uint32,
+    &ffi_type_uint64
+  };
+  ffi_arg lr1, lr2;
+  UINT32 l1 = 1;
+  UINT64 l2 = 2;
+  void *values[2] = {&l1, &l2};
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		     &ffi_type_uint32, args) == FFI_OK);
+
+  lr1 = align_arguments(l1, l2);
+
+  ffi_call(&cif, FFI_FN(align_arguments), &lr2, values);
+
+  if (lr1 == lr2)
+    printf("bpo-38748 arguments tests ok!\n");
+  else
+    CHECK(0);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/callback2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/callback2.c b/libffi-3.4.6/testsuite/libffi.call/callback2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/callback2.c	
@@ -0,0 +1,108 @@
+/* Area:	ffi_call
+   Purpose:	Check structures with nested array and callback.
+   Limitations:	none.
+   PR:		none.
+   Originator:	David Tenty <daltenty@ibm.com>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+int i=5;
+
+void callback(void) { i++; }
+
+typedef struct
+{
+  struct { double d; } s1;
+  double s[2];
+  unsigned char c2;
+} test_structure_12;
+
+static test_structure_12 ABI_ATTR struct12 (test_structure_12 ts, void (*func)(void))
+{
+  ts.s1.d += 1;
+  ts.c2 += 1;
+  ts.s[0] += 1;
+  ts.s[1] += 1;
+
+  func();
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts12_type,ts12a_type, ts12b_type;
+  ffi_type *ts12_type_elements[4];
+  ffi_type *ts12a_type_elements[2];
+  ffi_type *ts12b_type_elements[3];
+
+
+  test_structure_12 ts12_arg;
+  void (*ptr)(void)=&callback;
+
+  test_structure_12 *ts12_result =
+    (test_structure_12 *) malloc (sizeof(test_structure_12));
+
+  ts12a_type.size = 0;
+  ts12a_type.alignment = 0;
+  ts12a_type.type = FFI_TYPE_STRUCT;
+  ts12a_type.elements = ts12a_type_elements;
+  ts12a_type_elements[0] = &ffi_type_double;
+  ts12a_type_elements[1] = NULL;
+
+  ts12b_type.size = 0;
+  ts12b_type.alignment = 0;
+  ts12b_type.type = FFI_TYPE_STRUCT;
+  ts12b_type.elements = ts12b_type_elements;
+  ts12b_type_elements[0] = &ffi_type_double;
+  ts12b_type_elements[1] = &ffi_type_double;
+  ts12b_type_elements[2] = NULL;
+
+  ts12_type.size = 0;
+  ts12_type.alignment = 0;
+  ts12_type.type = FFI_TYPE_STRUCT;
+  ts12_type.elements = ts12_type_elements;
+  ts12_type_elements[0] = &ts12a_type;
+  ts12_type_elements[1] = &ts12b_type;
+  ts12_type_elements[2] = &ffi_type_uchar;
+  ts12_type_elements[3] = NULL;
+
+
+  args[0] = &ts12_type;
+  args[1] = &ffi_type_pointer;
+  values[0] = &ts12_arg;
+  values[1] = &ptr;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &ts12_type, args) == FFI_OK);
+
+  ts12_arg.s1.d = 5.55;
+  ts12_arg.c2 = 6;
+  ts12_arg.s[0] = 7.77;
+  ts12_arg.s[1] = 8.88;
+
+  printf ("%g\n", ts12_arg.s1.d);
+  printf ("%u\n", ts12_arg.c2);
+  printf ("%g\n", ts12_arg.s[0]);
+  printf ("%g\n", ts12_arg.s[1]);
+  printf ("%d\n", i);
+
+  ffi_call(&cif, FFI_FN(struct12), ts12_result, values);
+
+  printf ("%g\n", ts12_result->s1.d);
+  printf ("%u\n", ts12_result->c2);
+  printf ("%g\n", ts12_result->s[0]);
+  printf ("%g\n", ts12_result->s[1]);
+  printf ("%d\n", i);
+  CHECK(ts12_result->s1.d == 5.55 + 1);
+  CHECK(ts12_result->c2 == 6 + 1);
+  CHECK(ts12_result->s[0] == 7.77 + 1);
+  CHECK(ts12_result->s[1] == 8.88 + 1);
+  CHECK(i == 5 + 1);
+  CHECK(ts12_type.size == sizeof(test_structure_12));
+
+  free (ts12_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/callback3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/callback3.c b/libffi-3.4.6/testsuite/libffi.call/callback3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/callback3.c	
@@ -0,0 +1,114 @@
+/* Area:	ffi_call
+   Purpose:	Check structures with array and callback.
+   Limitations:	none.
+   PR:		none.
+   Originator:	David Tenty <daltenty@ibm.com>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+int i=5;
+
+void callback(void) { i++; }
+
+
+typedef struct
+{
+  struct { unsigned char c; double d; } s1;
+  double s[2];
+  unsigned char c2;
+} test_structure_12;
+
+static test_structure_12 ABI_ATTR struct12 (test_structure_12 ts, void (*func)(void))
+{
+  ts.s1.c += 1;
+  ts.s1.d += 1;
+  ts.c2 += 1;
+  ts.s[0] += 1;
+  ts.s[1] += 1;
+
+  func();
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts12_type,ts12b_type, ts12a_type;
+  ffi_type *ts12_type_elements[4];
+  ffi_type *ts12b_type_elements[3];
+  ffi_type *ts12a_type_elements[3];
+
+  test_structure_12 ts12_arg;
+  void (*ptr)(void)=&callback;
+
+  test_structure_12 *ts12_result =
+    (test_structure_12 *) malloc (sizeof(test_structure_12));
+
+  ts12a_type.size = 0;
+  ts12a_type.alignment = 0;
+  ts12a_type.type = FFI_TYPE_STRUCT;
+  ts12a_type.elements = ts12a_type_elements;
+  ts12a_type_elements[0] = &ffi_type_uchar;
+  ts12a_type_elements[1] = &ffi_type_double;
+  ts12a_type_elements[2] = NULL;
+
+  ts12b_type.size = 0;
+  ts12b_type.alignment = 0;
+  ts12b_type.type = FFI_TYPE_STRUCT;
+  ts12b_type.elements = ts12b_type_elements;
+  ts12b_type_elements[0] = &ffi_type_double;
+  ts12b_type_elements[1] = &ffi_type_double;
+  ts12b_type_elements[2] = NULL;
+
+  ts12_type.size = 0;
+  ts12_type.alignment = 0;
+  ts12_type.type = FFI_TYPE_STRUCT;
+  ts12_type.elements = ts12_type_elements;
+  ts12_type_elements[0] = &ts12a_type;
+  ts12_type_elements[1] = &ts12b_type;
+  ts12_type_elements[2] = &ffi_type_uchar;
+  ts12_type_elements[3] = NULL;
+
+
+  args[0] = &ts12_type;
+  args[1] = &ffi_type_pointer;
+  values[0] = &ts12_arg;
+  values[1] = &ptr;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &ts12_type, args) == FFI_OK);
+
+  ts12_arg.s1.c = 5;
+  ts12_arg.s1.d = 5.55;
+  ts12_arg.c2 = 6;
+  ts12_arg.s[0] = 7.77;
+  ts12_arg.s[1] = 8.88;
+
+  printf ("%d\n", ts12_arg.s1.c);
+  printf ("%g\n", ts12_arg.s1.d);
+  printf ("%u\n", ts12_arg.c2);
+  printf ("%g\n", ts12_arg.s[0]);
+  printf ("%g\n", ts12_arg.s[1]);
+  printf ("%d\n", i);
+
+  ffi_call(&cif, FFI_FN(struct12), ts12_result, values);
+
+  printf ("%d\n", ts12_result->s1.c);
+  printf ("%g\n", ts12_result->s1.d);
+  printf ("%u\n", ts12_result->c2);
+  printf ("%g\n", ts12_result->s[0]);
+  printf ("%g\n", ts12_result->s[1]);
+  printf ("%d\n", i);
+  CHECK(ts12_result->s1.c == 5 + 1);
+  CHECK(ts12_result->s1.d == 5.55 + 1);
+  CHECK(ts12_result->c2 == 6 + 1);
+  CHECK(ts12_result->s[0] == 7.77 + 1);
+  CHECK(ts12_result->s[1] == 8.88 + 1);
+  CHECK(i == 5 + 1);
+  CHECK(ts12_type.size == sizeof(test_structure_12));
+
+  free (ts12_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/callback4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/callback4.c b/libffi-3.4.6/testsuite/libffi.call/callback4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/callback4.c	
@@ -0,0 +1,119 @@
+/* Area:	ffi_call
+   Purpose:	Check structures with array and callback.
+   Limitations:	none.
+   PR:		none.
+   Originator:	David Tenty <daltenty@ibm.com>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+int i=5;
+
+void callback(void) { i++; }
+
+
+typedef struct
+{
+  unsigned char c1;
+  struct { double d; unsigned char c; } s[2];
+  unsigned char c2;
+} test_structure_12;
+
+static test_structure_12 ABI_ATTR struct12 (test_structure_12 ts, void (*func)(void))
+{
+  ts.c1 += 1;
+  ts.s[0].d += 1;
+  ts.s[0].c += 1;
+  ts.s[1].d += 1;
+  ts.s[1].c += 1;
+  ts.c2 += 1;
+
+  func();
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts12_type,ts12b_type, ts12a_type;
+  ffi_type *ts12_type_elements[4];
+  ffi_type *ts12b_type_elements[3];
+  ffi_type *ts12a_type_elements[3];
+
+  test_structure_12 ts12_arg;
+  void (*ptr)(void)=&callback;
+
+  test_structure_12 *ts12_result =
+    (test_structure_12 *) malloc (sizeof(test_structure_12));
+
+  ts12a_type.size = 0;
+  ts12a_type.alignment = 0;
+  ts12a_type.type = FFI_TYPE_STRUCT;
+  ts12a_type.elements = ts12a_type_elements;
+  ts12a_type_elements[0] = &ffi_type_double;
+  ts12a_type_elements[1] = &ffi_type_uchar;
+  ts12a_type_elements[2] = NULL;
+
+  ts12b_type.size = 0;
+  ts12b_type.alignment = 0;
+  ts12b_type.type = FFI_TYPE_STRUCT;
+  ts12b_type.elements = ts12b_type_elements;
+  ts12b_type_elements[0] = &ts12a_type;
+  ts12b_type_elements[1] = &ts12a_type;
+  ts12b_type_elements[2] = NULL;
+
+  ts12_type.size = 0;
+  ts12_type.alignment = 0;
+  ts12_type.type = FFI_TYPE_STRUCT;
+  ts12_type.elements = ts12_type_elements;
+  ts12_type_elements[0] = &ffi_type_uchar;
+  ts12_type_elements[1] = &ts12b_type;
+  ts12_type_elements[2] = &ffi_type_uchar;
+  ts12_type_elements[3] = NULL;
+
+
+  args[0] = &ts12_type;
+  args[1] = &ffi_type_pointer;
+  values[0] = &ts12_arg;
+  values[1] = &ptr;
+
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2, &ts12_type, args) == FFI_OK);
+
+  ts12_arg.c1 = 5;
+  ts12_arg.s[0].d = 5.55;
+  ts12_arg.s[0].c = 6;
+  ts12_arg.s[1].d = 7.77;
+  ts12_arg.s[1].c = 8;
+  ts12_arg.c2 = 9;
+
+  printf ("%u\n", ts12_arg.c1);
+  printf ("%g\n", ts12_arg.s[0].d);
+  printf ("%u\n", ts12_arg.s[0].c);
+  printf ("%g\n", ts12_arg.s[1].d);
+  printf ("%u\n", ts12_arg.s[1].c);
+  printf ("%u\n", ts12_arg.c2);
+  printf ("%d\n", i);
+
+  ffi_call(&cif, FFI_FN(struct12), ts12_result, values);
+
+  printf ("%u\n", ts12_result->c1);
+  printf ("%g\n", ts12_result->s[0].d);
+  printf ("%u\n", ts12_result->s[0].c);
+  printf ("%g\n", ts12_result->s[1].d);
+  printf ("%u\n", ts12_result->s[1].c);
+  printf ("%u\n", ts12_result->c2);
+  printf ("%d\n", i);
+  CHECK(ts12_result->c1 == 5 + 1);
+  CHECK(ts12_result->s[0].d == 5.55 + 1);
+  CHECK(ts12_result->s[0].c == 6 + 1);
+  CHECK(ts12_result->s[1].d == 7.77 + 1);
+  CHECK(ts12_result->s[1].c == 8 + 1);
+  CHECK(ts12_result->c2 == 9 + 1);
+  CHECK(i == 5 + 1);
+  CHECK(ts12_type.size == sizeof(test_structure_12));
+
+  free (ts12_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/pr1172638.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/pr1172638.c b/libffi-3.4.6/testsuite/libffi.call/pr1172638.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/pr1172638.c	
@@ -0,0 +1,127 @@
+/* Area:	ffi_call
+   Purpose:	Reproduce bug found in python ctypes
+   Limitations:	none.
+   PR:		Fedora 1174037  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct {
+  long x;
+  long y;
+} POINT;
+
+typedef struct {
+  long left;
+  long top;
+  long right;
+  long bottom;
+} RECT;
+
+static RECT ABI_ATTR pr_test(int i __UNUSED__, RECT ar __UNUSED__, 
+			     RECT* br __UNUSED__, POINT cp __UNUSED__, 
+			     RECT dr __UNUSED__, RECT *er __UNUSED__, 
+			     POINT fp, RECT gr __UNUSED__)
+{
+  RECT result;
+
+  result.left = fp.x;
+  result.right = fp.y;
+  result.top = fp.x;
+  result.bottom = fp.y;
+
+  return result;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type point_type, rect_type;
+  ffi_type *point_type_elements[3];  
+  ffi_type *rect_type_elements[5];  
+  
+  int i;
+  POINT cp, fp;
+  RECT ar, br, dr, er, gr; 
+  RECT *p1, *p2;
+
+  /* This is a hack to get a properly aligned result buffer */
+  RECT *rect_result =
+    (RECT *) malloc (sizeof(RECT));
+
+  point_type.size = 0;
+  point_type.alignment = 0;
+  point_type.type = FFI_TYPE_STRUCT;
+  point_type.elements = point_type_elements;
+  point_type_elements[0] = &ffi_type_slong;
+  point_type_elements[1] = &ffi_type_slong;
+  point_type_elements[2] = NULL;
+
+  rect_type.size = 0;
+  rect_type.alignment = 0;
+  rect_type.type = FFI_TYPE_STRUCT;
+  rect_type.elements = rect_type_elements;
+  rect_type_elements[0] = &ffi_type_slong;
+  rect_type_elements[1] = &ffi_type_slong;
+  rect_type_elements[2] = &ffi_type_slong;
+  rect_type_elements[3] = &ffi_type_slong;
+  rect_type_elements[4] = NULL;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &rect_type;
+  args[2] = &ffi_type_pointer;
+  args[3] = &point_type;
+  args[4] = &rect_type;
+  args[5] = &ffi_type_pointer;
+  args[6] = &point_type;
+  args[7] = &rect_type;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 8, &rect_type, args) == FFI_OK);
+
+  i = 1;
+  ar.left = 2;
+  ar.right = 3;
+  ar.top = 4;
+  ar.bottom = 5;
+  br.left = 6;
+  br.right = 7;
+  br.top = 8;
+  br.bottom = 9;
+  cp.x = 10;
+  cp.y = 11;
+  dr.left = 12;
+  dr.right = 13;
+  dr.top = 14;
+  dr.bottom = 15;
+  er.left = 16;
+  er.right = 17;
+  er.top = 18;
+  er.bottom = 19;
+  fp.x = 20;
+  fp.y = 21;
+  gr.left = 22;
+  gr.right = 23;
+  gr.top = 24;
+  gr.bottom = 25;
+  
+  values[0] = &i;
+  values[1] = &ar;
+  p1 = &br;
+  values[2] = &p1;
+  values[3] = &cp;
+  values[4] = &dr;
+  p2 = &er;
+  values[5] = &p2;
+  values[6] = &fp;
+  values[7] = &gr;
+
+  ffi_call (&cif, FFI_FN(pr_test), rect_result, values);
+  
+  CHECK(rect_result->top == 20);
+ 
+  free (rect_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/promotion.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/promotion.c b/libffi-3.4.6/testsuite/libffi.call/promotion.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/promotion.c	
@@ -0,0 +1,59 @@
+/* Area:	ffi_call
+   Purpose:	Promotion test.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+static int promotion(signed char sc, signed short ss,
+		     unsigned char uc, unsigned short us)
+{
+  int r = (int) sc + (int) ss + (int) uc + (int) us;
+
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  signed char sc;
+  unsigned char uc;
+  signed short ss;
+  unsigned short us;
+  unsigned long ul;
+
+  args[0] = &ffi_type_schar;
+  args[1] = &ffi_type_sshort;
+  args[2] = &ffi_type_uchar;
+  args[3] = &ffi_type_ushort;
+  values[0] = &sc;
+  values[1] = &ss;
+  values[2] = &uc;
+  values[3] = &us;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_sint, args) == FFI_OK);
+
+  us = 0;
+  ul = 0;
+
+  for (sc = (signed char) -127;
+       sc <= (signed char) 120; sc += 1)
+    for (ss = -30000; ss <= 30000; ss += 10000)
+      for (uc = (unsigned char) 0;
+	   uc <= (unsigned char) 200; uc += 20)
+	for (us = 0; us <= 60000; us += 10000)
+	  {
+	    ul++;
+	    ffi_call(&cif, FFI_FN(promotion), &rint, values);
+	    CHECK((int)rint == (signed char) sc + (signed short) ss +
+		  (unsigned char) uc + (unsigned short) us);
+	  }
+  printf("%lu promotion tests run\n", ul);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/pyobjc_tc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/pyobjc_tc.c b/libffi-3.4.6/testsuite/libffi.call/pyobjc_tc.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/pyobjc_tc.c	
@@ -0,0 +1,114 @@
+/* Area:	ffi_call
+   Purpose:	Check different structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	Ronald Oussoren <oussoren@cistron.nl> 20030824	*/
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct Point {
+	float x;
+	float y;
+} Point;
+
+typedef struct Size {
+	float h;
+	float w;
+} Size;
+
+typedef struct Rect {
+	Point o;
+	Size  s;
+} Rect;
+
+int doit(int o, char* s, Point p, Rect r, int last)
+{
+	printf("CALLED WITH %d %s {%f %f} {{%f %f} {%f %f}} %d\n",
+		o, s, p.x, p.y, r.o.x, r.o.y, r.s.h, r.s.w, last);
+	return 42;
+}
+
+
+int main(void)
+{
+	ffi_type point_type;
+	ffi_type size_type;
+	ffi_type rect_type;
+	ffi_cif cif;
+	ffi_type* arglist[6];
+	void* values[6];
+	int r;
+
+	/*
+	 *  First set up FFI types for the 3 struct types
+	 */
+
+	point_type.size = 0; /*sizeof(Point);*/
+	point_type.alignment = 0; /*__alignof__(Point);*/
+	point_type.type = FFI_TYPE_STRUCT;
+	point_type.elements = malloc(3 * sizeof(ffi_type*));
+	point_type.elements[0] = &ffi_type_float;
+	point_type.elements[1] = &ffi_type_float;
+	point_type.elements[2] = NULL;
+
+	size_type.size = 0;/* sizeof(Size);*/
+	size_type.alignment = 0;/* __alignof__(Size);*/
+	size_type.type = FFI_TYPE_STRUCT;
+	size_type.elements = malloc(3 * sizeof(ffi_type*));
+	size_type.elements[0] = &ffi_type_float;
+	size_type.elements[1] = &ffi_type_float;
+	size_type.elements[2] = NULL;
+
+	rect_type.size = 0;/*sizeof(Rect);*/
+	rect_type.alignment =0;/* __alignof__(Rect);*/
+	rect_type.type = FFI_TYPE_STRUCT;
+	rect_type.elements = malloc(3 * sizeof(ffi_type*));
+	rect_type.elements[0] = &point_type;
+	rect_type.elements[1] = &size_type;
+	rect_type.elements[2] = NULL;
+
+	/*
+	 * Create a CIF
+	 */
+	arglist[0] = &ffi_type_sint;
+	arglist[1] = &ffi_type_pointer;
+	arglist[2] = &point_type;
+	arglist[3] = &rect_type;
+	arglist[4] = &ffi_type_sint;
+	arglist[5] = NULL;
+
+	r = ffi_prep_cif(&cif, FFI_DEFAULT_ABI,
+			5, &ffi_type_sint, arglist);
+	if (r != FFI_OK) {
+		abort();
+	}
+
+
+	/* And call the function through the CIF */
+
+	{
+	Point p = { 1.0, 2.0 };
+	Rect  r = { { 9.0, 10.0}, { -1.0, -2.0 } };
+	int   o = 0;
+	int   l = 42;
+	char* m = "myMethod";
+	ffi_arg result;
+
+	values[0] = &o;
+	values[1] = &m;
+	values[2] = &p;
+	values[3] = &r;
+	values[4] = &l;
+	values[5] = NULL;
+
+	printf("CALLING WITH %d %s {%f %f} {{%f %f} {%f %f}} %d\n",
+		o, m, p.x, p.y, r.o.x, r.o.y, r.s.h, r.s.w, l);
+
+	ffi_call(&cif, FFI_FN(doit), &result, values);
+
+	printf ("The result is %d\n", (int)result);
+
+	}
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_fl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_fl.c b/libffi-3.4.6/testsuite/libffi.call/return_fl.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_fl.c	
@@ -0,0 +1,35 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl)
+{
+  return 2 * fl;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl, rfl;
+
+  args[0] = &ffi_type_float;
+  values[0] = &fl;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_float, args) == FFI_OK);
+
+  for (fl = -127.0; fl <  127; fl++)
+    {
+      ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+      printf ("%f vs %f\n", rfl, return_fl(fl));
+      CHECK(rfl ==  2 * fl);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_ll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_ll.c b/libffi-3.4.6/testsuite/libffi.call/return_ll.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_ll.c	
@@ -0,0 +1,41 @@
+/* Area:	ffi_call
+   Purpose:	Check return value long long.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+static long long return_ll(long long ll)
+{
+  return ll;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  long long rlonglong;
+  long long ll;
+
+  args[0] = &ffi_type_sint64;
+  values[0] = &ll;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_sint64, args) == FFI_OK);
+
+  for (ll = 0LL; ll < 100LL; ll++)
+    {
+      ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
+      CHECK(rlonglong == ll);
+    }
+
+  for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)
+    {
+      ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
+      CHECK(rlonglong == ll);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_sc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_sc.c b/libffi-3.4.6/testsuite/libffi.call/return_sc.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_sc.c	
@@ -0,0 +1,36 @@
+/* Area:	ffi_call
+   Purpose:	Check return value signed char.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static signed char return_sc(signed char sc)
+{
+  return sc;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+  signed char sc;
+
+  args[0] = &ffi_type_schar;
+  values[0] = &sc;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_schar, args) == FFI_OK);
+
+  for (sc = (signed char) -127;
+       sc < (signed char) 127; sc++)
+    {
+      ffi_call(&cif, FFI_FN(return_sc), &rint, values);
+      CHECK((signed char)rint == sc);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_sl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_sl.c b/libffi-3.4.6/testsuite/libffi.call/return_sl.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_sl.c	
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check if long as return type is handled correctly.
+   Limitations:	none.
+   PR:		none.
+ */
+
+/* { dg-do run } */
+#include "ffitest.h"
+static long return_sl(long l1, long l2)
+{
+  CHECK(l1 == 1073741823L);
+  CHECK(l2 == 1073741824L);
+  return l1 - l2;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg res;
+  unsigned long l1, l2;
+
+  args[0] = &ffi_type_slong;
+  args[1] = &ffi_type_slong;
+  values[0] = &l1;
+  values[1] = &l2;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_slong, args) == FFI_OK);
+
+  l1 = 1073741823L;
+  l2 = 1073741824L;
+
+  ffi_call(&cif, FFI_FN(return_sl), &res, values);
+  printf("res: %ld, %ld\n", (long)res, l1 - l2);
+  /* { dg-output "res: -1, -1" } */
+  CHECK((long)res == -1);
+  CHECK(l1 + 1 == l2);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_uc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_uc.c b/libffi-3.4.6/testsuite/libffi.call/return_uc.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_uc.c	
@@ -0,0 +1,38 @@
+/* Area:	ffi_call
+   Purpose:	Check return value unsigned char.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static unsigned char return_uc(unsigned char uc)
+{
+  return uc;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+
+  unsigned char uc;
+
+  args[0] = &ffi_type_uchar;
+  values[0] = &uc;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_uchar, args) == FFI_OK);
+
+  for (uc = (unsigned char) '\x00';
+       uc < (unsigned char) '\xff'; uc++)
+    {
+      ffi_call(&cif, FFI_FN(return_uc), &rint, values);
+      CHECK((unsigned char)rint == uc);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_ul.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_ul.c b/libffi-3.4.6/testsuite/libffi.call/return_ul.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_ul.c	
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check if unsigned long as return type is handled correctly.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<kaffeetisch at gmx dot de> 20060724  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+static unsigned long return_ul(unsigned long ul1, unsigned long ul2)
+{
+  CHECK(ul1 == 1073741823L);
+  CHECK(ul2 == 1073741824L);
+  return ul1 + ul2;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg res;
+  unsigned long ul1, ul2;
+
+  args[0] = &ffi_type_ulong;
+  args[1] = &ffi_type_ulong;
+  values[0] = &ul1;
+  values[1] = &ul2;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_ulong, args) == FFI_OK);
+
+  ul1 = 1073741823L;
+  ul2 = 1073741824L;
+
+  ffi_call(&cif, FFI_FN(return_ul), &res, values);
+  printf("res: %lu, %lu\n", (unsigned long)res, ul1 + ul2);
+  /* { dg-output "res: 2147483647, 2147483647" } */
+  CHECK(res == 2147483647L);
+  CHECK(ul1 + ul2 == 2147483647L);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/many_mixed.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/many_mixed.c b/libffi-3.4.6/testsuite/libffi.call/many_mixed.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/many_mixed.c	
@@ -0,0 +1,78 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+static double many(double f1,
+		  double f2,
+		  long int i1,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  double f6,
+		  long int i3,
+		  double f7,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (i1 + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], la[2],
+               fa[3], fa[4], la[5],
+               fa[6], fa[7], la[8],
+               fa[9], fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_dbl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_dbl.c b/libffi-3.4.6/testsuite/libffi.call/return_dbl.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_dbl.c	
@@ -0,0 +1,36 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl)
+{
+  printf ("%f\n", dbl);
+  return 2 * dbl;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl, rdbl;
+
+  args[0] = &ffi_type_double;
+  values[0] = &dbl;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, args) == FFI_OK);
+
+  for (dbl = -127.3; dbl <  127; dbl++)
+    {
+      ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+      printf ("%f vs %f\n", rdbl, return_dbl(dbl));
+      CHECK(rdbl == 2 * dbl);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_fl1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_fl1.c b/libffi-3.4.6/testsuite/libffi.call/return_fl1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_fl1.c	
@@ -0,0 +1,36 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl1, float fl2)
+{
+  return fl1 + fl2;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, rfl;
+
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2));
+  CHECK(rfl ==  fl1 + fl2);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_fl2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_fl2.c b/libffi-3.4.6/testsuite/libffi.call/return_fl2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_fl2.c	
@@ -0,0 +1,49 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+/* Use volatile float to avoid false negative on ix86.  See PR target/323.  */
+static float return_fl(float fl1, float fl2, float fl3, float fl4)
+{
+  volatile float sum;
+
+  sum = fl1 + fl2 + fl3 + fl4;
+  return sum;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, fl3, fl4, rfl;
+  volatile float sum;
+
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_float;
+  args[3] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+  values[2] = &fl3;
+  values[3] = &fl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+  fl3 = 255.1;
+  fl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2, fl3, fl4));
+
+  sum = fl1 + fl2 + fl3 + fl4;
+  CHECK(rfl == sum);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_fl3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_fl3.c b/libffi-3.4.6/testsuite/libffi.call/return_fl3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_fl3.c	
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl1, float fl2, unsigned int in3, float fl4)
+{
+  return fl1 + fl2 + in3 + fl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, fl4, rfl;
+  unsigned int in3;
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint;
+  args[3] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &fl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+  in3 = 255;
+  fl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2, in3, fl4));
+  CHECK(rfl ==  fl1 + fl2 + in3 + fl4);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_ldl.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_ldl.c b/libffi-3.4.6/testsuite/libffi.call/return_ldl.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_ldl.c	
@@ -0,0 +1,34 @@
+/* Area:	ffi_call
+   Purpose:	Check return value long double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20071113  */
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static long double return_ldl(long double ldl)
+{
+  return 2*ldl;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  long double ldl, rldl;
+
+  args[0] = &ffi_type_longdouble;
+  values[0] = &ldl;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_longdouble, args) == FFI_OK);
+
+  for (ldl = -127.0; ldl <  127.0; ldl++)
+    {
+      ffi_call(&cif, FFI_FN(return_ldl), &rldl, values);
+      CHECK(rldl ==  2 * ldl);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_ll1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_ll1.c b/libffi-3.4.6/testsuite/libffi.call/return_ll1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_ll1.c	
@@ -0,0 +1,48 @@
+/* Area:	ffi_call
+   Purpose:	Check if long long are passed in the corresponding regs on ppc.
+   Limitations:	none.
+   PR:		20104.
+   Originator:	<andreast@gcc.gnu.org> 20050222  */
+
+/* { dg-do run } */
+/* { dg-options "-Wno-format" { target alpha*-dec-osf* } } */
+#include "ffitest.h"
+static long long return_ll(int ll0, long long ll1, int ll2)
+{
+  CHECK(ll0 == 11111111);
+  CHECK(ll1 == 11111111111000LL);
+  CHECK(ll2 == 11111111);
+  return ll0 + ll1 + ll2;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  long long rlonglong;
+  long long ll1;
+  unsigned ll0, ll2;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_sint64;
+  args[2] = &ffi_type_sint;
+  values[0] = &ll0;
+  values[1] = &ll1;
+  values[2] = &ll2;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &ffi_type_sint64, args) == FFI_OK);
+
+  ll0 = 11111111;
+  ll1 = 11111111111000LL;
+  ll2 = 11111111;
+
+  ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
+  printf("res: %" PRIdLL ", %" PRIdLL "\n", rlonglong, ll0 + ll1 + ll2);
+  /* { dg-output "res: 11111133333222, 11111133333222" } */
+  CHECK(rlonglong == 11111133333222);
+  CHECK(ll0 + ll1 + ll2 == 11111133333222);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_struct1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_struct1.c b/libffi-3.4.6/testsuite/libffi.call/va_struct1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_struct1.c	
@@ -0,0 +1,134 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static int
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, s2.b);
+  va_end (ap);
+
+  CHECK(s1.a == 5);
+  CHECK(s1.b == 6);
+
+  CHECK(l.a == 10);
+  CHECK(l.b == 11);
+  CHECK(l.c == 12);
+  CHECK(l.d == 13);
+  CHECK(l.e == 14);
+
+  CHECK(s2.a == 7);
+  CHECK(s2.b == 8);
+  return n + 1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  ffi_arg res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &ffi_type_sint, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+  CHECK(res == 42);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_struct2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_struct2.c b/libffi-3.4.6/testsuite/libffi.call/va_struct2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_struct2.c	
@@ -0,0 +1,134 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static struct small_tag
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, s2.b);
+  CHECK(s1.a == 5);
+  CHECK(s1.b == 6);
+  CHECK(l.a == 10);
+  CHECK(l.b == 11);
+  CHECK(l.c == 12);
+  CHECK(l.d == 13);
+  CHECK(l.e == 14);
+  CHECK(s2.a == 7);
+  CHECK(s2.b == 8);
+  va_end (ap);
+  s1.a += s2.a;
+  s1.b += s2.b;
+  return s1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  struct small_tag res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &s_type, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d %d\n", res.a, res.b);
+  /* { dg-output "\nres: 12 14" } */
+  CHECK(res.a == 12);
+  CHECK(res.b == 14);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/va_struct3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/va_struct3.c b/libffi-3.4.6/testsuite/libffi.call/va_struct3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/va_struct3.c	
@@ -0,0 +1,140 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static struct large_tag
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, s2.b);
+
+  CHECK(s1.a == 5);
+  CHECK(s1.b == 6);
+  CHECK(l.a == 10);
+  CHECK(l.b == 11);
+  CHECK(l.c == 12);
+  CHECK(l.d == 13);
+  CHECK(l.e == 14);
+  CHECK(s2.a == 7);
+  CHECK(s2.b == 8);
+  va_end (ap);
+  l.a += s1.a;
+  l.b += s1.b;
+  l.c += s2.a;
+  l.d += s2.b;
+  return l;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  struct large_tag res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &l_type, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d %d %d %d %d\n", res.a, res.b, res.c, res.d, res.e);
+  /* { dg-output "\nres: 15 17 19 21 14" } */
+  CHECK(res.a == 15);
+  CHECK(res.b == 17);
+  CHECK(res.c == 19);
+  CHECK(res.d == 21);
+  CHECK(res.e == 14);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.call/align_mixed.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/align_mixed.c b/libffi-3.4.6/testsuite/libffi.call/align_mixed.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/align_mixed.c	
@@ -0,0 +1,46 @@
+/* Area:	ffi_call
+   Purpose:	Check for proper argument alignment.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<twalljava@java.net> (from many_win32.c) */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static float ABI_ATTR align_arguments(int i1,
+                                      double f2,
+                                      int i3,
+                                      double f4)
+{
+  return i1+f2+i3+f4;
+}
+
+int main(void)
+{
+  ffi_cif cif;
+  ffi_type *args[4] = {
+    &ffi_type_sint,
+    &ffi_type_double,
+    &ffi_type_sint,
+    &ffi_type_double
+  };
+  double fa[2] = {1,2};
+  int ia[2] = {1,2};
+  void *values[4] = {&ia[0], &fa[0], &ia[1], &fa[1]};
+  float f, ff;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 4,
+		     &ffi_type_float, args) == FFI_OK);
+
+  ff = align_arguments(ia[0], fa[0], ia[1], fa[1]);
+
+  ffi_call(&cif, FFI_FN(align_arguments), &f, values);
+
+  if (f == ff)
+    printf("align arguments tests ok!\n");
+  else
+    CHECK(0);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/many_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/many_double.c b/libffi-3.4.6/testsuite/libffi.call/many_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/many_double.c	
@@ -0,0 +1,70 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+static double many(double f1,
+		  double f2,
+		  double f3,
+		  double f4,
+		  double f5,
+		  double f6,
+		  double f7,
+		  double f8,
+		  double f9,
+		  double f10,
+		  double f11,
+		  double f12,
+		  double f13)
+{
+#if 0
+  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
+	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
+	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
+	 (double) f11, (double) f12, (double) f13);
+#endif
+
+  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[13];
+  void *values[13];
+  double fa[13];
+  double f, ff;
+  int i;
+
+  for (i = 0; i < 13; i++)
+    {
+      args[i] = &ffi_type_double;
+      values[i] = &fa[i];
+      fa[i] = (double) i;
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, 
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1],
+	       fa[2], fa[3],
+	       fa[4], fa[5],
+	       fa[6], fa[7],
+	       fa[8], fa[9],
+	       fa[10],fa[11],fa[12]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_dbl1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_dbl1.c b/libffi-3.4.6/testsuite/libffi.call/return_dbl1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_dbl1.c	
@@ -0,0 +1,43 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl1, float fl2, unsigned int in3, double dbl4)
+{
+  return dbl1 + fl2 + in3 + dbl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl1, dbl4, rdbl;
+  float fl2;
+  unsigned int in3;
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint;
+  args[3] = &ffi_type_double;
+  values[0] = &dbl1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &dbl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_double, args) == FFI_OK);
+  dbl1 = 127.0;
+  fl2 = 128.0;
+  in3 = 255;
+  dbl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+  printf ("%f vs %f\n", rdbl, return_dbl(dbl1, fl2, in3, dbl4));
+  CHECK(rdbl ==  dbl1 + fl2 + in3 + dbl4);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/return_dbl2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/return_dbl2.c b/libffi-3.4.6/testsuite/libffi.call/return_dbl2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/return_dbl2.c	
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl1, double dbl2, unsigned int in3, double dbl4)
+{
+  return dbl1 + dbl2 + in3 + dbl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl1, dbl2, dbl4, rdbl;
+  unsigned int in3;
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_double;
+  args[2] = &ffi_type_uint;
+  args[3] = &ffi_type_double;
+  values[0] = &dbl1;
+  values[1] = &dbl2;
+  values[2] = &in3;
+  values[3] = &dbl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_double, args) == FFI_OK);
+  dbl1 = 127.0;
+  dbl2 = 128.0;
+  in3 = 255;
+  dbl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+  printf ("%f vs %f\n", rdbl, return_dbl(dbl1, dbl2, in3, dbl4));
+  CHECK(rdbl ==  dbl1 + dbl2 + in3 + dbl4);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/align_stdcall.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/align_stdcall.c b/libffi-3.4.6/testsuite/libffi.call/align_stdcall.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/align_stdcall.c	
@@ -0,0 +1,46 @@
+/* Area:	ffi_call
+   Purpose:	Check for proper argument alignment.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<twalljava@java.net> (from many_win32.c) */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static float ABI_ATTR align_arguments(int i1,
+                                      double f2,
+                                      int i3,
+                                      double f4)
+{
+  return i1+f2+i3+f4;
+}
+
+int main(void)
+{
+  ffi_cif cif;
+  ffi_type *args[4] = {
+    &ffi_type_sint,
+    &ffi_type_double,
+    &ffi_type_sint,
+    &ffi_type_double
+  };
+  double fa[2] = {1,2};
+  int ia[2] = {1,2};
+  void *values[4] = {&ia[0], &fa[0], &ia[1], &fa[1]};
+  float f, ff;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 4,
+		     &ffi_type_float, args) == FFI_OK);
+
+  ff = align_arguments(ia[0], fa[0], ia[1], fa[1]);;
+
+  ffi_call(&cif, FFI_FN(align_arguments), &f, values);
+
+  if (f == ff)
+    printf("align arguments tests ok!\n");
+  else
+    CHECK(0);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/uninitialized.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/uninitialized.c b/libffi-3.4.6/testsuite/libffi.call/uninitialized.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/uninitialized.c	
@@ -0,0 +1,61 @@
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 struct1(test_structure_1 ts)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  memset(&cif, 1, sizeof(cif));
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+
+  test_structure_1 ts1_arg;
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/err_bad_typedef.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/err_bad_typedef.c b/libffi-3.4.6/testsuite/libffi.call/err_bad_typedef.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/err_bad_typedef.c	
@@ -0,0 +1,26 @@
+/* Area:		ffi_prep_cif
+   Purpose:		Test error return for bad typedefs.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+int main (void)
+{
+	ffi_cif cif;
+	ffi_type* arg_types[1];
+
+	ffi_type	badType	= ffi_type_void;
+
+	arg_types[0] = NULL;
+
+	badType.size = 0;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0, &badType,
+		arg_types) == FFI_BAD_TYPEDEF);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_return_2H.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_return_2H.c b/libffi-3.4.6/testsuite/libffi.call/struct_return_2H.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_return_2H.c	
@@ -0,0 +1,63 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  short x;
+  short y;
+} test_structure_5;
+
+static test_structure_5 ABI_ATTR struct5(test_structure_5 inp)
+{
+  inp.x *= 2;
+  inp.y *= 3;
+
+  return inp;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts5_type;
+  ffi_type *ts5_type_elements[3];
+
+  test_structure_5 ts5_arg1;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_5 *ts5_result =
+    (test_structure_5 *) malloc (sizeof(test_structure_5));
+
+  ts5_type.size = 0;
+  ts5_type.alignment = 0;
+  ts5_type.type = FFI_TYPE_STRUCT;
+  ts5_type.elements = ts5_type_elements;
+  ts5_type_elements[0] = &ffi_type_sshort;
+  ts5_type_elements[1] = &ffi_type_sshort;
+  ts5_type_elements[2] = NULL;
+
+  args[0] = &ts5_type;
+  values[0] = &ts5_arg1;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts5_type, args) == FFI_OK);
+
+  ts5_arg1.x = 99;
+  ts5_arg1.y = 88;
+
+  ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
+
+  CHECK(ts5_result->x == 99*2);
+  CHECK(ts5_result->y == 88*3);
+  CHECK(ts5_arg1.x == 99);
+  CHECK(ts5_arg1.y == 88);
+
+  free (ts5_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_return_8H.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_return_8H.c b/libffi-3.4.6/testsuite/libffi.call/struct_return_8H.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_return_8H.c	
@@ -0,0 +1,90 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+typedef struct
+{
+  int a;
+  int b;
+  int c;
+  int d;
+  int e;
+  int f;
+  int g;
+  int h;
+} test_structure_5;
+
+static test_structure_5 ABI_ATTR struct5(test_structure_5 inp)
+{
+  inp.a *= 2;
+  inp.b *= 3;
+  inp.c *= 4;
+  inp.d *= 5;
+  inp.e *= 6;
+  inp.f *= 7;
+  inp.g *= 8;
+  inp.h *= 9;
+  return inp;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts5_type;
+  ffi_type *ts5_type_elements[9];
+
+  test_structure_5 ts5_arg1;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_5 *ts5_result =
+    (test_structure_5 *) malloc (sizeof(test_structure_5));
+
+  ts5_type.size = 0;
+  ts5_type.alignment = 0;
+  ts5_type.type = FFI_TYPE_STRUCT;
+  ts5_type.elements = ts5_type_elements;
+  ts5_type_elements[0] = &ffi_type_sint;
+  ts5_type_elements[1] = &ffi_type_sint;
+  ts5_type_elements[2] = &ffi_type_sint;
+  ts5_type_elements[3] = &ffi_type_sint;
+  ts5_type_elements[4] = &ffi_type_sint;
+  ts5_type_elements[5] = &ffi_type_sint;
+  ts5_type_elements[6] = &ffi_type_sint;
+  ts5_type_elements[7] = &ffi_type_sint;
+  ts5_type_elements[8] = NULL;
+
+  args[0] = &ts5_type;
+  values[0] = &ts5_arg1;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts5_type, args) == FFI_OK);
+
+  ts5_arg1.a = 9;
+  ts5_arg1.b = 8;
+  ts5_arg1.c = 7;
+  ts5_arg1.d = 6;
+  ts5_arg1.e = 5;
+  ts5_arg1.f = 4;
+  ts5_arg1.g = 3;
+  ts5_arg1.h = 2;
+
+  ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
+
+  CHECK(ts5_result->a == 9*2);
+  CHECK(ts5_result->b == 8*3);
+  CHECK(ts5_result->c == 7*4);
+  CHECK(ts5_result->d == 6*5);
+  CHECK(ts5_result->e == 5*6);
+  CHECK(ts5_result->f == 4*7);
+  CHECK(ts5_result->g == 3*8);
+  CHECK(ts5_result->h == 2*9);
+
+  free (ts5_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_2.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_2.c	
@@ -0,0 +1,63 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned int ui01;
+  unsigned int ui02;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.ui02++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[3];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uint;
+  ts1_type_elements[1] = &ffi_type_uint;
+  ts1_type_elements[2] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.ui02 = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui02 == 556);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(ts1_arg.ui02 == 555);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3.c	
@@ -0,0 +1,65 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned int ui01;
+  unsigned int ui02;
+  unsigned int ui03;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.ui03++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uint;
+  ts1_type_elements[1] = &ffi_type_uint;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.ui03 = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui03 == 556);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(ts1_arg.ui03 == 555);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4.c	
@@ -0,0 +1,67 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned int ui01;
+  unsigned int ui02;
+  unsigned int ui03;
+  unsigned int ui04;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.ui04++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[5];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uint;
+  ts1_type_elements[1] = &ffi_type_uint;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = &ffi_type_uint;
+  ts1_type_elements[4] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.ui04 = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui04 == 556);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(ts1_arg.ui04 == 555);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_3f.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3f.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3f.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_3f.c	
@@ -0,0 +1,65 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  float f01;
+  float f02;
+  float f03;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.f03++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[5];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_float;
+  ts1_type_elements[1] = &ffi_type_float;
+  ts1_type_elements[2] = &ffi_type_float;
+  ts1_type_elements[3] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.f03 = 555.5;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(fabs(ts1_result->f03 - 556.5) < FLT_EPSILON);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(fabs(ts1_arg.f03 - 555.5) < FLT_EPSILON);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_4f.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4f.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4f.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_4f.c	
@@ -0,0 +1,67 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  float f01;
+  float f02;
+  float f03;
+  float f04;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.f04++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[5];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_float;
+  ts1_type_elements[1] = &ffi_type_float;
+  ts1_type_elements[2] = &ffi_type_float;
+  ts1_type_elements[3] = &ffi_type_float;
+  ts1_type_elements[4] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.f04 = 555.5;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(fabs(ts1_result->f04 - 556.5) < FLT_EPSILON);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(fabs(ts1_arg.f04 - 555.5) < FLT_EPSILON);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_big.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_big.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_big.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_big.c	
@@ -0,0 +1,93 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned int ui01;
+  unsigned int ui02;
+  unsigned int ui03;
+  unsigned int ui04;
+  unsigned int ui05;
+  unsigned int ui06;
+  unsigned int ui07;
+  unsigned int ui08;
+  unsigned int ui09;
+  unsigned int ui10;
+  unsigned int ui11;
+  unsigned int ui12;
+  unsigned int ui13;
+  unsigned int ui14;
+  unsigned int ui15;
+  unsigned int ui16;
+  unsigned int ui17;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.ui17++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[18];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uint;
+  ts1_type_elements[1] = &ffi_type_uint;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = &ffi_type_uint;
+  ts1_type_elements[4] = &ffi_type_uint;
+  ts1_type_elements[5] = &ffi_type_uint;
+  ts1_type_elements[6] = &ffi_type_uint;
+  ts1_type_elements[7] = &ffi_type_uint;
+  ts1_type_elements[8] = &ffi_type_uint;
+  ts1_type_elements[9] = &ffi_type_uint;
+  ts1_type_elements[10] = &ffi_type_uint;
+  ts1_type_elements[11] = &ffi_type_uint;
+  ts1_type_elements[12] = &ffi_type_uint;
+  ts1_type_elements[13] = &ffi_type_uint;
+  ts1_type_elements[14] = &ffi_type_uint;
+  ts1_type_elements[15] = &ffi_type_uint;
+  ts1_type_elements[16] = &ffi_type_uint;
+  ts1_type_elements[17] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.ui17 = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui17 == 556);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(ts1_arg.ui17 == 555);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.call/struct_by_value_small.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.call/struct_by_value_small.c b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_small.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.call/struct_by_value_small.c	
@@ -0,0 +1,61 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned int ui17;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.ui17++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[2];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uint;
+  ts1_type_elements[1] = NULL;
+
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+
+  ts1_arg.ui17 = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+
+  CHECK(ts1_result->ui17 == 556);
+
+  /* This will fail if ffi_call isn't passing the struct by value. */
+  CHECK(ts1_arg.ui17 == 555);
+
+  free (ts1_result);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/Makefile.am
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/Makefile.am b/libffi-3.4.6/testsuite/Makefile.am
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/Makefile.am	
@@ -0,0 +1,87 @@
+## Process this file with automake to produce Makefile.in.
+
+AUTOMAKE_OPTIONS = foreign dejagnu
+
+EXTRA_DEJAGNU_SITE_CONFIG=../local.exp
+
+CLEANFILES = *.exe core* *.log *.sum
+
+EXTRA_DIST = config/default.exp emscripten/build.sh emscripten/conftest.py \
+	emscripten/node-tests.sh emscripten/test.html emscripten/test_libffi.py \
+  emscripten/build-tests.sh lib/libffi.exp lib/target-libpath.exp \
+	lib/wrapper.exp libffi.bhaible/Makefile libffi.bhaible/README \
+	libffi.bhaible/alignof.h libffi.bhaible/bhaible.exp libffi.bhaible/test-call.c \
+	libffi.bhaible/test-callback.c libffi.bhaible/testcases.c libffi.call/align_mixed.c \
+	libffi.call/align_stdcall.c libffi.call/bpo_38748.c libffi.call/call.exp \
+	libffi.call/err_bad_typedef.c libffi.call/ffitest.h libffi.call/float.c \
+	libffi.call/float1.c libffi.call/float2.c libffi.call/float3.c \
+	libffi.call/float4.c libffi.call/float_va.c libffi.call/many.c \
+	libffi.call/many2.c libffi.call/many_double.c libffi.call/many_mixed.c \
+	libffi.call/negint.c libffi.call/offsets.c libffi.call/pr1172638.c \
+	libffi.call/promotion.c libffi.call/pyobjc_tc.c libffi.call/return_dbl.c \
+	libffi.call/return_dbl1.c libffi.call/return_dbl2.c libffi.call/return_fl.c \
+	libffi.call/return_fl1.c libffi.call/return_fl2.c libffi.call/return_fl3.c \
+	libffi.call/return_ldl.c libffi.call/return_ll.c libffi.call/return_ll1.c \
+	libffi.call/return_sc.c libffi.call/return_sl.c libffi.call/return_uc.c \
+	libffi.call/return_ul.c libffi.call/s55.c libffi.call/strlen.c \
+	libffi.call/strlen2.c libffi.call/strlen3.c libffi.call/strlen4.c \
+	libffi.call/struct1.c libffi.call/struct10.c libffi.call/struct2.c \
+	libffi.call/struct3.c libffi.call/struct4.c libffi.call/struct5.c \
+	libffi.call/struct6.c libffi.call/struct7.c libffi.call/struct8.c \
+	libffi.call/struct9.c libffi.call/struct_by_value_2.c libffi.call/struct_by_value_3.c \
+	libffi.call/struct_by_value_3f.c libffi.call/struct_by_value_4.c libffi.call/struct_by_value_4f.c \
+	libffi.call/struct_by_value_big.c libffi.call/struct_by_value_small.c libffi.call/struct_return_2H.c \
+	libffi.call/struct_return_8H.c libffi.call/uninitialized.c libffi.call/va_1.c \
+	libffi.call/va_2.c libffi.call/va_3.c libffi.call/va_struct1.c \
+	libffi.call/va_struct2.c libffi.call/va_struct3.c libffi.call/callback.c \
+	libffi.call/callback2.c libffi.call/callback3.c libffi.call/callback4.c \
+	libffi.closures/closure.exp libffi.closures/closure_fn0.c libffi.closures/closure_fn1.c \
+	libffi.closures/closure_fn2.c libffi.closures/closure_fn3.c libffi.closures/closure_fn4.c \
+	libffi.closures/closure_fn5.c libffi.closures/closure_fn6.c libffi.closures/closure_loc_fn0.c \
+	libffi.closures/closure_simple.c libffi.closures/cls_12byte.c libffi.closures/cls_16byte.c \
+	libffi.closures/cls_18byte.c libffi.closures/cls_19byte.c libffi.closures/cls_1_1byte.c \
+	libffi.closures/cls_20byte.c libffi.closures/cls_20byte1.c libffi.closures/cls_24byte.c \
+	libffi.closures/cls_2byte.c libffi.closures/cls_3_1byte.c libffi.closures/cls_3byte1.c \
+	libffi.closures/cls_3byte2.c libffi.closures/cls_3float.c libffi.closures/cls_4_1byte.c \
+	libffi.closures/cls_4byte.c libffi.closures/cls_5_1_byte.c libffi.closures/cls_5byte.c \
+	libffi.closures/cls_64byte.c libffi.closures/cls_6_1_byte.c libffi.closures/cls_6byte.c \
+	libffi.closures/cls_7_1_byte.c libffi.closures/cls_7byte.c libffi.closures/cls_8byte.c \
+	libffi.closures/cls_9byte1.c libffi.closures/cls_9byte2.c libffi.closures/cls_align_double.c \
+	libffi.closures/cls_align_float.c libffi.closures/cls_align_longdouble.c libffi.closures/cls_align_longdouble_split.c \
+	libffi.closures/cls_align_longdouble_split2.c libffi.closures/cls_align_pointer.c libffi.closures/cls_align_sint16.c \
+	libffi.closures/cls_align_sint32.c libffi.closures/cls_align_sint64.c libffi.closures/cls_align_uint16.c \
+	libffi.closures/cls_align_uint32.c libffi.closures/cls_align_uint64.c libffi.closures/cls_dbls_struct.c \
+	libffi.closures/cls_double.c libffi.closures/cls_double_va.c libffi.closures/cls_float.c \
+	libffi.closures/cls_longdouble.c libffi.closures/cls_longdouble_va.c libffi.closures/cls_many_mixed_args.c \
+	libffi.closures/cls_many_mixed_float_double.c libffi.closures/cls_multi_schar.c libffi.closures/cls_multi_sshort.c \
+	libffi.closures/cls_multi_sshortchar.c libffi.closures/cls_multi_uchar.c libffi.closures/cls_multi_ushort.c \
+	libffi.closures/cls_multi_ushortchar.c libffi.closures/cls_pointer.c libffi.closures/cls_pointer_stack.c \
+	libffi.closures/cls_schar.c libffi.closures/cls_sint.c libffi.closures/cls_sshort.c \
+	libffi.closures/cls_struct_va1.c libffi.closures/cls_uchar.c libffi.closures/cls_uint.c \
+	libffi.closures/cls_uint_va.c libffi.closures/cls_ulong_va.c libffi.closures/cls_ulonglong.c \
+	libffi.closures/cls_ushort.c libffi.closures/err_bad_abi.c libffi.closures/ffitest.h \
+	libffi.closures/huge_struct.c libffi.closures/nested_struct.c libffi.closures/nested_struct1.c \
+	libffi.closures/nested_struct10.c libffi.closures/nested_struct11.c libffi.closures/nested_struct12.c \
+	libffi.closures/nested_struct13.c libffi.closures/nested_struct2.c libffi.closures/nested_struct3.c \
+	libffi.closures/nested_struct4.c libffi.closures/nested_struct5.c libffi.closures/nested_struct6.c \
+	libffi.closures/nested_struct7.c libffi.closures/nested_struct8.c libffi.closures/nested_struct9.c \
+	libffi.closures/problem1.c libffi.closures/single_entry_structs1.c libffi.closures/single_entry_structs2.c \
+	libffi.closures/single_entry_structs3.c libffi.closures/stret_large.c libffi.closures/stret_large2.c \
+	libffi.closures/stret_medium.c libffi.closures/stret_medium2.c libffi.closures/testclosure.c \
+	libffi.closures/unwindtest.cc libffi.closures/unwindtest_ffi_call.cc libffi.complex/cls_align_complex.inc \
+	libffi.complex/cls_align_complex_double.c libffi.complex/cls_align_complex_float.c libffi.complex/cls_align_complex_longdouble.c \
+	libffi.complex/cls_complex.inc libffi.complex/cls_complex_double.c libffi.complex/cls_complex_float.c \
+	libffi.complex/cls_complex_longdouble.c libffi.complex/cls_complex_struct.inc libffi.complex/cls_complex_struct_double.c \
+	libffi.complex/cls_complex_struct_float.c libffi.complex/cls_complex_struct_longdouble.c libffi.complex/cls_complex_va.inc \
+	libffi.complex/cls_complex_va_double.c libffi.complex/cls_complex_va_float.c libffi.complex/cls_complex_va_longdouble.c \
+	libffi.complex/complex.exp libffi.complex/complex.inc libffi.complex/complex_defs_double.inc \
+	libffi.complex/complex_defs_float.inc libffi.complex/complex_defs_longdouble.inc libffi.complex/complex_double.c \
+	libffi.complex/complex_float.c libffi.complex/complex_int.c libffi.complex/complex_longdouble.c \
+	libffi.complex/ffitest.h libffi.complex/many_complex.inc libffi.complex/many_complex_double.c \
+	libffi.complex/many_complex_float.c libffi.complex/many_complex_longdouble.c libffi.complex/return_complex.inc \
+	libffi.complex/return_complex1.inc libffi.complex/return_complex1_double.c libffi.complex/return_complex1_float.c \
+	libffi.complex/return_complex1_longdouble.c libffi.complex/return_complex2.inc libffi.complex/return_complex2_double.c \
+	libffi.complex/return_complex2_float.c libffi.complex/return_complex2_longdouble.c libffi.complex/return_complex_double.c \
+	libffi.complex/return_complex_float.c libffi.complex/return_complex_longdouble.c libffi.go/aa-direct.c \
+	libffi.go/closure1.c libffi.go/ffitest.h libffi.go/go.exp \
+	libffi.go/static-chain.h Makefile.am Makefile.in
Index: libffi-3.4.6/testsuite/libffi.bhaible/README
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/README b/libffi-3.4.6/testsuite/libffi.bhaible/README
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/README	
@@ -0,0 +1,78 @@
+This package contains a test suite for libffi.
+
+This test suite can be compiled with a C compiler. No need for 'expect'
+or some other package that is often not installed.
+
+The test suite consists of 81 C functions, each with a different signature.
+* test-call verifies that calling each function directly produces the same
+  results as calling the function indirectly through 'ffi_call'.
+* test-callback verifies that calling each function directly produces the same
+  results as calling a function that is a callback (object build by
+  'ffi_prep_closure_loc') and simulates the original function.
+
+Each direct or indirect invocation should produce one line of output to
+stdout. A correct output consists of paired lines, such as
+
+void f(void):
+void f(void):
+int f(void):->99
+int f(void):->99
+int f(int):(1)->2
+int f(int):(1)->2
+int f(2*int):(1,2)->3
+int f(2*int):(1,2)->3
+...
+
+The Makefile then creates two files:
+* failed-call, which consists of the non-paired lines of output of
+  'test-call',
+* failed-callback, which consists of the non-paired lines of output of
+  'test-callback'.
+
+The test suite passes if both failed-call and failed-callback come out
+as empty.
+
+
+How to use the test suite
+-------------------------
+
+1. Modify the Makefile's variables
+   prefix = the directory in which libffi was installed
+   CC = the C compiler, often with options such as "-m32" or "-m64"
+        that enforce a certain ABI,
+   CFLAGS = optimization options (need to change them only for non-GCC
+            compilers)
+2. Run "make". If it fails already in "test-call", run also
+   "make check-callback".
+3. If this failed, inspect the output files.
+
+
+How to interpret the results
+----------------------------
+
+The failed-call and failed-callback files consist of paired lines:
+The first line is the result of the direct invocation.
+The second line is the result of invocation through libffi.
+
+For example, this output
+
+uchar f(uchar,ushort,uint,ulong):(97,2,3,4)->255
+uchar f(uchar,ushort,uint,ulong):(97,2,3,4)->0
+
+indicates that the arguments were passed correctly, but the return
+value came out wrong.
+
+And this output
+
+float f(17*float,3*int,L):(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,6,7,8,561,1105,1729,2465,2821,6601)->15319.1
+float f(17*float,3*int,L):(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,-140443648,10,268042216,-72537980,-140443648,-140443648,-140443648,-140443648,-140443648)->-6.47158e+08
+
+indicates that integer arguments that come after 17 floating-point arguments
+were not passed correctly.
+
+
+Credits
+-------
+
+The test suite is based on the one of GNU libffcall-2.0.
+Authors: Bill Triggs, Bruno Haible
Index: libffi-3.4.6/testsuite/libffi.bhaible/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/Makefile b/libffi-3.4.6/testsuite/libffi.bhaible/Makefile
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/Makefile	
@@ -0,0 +1,28 @@
+CC = gcc
+CFLAGS = -O2 -Wall
+prefix =
+includedir = $(prefix)/include
+libdir = $(prefix)/lib
+CPPFLAGS = -I$(includedir)
+LDFLAGS = -L$(libdir) -Wl,-rpath,$(libdir)
+
+all: check-call check-callback
+
+test-call: test-call.c testcases.c
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -o test-call test-call.c -lffi
+
+test-callback: test-callback.c testcases.c
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -o test-callback test-callback.c -lffi
+
+check-call: test-call
+	./test-call > test-call.out
+	LC_ALL=C uniq -u < test-call.out > failed-call
+	test '!' -s failed-call
+
+check-callback: test-callback
+	./test-callback > test-callback.out
+	LC_ALL=C uniq -u < test-callback.out > failed-callback
+	test '!' -s failed-callback
+
+clean:
+	rm -f test-call test-callback test-call.out test-callback.out failed-call failed-callback
Index: libffi-3.4.6/testsuite/libffi.bhaible/alignof.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/alignof.h b/libffi-3.4.6/testsuite/libffi.bhaible/alignof.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/alignof.h	
@@ -0,0 +1,50 @@
+/* Determine alignment of types.
+   Copyright (C) 2003-2004, 2006, 2009-2017 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _ALIGNOF_H
+#define _ALIGNOF_H
+
+#include <stddef.h>
+
+/* alignof_slot (TYPE)
+   Determine the alignment of a structure slot (field) of a given type,
+   at compile time.  Note that the result depends on the ABI.
+   This is the same as alignof (TYPE) and _Alignof (TYPE), defined in
+   <stdalign.h> if __alignof_is_defined is 1.
+   Note: The result cannot be used as a value for an 'enum' constant,
+   due to bugs in HP-UX 10.20 cc and AIX 3.2.5 xlc.  */
+#if defined __cplusplus
+  template <class type> struct alignof_helper { char __slot1; type __slot2; };
+# define alignof_slot(type) offsetof (alignof_helper<type>, __slot2)
+#else
+# define alignof_slot(type) offsetof (struct { char __slot1; type __slot2; }, __slot2)
+#endif
+
+/* alignof_type (TYPE)
+   Determine the good alignment of an object of the given type at compile time.
+   Note that this is not necessarily the same as alignof_slot(type).
+   For example, with GNU C on x86 platforms: alignof_type(double) = 8, but
+   - when -malign-double is not specified:  alignof_slot(double) = 4,
+   - when -malign-double is specified:      alignof_slot(double) = 8.
+   Note: The result cannot be used as a value for an 'enum' constant,
+   due to bugs in HP-UX 10.20 cc and AIX 3.2.5 xlc.  */
+#if defined __GNUC__ || defined __IBM__ALIGNOF__
+# define alignof_type __alignof__
+#else
+# define alignof_type alignof_slot
+#endif
+
+#endif /* _ALIGNOF_H */
Index: libffi-3.4.6/testsuite/libffi.bhaible/bhaible.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/bhaible.exp b/libffi-3.4.6/testsuite/libffi.bhaible/bhaible.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/bhaible.exp	
@@ -0,0 +1,63 @@
+# Copyright (C) 2003, 2006, 2009, 2010, 2014, 2018 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+dg-init
+libffi-init
+
+global srcdir subdir
+global compiler_vendor
+
+# The conversion of this testsuite into a dejagnu compatible testsuite
+# was done in a pretty lazy fashion, and requires the use of compiler
+# flags to disable warnings for now.
+if { [string match $compiler_vendor "gnu"] } {
+    set warning_options "-Wno-unused-variable -Wno-unused-parameter -Wno-unused-but-set-variable -Wno-uninitialized";
+}
+if { [string match $compiler_vendor "microsoft"] } {
+    # -wd4996  suggest use of vsprintf_s instead of vsprintf
+    # -wd4116  unnamed type definition
+    # -wd4101  unreferenced local variable
+    # -wd4244  warning about implicit double to float conversion
+    set warning_options "-wd4996 -wd4116 -wd4101 -wd4244";
+}
+if { ![string match $compiler_vendor "microsoft"] && ![string match $compiler_vendor "gnu"] } {
+    set warning_options "-Wno-unused-variable -Wno-unused-parameter -Wno-uninitialized";
+}
+
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/test-call.c]]
+
+for {set i 1} {$i < 82} {incr i} {
+    run-many-tests $tlist [format "-DDGTEST=%d %s" $i $warning_options]
+}
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/test-callback.c]]
+
+for {set i 1} {$i < 81} {incr i} {
+    if { [libffi_feature_test "#if FFI_CLOSURES"] } {
+        run-many-tests $tlist [format "-DDGTEST=%d %s" $i $warning_options]
+    } else {
+        foreach test $tlist {
+            unsupported [format "%s -DDGTEST=%d %s" $test $i $warning_options]
+        }
+    }
+}
+
+dg-finish
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/libffi.bhaible/test-call.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/test-call.c b/libffi-3.4.6/testsuite/libffi.bhaible/test-call.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/test-call.c	
@@ -0,0 +1,1746 @@
+/**
+  Copyright 1993 Bill Triggs <Bill.Triggs@inrialpes.fr>
+  Copyright 1995-2017 Bruno Haible <bruno@clisp.org>
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**/
+
+/* { dg-do run { xfail gccbug } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ffi.h>
+#include "alignof.h"
+#include <stdarg.h>
+
+/* libffi testsuite local changes -------------------------------- */
+#ifdef DGTEST
+/* Redefine exit(1) as a test failure */
+#define exit(V) (void)((V) ? (abort(), 1) : exit(0))
+int count = 0;
+char rbuf1[2048];
+char rbuf2[2048];
+int _fprintf(FILE *stream, const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+
+  switch (count++)
+    {
+    case 0:
+    case 1:
+      vsprintf(&rbuf1[strlen(rbuf1)], format, args);
+      break;
+    case 2:
+      printf("%s", rbuf1);
+      vsprintf(rbuf2, format, args);
+      break;
+    case 3:
+      vsprintf(&rbuf2[strlen(rbuf2)], format, args);
+      printf("%s", rbuf2);
+      fflush (stdout);
+      if (strcmp (rbuf1, rbuf2)) abort();
+      break;
+    }
+
+  va_end(args);
+
+  return 0;
+}
+#define fprintf _fprintf
+#endif
+/* --------------------------------------------------------------- */
+
+#include "testcases.c"
+
+#ifndef ABI_NUM
+#define ABI_NUM FFI_DEFAULT_ABI
+#endif
+
+/* Definitions that ought to be part of libffi. */
+static ffi_type ffi_type_char;
+#define ffi_type_slonglong ffi_type_sint64
+#define ffi_type_ulonglong ffi_type_uint64
+
+/* libffi does not support arrays inside structs. */
+#define SKIP_EXTRA_STRUCTS
+
+#define FFI_PREP_CIF(cif,argtypes,rettype) \
+  if (ffi_prep_cif(&(cif),ABI_NUM,sizeof(argtypes)/sizeof(argtypes[0]),&rettype,argtypes) != FFI_OK) abort()
+#define FFI_PREP_CIF_NOARGS(cif,rettype) \
+  if (ffi_prep_cif(&(cif),ABI_NUM,0,&rettype,NULL) != FFI_OK) abort()
+#define FFI_CALL(cif,fn,args,retaddr) \
+  ffi_call(&(cif),(void(*)(void))(fn),retaddr,args)
+
+long clear_traces_i (long a, long b, long c, long d, long e, long f, long g, long h,
+                     long i, long j, long k, long l, long m, long n, long o, long p)
+{ return 0; }
+float clear_traces_f (float a, float b, float c, float d, float e, float f, float g,
+                      float h, float i, float j, float k, float l, float m, float n,
+                      float o, float p)
+{ return 0.0; }
+double clear_traces_d (double a, double b, double c, double d, double e, double f, double g,
+                       double h, double i, double j, double k, double l, double m, double n,
+                       double o, double p)
+{ return 0.0; }
+J clear_traces_J (void)
+{ J j; j.l1 = j.l2 = 0; return j; }
+void clear_traces (void)
+{ clear_traces_i(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
+  clear_traces_f(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
+  clear_traces_d(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
+  clear_traces_J();
+}
+
+void
+  void_tests (void)
+{
+#if (!defined(DGTEST)) || DGTEST == 1  
+  v_v();
+  clear_traces();
+  {
+    ffi_cif cif;
+    FFI_PREP_CIF_NOARGS(cif,ffi_type_void);
+    {
+      FFI_CALL(cif,v_v,NULL,NULL);
+    }
+  }
+#endif  
+  return;
+}
+void
+  int_tests (void)
+{
+  int ir;
+  ffi_arg retvalue;
+#if (!defined(DGTEST)) || DGTEST == 2
+  ir = i_v();
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_cif cif;
+    FFI_PREP_CIF_NOARGS(cif,ffi_type_sint);
+    {
+      FFI_CALL(cif,i_v,NULL,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 3
+  ir = i_i(i1);
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+    {
+      /*const*/ void* args[] = { &i1 };
+      FFI_CALL(cif,i_i,args,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 4
+  ir = i_i2(i1,i2);
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+    {
+      /*const*/ void* args[] = { &i1, &i2 };
+      FFI_CALL(cif,i_i2,args,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 5
+  ir = i_i4(i1,i2,i3,i4);
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &i3, &i4 };
+      FFI_CALL(cif,i_i4,args,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 6
+  ir = i_i8(i1,i2,i3,i4,i5,i6,i7,i8);
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &i3, &i4, &i5, &i6, &i7, &i8 };
+      FFI_CALL(cif,i_i8,args,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 7
+  ir = i_i16(i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15,i16);
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+  ir = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &i3, &i4, &i5, &i6, &i7, &i8, &i9, &i10, &i11, &i12, &i13, &i14, &i15, &i16 };
+      FFI_CALL(cif,i_i16,args,&retvalue);
+      ir = retvalue;
+    }
+  }
+  fprintf(out,"->%d\n",ir);
+  fflush(out);
+#endif
+
+  return;
+}
+void
+  float_tests (void)
+{
+  float fr;
+
+#if (!defined(DGTEST)) || DGTEST == 8
+  fr = f_f(f1);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1 };
+      FFI_CALL(cif,f_f,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 9
+  fr = f_f2(f1,f2);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2 };
+      FFI_CALL(cif,f_f2,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 10
+  fr = f_f4(f1,f2,f3,f4);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4 };
+      FFI_CALL(cif,f_f4,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 11
+  fr = f_f8(f1,f2,f3,f4,f5,f6,f7,f8);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8 };
+      FFI_CALL(cif,f_f8,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 12
+  fr = f_f16(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &f9, &f10, &f11, &f12, &f13, &f14, &f15, &f16 };
+      FFI_CALL(cif,f_f16,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 13
+  fr = f_f24(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &f9, &f10, &f11, &f12, &f13, &f14, &f15, &f16, &f17, &f18, &f19, &f20, &f21, &f22, &f23, &f24 };
+      FFI_CALL(cif,f_f24,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+}
+void
+  double_tests (void)
+{
+  double dr;
+
+#if (!defined(DGTEST)) || DGTEST == 14
+  
+  dr = d_d(d1);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1 };
+      FFI_CALL(cif,d_d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 15
+  dr = d_d2(d1,d2);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2 };
+      FFI_CALL(cif,d_d2,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 16
+  dr = d_d4(d1,d2,d3,d4);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4 };
+      FFI_CALL(cif,d_d4,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 17
+  dr = d_d8(d1,d2,d3,d4,d5,d6,d7,d8);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8 };
+      FFI_CALL(cif,d_d8,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 18
+  dr = d_d16(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8, &d9, &d10, &d11, &d12, &d13, &d14, &d15, &d16 };
+      FFI_CALL(cif,d_d16,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif  
+  return;
+}
+void
+  pointer_tests (void)
+{
+  void* vpr;
+
+#if (!defined(DGTEST)) || DGTEST == 19
+  vpr = vp_vpdpcpsp(&uc1,&d2,str3,&I4);
+  fprintf(out,"->0x%p\n",vpr);
+  fflush(out);
+  vpr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_pointer, &ffi_type_pointer, &ffi_type_pointer, &ffi_type_pointer };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_pointer);
+    {
+      void* puc1 = &uc1;
+      void* pd2 = &d2;
+      void* pstr3 = str3;
+      void* pI4 = &I4;
+      /*const*/ void* args[] = { &puc1, &pd2, &pstr3, &pI4 };
+      FFI_CALL(cif,vp_vpdpcpsp,args,&vpr);
+    }
+  }
+  fprintf(out,"->0x%p\n",vpr);
+  fflush(out);
+#endif  
+  return;
+}
+void
+  mixed_number_tests (void)
+{
+  uchar ucr;
+  ushort usr;
+  float fr;
+  double dr;
+  long long llr;
+
+  /* Unsigned types.
+   */
+#if (!defined(DGTEST)) || DGTEST == 20
+  ucr = uc_ucsil(uc1, us2, ui3, ul4);
+  fprintf(out,"->%u\n",ucr);
+  fflush(out);
+  ucr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_uchar, &ffi_type_ushort, &ffi_type_uint, &ffi_type_ulong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_uchar);
+    {
+      ffi_arg r;
+      /*const*/ void* args[] = { &uc1, &us2, &ui3, &ul4 };
+      FFI_CALL(cif,uc_ucsil,args,&r);
+      ucr = (uchar) r;
+    }
+  }
+  fprintf(out,"->%u\n",ucr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 21
+  /* Mixed int & float types.
+   */
+  dr = d_iidd(i1,i2,d3,d4);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &d3, &d4 };
+      FFI_CALL(cif,d_iidd,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 22
+  dr = d_iiidi(i1,i2,i3,d4,i5);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &i3, &d4, &i5 };
+      FFI_CALL(cif,d_iiidi,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 23
+  dr = d_idid(i1,d2,i3,d4);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_double, &ffi_type_sint, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &i1, &d2, &i3, &d4 };
+      FFI_CALL(cif,d_idid,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 24
+  dr = d_fdi(f1,d2,i3);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &f1, &d2, &i3 };
+      FFI_CALL(cif,d_fdi,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 25
+  usr = us_cdcd(c1,d2,c3,d4);
+  fprintf(out,"->%u\n",usr);
+  fflush(out);
+  usr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_char, &ffi_type_double, &ffi_type_char, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_ushort);
+    {
+      ffi_arg rint;
+      /*const*/ void* args[] = { &c1, &d2, &c3, &d4 };
+      FFI_CALL(cif,us_cdcd,args,&rint);
+      usr = (ushort) rint;
+    }
+  }
+  fprintf(out,"->%u\n",usr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 26
+  /* Long long types.
+   */
+  llr = ll_iiilli(i1,i2,i3,ll1,i13);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_slonglong, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &i1, &i2, &i3, &ll1, &i13 };
+      FFI_CALL(cif,ll_iiilli,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 27
+  llr = ll_flli(f13,ll1,i13);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_slonglong, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &f13, &ll1, &i13 };
+      FFI_CALL(cif,ll_flli,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 28
+  fr = f_fi(f1,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &i9 };
+      FFI_CALL(cif,f_fi,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 29
+  fr = f_f2i(f1,f2,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &i9 };
+      FFI_CALL(cif,f_f2i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 30
+  fr = f_f3i(f1,f2,f3,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &i9 };
+      FFI_CALL(cif,f_f3i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 31
+  fr = f_f4i(f1,f2,f3,f4,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &i9 };
+      FFI_CALL(cif,f_f4i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 32
+  fr = f_f7i(f1,f2,f3,f4,f5,f6,f7,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &i9 };
+      FFI_CALL(cif,f_f7i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 33
+  fr = f_f8i(f1,f2,f3,f4,f5,f6,f7,f8,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &i9 };
+      FFI_CALL(cif,f_f8i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 34
+  fr = f_f12i(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &f9, &f10, &f11, &f12, &i9 };
+      FFI_CALL(cif,f_f12i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 35
+  fr = f_f13i(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,i9);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &f9, &f10, &f11, &f12, &f13, &i9 };
+      FFI_CALL(cif,f_f13i,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 36
+  dr = d_di(d1,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &i9 };
+      FFI_CALL(cif,d_di,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 37
+  dr = d_d2i(d1,d2,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &i9 };
+      FFI_CALL(cif,d_d2i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 38
+  dr = d_d3i(d1,d2,d3,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &i9 };
+      FFI_CALL(cif,d_d3i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 39
+  dr = d_d4i(d1,d2,d3,d4,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &i9 };
+      FFI_CALL(cif,d_d4i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 40
+  dr = d_d7i(d1,d2,d3,d4,d5,d6,d7,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &i9 };
+      FFI_CALL(cif,d_d7i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 41
+  dr = d_d8i(d1,d2,d3,d4,d5,d6,d7,d8,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8, &i9 };
+      FFI_CALL(cif,d_d8i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 42
+  dr = d_d12i(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8, &d9, &d10, &d11, &d12, &i9 };
+      FFI_CALL(cif,d_d12i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 43
+  dr = d_d13i(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,i9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8, &d9, &d10, &d11, &d12, &d13, &i9 };
+      FFI_CALL(cif,d_d13i,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif  
+  return;
+}
+void
+  small_structure_return_tests (void)
+{
+#if (!defined(DGTEST)) || DGTEST == 44
+  {
+    Size1 r = S1_v();
+    fprintf(out,"->{%c}\n",r.x1);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size1_elements[] = { &ffi_type_char, NULL };
+      ffi_type ffi_type_Size1;
+      ffi_type_Size1.type = FFI_TYPE_STRUCT;
+      ffi_type_Size1.size = sizeof(Size1);
+      ffi_type_Size1.alignment = alignof_slot(Size1);
+      ffi_type_Size1.elements = ffi_type_Size1_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size1);
+      {
+        FFI_CALL(cif,S1_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c}\n",r.x1);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 45
+  {
+    Size2 r = S2_v();
+    fprintf(out,"->{%c%c}\n",r.x1,r.x2);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size2_elements[] = { &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size2;
+      ffi_type_Size2.type = FFI_TYPE_STRUCT;
+      ffi_type_Size2.size = sizeof(Size2);
+      ffi_type_Size2.alignment = alignof_slot(Size2);
+      ffi_type_Size2.elements = ffi_type_Size2_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size2);
+      {
+        FFI_CALL(cif,S2_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c}\n",r.x1,r.x2);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 46
+  {
+    Size3 r = S3_v();
+    fprintf(out,"->{%c%c%c}\n",r.x1,r.x2,r.x3);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size3_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size3;
+      ffi_type_Size3.type = FFI_TYPE_STRUCT;
+      ffi_type_Size3.size = sizeof(Size3);
+      ffi_type_Size3.alignment = alignof_slot(Size3);
+      ffi_type_Size3.elements = ffi_type_Size3_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size3);
+      {
+        FFI_CALL(cif,S3_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c}\n",r.x1,r.x2,r.x3);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 47
+  {
+    Size4 r = S4_v();
+    fprintf(out,"->{%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size4_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size4;
+      ffi_type_Size4.type = FFI_TYPE_STRUCT;
+      ffi_type_Size4.size = sizeof(Size4);
+      ffi_type_Size4.alignment = alignof_slot(Size4);
+      ffi_type_Size4.elements = ffi_type_Size4_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size4);
+      {
+        FFI_CALL(cif,S4_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 48
+  {
+    Size7 r = S7_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size7_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size7;
+      ffi_type_Size7.type = FFI_TYPE_STRUCT;
+      ffi_type_Size7.size = sizeof(Size7);
+      ffi_type_Size7.alignment = alignof_slot(Size7);
+      ffi_type_Size7.elements = ffi_type_Size7_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size7);
+      {
+        FFI_CALL(cif,S7_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 49
+  {
+    Size8 r = S8_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size8_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size8;
+      ffi_type_Size8.type = FFI_TYPE_STRUCT;
+      ffi_type_Size8.size = sizeof(Size8);
+      ffi_type_Size8.alignment = alignof_slot(Size8);
+      ffi_type_Size8.elements = ffi_type_Size8_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size8);
+      {
+        FFI_CALL(cif,S8_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 50
+  {
+    Size12 r = S12_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size12_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size12;
+      ffi_type_Size12.type = FFI_TYPE_STRUCT;
+      ffi_type_Size12.size = sizeof(Size12);
+      ffi_type_Size12.alignment = alignof_slot(Size12);
+      ffi_type_Size12.elements = ffi_type_Size12_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size12);
+      {
+        FFI_CALL(cif,S12_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 51  
+  {
+    Size15 r = S15_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size15_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size15;
+      ffi_type_Size15.type = FFI_TYPE_STRUCT;
+      ffi_type_Size15.size = sizeof(Size15);
+      ffi_type_Size15.alignment = alignof_slot(Size15);
+      ffi_type_Size15.elements = ffi_type_Size15_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size15);
+      {
+        FFI_CALL(cif,S15_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15);
+    fflush(out);
+  }
+#endif
+#if (!defined(DGTEST)) || DGTEST == 52  
+  {
+    Size16 r = S16_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15,r.x16);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    {
+      ffi_type* ffi_type_Size16_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size16;
+      ffi_type_Size16.type = FFI_TYPE_STRUCT;
+      ffi_type_Size16.size = sizeof(Size16);
+      ffi_type_Size16.alignment = alignof_slot(Size16);
+      ffi_type_Size16.elements = ffi_type_Size16_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size16);
+      {
+        FFI_CALL(cif,S16_v,NULL,&r);
+      }
+    }
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15,r.x16);
+    fflush(out);
+  }
+#endif
+}
+void
+  structure_tests (void)
+{
+  Int Ir;
+  Char Cr;
+  Float Fr;
+  Double Dr;
+  J Jr;
+#ifndef SKIP_EXTRA_STRUCTS  
+  T Tr;
+  X Xr;
+#endif  
+
+#if (!defined(DGTEST)) || DGTEST == 53  
+  Ir = I_III(I1,I2,I3);
+  fprintf(out,"->{%d}\n",Ir.x);
+  fflush(out);
+  Ir.x = 0; clear_traces();
+  {
+    ffi_type* ffi_type_Int_elements[] = { &ffi_type_sint, NULL };
+    ffi_type ffi_type_Int;
+    ffi_type_Int.type = FFI_TYPE_STRUCT;
+    ffi_type_Int.size = sizeof(Int);
+    ffi_type_Int.alignment = alignof_slot(Int);
+    ffi_type_Int.elements = ffi_type_Int_elements;
+    ffi_type* argtypes[] = { &ffi_type_Int, &ffi_type_Int, &ffi_type_Int };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_Int);
+    {
+      /*const*/ void* args[] = { &I1, &I2, &I3 };
+      FFI_CALL(cif,I_III,args,&Ir);
+    }
+  }
+  fprintf(out,"->{%d}\n",Ir.x);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 54
+  Cr = C_CdC(C1,d2,C3);
+  fprintf(out,"->{'%c'}\n",Cr.x);
+  fflush(out);
+  Cr.x = '\0'; clear_traces();
+  {
+    ffi_type* ffi_type_Char_elements[] = { &ffi_type_char, NULL };
+    ffi_type ffi_type_Char;
+    ffi_type_Char.type = FFI_TYPE_STRUCT;
+    ffi_type_Char.size = sizeof(Char);
+    ffi_type_Char.alignment = alignof_slot(Char);
+    ffi_type_Char.elements = ffi_type_Char_elements;
+    ffi_type* argtypes[] = { &ffi_type_Char, &ffi_type_double, &ffi_type_Char };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_Char);
+    {
+      /*const*/ void* args[] = { &C1, &d2, &C3 };
+      FFI_CALL(cif,C_CdC,args,&Cr);
+    }
+  }
+  fprintf(out,"->{'%c'}\n",Cr.x);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 55
+  Fr = F_Ffd(F1,f2,d3);
+  fprintf(out,"->{%g}\n",Fr.x);
+  fflush(out);
+  Fr.x = 0.0; clear_traces();
+  {
+    ffi_type* ffi_type_Float_elements[] = { &ffi_type_float, NULL };
+    ffi_type ffi_type_Float;
+    ffi_type_Float.type = FFI_TYPE_STRUCT;
+    ffi_type_Float.size = sizeof(Float);
+    ffi_type_Float.alignment = alignof_slot(Float);
+    ffi_type_Float.elements = ffi_type_Float_elements;
+    ffi_type* argtypes[] = { &ffi_type_Float, &ffi_type_float, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_Float);
+    {
+      /*const*/ void* args[] = { &F1, &f2, &d3 };
+      FFI_CALL(cif,F_Ffd,args,&Fr);
+    }
+  }
+  fprintf(out,"->{%g}\n",Fr.x);
+  fflush(out);
+#endif  
+#if (!defined(DGTEST)) || DGTEST == 56  
+  Dr = D_fDd(f1,D2,d3);
+  fprintf(out,"->{%g}\n",Dr.x);
+  fflush(out);
+  Dr.x = 0.0; clear_traces();
+  {
+    ffi_type* ffi_type_Double_elements[] = { &ffi_type_double, NULL };
+    ffi_type ffi_type_Double;
+    ffi_type_Double.type = FFI_TYPE_STRUCT;
+    ffi_type_Double.size = sizeof(Double);
+    ffi_type_Double.alignment = alignof_slot(Double);
+    ffi_type_Double.elements = ffi_type_Double_elements;
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_Double, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_Double);
+    {
+      /*const*/ void* args[] = { &f1, &D2, &d3 };
+      FFI_CALL(cif,D_fDd,args,&Dr);
+    }
+  }
+  fprintf(out,"->{%g}\n",Dr.x);
+  fflush(out);
+#endif  
+#if (!defined(DGTEST)) || DGTEST == 57  
+  Dr = D_Dfd(D1,f2,d3);
+  fprintf(out,"->{%g}\n",Dr.x);
+  fflush(out);
+  Dr.x = 0.0; clear_traces();
+  {
+    ffi_type* ffi_type_Double_elements[] = { &ffi_type_double, NULL };
+    ffi_type ffi_type_Double;
+    ffi_type_Double.type = FFI_TYPE_STRUCT;
+    ffi_type_Double.size = sizeof(Double);
+    ffi_type_Double.alignment = alignof_slot(Double);
+    ffi_type_Double.elements = ffi_type_Double_elements;
+    ffi_type* argtypes[] = { &ffi_type_Double, &ffi_type_float, &ffi_type_double };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_Double);
+    {
+      /*const*/ void* args[] = { &D1, &f2, &d3 };
+      FFI_CALL(cif,D_Dfd,args,&Dr);
+    }
+  }
+  fprintf(out,"->{%g}\n",Dr.x);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 58  
+  Jr = J_JiJ(J1,i2,J2);
+  fprintf(out,"->{%ld,%ld}\n",Jr.l1,Jr.l2);
+  fflush(out);
+  Jr.l1 = Jr.l2 = 0; clear_traces();
+  {
+    ffi_type* ffi_type_J_elements[] = { &ffi_type_slong, &ffi_type_slong, NULL };
+    ffi_type ffi_type_J;
+    ffi_type_J.type = FFI_TYPE_STRUCT;
+    ffi_type_J.size = sizeof(J);
+    ffi_type_J.alignment = alignof_slot(J);
+    ffi_type_J.elements = ffi_type_J_elements;
+    ffi_type* argtypes[] = { &ffi_type_J, &ffi_type_sint, &ffi_type_J };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_J);
+    {
+      /*const*/ void* args[] = { &J1, &i2, &J2 };
+      FFI_CALL(cif,J_JiJ,args,&Jr);
+    }
+  }
+  fprintf(out,"->{%ld,%ld}\n",Jr.l1,Jr.l2);
+  fflush(out);
+#endif
+#ifndef SKIP_EXTRA_STRUCTS
+#if (!defined(DGTEST)) || DGTEST == 59
+  Tr = T_TcT(T1,' ',T2);
+  fprintf(out,"->{\"%c%c%c\"}\n",Tr.c[0],Tr.c[1],Tr.c[2]);
+  fflush(out);
+  Tr.c[0] = Tr.c[1] = Tr.c[2] = 0; clear_traces();
+  {
+    ffi_type* ffi_type_T_elements[] = { ??, NULL };
+    ffi_type ffi_type_T;
+    ffi_type_T.type = FFI_TYPE_STRUCT;
+    ffi_type_T.size = sizeof(T);
+    ffi_type_T.alignment = alignof_slot(T);
+    ffi_type_T.elements = ffi_type_T_elements;
+    ffi_type* argtypes[] = { &ffi_type_T, &ffi_type_char, &ffi_type_T };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_T);
+    {
+      char space = ' ';
+      /*const*/ void* args[] = { &T1, &space, &T2 };
+      FFI_CALL(cif,T_TcT,args,&Tr);
+    }
+  }
+  fprintf(out,"->{\"%c%c%c\"}\n",Tr.c[0],Tr.c[1],Tr.c[2]);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 60
+  Xr = X_BcdB(B1,c2,d3,B2);
+  fprintf(out,"->{\"%s\",'%c'}\n",Xr.c,Xr.c1);
+  fflush(out);
+  Xr.c[0]=Xr.c1='\0'; clear_traces();
+  {
+    ffi_type* ffi_type_X_elements[] = { ??, NULL };
+    ffi_type ffi_type_X;
+    ffi_type_X.type = FFI_TYPE_STRUCT;
+    ffi_type_X.size = sizeof(X);
+    ffi_type_X.alignment = alignof_slot(X);
+    ffi_type_X.elements = ffi_type_X_elements;
+    ffi_type* argtypes[] = { &ffi_type_X, &ffi_type_char, &ffi_type_double, &ffi_type_X };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_X);
+    {
+      /*const*/ void* args[] = { &B1, &c2, &d3, &B2 };
+      FFI_CALL(cif,X_BcdB,args,&Xr);
+    }
+  }
+  fprintf(out,"->{\"%s\",'%c'}\n",Xr.c,Xr.c1);
+  fflush(out);
+#endif
+#endif
+
+  return;
+}
+
+void
+  gpargs_boundary_tests (void)
+{
+  ffi_type* ffi_type_K_elements[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, NULL };
+  ffi_type ffi_type_K;
+  ffi_type* ffi_type_L_elements[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, NULL };
+  ffi_type ffi_type_L;
+  long lr;
+  long long llr;
+  float fr;
+  double dr;
+
+  ffi_type_K.type = FFI_TYPE_STRUCT;
+  ffi_type_K.size = sizeof(K);
+  ffi_type_K.alignment = alignof_slot(K);
+  ffi_type_K.elements = ffi_type_K_elements;
+
+  ffi_type_L.type = FFI_TYPE_STRUCT;
+  ffi_type_L.size = sizeof(L);
+  ffi_type_L.alignment = alignof_slot(L);
+  ffi_type_L.elements = ffi_type_L_elements;
+
+#if (!defined(DGTEST)) || DGTEST == 61  
+  lr = l_l0K(K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &K1, &l9 };
+      FFI_CALL(cif,l_l0K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 62  
+  lr = l_l1K(l1,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &K1, &l9 };
+      FFI_CALL(cif,l_l1K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 63  
+  lr = l_l2K(l1,l2,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &K1, &l9 };
+      FFI_CALL(cif,l_l2K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 64  
+  lr = l_l3K(l1,l2,l3,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &K1, &l9 };
+      FFI_CALL(cif,l_l3K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 65
+  lr = l_l4K(l1,l2,l3,l4,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &K1, &l9 };
+      FFI_CALL(cif,l_l4K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 66
+  lr = l_l5K(l1,l2,l3,l4,l5,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &K1, &l9 };
+      FFI_CALL(cif,l_l5K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 67  
+  lr = l_l6K(l1,l2,l3,l4,l5,l6,K1,l9);
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+  lr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &l6, &K1, &l9 };
+      FFI_CALL(cif,l_l6K,args,&lr);
+    }
+  }
+  fprintf(out,"->%ld\n",lr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 68  
+  fr = f_f17l3L(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,l6,l7,l8,L1);
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+  fr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_L };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+    {
+      /*const*/ void* args[] = { &f1, &f2, &f3, &f4, &f5, &f6, &f7, &f8, &f9, &f10, &f11, &f12, &f13, &f14, &f15, &f16, &f17, &l6, &l7, &l8, &L1 };
+      FFI_CALL(cif,f_f17l3L,args,&fr);
+    }
+  }
+  fprintf(out,"->%g\n",fr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 69  
+  dr = d_d17l3L(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,d17,l6,l7,l8,L1);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_L };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &d1, &d2, &d3, &d4, &d5, &d6, &d7, &d8, &d9, &d10, &d11, &d12, &d13, &d14, &d15, &d16, &d17, &l6, &l7, &l8, &L1 };
+      FFI_CALL(cif,d_d17l3L,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 70  
+  llr = ll_l2ll(l1,l2,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &ll1, &l9 };
+      FFI_CALL(cif,ll_l2ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 71
+  llr = ll_l3ll(l1,l2,l3,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &ll1, &l9 };
+      FFI_CALL(cif,ll_l3ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 72  
+  llr = ll_l4ll(l1,l2,l3,l4,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &ll1, &l9 };
+      FFI_CALL(cif,ll_l4ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 73  
+  llr = ll_l5ll(l1,l2,l3,l4,l5,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &ll1, &l9 };
+      FFI_CALL(cif,ll_l5ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 74  
+  llr = ll_l6ll(l1,l2,l3,l4,l5,l6,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &l6, &ll1, &l9 };
+      FFI_CALL(cif,ll_l6ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 75  
+  llr = ll_l7ll(l1,l2,l3,l4,l5,l6,l7,ll1,l9);
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+  llr = 0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &l6, &l7, &ll1, &l9 };
+      FFI_CALL(cif,ll_l7ll,args,&llr);
+    }
+  }
+  fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 76  
+  dr = d_l2d(l1,l2,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &d2, &l9 };
+      FFI_CALL(cif,d_l2d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 77  
+  dr = d_l3d(l1,l2,l3,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &d2, &l9 };
+      FFI_CALL(cif,d_l3d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 78  
+  dr = d_l4d(l1,l2,l3,l4,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &d2, &l9 };
+      FFI_CALL(cif,d_l4d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 79  
+  dr = d_l5d(l1,l2,l3,l4,l5,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &d2, &l9 };
+      FFI_CALL(cif,d_l5d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 80  
+  dr = d_l6d(l1,l2,l3,l4,l5,l6,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &l6, &d2, &l9 };
+      FFI_CALL(cif,d_l6d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+#if (!defined(DGTEST)) || DGTEST == 81  
+  dr = d_l7d(l1,l2,l3,l4,l5,l6,l7,d2,l9);
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+  dr = 0.0; clear_traces();
+  {
+    ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+    ffi_cif cif;
+    FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+    {
+      /*const*/ void* args[] = { &l1, &l2, &l3, &l4, &l5, &l6, &l7, &d2, &l9 };
+      FFI_CALL(cif,d_l7d,args,&dr);
+    }
+  }
+  fprintf(out,"->%g\n",dr);
+  fflush(out);
+#endif
+  return;
+}
+
+int
+  main (void)
+{
+  ffi_type_char = (char)(-1) < 0 ? ffi_type_schar : ffi_type_uchar;
+  out = stdout;
+
+  void_tests();
+  int_tests();
+  float_tests();
+  double_tests();
+  pointer_tests();
+  mixed_number_tests();
+  small_structure_return_tests();
+  structure_tests();
+  gpargs_boundary_tests();
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.bhaible/testcases.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/testcases.c b/libffi-3.4.6/testsuite/libffi.bhaible/testcases.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/testcases.c	
@@ -0,0 +1,747 @@
+/*
+ * Copyright 1993 Bill Triggs <Bill.Triggs@inrialpes.fr>
+ * Copyright 1995-2017 Bruno Haible <bruno@clisp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* This file defines test functions of selected signatures, that exercise
+   dark corners of the various ABIs. */
+
+#include <stdio.h>
+
+FILE* out;
+
+#define uchar unsigned char
+#define ushort unsigned short
+#define uint unsigned int
+#define ulong unsigned long
+
+typedef struct { char x; } Char;
+typedef struct { short x; } Short;
+typedef struct { int x; } Int;
+typedef struct { long x; } Long;
+typedef struct { float x; } Float;
+typedef struct { double x; } Double;
+typedef struct { char c; float f; } A;
+typedef struct { double d; int i[3]; } B;
+typedef struct { long l1; long l2; } J;
+typedef struct { long l1; long l2; long l3; long l4; } K;
+typedef struct { long l1; long l2; long l3; long l4; long l5; long l6; } L;
+typedef struct { char x1; } Size1;
+typedef struct { char x1; char x2; } Size2;
+typedef struct { char x1; char x2; char x3; } Size3;
+typedef struct { char x1; char x2; char x3; char x4; } Size4;
+typedef struct {
+  char x1; char x2; char x3; char x4; char x5; char x6; char x7;
+} Size7;
+typedef struct {
+  char x1; char x2; char x3; char x4; char x5; char x6; char x7; char x8;
+} Size8;
+typedef struct {
+  char x1; char x2; char x3; char x4; char x5; char x6; char x7; char x8;
+  char x9; char x10; char x11; char x12;
+} Size12;
+typedef struct {
+  char x1; char x2; char x3; char x4; char x5; char x6; char x7; char x8;
+  char x9; char x10; char x11; char x12; char x13; char x14; char x15;
+} Size15;
+typedef struct {
+  char x1; char x2; char x3; char x4; char x5; char x6; char x7; char x8;
+  char x9; char x10; char x11; char x12; char x13; char x14; char x15; char x16;
+} Size16;
+typedef struct { char c[3]; } T;
+typedef struct { char c[33],c1; } X;
+
+/* Don't use a number over 127, as some systems use signed chars and
+   the test case 25 doesn't account for this, resulting in undefined
+   behavior. See https://github.com/libffi/libffi/issues/598. */
+char c1='a', c2=127, c3=(char)1;
+
+short s1=32767, s2=(short)32768, s3=3, s4=4, s5=5, s6=6, s7=7, s8=8, s9=9;
+int i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9,
+    i10=11, i11=12, i12=13, i13=14, i14=15, i15=16, i16=17;
+long l1=1, l2=2, l3=3, l4=4, l5=5, l6=6, l7=7, l8=8, l9=9;
+long long ll1 = 3875056143130689530LL;
+float f1=0.1f, f2=0.2f, f3=0.3f, f4=0.4f, f5=0.5f, f6=0.6f, f7=0.7f, f8=0.8f, f9=0.9f,
+      f10=1.1f, f11=1.2f, f12=1.3f, f13=1.4f, f14=1.5f, f15=1.6f, f16=1.7f, f17=1.8f,
+      f18=1.9f, f19=2.1f, f20=2.2f, f21=2.3f, f22=2.4f, f23=2.5f, f24=2.6f;
+double d1=0.1, d2=0.2, d3=0.3, d4=0.4, d5=0.5, d6=0.6, d7=0.7, d8=0.8, d9=0.9,
+       d10=1.1, d11=1.2, d12=1.3, d13=1.4, d14=1.5, d15=1.6, d16=1.7, d17=1.8;
+
+uchar uc1='a', uc2=127, uc3=128, uc4=255, uc5=(uchar)-1;
+ushort us1=1, us2=2, us3=3, us4=4, us5=5, us6=6, us7=7, us8=8, us9=9;
+uint ui1=1, ui2=2, ui3=3, ui4=4, ui5=5, ui6=6, ui7=7, ui8=8, ui9=9;
+ulong ul1=1, ul2=2, ul3=3, ul4=4, ul5=5, ul6=6, ul7=7, ul8=8, ul9=9;
+
+char *str1="hello",str2[]="goodbye",*str3="still here?";
+Char C1={'A'}, C2={'B'}, C3={'C'}, C4={'\377'}, C5={(char)(-1)};
+Short S1={1}, S2={2}, S3={3}, S4={4}, S5={5}, S6={6}, S7={7}, S8={8}, S9={9};
+Int I1={1}, I2={2}, I3={3}, I4={4}, I5={5}, I6={6}, I7={7}, I8={8}, I9={9};
+Float F1={0.1f}, F2={0.2f}, F3={0.3f}, F4={0.4f}, F5={0.5f}, F6={0.6f}, F7={0.7f}, F8={0.8f}, F9={0.9f};
+Double D1={0.1}, D2={0.2}, D3={0.3}, D4={0.4}, D5={0.5}, D6={0.6}, D7={0.7}, D8={0.8}, D9={0.9};
+
+A A1={'a',0.1f},A2={'b',0.2f},A3={'\377',0.3f};
+B B1={0.1,{1,2,3}},B2={0.2,{5,4,3}};
+J J1={47,11},J2={73,55};
+K K1={19,69,12,28};
+L L1={561,1105,1729,2465,2821,6601}; /* A002997 */
+Size1 Size1_1={'a'};
+Size2 Size2_1={'a','b'};
+Size3 Size3_1={'a','b','c'};
+Size4 Size4_1={'a','b','c','d'};
+Size7 Size7_1={'a','b','c','d','e','f','g'};
+Size8 Size8_1={'a','b','c','d','e','f','g','h'};
+Size12 Size12_1={'a','b','c','d','e','f','g','h','i','j','k','l'};
+Size15 Size15_1={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o'};
+Size16 Size16_1={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};
+T T1={{'t','h','e'}},T2={{'f','o','x'}};
+X X1={"abcdefghijklmnopqrstuvwxyzABCDEF",'G'}, X2={"123",'9'}, X3={"return-return-return",'R'};
+
+#if defined(__GNUC__)
+#define __STDCALL__ __attribute__((stdcall))
+#define __THISCALL__ __attribute__((thiscall))
+#define __FASTCALL__ __attribute__((fastcall))
+#define __MSABI__ __attribute__((ms_abi))
+#else
+#define __STDCALL__ __stdcall
+#define __THISCALL__ __thiscall
+#define __FASTCALL__ __fastcall
+#endif
+
+#ifndef ABI_ATTR
+#define ABI_ATTR
+#endif
+
+/* void tests */
+void ABI_ATTR v_v (void)
+{
+  fprintf(out,"void f(void):\n");
+  fflush(out);
+}
+
+/* int tests */
+int ABI_ATTR i_v (void)
+{
+  int r=99;
+  fprintf(out,"int f(void):");
+  fflush(out);
+  return r;
+}
+int ABI_ATTR i_i (int a)
+{
+  int r=a+1;
+  fprintf(out,"int f(int):(%d)",a);
+  fflush(out);
+  return r;
+}
+int ABI_ATTR i_i2 (int a, int b)
+{
+  int r=a+b;
+  fprintf(out,"int f(2*int):(%d,%d)",a,b);
+  fflush(out);
+  return r;
+}
+int ABI_ATTR i_i4 (int a, int b, int c, int d)
+{
+  int r=a+b+c+d;
+  fprintf(out,"int f(4*int):(%d,%d,%d,%d)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+int ABI_ATTR i_i8 (int a, int b, int c, int d, int e, int f, int g, int h)
+{
+  int r=a+b+c+d+e+f+g+h;
+  fprintf(out,"int f(8*int):(%d,%d,%d,%d,%d,%d,%d,%d)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  return r;
+}
+int ABI_ATTR i_i16 (int a, int b, int c, int d, int e, int f, int g, int h,
+           int i, int j, int k, int l, int m, int n, int o, int p)
+{
+  int r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"int f(16*int):(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)",
+          a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  return r;
+}
+
+/* float tests */
+float ABI_ATTR f_f (float a)
+{
+  float r=a+1.0f;
+  fprintf(out,"float f(float):(%g)",a);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f2 (float a, float b)
+{
+  float r=a+b;
+  fprintf(out,"float f(2*float):(%g,%g)",a,b);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f4 (float a, float b, float c, float d)
+{
+  float r=a+b+c+d;
+  fprintf(out,"float f(4*float):(%g,%g,%g,%g)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f8 (float a, float b, float c, float d, float e, float f,
+            float g, float h)
+{
+  float r=a+b+c+d+e+f+g+h;
+  fprintf(out,"float f(8*float):(%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f16 (float a, float b, float c, float d, float e, float f, float g, float h,
+             float i, float j, float k, float l, float m, float n, float o, float p)
+{
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"float f(16*float):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f24 (float a, float b, float c, float d, float e, float f, float g, float h,
+             float i, float j, float k, float l, float m, float n, float o, float p,
+             float q, float s, float t, float u, float v, float w, float x, float y)
+{
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+v+w+x+y;
+  fprintf(out,"float f(24*float):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,v,w,x,y);
+  fflush(out);
+  return r;
+}
+
+/* double tests */
+double ABI_ATTR d_d (double a)
+{
+  double r=a+1.0;
+  fprintf(out,"double f(double):(%g)",a);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d2 (double a, double b)
+{
+  double r=a+b;
+  fprintf(out,"double f(2*double):(%g,%g)",a,b);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d4 (double a, double b, double c, double d)
+{
+  double r=a+b+c+d;
+  fprintf(out,"double f(4*double):(%g,%g,%g,%g)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d8 (double a, double b, double c, double d, double e, double f,
+             double g, double h)
+{
+  double r=a+b+c+d+e+f+g+h;
+  fprintf(out,"double f(8*double):(%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d16 (double a, double b, double c, double d, double e, double f,
+              double g, double h, double i, double j, double k, double l,
+              double m, double n, double o, double p)
+{
+  double r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"double f(16*double):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  return r;
+}
+
+/* pointer tests */
+void* ABI_ATTR vp_vpdpcpsp (void* a, double* b, char* c, Int* d)
+{
+  void* ret = (char*)b + 1;
+  fprintf(out,"void* f(void*,double*,char*,Int*):(0x%p,0x%p,0x%p,0x%p)",a,b,c,d);
+  fflush(out);
+  return ret;
+}
+
+/* mixed number tests */
+uchar ABI_ATTR uc_ucsil (uchar a, ushort b, uint c, ulong d)
+{
+  uchar r = (uchar)-1;
+  fprintf(out,"uchar f(uchar,ushort,uint,ulong):(%u,%u,%u,%lu)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_iidd (int a, int b, double c, double d)
+{
+  double r = a+b+c+d;
+  fprintf(out,"double f(int,int,double,double):(%d,%d,%g,%g)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_iiidi (int a, int b, int c, double d, int e)
+{
+  double r = a+b+c+d+e;
+  fprintf(out,"double f(int,int,int,double,int):(%d,%d,%d,%g,%d)",a,b,c,d,e);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_idid (int a, double b, int c, double d)
+{
+  double r = a+b+c+d;
+  fprintf(out,"double f(int,double,int,double):(%d,%g,%d,%g)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_fdi (float a, double b, int c)
+{
+  double r = a+b+c;
+  fprintf(out,"double f(float,double,int):(%g,%g,%d)",a,b,c);
+  fflush(out);
+  return r;
+}
+ushort ABI_ATTR us_cdcd (char a, double b, char c, double d)
+{
+  ushort r = (ushort)(a + b + c + d);
+  fprintf(out,"ushort f(char,double,char,double):('%c',%g,'%c',%g)",a,b,c,d);
+  fflush(out);
+  return r;
+}
+
+long long ABI_ATTR ll_iiilli (int a, int b, int c, long long d, int e)
+{
+  long long r = (long long)(int)a+(long long)(int)b+(long long)(int)c+d+(long long)(int)e;
+  fprintf(out,"long long f(int,int,int,long long,int):(%d,%d,%d,0x%lx%08lx,%d)",a,b,c,(long)(d>>32),(long)(d&0xffffffff),e);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_flli (float a, long long b, int c)
+{
+  long long r = (long long)(int)a + b + (long long)c;
+  fprintf(out,"long long f(float,long long,int):(%g,0x%lx%08lx,0x%lx)",a,(long)(b>>32),(long)(b&0xffffffff),(long)c);
+  fflush(out);
+  return r;
+}
+
+float ABI_ATTR f_fi (float a, int z)
+{
+  float r = a+z;
+  fprintf(out,"float f(float,int):(%g,%d)",a,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f2i (float a, float b, int z)
+{
+  float r = a+b+z;
+  fprintf(out,"float f(2*float,int):(%g,%g,%d)",a,b,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f3i (float a, float b, float c, int z)
+{
+  float r = a+b+c+z;
+  fprintf(out,"float f(3*float,int):(%g,%g,%g,%d)",a,b,c,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f4i (float a, float b, float c, float d, int z)
+{
+  float r = a+b+c+d+z;
+  fprintf(out,"float f(4*float,int):(%g,%g,%g,%g,%d)",a,b,c,d,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f7i (float a, float b, float c, float d, float e, float f, float g,
+             int z)
+{
+  float r = a+b+c+d+e+f+g+z;
+  fprintf(out,"float f(7*float,int):(%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f8i (float a, float b, float c, float d, float e, float f, float g,
+             float h, int z)
+{
+  float r = a+b+c+d+e+f+g+h+z;
+  fprintf(out,"float f(8*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f12i (float a, float b, float c, float d, float e, float f, float g,
+              float h, float i, float j, float k, float l, int z)
+{
+  float r = a+b+c+d+e+f+g+h+i+j+k+l+z;
+  fprintf(out,"float f(12*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,z);
+  fflush(out);
+  return r;
+}
+float ABI_ATTR f_f13i (float a, float b, float c, float d, float e, float f, float g,
+              float h, float i, float j, float k, float l, float m, int z)
+{
+  float r = a+b+c+d+e+f+g+h+i+j+k+l+m+z;
+  fprintf(out,"float f(13*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,m,z);
+  fflush(out);
+  return r;
+}
+
+double ABI_ATTR d_di (double a, int z)
+{
+  double r = a+z;
+  fprintf(out,"double f(double,int):(%g,%d)",a,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d2i (double a, double b, int z)
+{
+  double r = a+b+z;
+  fprintf(out,"double f(2*double,int):(%g,%g,%d)",a,b,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d3i (double a, double b, double c, int z)
+{
+  double r = a+b+c+z;
+  fprintf(out,"double f(3*double,int):(%g,%g,%g,%d)",a,b,c,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d4i (double a, double b, double c, double d, int z)
+{
+  double r = a+b+c+d+z;
+  fprintf(out,"double f(4*double,int):(%g,%g,%g,%g,%d)",a,b,c,d,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d7i (double a, double b, double c, double d, double e, double f,
+              double g, int z)
+{
+  double r = a+b+c+d+e+f+g+z;
+  fprintf(out,"double f(7*double,int):(%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d8i (double a, double b, double c, double d, double e, double f,
+              double g, double h, int z)
+{
+  double r = a+b+c+d+e+f+g+h+z;
+  fprintf(out,"double f(8*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d12i (double a, double b, double c, double d, double e, double f,
+               double g, double h, double i, double j, double k, double l,
+               int z)
+{
+  double r = a+b+c+d+e+f+g+h+i+j+k+l+z;
+  fprintf(out,"double f(12*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,z);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d13i (double a, double b, double c, double d, double e, double f,
+               double g, double h, double i, double j, double k, double l,
+               double m, int z)
+{
+  double r = a+b+c+d+e+f+g+h+i+j+k+l+m+z;
+  fprintf(out,"double f(13*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,m,z);
+  fflush(out);
+  return r;
+}
+
+/* small structure return tests */
+Size1 ABI_ATTR S1_v (void)
+{
+  fprintf(out,"Size1 f(void):");
+  fflush(out);
+  return Size1_1;
+}
+Size2 ABI_ATTR S2_v (void)
+{
+  fprintf(out,"Size2 f(void):");
+  fflush(out);
+  return Size2_1;
+}
+Size3 ABI_ATTR S3_v (void)
+{
+  fprintf(out,"Size3 f(void):");
+  fflush(out);
+  return Size3_1;
+}
+Size4 ABI_ATTR S4_v (void)
+{
+  fprintf(out,"Size4 f(void):");
+  fflush(out);
+  return Size4_1;
+}
+Size7 ABI_ATTR S7_v (void)
+{
+  fprintf(out,"Size7 f(void):");
+  fflush(out);
+  return Size7_1;
+}
+Size8 ABI_ATTR S8_v (void)
+{
+  fprintf(out,"Size8 f(void):");
+  fflush(out);
+  return Size8_1;
+}
+Size12 ABI_ATTR S12_v (void)
+{
+  fprintf(out,"Size12 f(void):");
+  fflush(out);
+  return Size12_1;
+}
+Size15 ABI_ATTR S15_v (void)
+{
+  fprintf(out,"Size15 f(void):");
+  fflush(out);
+  return Size15_1;
+}
+Size16 ABI_ATTR S16_v (void)
+{
+  fprintf(out,"Size16 f(void):");
+  fflush(out);
+  return Size16_1;
+}
+
+/* structure tests */
+Int ABI_ATTR I_III (Int a, Int b, Int c)
+{
+  Int r;
+  r.x = a.x + b.x + c.x;
+  fprintf(out,"Int f(Int,Int,Int):({%d},{%d},{%d})",a.x,b.x,c.x);
+  fflush(out);
+  return r;
+}
+Char ABI_ATTR C_CdC (Char a, double b, Char c)
+{
+  Char r;
+  r.x = (a.x + c.x)/2;
+  fprintf(out,"Char f(Char,double,Char):({'%c'},%g,{'%c'})",a.x,b,c.x);
+  fflush(out);
+  return r;
+}
+Float ABI_ATTR F_Ffd (Float a, float b, double c)
+{
+  Float r;
+  r.x = (float) (a.x + b + c);
+  fprintf(out,"Float f(Float,float,double):({%g},%g,%g)",a.x,b,c);
+  fflush(out);
+  return r;
+}
+Double ABI_ATTR D_fDd (float a, Double b, double c)
+{
+  Double r;
+  r.x = a + b.x + c;
+  fprintf(out,"Double f(float,Double,double):(%g,{%g},%g)",a,b.x,c);
+  fflush(out);
+  return r;
+}
+Double ABI_ATTR D_Dfd (Double a, float b, double c)
+{
+  Double r;
+  r.x = a.x + b + c;
+  fprintf(out,"Double f(Double,float,double):({%g},%g,%g)",a.x,b,c);
+  fflush(out);
+  return r;
+}
+J ABI_ATTR J_JiJ (J a, int b, J c)
+{
+  J r;
+  r.l1 = a.l1+c.l1; r.l2 = a.l2+b+c.l2;
+  fprintf(out,"J f(J,int,J):({%ld,%ld},%d,{%ld,%ld})",a.l1,a.l2,b,c.l1,c.l2);
+  fflush(out);
+  return r;
+}
+T ABI_ATTR T_TcT (T a, char b, T c)
+{
+  T r;
+  r.c[0]='b'; r.c[1]=c.c[1]; r.c[2]=c.c[2];
+  fprintf(out,"T f(T,char,T):({\"%c%c%c\"},'%c',{\"%c%c%c\"})",a.c[0],a.c[1],a.c[2],b,c.c[0],c.c[1],c.c[2]);
+  fflush(out);
+  return r;
+}
+X ABI_ATTR X_BcdB (B a, char b, double c, B d)
+{
+  static X xr={"return val",'R'};
+  X r;
+  r = xr;
+  r.c1 = b;
+  fprintf(out,"X f(B,char,double,B):({%g,{%d,%d,%d}},'%c',%g,{%g,{%d,%d,%d}})",
+          a.d,a.i[0],a.i[1],a.i[2],b,c,d.d,d.i[0],d.i[1],d.i[2]);
+  fflush(out);
+  return r;
+}
+
+/* Test for cases where some argument (especially structure, 'long long', or
+   'double') may be passed partially in general-purpose argument registers
+   and partially on the stack. Different ABIs pass between 4 and 8 arguments
+   (or none) in general-purpose argument registers. */
+
+long ABI_ATTR l_l0K (K b, long c)
+{
+  long r = b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(K,long):(%ld,%ld,%ld,%ld,%ld)",b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l1K (long a1, K b, long c)
+{
+  long r = a1 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld)",a1,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l2K (long a1, long a2, K b, long c)
+{
+  long r = a1 + a2 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(2*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l3K (long a1, long a2, long a3, K b, long c)
+{
+  long r = a1 + a2 + a3 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(3*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l4K (long a1, long a2, long a3, long a4, K b, long c)
+{
+  long r = a1 + a2 + a3 + a4 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(4*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l5K (long a1, long a2, long a3, long a4, long a5, K b, long c)
+{
+  long r = a1 + a2 + a3 + a4 + a5 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(5*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,a5,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+long ABI_ATTR l_l6K (long a1, long a2, long a3, long a4, long a5, long a6, K b, long c)
+{
+  long r = a1 + a2 + a3 + a4 + a5 + a6 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(6*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,a5,a6,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  return r;
+}
+/* These tests is crafted on the knowledge that for all known ABIs:
+   * 17 > number of floating-point argument registers,
+   * 3 < number of general-purpose argument registers < 3 + 6. */
+float ABI_ATTR f_f17l3L (float a, float b, float c, float d, float e, float f, float g,
+                float h, float i, float j, float k, float l, float m, float n,
+                float o, float p, float q,
+                long s, long t, long u, L z)
+{
+  float r = a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+z.l1+z.l2+z.l3+z.l4+z.l5+z.l6;
+  fprintf(out,"float f(17*float,3*int,L):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,z.l1,z.l2,z.l3,z.l4,z.l5,z.l6);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_d17l3L (double a, double b, double c, double d, double e, double f,
+                 double g, double h, double i, double j, double k, double l,
+                 double m, double n, double o, double p, double q,
+                 long s, long t, long u, L z)
+{
+  double r = a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+z.l1+z.l2+z.l3+z.l4+z.l5+z.l6;
+  fprintf(out,"double f(17*double,3*int,L):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,z.l1,z.l2,z.l3,z.l4,z.l5,z.l6);
+  fflush(out);
+  return r;
+}
+
+long long ABI_ATTR ll_l2ll (long a1, long a2, long long b, long c)
+{
+  long long r = (long long) (a1 + a2) + b + c;
+  fprintf(out,"long long f(2*long,long long,long):(%ld,%ld,0x%lx%08lx,%ld)",a1,a2,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_l3ll (long a1, long a2, long a3, long long b, long c)
+{
+  long long r = (long long) (a1 + a2 + a3) + b + c;
+  fprintf(out,"long long f(3*long,long long,long):(%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_l4ll (long a1, long a2, long a3, long a4, long long b, long c)
+{
+  long long r = (long long) (a1 + a2 + a3 + a4) + b + c;
+  fprintf(out,"long long f(4*long,long long,long):(%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_l5ll (long a1, long a2, long a3, long a4, long a5, long long b, long c)
+{
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5) + b + c;
+  fprintf(out,"long long f(5*long,long long,long):(%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_l6ll (long a1, long a2, long a3, long a4, long a5, long a6, long long b, long c)
+{
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5 + a6) + b + c;
+  fprintf(out,"long long f(6*long,long long,long):(%ld,%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,a6,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+long long ABI_ATTR ll_l7ll (long a1, long a2, long a3, long a4, long a5, long a6, long a7, long long b, long c)
+{
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5 + a6 + a7) + b + c;
+  fprintf(out,"long long f(7*long,long long,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,a6,a7,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  return r;
+}
+
+double ABI_ATTR d_l2d (long a1, long a2, double b, long c)
+{
+  double r = (double) (a1 + a2) + b + c;
+  fprintf(out,"double f(2*long,double,long):(%ld,%ld,%g,%ld)",a1,a2,b,c);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_l3d (long a1, long a2, long a3, double b, long c)
+{
+  double r = (double) (a1 + a2 + a3) + b + c;
+  fprintf(out,"double f(3*long,double,long):(%ld,%ld,%ld,%g,%ld)",a1,a2,a3,b,c);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_l4d (long a1, long a2, long a3, long a4, double b, long c)
+{
+  double r = (double) (a1 + a2 + a3 + a4) + b + c;
+  fprintf(out,"double f(4*long,double,long):(%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,b,c);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_l5d (long a1, long a2, long a3, long a4, long a5, double b, long c)
+{
+  double r = (double) (a1 + a2 + a3 + a4 + a5) + b + c;
+  fprintf(out,"double f(5*long,double,long):(%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,b,c);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_l6d (long a1, long a2, long a3, long a4, long a5, long a6, double b, long c)
+{
+  double r = (double) (a1 + a2 + a3 + a4 + a5 + a6) + b + c;
+  fprintf(out,"double f(6*long,double,long):(%ld,%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,a6,b,c);
+  fflush(out);
+  return r;
+}
+double ABI_ATTR d_l7d (long a1, long a2, long a3, long a4, long a5, long a6, long a7, double b, long c)
+{
+  double r = (double) (a1 + a2 + a3 + a4 + a5 + a6 + a7) + b + c;
+  fprintf(out,"double f(7*long,double,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,a6,a7,b,c);
+  fflush(out);
+  return r;
+}
Index: libffi-3.4.6/testsuite/libffi.bhaible/test-callback.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.bhaible/test-callback.c b/libffi-3.4.6/testsuite/libffi.bhaible/test-callback.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.bhaible/test-callback.c	
@@ -0,0 +1,2885 @@
+/*
+ * Copyright 1993 Bill Triggs <Bill.Triggs@inrialpes.fr>
+ * Copyright 1995-2017 Bruno Haible <bruno@clisp.org>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* { dg-do run { xfail gccbug } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ffi.h>
+#include "alignof.h"
+#include <stdarg.h>
+
+/* libffi testsuite local changes -------------------------------- */
+#ifdef DGTEST
+/* Redefine exit(1) as a test failure */
+#define exit(V) (void)((V) ? (abort(), 1) : exit(0))
+int count = 0;
+char rbuf1[2048];
+char rbuf2[2048];
+int _fprintf(FILE *stream, const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+
+  switch (count++)
+    {
+    case 0:
+    case 1:
+      vsprintf(&rbuf1[strlen(rbuf1)], format, args);
+      break;
+    case 2:
+      printf("%s", rbuf1);
+      vsprintf(rbuf2, format, args);
+      break;
+    case 3:
+      vsprintf(&rbuf2[strlen(rbuf2)], format, args);
+      printf("%s", rbuf2);
+      if (strcmp (rbuf1, rbuf2)) abort();
+      break;
+    }
+
+  va_end(args);
+
+  return 0;
+}
+#define fprintf _fprintf
+#endif
+/* --------------------------------------------------------------- */
+
+#include "testcases.c"
+
+#ifndef ABI_NUM
+#define ABI_NUM FFI_DEFAULT_ABI
+#endif
+
+/* Definitions that ought to be part of libffi. */
+static ffi_type ffi_type_char;
+#define ffi_type_slonglong ffi_type_sint64
+#define ffi_type_ulonglong ffi_type_uint64
+
+/* libffi does not support arrays inside structs. */
+#define SKIP_EXTRA_STRUCTS
+
+#define FFI_PREP_CIF(cif,argtypes,rettype) \
+  if (ffi_prep_cif(&(cif),ABI_NUM,sizeof(argtypes)/sizeof(argtypes[0]),&rettype,argtypes) != FFI_OK) abort()
+#define FFI_PREP_CIF_NOARGS(cif,rettype) \
+  if (ffi_prep_cif(&(cif),ABI_NUM,0,&rettype,NULL) != FFI_OK) abort()
+
+#if defined(__sparc__) && defined(__sun) && defined(__SUNPRO_C) /* SUNWspro cc */
+/* SunPRO cc miscompiles the simulator function for X_BcdB: d.i[1] is
+ * temporarily stored in %l2 and put onto the stack from %l2, but in between
+ * the copy of X has used %l2 as a counter without saving and restoring its
+ * value.
+ */
+#define SKIP_X
+#endif
+#if defined(__mipsn32__) && !defined(__GNUC__)
+/* The X test crashes for an unknown reason. */
+#define SKIP_X
+#endif
+
+
+/* These functions simulate the behaviour of the functions defined in testcases.c. */
+
+/* void tests */
+void v_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&v_v) { fprintf(out,"wrong data for v_v\n"); exit(1); }
+  fprintf(out,"void f(void):\n");
+  fflush(out);
+}
+
+/* int tests */
+void i_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_v) { fprintf(out,"wrong data for i_v\n"); exit(1); }
+ {int r=99;
+  fprintf(out,"int f(void):");
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void i_i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_i) { fprintf(out,"wrong data for i_i\n"); exit(1); }
+  int a = *(int*)(*args++);
+  int r=a+1;
+  fprintf(out,"int f(int):(%d)",a);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}
+void i_i2_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_i2) { fprintf(out,"wrong data for i_i2\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int r=a+b;
+  fprintf(out,"int f(2*int):(%d,%d)",a,b);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void i_i4_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_i4) { fprintf(out,"wrong data for i_i4\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int c = *(int*)(*args++);
+  int d = *(int*)(*args++);
+  int r=a+b+c+d;
+  fprintf(out,"int f(4*int):(%d,%d,%d,%d)",a,b,c,d);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void i_i8_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_i8) { fprintf(out,"wrong data for i_i8\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int c = *(int*)(*args++);
+  int d = *(int*)(*args++);
+  int e = *(int*)(*args++);
+  int f = *(int*)(*args++);
+  int g = *(int*)(*args++);
+  int h = *(int*)(*args++);
+  int r=a+b+c+d+e+f+g+h;
+  fprintf(out,"int f(8*int):(%d,%d,%d,%d,%d,%d,%d,%d)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void i_i16_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&i_i16) { fprintf(out,"wrong data for i_i16\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int c = *(int*)(*args++);
+  int d = *(int*)(*args++);
+  int e = *(int*)(*args++);
+  int f = *(int*)(*args++);
+  int g = *(int*)(*args++);
+  int h = *(int*)(*args++);
+  int i = *(int*)(*args++);
+  int j = *(int*)(*args++);
+  int k = *(int*)(*args++);
+  int l = *(int*)(*args++);
+  int m = *(int*)(*args++);
+  int n = *(int*)(*args++);
+  int o = *(int*)(*args++);
+  int p = *(int*)(*args++);
+  int r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"int f(16*int):(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)",
+          a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+
+/* float tests */
+void f_f_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f) { fprintf(out,"wrong data for f_f\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float r=a+1.0;
+  fprintf(out,"float f(float):(%g)",a);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f2_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f2) { fprintf(out,"wrong data for f_f2\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float r=a+b;
+  fprintf(out,"float f(2*float):(%g,%g)",a,b);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f4_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f4) { fprintf(out,"wrong data for f_f4\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float r=a+b+c+d;
+  fprintf(out,"float f(4*float):(%g,%g,%g,%g)",a,b,c,d);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f8_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f8) { fprintf(out,"wrong data for f_f8\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float r=a+b+c+d+e+f+g+h;
+  fprintf(out,"float f(8*float):(%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f16_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f16) { fprintf(out,"wrong data for f_f16\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float i = *(float*)(*args++);
+  float j = *(float*)(*args++);
+  float k = *(float*)(*args++);
+  float l = *(float*)(*args++);
+  float m = *(float*)(*args++);
+  float n = *(float*)(*args++);
+  float o = *(float*)(*args++);
+  float p = *(float*)(*args++);
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"float f(16*float):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f24_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f24) { fprintf(out,"wrong data for f_f24\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float i = *(float*)(*args++);
+  float j = *(float*)(*args++);
+  float k = *(float*)(*args++);
+  float l = *(float*)(*args++);
+  float m = *(float*)(*args++);
+  float n = *(float*)(*args++);
+  float o = *(float*)(*args++);
+  float p = *(float*)(*args++);
+  float q = *(float*)(*args++);
+  float s = *(float*)(*args++);
+  float t = *(float*)(*args++);
+  float u = *(float*)(*args++);
+  float v = *(float*)(*args++);
+  float w = *(float*)(*args++);
+  float x = *(float*)(*args++);
+  float y = *(float*)(*args++);
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+v+w+x+y;
+  fprintf(out,"float f(24*float):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,v,w,x,y);
+  fflush(out);
+  *(float*)retp = r;
+}}
+
+/* double tests */
+void d_d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d) { fprintf(out,"wrong data for d_d\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double r=a+1.0;
+  fprintf(out,"double f(double):(%g)",a);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d2_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d2) { fprintf(out,"wrong data for d_d2\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double r=a+b;
+  fprintf(out,"double f(2*double):(%g,%g)",a,b);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d4_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d4) { fprintf(out,"wrong data for d_d4\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double r=a+b+c+d;
+  fprintf(out,"double f(4*double):(%g,%g,%g,%g)",a,b,c,d);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d8_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d8) { fprintf(out,"wrong data for d_d8\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  double r=a+b+c+d+e+f+g+h;
+  fprintf(out,"double f(8*double):(%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d16_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d16) { fprintf(out,"wrong data for d_d16\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  double i = *(double*)(*args++);
+  double j = *(double*)(*args++);
+  double k = *(double*)(*args++);
+  double l = *(double*)(*args++);
+  double m = *(double*)(*args++);
+  double n = *(double*)(*args++);
+  double o = *(double*)(*args++);
+  double p = *(double*)(*args++);
+  double r=a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p;
+  fprintf(out,"double f(16*double):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  fflush(out);
+  *(double*)retp = r;
+}}
+
+/* pointer tests */
+void vp_vpdpcpsp_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&vp_vpdpcpsp) { fprintf(out,"wrong data for vp_vpdpcpsp\n"); exit(1); }
+ {void* a = *(void* *)(*args++);
+  double* b = *(double* *)(*args++);
+  char* c = *(char* *)(*args++);
+  Int* d = *(Int* *)(*args++);
+  void* ret = (char*)b + 1;
+  fprintf(out,"void* f(void*,double*,char*,Int*):(0x%p,0x%p,0x%p,0x%p)",a,b,c,d);
+  fflush(out);
+  *(void* *)retp = ret;
+}}
+
+/* mixed number tests */
+void uc_ucsil_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&uc_ucsil) { fprintf(out,"wrong data for uc_ucsil\n"); exit(1); }
+ {uchar a = *(unsigned char *)(*args++);
+  ushort b = *(unsigned short *)(*args++);
+  uint c = *(unsigned int *)(*args++);
+  ulong d = *(unsigned long *)(*args++);
+  uchar r = (uchar)-1;
+  fprintf(out,"uchar f(uchar,ushort,uint,ulong):(%u,%u,%u,%lu)",a,b,c,d);
+  fflush(out);
+  *(ffi_arg *)retp = r;
+}}
+void d_iidd_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_iidd) { fprintf(out,"wrong data for d_iidd\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double r=a+b+c+d;
+  fprintf(out,"double f(int,int,double,double):(%d,%d,%g,%g)",a,b,c,d);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_iiidi_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_iiidi) { fprintf(out,"wrong data for d_iiidi\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int c = *(int*)(*args++);
+  double d = *(double*)(*args++);
+  int e = *(int*)(*args++);
+  double r=a+b+c+d+e;
+  fprintf(out,"double f(int,int,int,double,int):(%d,%d,%d,%g,%d)",a,b,c,d,e);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_idid_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_idid) { fprintf(out,"wrong data for d_idid\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  double b = *(double*)(*args++);
+  int c = *(int*)(*args++);
+  double d = *(double*)(*args++);
+  double r=a+b+c+d;
+  fprintf(out,"double f(int,double,int,double):(%d,%g,%d,%g)",a,b,c,d);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_fdi_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_fdi) { fprintf(out,"wrong data for d_fdi\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  double b = *(double*)(*args++);
+  int c = *(int*)(*args++);
+  double r=a+b+c;
+  fprintf(out,"double f(float,double,int):(%g,%g,%d)",a,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void us_cdcd_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&us_cdcd) { fprintf(out,"wrong data for us_cdcd\n"); exit(1); }
+ {char a = *(char*)(*args++);
+  double b = *(double*)(*args++);
+  char c = *(char*)(*args++);
+  double d = *(double*)(*args++);
+  ushort r = (ushort)(a + b + c + d);
+  fprintf(out,"ushort f(char,double,char,double):('%c',%g,'%c',%g)",a,b,c,d);
+  fflush(out);
+  *(ffi_arg *)retp = r;
+}}
+void ll_iiilli_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_iiilli) { fprintf(out,"wrong data for ll_iiilli\n"); exit(1); }
+ {int a = *(int*)(*args++);
+  int b = *(int*)(*args++);
+  int c = *(int*)(*args++);
+  long long d = *(long long *)(*args++);
+  int e = *(int*)(*args++);
+  long long r = (long long)(int)a + (long long)(int)b + (long long)(int)c + d + (long long)e;
+  fprintf(out,"long long f(int,int,int,long long,int):(%d,%d,%d,0x%lx%08lx,%d)",a,b,c,(long)(d>>32),(long)(d&0xffffffff),e);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_flli_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_flli) { fprintf(out,"wrong data for ll_flli\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  long long b = *(long long *)(*args++);
+  int c = *(int*)(*args++);
+  long long r = (long long)(int)a + b + (long long)c;
+  fprintf(out,"long long f(float,long long,int):(%g,0x%lx%08lx,0x%lx)",a,(long)(b>>32),(long)(b&0xffffffff),(long)c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void f_fi_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_fi) { fprintf(out,"wrong data for f_fi\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+z;
+  fprintf(out,"float f(float,int):(%g,%d)",a,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f2i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f2i) { fprintf(out,"wrong data for f_f2i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+z;
+  fprintf(out,"float f(2*float,int):(%g,%g,%d)",a,b,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f3i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f3i) { fprintf(out,"wrong data for f_f3i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+z;
+  fprintf(out,"float f(3*float,int):(%g,%g,%g,%d)",a,b,c,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f4i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f4i) { fprintf(out,"wrong data for f_f4i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+d+z;
+  fprintf(out,"float f(4*float,int):(%g,%g,%g,%g,%d)",a,b,c,d,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f7i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f7i) { fprintf(out,"wrong data for f_f7i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+d+e+f+g+z;
+  fprintf(out,"float f(7*float,int):(%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f8i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f8i) { fprintf(out,"wrong data for f_f8i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+d+e+f+g+h+z;
+  fprintf(out,"float f(8*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f12i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f12i) { fprintf(out,"wrong data for f_f12i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float i = *(float*)(*args++);
+  float j = *(float*)(*args++);
+  float k = *(float*)(*args++);
+  float l = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+z;
+  fprintf(out,"float f(12*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void f_f13i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f13i) { fprintf(out,"wrong data for f_f13i\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float i = *(float*)(*args++);
+  float j = *(float*)(*args++);
+  float k = *(float*)(*args++);
+  float l = *(float*)(*args++);
+  float m = *(float*)(*args++);
+  int z = *(int*)(*args++);
+  float r=a+b+c+d+e+f+g+h+i+j+k+l+m+z;
+  fprintf(out,"float f(13*float,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,m,z);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void d_di_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_di) { fprintf(out,"wrong data for d_di\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+z;
+  fprintf(out,"double f(double,int):(%g,%d)",a,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d2i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d2i) { fprintf(out,"wrong data for d_d2i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+z;
+  fprintf(out,"double f(2*double,int):(%g,%g,%d)",a,b,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d3i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d3i) { fprintf(out,"wrong data for d_d3i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+z;
+  fprintf(out,"double f(3*double,int):(%g,%g,%g,%d)",a,b,c,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d4i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d4i) { fprintf(out,"wrong data for d_d4i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+d+z;
+  fprintf(out,"double f(4*double,int):(%g,%g,%g,%g,%d)",a,b,c,d,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d7i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d7i) { fprintf(out,"wrong data for d_d7i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+d+e+f+g+z;
+  fprintf(out,"double f(7*double,int):(%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d8i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d8i) { fprintf(out,"wrong data for d_d8i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+d+e+f+g+h+z;
+  fprintf(out,"double f(8*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d12i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d12i) { fprintf(out,"wrong data for d_d12i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  double i = *(double*)(*args++);
+  double j = *(double*)(*args++);
+  double k = *(double*)(*args++);
+  double l = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+d+e+f+g+h+i+j+k+l+z;
+  fprintf(out,"double f(12*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_d13i_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d13i) { fprintf(out,"wrong data for d_d13i\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  double i = *(double*)(*args++);
+  double j = *(double*)(*args++);
+  double k = *(double*)(*args++);
+  double l = *(double*)(*args++);
+  double m = *(double*)(*args++);
+  int z = *(int*)(*args++);
+  double r=a+b+c+d+e+f+g+h+i+j+k+l+m+z;
+  fprintf(out,"double f(13*double,int):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%d)",a,b,c,d,e,f,g,h,i,j,k,l,m,z);
+  fflush(out);
+  *(double*)retp = r;
+}}
+
+/* small structure return tests */
+void S1_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S1_v) { fprintf(out,"wrong data for S1_v\n"); exit(1); }
+ {Size1 r = Size1_1;
+  fprintf(out,"Size1 f(void):");
+  fflush(out);
+  *(Size1*)retp = r;
+}}
+void S2_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S2_v) { fprintf(out,"wrong data for S2_v\n"); exit(1); }
+ {Size2 r = Size2_1;
+  fprintf(out,"Size2 f(void):");
+  fflush(out);
+  *(Size2*)retp = r;
+}}
+void S3_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S3_v) { fprintf(out,"wrong data for S3_v\n"); exit(1); }
+ {Size3 r = Size3_1;
+  fprintf(out,"Size3 f(void):");
+  fflush(out);
+  *(Size3*)retp = r;
+}}
+void S4_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S4_v) { fprintf(out,"wrong data for S4_v\n"); exit(1); }
+ {Size4 r = Size4_1;
+  fprintf(out,"Size4 f(void):");
+  fflush(out);
+  *(Size4*)retp = r;
+}}
+void S7_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S7_v) { fprintf(out,"wrong data for S7_v\n"); exit(1); }
+ {Size7 r = Size7_1;
+  fprintf(out,"Size7 f(void):");
+  fflush(out);
+  *(Size7*)retp = r;
+}}
+void S8_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S8_v) { fprintf(out,"wrong data for S8_v\n"); exit(1); }
+ {Size8 r = Size8_1;
+  fprintf(out,"Size8 f(void):");
+  fflush(out);
+  *(Size8*)retp = r;
+}}
+void S12_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S12_v) { fprintf(out,"wrong data for S12_v\n"); exit(1); }
+ {Size12 r = Size12_1;
+  fprintf(out,"Size12 f(void):");
+  fflush(out);
+  *(Size12*)retp = r;
+}}
+void S15_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S15_v) { fprintf(out,"wrong data for S15_v\n"); exit(1); }
+ {Size15 r = Size15_1;
+  fprintf(out,"Size15 f(void):");
+  fflush(out);
+  *(Size15*)retp = r;
+}}
+void S16_v_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&S16_v) { fprintf(out,"wrong data for S16_v\n"); exit(1); }
+ {Size16 r = Size16_1;
+  fprintf(out,"Size16 f(void):");
+  fflush(out);
+  *(Size16*)retp = r;
+}}
+
+/* structure tests */
+void I_III_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&I_III) { fprintf(out,"wrong data for I_III\n"); exit(1); }
+ {Int a = *(Int*)(*args++);
+  Int b = *(Int*)(*args++);
+  Int c = *(Int*)(*args++);
+  Int r;
+  r.x = a.x + b.x + c.x;
+  fprintf(out,"Int f(Int,Int,Int):({%d},{%d},{%d})",a.x,b.x,c.x);
+  fflush(out);
+  *(Int*)retp = r;
+}}
+void C_CdC_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&C_CdC) { fprintf(out,"wrong data for C_CdC\n"); exit(1); }
+ {Char a = *(Char*)(*args++);
+  double b = *(double*)(*args++);
+  Char c = *(Char*)(*args++);
+  Char r;
+  r.x = (a.x + c.x)/2;
+  fprintf(out,"Char f(Char,double,Char):({'%c'},%g,{'%c'})",a.x,b,c.x);
+  fflush(out);
+  *(Char*)retp = r;
+}}
+void F_Ffd_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&F_Ffd) { fprintf(out,"wrong data for F_Ffd\n"); exit(1); }
+ {Float a = *(Float*)(*args++);
+  float b = *(float*)(*args++);
+  double c = *(double*)(*args++);
+  Float r;
+  r.x = a.x + b + c;
+  fprintf(out,"Float f(Float,float,double):({%g},%g,%g)",a.x,b,c);
+  fflush(out);
+  *(Float*)retp = r;
+}}
+void D_fDd_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&D_fDd) { fprintf(out,"wrong data for D_fDd\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  Double b = *(Double*)(*args++);
+  double c = *(double*)(*args++);
+  Double r;
+  r.x = a + b.x + c;
+  fprintf(out,"Double f(float,Double,double):(%g,{%g},%g)",a,b.x,c);
+  fflush(out);
+  *(Double*)retp = r;
+}}
+void D_Dfd_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&D_Dfd) { fprintf(out,"wrong data for D_Dfd\n"); exit(1); }
+ {Double a = *(Double*)(*args++);
+  float b = *(float*)(*args++);
+  double c = *(double*)(*args++);
+  Double r;
+  r.x = a.x + b + c;
+  fprintf(out,"Double f(Double,float,double):({%g},%g,%g)",a.x,b,c);
+  fflush(out);
+  *(Double*)retp = r;
+}}
+void J_JiJ_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&J_JiJ) { fprintf(out,"wrong data for J_JiJ\n"); exit(1); }
+ {J a = *(J*)(*args++);
+  int b= *(int*)(*args++);
+  J c = *(J*)(*args++);
+  J r;
+  r.l1 = a.l1+c.l1; r.l2 = a.l2+b+c.l2;
+  fprintf(out,"J f(J,int,J):({%ld,%ld},%d,{%ld,%ld})",a.l1,a.l2,b,c.l1,c.l2);
+  fflush(out);
+  *(J*)retp = r;
+}}
+#ifndef SKIP_EXTRA_STRUCTS
+void T_TcT_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&T_TcT) { fprintf(out,"wrong data for T_TcT\n"); exit(1); }
+ {T a = *(T*)(*args++);
+  char b = *(char*)(*args++);
+  T c = *(T*)(*args++);
+  T r;
+  r.c[0]='b'; r.c[1]=c.c[1]; r.c[2]=c.c[2];
+  fprintf(out,"T f(T,char,T):({\"%c%c%c\"},'%c',{\"%c%c%c\"})",a.c[0],a.c[1],a.c[2],b,c.c[0],c.c[1],c.c[2]);
+  fflush(out);
+  *(T*)retp = r;
+}}
+void X_BcdB_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&X_BcdB) { fprintf(out,"wrong data for X_BcdB\n"); exit(1); }
+ {B a = *(B*)(*args++);
+  char b = *(char*)(*args++);
+  double c = *(double*)(*args++);
+  B d = *(B*)(*args++);
+  static X xr={"return val",'R'};
+  X r;
+  r = xr;
+  r.c1 = b;
+  fprintf(out,"X f(B,char,double,B):({%g,{%d,%d,%d}},'%c',%g,{%g,{%d,%d,%d}})",
+          a.d,a.i[0],a.i[1],a.i[2],b,c,d.d,d.i[0],d.i[1],d.i[2]);
+  fflush(out);
+  *(X*)retp = r;
+}}
+#endif
+
+/* gpargs boundary tests */
+void l_l0K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l0K) { fprintf(out,"wrong data for l_l0K\n"); exit(1); }
+ {K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(K,long):(%ld,%ld,%ld,%ld,%ld)",b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l1K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l1K) { fprintf(out,"wrong data for l_l1K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld)",a1,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l2K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l2K) { fprintf(out,"wrong data for l_l2K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + a2 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(2*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l3K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l3K) { fprintf(out,"wrong data for l_l3K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + a2 + a3 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(3*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l4K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l4K) { fprintf(out,"wrong data for l_l4K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + a2 + a3 + a4 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(4*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l5K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l5K) { fprintf(out,"wrong data for l_l5K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + a2 + a3 + a4 + a5 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(5*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,a5,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void l_l6K_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&l_l6K) { fprintf(out,"wrong data for l_l6K\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long a6 = *(long*)(*args++);
+  K b = *(K*)(*args++);
+  long c = *(long*)(*args++);
+  long r = a1 + a2 + a3 + a4 + a5 + a6 + b.l1 + b.l2 + b.l3 + b.l4 + c;
+  fprintf(out,"long f(6*long,K,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a1,a2,a3,a4,a5,a6,b.l1,b.l2,b.l3,b.l4,c);
+  fflush(out);
+  *(ffi_arg*)retp = r;
+}}
+void f_f17l3L_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&f_f17l3L) { fprintf(out,"wrong data for f_f17l3L\n"); exit(1); }
+ {float a = *(float*)(*args++);
+  float b = *(float*)(*args++);
+  float c = *(float*)(*args++);
+  float d = *(float*)(*args++);
+  float e = *(float*)(*args++);
+  float f = *(float*)(*args++);
+  float g = *(float*)(*args++);
+  float h = *(float*)(*args++);
+  float i = *(float*)(*args++);
+  float j = *(float*)(*args++);
+  float k = *(float*)(*args++);
+  float l = *(float*)(*args++);
+  float m = *(float*)(*args++);
+  float n = *(float*)(*args++);
+  float o = *(float*)(*args++);
+  float p = *(float*)(*args++);
+  float q = *(float*)(*args++);
+  long s = *(long*)(*args++);
+  long t = *(long*)(*args++);
+  long u = *(long*)(*args++);
+  L z = *(L*)(*args++);
+  float r = a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+z.l1+z.l2+z.l3+z.l4+z.l5+z.l6;
+  fprintf(out,"float f(17*float,3*int,L):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,z.l1,z.l2,z.l3,z.l4,z.l5,z.l6);
+  fflush(out);
+  *(float*)retp = r;
+}}
+void d_d17l3L_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_d17l3L) { fprintf(out,"wrong data for d_d17l3L\n"); exit(1); }
+ {double a = *(double*)(*args++);
+  double b = *(double*)(*args++);
+  double c = *(double*)(*args++);
+  double d = *(double*)(*args++);
+  double e = *(double*)(*args++);
+  double f = *(double*)(*args++);
+  double g = *(double*)(*args++);
+  double h = *(double*)(*args++);
+  double i = *(double*)(*args++);
+  double j = *(double*)(*args++);
+  double k = *(double*)(*args++);
+  double l = *(double*)(*args++);
+  double m = *(double*)(*args++);
+  double n = *(double*)(*args++);
+  double o = *(double*)(*args++);
+  double p = *(double*)(*args++);
+  double q = *(double*)(*args++);
+  long s = *(long*)(*args++);
+  long t = *(long*)(*args++);
+  long u = *(long*)(*args++);
+  L z = *(L*)(*args++);
+  double r = a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+s+t+u+z.l1+z.l2+z.l3+z.l4+z.l5+z.l6;
+  fprintf(out,"double f(17*double,3*int,L):(%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld,%ld)",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,z.l1,z.l2,z.l3,z.l4,z.l5,z.l6);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void ll_l2ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l2ll) { fprintf(out,"wrong data for ll_l2ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2) + b + c;
+  fprintf(out,"long long f(2*long,long long,long):(%ld,%ld,0x%lx%08lx,%ld)",a1,a2,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_l3ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l3ll) { fprintf(out,"wrong data for ll_l3ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2 + a3) + b + c;
+  fprintf(out,"long long f(3*long,long long,long):(%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_l4ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l4ll) { fprintf(out,"wrong data for ll_l4ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2 + a3 + a4) + b + c;
+  fprintf(out,"long long f(4*long,long long,long):(%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_l5ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l5ll) { fprintf(out,"wrong data for ll_l5ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5) + b + c;
+  fprintf(out,"long long f(5*long,long long,long):(%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_l6ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l6ll) { fprintf(out,"wrong data for ll_l6ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long a6 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5 + a6) + b + c;
+  fprintf(out,"long long f(6*long,long long,long):(%ld,%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,a6,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void ll_l7ll_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&ll_l7ll) { fprintf(out,"wrong data for ll_l7ll\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long a6 = *(long*)(*args++);
+  long a7 = *(long*)(*args++);
+  long long b = *(long long *)(*args++);
+  long c = *(long*)(*args++);
+  long long r = (long long) (a1 + a2 + a3 + a4 + a5 + a6 + a7) + b + c;
+  fprintf(out,"long long f(7*long,long long,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,0x%lx%08lx,%ld)",a1,a2,a3,a4,a5,a6,a7,(long)(b>>32),(long)(b&0xffffffff),c);
+  fflush(out);
+  *(long long *)retp = r;
+}}
+void d_l2d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l2d) { fprintf(out,"wrong data for d_l2d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2) + b + c;
+  fprintf(out,"double f(2*long,double,long):(%ld,%ld,%g,%ld)",a1,a2,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_l3d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l3d) { fprintf(out,"wrong data for d_l3d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2 + a3) + b + c;
+  fprintf(out,"double f(3*long,double,long):(%ld,%ld,%ld,%g,%ld)",a1,a2,a3,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_l4d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l4d) { fprintf(out,"wrong data for d_l4d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2 + a3 + a4) + b + c;
+  fprintf(out,"double f(4*long,double,long):(%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_l5d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l5d) { fprintf(out,"wrong data for d_l5d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2 + a3 + a4 + a5) + b + c;
+  fprintf(out,"double f(5*long,double,long):(%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_l6d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l6d) { fprintf(out,"wrong data for d_l6d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long a6 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2 + a3 + a4 + a5 + a6) + b + c;
+  fprintf(out,"double f(6*long,double,long):(%ld,%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,a6,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+void d_l7d_simulator (ffi_cif* cif, void* retp, /*const*/ void* /*const*/ *args, void* data)
+{
+  if (data != (void*)&d_l7d) { fprintf(out,"wrong data for d_l7d\n"); exit(1); }
+ {long a1 = *(long*)(*args++);
+  long a2 = *(long*)(*args++);
+  long a3 = *(long*)(*args++);
+  long a4 = *(long*)(*args++);
+  long a5 = *(long*)(*args++);
+  long a6 = *(long*)(*args++);
+  long a7 = *(long*)(*args++);
+  double b = *(double*)(*args++);
+  long c = *(long*)(*args++);
+  double r = (double) (a1 + a2 + a3 + a4 + a5 + a6 + a7) + b + c;
+  fprintf(out,"double f(7*long,double,long):(%ld,%ld,%ld,%ld,%ld,%ld,%ld,%g,%ld)",a1,a2,a3,a4,a5,a6,a7,b,c);
+  fflush(out);
+  *(double*)retp = r;
+}}
+
+
+/*
+ * The way we run these tests - first call the function directly, then
+ * through vacall() - there is the danger that arguments or results seem
+ * to be passed correctly, but what we are seeing are in fact the vestiges
+ * (traces) or the previous call. This may seriously fake the test.
+ * Avoid this by clearing the registers between the first and the second call.
+ */
+long clear_traces_i (long a, long b, long c, long d, long e, long f, long g, long h,
+                     long i, long j, long k, long l, long m, long n, long o, long p)
+{ return 0; }
+float clear_traces_f (float a, float b, float c, float d, float e, float f, float g,
+                      float h, float i, float j, float k, float l, float m, float n,
+                      float o, float p)
+{ return 0.0; }
+double clear_traces_d (double a, double b, double c, double d, double e, double f, double g,
+                       double h, double i, double j, double k, double l, double m, double n,
+                       double o, double p)
+{ return 0.0; }
+J clear_traces_J (void)
+{ J j; j.l1 = j.l2 = 0; return j; }
+void clear_traces (void)
+{ clear_traces_i(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
+  clear_traces_f(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
+  clear_traces_d(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
+  clear_traces_J();
+}
+
+int main (void)
+{
+  void* callback_code;
+  void* callback_writable;
+#define ALLOC_CALLBACK() \
+  callback_writable = ffi_closure_alloc(sizeof(ffi_closure),&callback_code); \
+  if (!callback_writable) abort()
+#define PREP_CALLBACK(cif,simulator,data) \
+  if (ffi_prep_closure_loc(callback_writable,&(cif),simulator,data,callback_code) != FFI_OK) abort()
+#define FREE_CALLBACK() \
+  ffi_closure_free(callback_writable)
+
+  ffi_type_char = (char)(-1) < 0 ? ffi_type_schar : ffi_type_uchar;
+  out = stdout;
+
+#if (!defined(DGTEST)) || DGTEST == 1  
+  /* void tests */
+  v_v();
+  clear_traces();
+  ALLOC_CALLBACK();
+  {
+    ffi_cif cif;
+    FFI_PREP_CIF_NOARGS(cif,ffi_type_void);
+    PREP_CALLBACK(cif,v_v_simulator,(void*)&v_v);
+    ((void (ABI_ATTR *) (void)) callback_code) ();
+  }
+  FREE_CALLBACK();
+#endif
+
+  /* int tests */
+  { int ir;
+
+#if (!defined(DGTEST)) || DGTEST == 2
+    ir = i_v();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_sint);
+      PREP_CALLBACK(cif,i_v_simulator,(void*)&i_v);
+      ir = ((int (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif    
+
+#if (!defined(DGTEST)) || DGTEST == 3
+    ir = i_i(i1);
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+      PREP_CALLBACK(cif,i_i_simulator,(void*)&i_i);
+      ir = ((int (ABI_ATTR *) (int)) callback_code) (i1);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 4    
+    ir = i_i2(i1,i2);
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+      PREP_CALLBACK(cif,i_i2_simulator,(void*)&i_i2);
+      ir = ((int (ABI_ATTR *) (int,int)) callback_code) (i1,i2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 5    
+    ir = i_i4(i1,i2,i3,i4);
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+      PREP_CALLBACK(cif,i_i4_simulator,(void*)&i_i4);
+      ir = ((int (ABI_ATTR *) (int,int,int,int)) callback_code) (i1,i2,i3,i4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 6    
+    ir = i_i8(i1,i2,i3,i4,i5,i6,i7,i8);
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+      PREP_CALLBACK(cif,i_i8_simulator,(void*)&i_i8);
+      ir = ((int (ABI_ATTR *) (int,int,int,int,int,int,int,int)) callback_code) (i1,i2,i3,i4,i5,i6,i7,i8);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif
+  
+#if (!defined(DGTEST)) || DGTEST == 7
+    ir = i_i16(i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15,i16);
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+    ir = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_sint);
+      PREP_CALLBACK(cif,i_i16_simulator,(void*)&i_i16);
+      ir = ((int (ABI_ATTR *) (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)) callback_code) (i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15,i16);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%d\n",ir);
+    fflush(out);
+#endif
+  }
+
+  /* float tests */
+  { float fr;
+
+#if (!defined(DGTEST)) || DGTEST == 8  
+    fr = f_f(f1);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f_simulator,(void*)&f_f);
+      fr = ((float (ABI_ATTR *) (float)) callback_code) (f1);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 9    
+    fr = f_f2(f1,f2);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f2_simulator,(void*)&f_f2);
+      fr = ((float (ABI_ATTR *) (float,float)) callback_code) (f1,f2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 10
+    fr = f_f4(f1,f2,f3,f4);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f4_simulator,(void*)&f_f4);
+      fr = ((float (ABI_ATTR *) (float,float,float,float)) callback_code) (f1,f2,f3,f4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 11    
+    fr = f_f8(f1,f2,f3,f4,f5,f6,f7,f8);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f8_simulator,(void*)&f_f8);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 12    
+    fr = f_f16(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f16_simulator,(void*)&f_f16);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 13    
+    fr = f_f24(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f24_simulator,(void*)&f_f24);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+  }
+
+  /* double tests */
+  { double dr;
+
+#if (!defined(DGTEST)) || DGTEST == 14
+    dr = d_d(d1);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d_simulator,(void*)&d_d);
+      dr = ((double (ABI_ATTR *) (double)) callback_code) (d1);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 15    
+    dr = d_d2(d1,d2);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d2_simulator,(void*)&d_d2);
+      dr = ((double (ABI_ATTR *) (double,double)) callback_code) (d1,d2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+  
+#if (!defined(DGTEST)) || DGTEST == 16    
+    dr = d_d4(d1,d2,d3,d4);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d4_simulator,(void*)&d_d4);
+      dr = ((double (ABI_ATTR *) (double,double,double,double)) callback_code) (d1,d2,d3,d4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 17    
+    dr = d_d8(d1,d2,d3,d4,d5,d6,d7,d8);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d8_simulator,(void*)&d_d8);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 18    
+    dr = d_d16(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d16_simulator,(void*)&d_d16);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+  }
+
+  /* pointer tests */
+  { void* vpr;
+
+#if (!defined(DGTEST)) || DGTEST == 19 
+    vpr = vp_vpdpcpsp(&uc1,&d2,str3,&I4);
+    fprintf(out,"->0x%p\n",vpr);
+    fflush(out);
+    vpr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_pointer, &ffi_type_pointer, &ffi_type_pointer, &ffi_type_pointer };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_pointer);
+      PREP_CALLBACK(cif,vp_vpdpcpsp_simulator,(void*)&vp_vpdpcpsp);
+      vpr = ((void* (ABI_ATTR *) (void*,double*,char*,Int*)) callback_code) (&uc1,&d2,str3,&I4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%p\n",vpr);
+    fflush(out);
+#endif
+  }
+
+  /* mixed number tests */
+  { uchar ucr;
+    ushort usr;
+    float fr;
+    double dr;
+    long long llr;
+
+#if (!defined(DGTEST)) || DGTEST == 20
+    ucr = uc_ucsil(uc1,us2,ui3,ul4);
+    fprintf(out,"->%u\n",ucr);
+    fflush(out);
+    ucr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_uchar, &ffi_type_ushort, &ffi_type_uint, &ffi_type_ulong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_uchar);
+      PREP_CALLBACK(cif,uc_ucsil_simulator,(void*)&uc_ucsil);
+      ucr = ((uchar (ABI_ATTR *) (uchar,ushort,uint,ulong)) callback_code) (uc1,us2,ui3,ul4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%u\n",ucr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 21    
+    dr = d_iidd(i1,i2,d3,d4);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_iidd_simulator,(void*)&d_iidd);
+      dr = ((double (ABI_ATTR *) (int,int,double,double)) callback_code) (i1,i2,d3,d4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 22    
+    dr = d_iiidi(i1,i2,i3,d4,i5);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_iiidi_simulator,(void*)&d_iiidi);
+      dr = ((double (ABI_ATTR *) (int,int,int,double,int)) callback_code) (i1,i2,i3,d4,i5);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 23    
+    dr = d_idid(i1,d2,i3,d4);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_double, &ffi_type_sint, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_idid_simulator,(void*)&d_idid);
+      dr = ((double (ABI_ATTR *) (int,double,int,double)) callback_code) (i1,d2,i3,d4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 24    
+    dr = d_fdi(f1,d2,i3);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_fdi_simulator,(void*)&d_fdi);
+      dr = ((double (ABI_ATTR *) (float,double,int)) callback_code) (f1,d2,i3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 25    
+    usr = us_cdcd(c1,d2,c3,d4);
+    fprintf(out,"->%u\n",usr);
+    fflush(out);
+    usr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_char, &ffi_type_double, &ffi_type_char, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_ushort);
+      PREP_CALLBACK(cif,us_cdcd_simulator,(void*)&us_cdcd);
+      usr = ((ushort (ABI_ATTR *) (char,double,char,double)) callback_code) (c1,d2,c3,d4);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%u\n",usr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 26    
+    llr = ll_iiilli(i1,i2,i3,ll1,i13);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_sint, &ffi_type_sint, &ffi_type_sint, &ffi_type_slonglong, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_iiilli_simulator,(void*)&ll_iiilli);
+      llr = ((long long (ABI_ATTR *) (int,int,int,long long,int)) callback_code) (i1,i2,i3,ll1,i13);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 27    
+    llr = ll_flli(f13,ll1,i13);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_slonglong, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_flli_simulator,(void*)&ll_flli);
+      llr = ((long long (ABI_ATTR *) (float,long long,int)) callback_code) (f13,ll1,i13);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 28    
+    fr = f_fi(f1,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_fi_simulator,(void*)&f_fi);
+      fr = ((float (ABI_ATTR *) (float,int)) callback_code) (f1,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 29    
+    fr = f_f2i(f1,f2,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f2i_simulator,(void*)&f_f2i);
+      fr = ((float (ABI_ATTR *) (float,float,int)) callback_code) (f1,f2,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 30    
+    fr = f_f3i(f1,f2,f3,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f3i_simulator,(void*)&f_f3i);
+      fr = ((float (ABI_ATTR *) (float,float,float,int)) callback_code) (f1,f2,f3,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 31    
+    fr = f_f4i(f1,f2,f3,f4,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f4i_simulator,(void*)&f_f4i);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,int)) callback_code) (f1,f2,f3,f4,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 32    
+    fr = f_f7i(f1,f2,f3,f4,f5,f6,f7,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f7i_simulator,(void*)&f_f7i);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,int)) callback_code) (f1,f2,f3,f4,f5,f6,f7,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 33    
+    fr = f_f8i(f1,f2,f3,f4,f5,f6,f7,f8,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f8i_simulator,(void*)&f_f8i);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float,int)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 34    
+    fr = f_f13i(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,i9);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f13i_simulator,(void*)&f_f13i);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float,float,float,float,float,float,int)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 35    
+    dr = d_di(d1,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_di_simulator,(void*)&d_di);
+      dr = ((double (ABI_ATTR *) (double,int)) callback_code) (d1,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 36    
+    dr = d_d2i(d1,d2,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d2i_simulator,(void*)&d_d2i);
+      dr = ((double (ABI_ATTR *) (double,double,int)) callback_code) (d1,d2,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 37    
+    dr = d_d3i(d1,d2,d3,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d3i_simulator,(void*)&d_d3i);
+      dr = ((double (ABI_ATTR *) (double,double,double,int)) callback_code) (d1,d2,d3,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 38    
+    dr = d_d4i(d1,d2,d3,d4,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d4i_simulator,(void*)&d_d4i);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,int)) callback_code) (d1,d2,d3,d4,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 39    
+    dr = d_d7i(d1,d2,d3,d4,d5,d6,d7,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d7i_simulator,(void*)&d_d7i);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,int)) callback_code) (d1,d2,d3,d4,d5,d6,d7,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 40    
+    dr = d_d8i(d1,d2,d3,d4,d5,d6,d7,d8,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d8i_simulator,(void*)&d_d8i);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double,int)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 41    
+    dr = d_d12i(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d12i_simulator,(void*)&d_d12i);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double,double,double,double,double,int)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 42    
+    dr = d_d13i(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,i9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_sint };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d13i_simulator,(void*)&d_d13i);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double,double,double,double,double,double,int)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,i9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+  }
+
+  /* small structure return tests */
+#if (!defined(DGTEST)) || DGTEST == 43
+  {
+    Size1 r = S1_v();
+    fprintf(out,"->{%c}\n",r.x1);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size1_elements[] = { &ffi_type_char, NULL };
+      ffi_type ffi_type_Size1;
+      ffi_type_Size1.type = FFI_TYPE_STRUCT;
+      ffi_type_Size1.size = sizeof(Size1);
+      ffi_type_Size1.alignment = alignof_slot(Size1);
+      ffi_type_Size1.elements = ffi_type_Size1_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size1);
+      PREP_CALLBACK(cif,S1_v_simulator,(void*)&S1_v);
+      r = ((Size1 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c}\n",r.x1);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 44
+  {
+    Size2 r = S2_v();
+    fprintf(out,"->{%c%c}\n",r.x1,r.x2);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size2_elements[] = { &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size2;
+      ffi_type_Size2.type = FFI_TYPE_STRUCT;
+      ffi_type_Size2.size = sizeof(Size2);
+      ffi_type_Size2.alignment = alignof_slot(Size2);
+      ffi_type_Size2.elements = ffi_type_Size2_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size2);
+      PREP_CALLBACK(cif,S2_v_simulator,(void*)&S2_v);
+      r = ((Size2 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c}\n",r.x1,r.x2);
+    fflush(out);
+  }
+#endif    
+
+#if (!defined(DGTEST)) || DGTEST == 45
+  {
+    Size3 r = S3_v();
+    fprintf(out,"->{%c%c%c}\n",r.x1,r.x2,r.x3);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size3_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size3;
+      ffi_type_Size3.type = FFI_TYPE_STRUCT;
+      ffi_type_Size3.size = sizeof(Size3);
+      ffi_type_Size3.alignment = alignof_slot(Size3);
+      ffi_type_Size3.elements = ffi_type_Size3_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size3);
+      PREP_CALLBACK(cif,S3_v_simulator,(void*)&S3_v);
+      r = ((Size3 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c}\n",r.x1,r.x2,r.x3);
+    fflush(out);
+  }
+#endif    
+
+#if (!defined(DGTEST)) || DGTEST == 46
+  {
+    Size4 r = S4_v();
+    fprintf(out,"->{%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size4_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size4;
+      ffi_type_Size4.type = FFI_TYPE_STRUCT;
+      ffi_type_Size4.size = sizeof(Size4);
+      ffi_type_Size4.alignment = alignof_slot(Size4);
+      ffi_type_Size4.elements = ffi_type_Size4_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size4);
+      PREP_CALLBACK(cif,S4_v_simulator,(void*)&S4_v);
+      r = ((Size4 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 47  
+  {
+    Size7 r = S7_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size7_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size7;
+      ffi_type_Size7.type = FFI_TYPE_STRUCT;
+      ffi_type_Size7.size = sizeof(Size7);
+      ffi_type_Size7.alignment = alignof_slot(Size7);
+      ffi_type_Size7.elements = ffi_type_Size7_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size7);
+      PREP_CALLBACK(cif,S7_v_simulator,(void*)&S7_v);
+      r = ((Size7 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 48  
+  {
+    Size8 r = S8_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size8_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size8;
+      ffi_type_Size8.type = FFI_TYPE_STRUCT;
+      ffi_type_Size8.size = sizeof(Size8);
+      ffi_type_Size8.alignment = alignof_slot(Size8);
+      ffi_type_Size8.elements = ffi_type_Size8_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size8);
+      PREP_CALLBACK(cif,S8_v_simulator,(void*)&S8_v);
+      r = ((Size8 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 49
+  {
+    Size12 r = S12_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size12_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size12;
+      ffi_type_Size12.type = FFI_TYPE_STRUCT;
+      ffi_type_Size12.size = sizeof(Size12);
+      ffi_type_Size12.alignment = alignof_slot(Size12);
+      ffi_type_Size12.elements = ffi_type_Size12_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size12);
+      PREP_CALLBACK(cif,S12_v_simulator,(void*)&S12_v);
+      r = ((Size12 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 50  
+  {
+    Size15 r = S15_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size15_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size15;
+      ffi_type_Size15.type = FFI_TYPE_STRUCT;
+      ffi_type_Size15.size = sizeof(Size15);
+      ffi_type_Size15.alignment = alignof_slot(Size15);
+      ffi_type_Size15.elements = ffi_type_Size15_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size15);
+      PREP_CALLBACK(cif,S15_v_simulator,(void*)&S15_v);
+      r = ((Size15 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15);
+    fflush(out);
+  }
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 51
+  {
+    Size16 r = S16_v();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15,r.x16);
+    fflush(out);
+    memset(&r,0,sizeof(r)); clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Size16_elements[] = { &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, &ffi_type_char, NULL };
+      ffi_type ffi_type_Size16;
+      ffi_type_Size16.type = FFI_TYPE_STRUCT;
+      ffi_type_Size16.size = sizeof(Size16);
+      ffi_type_Size16.alignment = alignof_slot(Size16);
+      ffi_type_Size16.elements = ffi_type_Size16_elements;
+      ffi_cif cif;
+      FFI_PREP_CIF_NOARGS(cif,ffi_type_Size16);
+      PREP_CALLBACK(cif,S16_v_simulator,(void*)&S16_v);
+      r = ((Size16 (ABI_ATTR *) (void)) callback_code) ();
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c}\n",r.x1,r.x2,r.x3,r.x4,r.x5,r.x6,r.x7,r.x8,r.x9,r.x10,r.x11,r.x12,r.x13,r.x14,r.x15,r.x16);
+    fflush(out);
+  }
+#endif
+
+  
+  /* structure tests */
+  { Int Ir;
+    Char Cr;
+    Float Fr;
+    Double Dr;
+    J Jr;
+#ifndef SKIP_EXTRA_STRUCTS
+    T Tr;
+    X Xr;
+#endif    
+
+#if (!defined(DGTEST)) || DGTEST == 52
+    Ir = I_III(I1,I2,I3);
+    fprintf(out,"->{%d}\n",Ir.x);
+    fflush(out);
+    Ir.x = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Int_elements[] = { &ffi_type_sint, NULL };
+      ffi_type ffi_type_Int;
+      ffi_type_Int.type = FFI_TYPE_STRUCT;
+      ffi_type_Int.size = sizeof(Int);
+      ffi_type_Int.alignment = alignof_slot(Int);
+      ffi_type_Int.elements = ffi_type_Int_elements;
+      ffi_type* argtypes[] = { &ffi_type_Int, &ffi_type_Int, &ffi_type_Int };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_Int);
+      PREP_CALLBACK(cif,I_III_simulator,(void*)&I_III);
+      Ir = ((Int (ABI_ATTR *) (Int,Int,Int)) callback_code) (I1,I2,I3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%d}\n",Ir.x);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 53
+    Cr = C_CdC(C1,d2,C3);
+    fprintf(out,"->{'%c'}\n",Cr.x);
+    fflush(out);
+    Cr.x = '\0'; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Char_elements[] = { &ffi_type_char, NULL };
+      ffi_type ffi_type_Char;
+      ffi_type_Char.type = FFI_TYPE_STRUCT;
+      ffi_type_Char.size = sizeof(Char);
+      ffi_type_Char.alignment = alignof_slot(Char);
+      ffi_type_Char.elements = ffi_type_Char_elements;
+      ffi_type* argtypes[] = { &ffi_type_Char, &ffi_type_double, &ffi_type_Char };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_Char);
+      PREP_CALLBACK(cif,C_CdC_simulator,(void*)&C_CdC);
+      Cr = ((Char (ABI_ATTR *) (Char,double,Char)) callback_code) (C1,d2,C3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{'%c'}\n",Cr.x);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 54    
+    Fr = F_Ffd(F1,f2,d3);
+    fprintf(out,"->{%g}\n",Fr.x);
+    fflush(out);
+    Fr.x = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Float_elements[] = { &ffi_type_float, NULL };
+      ffi_type ffi_type_Float;
+      ffi_type_Float.type = FFI_TYPE_STRUCT;
+      ffi_type_Float.size = sizeof(Float);
+      ffi_type_Float.alignment = alignof_slot(Float);
+      ffi_type_Float.elements = ffi_type_Float_elements;
+      ffi_type* argtypes[] = { &ffi_type_Float, &ffi_type_float, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_Float);
+      PREP_CALLBACK(cif,F_Ffd_simulator,(void*)&F_Ffd);
+      Fr = ((Float (ABI_ATTR *) (Float,float,double)) callback_code) (F1,f2,d3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%g}\n",Fr.x);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 55    
+    Dr = D_fDd(f1,D2,d3);
+    fprintf(out,"->{%g}\n",Dr.x);
+    fflush(out);
+    Dr.x = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Double_elements[] = { &ffi_type_double, NULL };
+      ffi_type ffi_type_Double;
+      ffi_type_Double.type = FFI_TYPE_STRUCT;
+      ffi_type_Double.size = sizeof(Double);
+      ffi_type_Double.alignment = alignof_slot(Double);
+      ffi_type_Double.elements = ffi_type_Double_elements;
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_Double, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_Double);
+      PREP_CALLBACK(cif,D_fDd_simulator,(void*)&D_fDd);
+      Dr = ((Double (ABI_ATTR *) (float,Double,double)) callback_code) (f1,D2,d3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%g}\n",Dr.x);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 56
+    Dr = D_Dfd(D1,f2,d3);
+    fprintf(out,"->{%g}\n",Dr.x);
+    fflush(out);
+    Dr.x = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_Double_elements[] = { &ffi_type_double, NULL };
+      ffi_type ffi_type_Double;
+      ffi_type_Double.type = FFI_TYPE_STRUCT;
+      ffi_type_Double.size = sizeof(Double);
+      ffi_type_Double.alignment = alignof_slot(Double);
+      ffi_type_Double.elements = ffi_type_Double_elements;
+      ffi_type* argtypes[] = { &ffi_type_Double, &ffi_type_float, &ffi_type_double };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_Double);
+      PREP_CALLBACK(cif,D_Dfd_simulator,(void*)&D_Dfd);
+      Dr = ((Double (ABI_ATTR *) (Double,float,double)) callback_code) (D1,f2,d3);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%g}\n",Dr.x);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 57
+    Jr = J_JiJ(J1,i2,J2);
+    fprintf(out,"->{%ld,%ld}\n",Jr.l1,Jr.l2);
+    fflush(out);
+    Jr.l1 = Jr.l2 = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_J_elements[] = { &ffi_type_slong, &ffi_type_slong, NULL };
+      ffi_type ffi_type_J;
+      ffi_type_J.type = FFI_TYPE_STRUCT;
+      ffi_type_J.size = sizeof(J);
+      ffi_type_J.alignment = alignof_slot(J);
+      ffi_type_J.elements = ffi_type_J_elements;
+      ffi_type* argtypes[] = { &ffi_type_J, &ffi_type_sint, &ffi_type_J };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_J);
+      PREP_CALLBACK(cif,J_JiJ_simulator,(void*)&J_JiJ);
+      Jr = ((J (ABI_ATTR *) (J,int,J)) callback_code) (J1,i2,J2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{%ld,%ld}\n",Jr.l1,Jr.l2);
+    fflush(out);
+#endif
+
+#ifndef SKIP_EXTRA_STRUCTS
+#if (!defined(DGTEST)) || DGTEST == 58
+    Tr = T_TcT(T1,' ',T2);
+    fprintf(out,"->{\"%c%c%c\"}\n",Tr.c[0],Tr.c[1],Tr.c[2]);
+    fflush(out);
+    Tr.c[0] = Tr.c[1] = Tr.c[2] = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_T_elements[] = { ??, NULL };
+      ffi_type ffi_type_T;
+      ffi_type_T.type = FFI_TYPE_STRUCT;
+      ffi_type_T.size = sizeof(T);
+      ffi_type_T.alignment = alignof_slot(T);
+      ffi_type_T.elements = ffi_type_T_elements;
+      ffi_type* argtypes[] = { &ffi_type_T, &ffi_type_char, &ffi_type_T };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_T);
+      PREP_CALLBACK(cif,T_TcT_simulator,(void*)&T_TcT);
+      Tr = ((T (ABI_ATTR *) (T,char,T)) callback_code) (T1,' ',T2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{\"%c%c%c\"}\n",Tr.c[0],Tr.c[1],Tr.c[2]);
+    fflush(out);
+#endif
+
+#ifndef SKIP_X
+#if (!defined(DGTEST)) || DGTEST == 59
+    Xr = X_BcdB(B1,c2,d3,B2);
+    fprintf(out,"->{\"%s\",'%c'}\n",Xr.c,Xr.c1);
+    fflush(out);
+    Xr.c[0]=Xr.c1='\0'; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* ffi_type_X_elements[] = { ??, NULL };
+      ffi_type ffi_type_X;
+      ffi_type_X.type = FFI_TYPE_STRUCT;
+      ffi_type_X.size = sizeof(X);
+      ffi_type_X.alignment = alignof_slot(X);
+      ffi_type_X.elements = ffi_type_X_elements;
+      ffi_type* argtypes[] = { &ffi_type_X, &ffi_type_char, &ffi_type_double, &ffi_type_X };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_X);
+      PREP_CALLBACK(cif,X_BcdB_simulator,(void*)&X_BcdB);
+      Xr = ((X (ABI_ATTR *) (B,char,double,B)) callback_code) (B1,c2,d3,B2);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->{\"%s\",'%c'}\n",Xr.c,Xr.c1);
+    fflush(out);
+#endif
+#endif
+#endif
+  }
+
+  
+  /* gpargs boundary tests */
+  {
+    ffi_type* ffi_type_K_elements[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, NULL };
+    ffi_type ffi_type_K;
+    ffi_type* ffi_type_L_elements[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, NULL };
+    ffi_type ffi_type_L;
+    long lr;
+    long long llr;
+    float fr;
+    double dr;
+
+    ffi_type_K.type = FFI_TYPE_STRUCT;
+    ffi_type_K.size = sizeof(K);
+    ffi_type_K.alignment = alignof_slot(K);
+    ffi_type_K.elements = ffi_type_K_elements;
+
+    ffi_type_L.type = FFI_TYPE_STRUCT;
+    ffi_type_L.size = sizeof(L);
+    ffi_type_L.alignment = alignof_slot(L);
+    ffi_type_L.elements = ffi_type_L_elements;
+
+#if (!defined(DGTEST)) || DGTEST == 60
+    lr = l_l0K(K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l0K_simulator,(void*)l_l0K);
+      lr = ((long (ABI_ATTR *) (K,long)) callback_code) (K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 61
+    lr = l_l1K(l1,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l1K_simulator,(void*)l_l1K);
+      lr = ((long (ABI_ATTR *) (long,K,long)) callback_code) (l1,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 62
+    lr = l_l2K(l1,l2,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l2K_simulator,(void*)l_l2K);
+      lr = ((long (ABI_ATTR *) (long,long,K,long)) callback_code) (l1,l2,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 63
+    lr = l_l3K(l1,l2,l3,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l3K_simulator,(void*)l_l3K);
+      lr = ((long (ABI_ATTR *) (long,long,long,K,long)) callback_code) (l1,l2,l3,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 64
+    lr = l_l4K(l1,l2,l3,l4,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l4K_simulator,(void*)l_l4K);
+      lr = ((long (ABI_ATTR *) (long,long,long,long,K,long)) callback_code) (l1,l2,l3,l4,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 65  
+    lr = l_l5K(l1,l2,l3,l4,l5,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l5K_simulator,(void*)l_l5K);
+      lr = ((long (ABI_ATTR *) (long,long,long,long,long,K,long)) callback_code) (l1,l2,l3,l4,l5,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 66
+    lr = l_l6K(l1,l2,l3,l4,l5,l6,K1,l9);
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+    lr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_K, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slong);
+      PREP_CALLBACK(cif,l_l6K_simulator,(void*)l_l6K);
+      lr = ((long (ABI_ATTR *) (long,long,long,long,long,long,K,long)) callback_code) (l1,l2,l3,l4,l5,l6,K1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%ld\n",lr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 67    
+    fr = f_f17l3L(f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,l6,l7,l8,L1);
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+    fr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_float, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_L };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_float);
+      PREP_CALLBACK(cif,f_f17l3L_simulator,(void*)&f_f17l3L);
+      fr = ((float (ABI_ATTR *) (float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,long,long,long,L)) callback_code) (f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,l6,l7,l8,L1);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",fr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 68    
+    dr = d_d17l3L(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,d17,l6,l7,l8,L1);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_double, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_L };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_d17l3L_simulator,(void*)&d_d17l3L);
+      dr = ((double (ABI_ATTR *) (double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,long,long,long,L)) callback_code) (d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,d17,l6,l7,l8,L1);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 69    
+    llr = ll_l2ll(l1,l2,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l2ll_simulator,(void*)ll_l2ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long long,long)) callback_code) (l1,l2,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 70
+    llr = ll_l3ll(l1,l2,l3,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l3ll_simulator,(void*)ll_l3ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long,long long,long)) callback_code) (l1,l2,l3,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 71    
+    llr = ll_l4ll(l1,l2,l3,l4,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l4ll_simulator,(void*)ll_l4ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long,long,long long,long)) callback_code) (l1,l2,l3,l4,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 72    
+    llr = ll_l5ll(l1,l2,l3,l4,l5,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l5ll_simulator,(void*)ll_l5ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long,long,long,long long,long)) callback_code) (l1,l2,l3,l4,l5,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 73    
+    llr = ll_l6ll(l1,l2,l3,l4,l5,l6,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l6ll_simulator,(void*)ll_l6ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long,long,long,long,long long,long)) callback_code) (l1,l2,l3,l4,l5,l6,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 74    
+    llr = ll_l7ll(l1,l2,l3,l4,l5,l6,l7,ll1,l9);
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+    llr = 0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slonglong, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_slonglong);
+      PREP_CALLBACK(cif,ll_l7ll_simulator,(void*)ll_l7ll);
+      llr = ((long long (ABI_ATTR *) (long,long,long,long,long,long,long,long long,long)) callback_code) (l1,l2,l3,l4,l5,l6,l7,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->0x%lx%08lx\n",(long)(llr>>32),(long)(llr&0xffffffff));
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 75    
+    dr = d_l2d(l1,l2,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l2d_simulator,(void*)d_l2d);
+      dr = ((double (ABI_ATTR *) (long,long,double,long)) callback_code) (l1,l2,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 76    
+    dr = d_l3d(l1,l2,l3,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l3d_simulator,(void*)d_l3d);
+      dr = ((double (ABI_ATTR *) (long,long,long,double,long)) callback_code) (l1,l2,l3,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 77    
+    dr = d_l4d(l1,l2,l3,l4,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l4d_simulator,(void*)d_l4d);
+      dr = ((double (ABI_ATTR *) (long,long,long,long,double,long)) callback_code) (l1,l2,l3,l4,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 78
+    dr = d_l5d(l1,l2,l3,l4,l5,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l5d_simulator,(void*)d_l5d);
+      dr = ((double (ABI_ATTR *) (long,long,long,long,long,double,long)) callback_code) (l1,l2,l3,l4,l5,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 79
+    dr = d_l6d(l1,l2,l3,l4,l5,l6,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l6d_simulator,(void*)d_l6d);
+      dr = ((double (ABI_ATTR *) (long,long,long,long,long,long,double,long)) callback_code) (l1,l2,l3,l4,l5,l6,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+#if (!defined(DGTEST)) || DGTEST == 80
+    dr = d_l7d(l1,l2,l3,l4,l5,l6,l7,ll1,l9);
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+    dr = 0.0; clear_traces();
+    ALLOC_CALLBACK();
+    {
+      ffi_type* argtypes[] = { &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_slong, &ffi_type_double, &ffi_type_slong };
+      ffi_cif cif;
+      FFI_PREP_CIF(cif,argtypes,ffi_type_double);
+      PREP_CALLBACK(cif,d_l7d_simulator,(void*)d_l7d);
+      dr = ((double (ABI_ATTR *) (long,long,long,long,long,long,long,double,long)) callback_code) (l1,l2,l3,l4,l5,l6,l7,ll1,l9);
+    }
+    FREE_CALLBACK();
+    fprintf(out,"->%g\n",dr);
+    fflush(out);
+#endif
+
+  }
+  
+  exit(0);
+}
+
Index: libffi-3.4.6/testsuite/libffi.complex/ffitest.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/ffitest.h b/libffi-3.4.6/testsuite/libffi.complex/ffitest.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/ffitest.h	
@@ -0,0 +1,1 @@
+#include "../libffi.call/ffitest.h"
Index: libffi-3.4.6/testsuite/libffi.complex/complex.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex.exp b/libffi-3.4.6/testsuite/libffi.complex/complex.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex.exp	
@@ -0,0 +1,36 @@
+# Copyright (C) 2003, 2006, 2009, 2010, 2014 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+dg-init
+libffi-init
+
+global srcdir subdir
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.{c,cc}]]
+
+if { [libffi_feature_test "#ifdef FFI_TARGET_HAS_COMPLEX_TYPE"] } {
+    run-many-tests $tlist ""
+} else {
+    foreach test $tlist {
+	unsupported "$test"
+    }
+}
+
+dg-finish
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/libffi.complex/complex.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex.inc b/libffi-3.4.6/testsuite/libffi.complex/complex.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex.inc	
@@ -0,0 +1,51 @@
+/* -*-c-*-*/
+#include "ffitest.h"
+#include <complex.h>
+
+static _Complex T_C_TYPE f_complex(_Complex T_C_TYPE c, int x, int *py)
+{
+  c = -(2 * creal (c)) + (cimag (c) + 1)* I;
+  *py += x;
+
+  return c;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex T_C_TYPE tc_arg;
+  _Complex T_C_TYPE tc_result;
+  int tc_int_arg_x;
+  int tc_y;
+  int *tc_ptr_arg_y = &tc_y;
+
+  args[0] = &T_FFI_TYPE;
+  args[1] = &ffi_type_sint;
+  args[2] = &ffi_type_pointer;
+  values[0] = &tc_arg;
+  values[1] = &tc_int_arg_x;
+  values[2] = &tc_ptr_arg_y;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &T_FFI_TYPE, args) == FFI_OK);
+
+  tc_arg = 1 + 7 * I;
+  tc_int_arg_x = 1234;
+  tc_y = 9876;
+  ffi_call(&cif, FFI_FN(f_complex), &tc_result, values);
+
+  printf ("%f,%fi %f,%fi, x %d 1234, y %d 11110\n",
+	  T_CONV creal (tc_result), T_CONV cimag (tc_result),
+	  T_CONV creal (2.0), T_CONV creal (8.0), tc_int_arg_x, tc_y);
+
+  CHECK (creal (tc_result) == -2);
+  CHECK (cimag (tc_result) == 8);
+  CHECK (tc_int_arg_x == 1234);
+  CHECK (*tc_ptr_arg_y == 11110);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/complex_int.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_int.c b/libffi-3.4.6/testsuite/libffi.complex/complex_int.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_int.c	
@@ -0,0 +1,86 @@
+/* Area:	ffi_call
+   Purpose:	Check non-standard complex types.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+#include "ffi.h"
+#include <complex.h>
+
+_Complex int f_complex(_Complex int c, int x, int *py)
+{
+  __real__ c = -2 * __real__ c;
+  __imag__ c = __imag__ c + 1;
+  *py += x;
+  return c;
+}
+
+/*
+ * This macro can be used to define new complex type descriptors
+ * in a platform independent way.
+ *
+ * name: Name of the new descriptor is ffi_type_complex_<name>.
+ * type: The C base type of the complex type.
+ */
+#define FFI_COMPLEX_TYPEDEF(name, type, ffitype)	     \
+  static ffi_type *ffi_elements_complex_##name [2] = {	     \
+    (ffi_type *)(&ffitype), NULL			     \
+  };							     \
+  struct struct_align_complex_##name {			     \
+    char c;						     \
+    _Complex type x;					     \
+  };							     \
+  ffi_type ffi_type_complex_##name = {		     \
+    sizeof(_Complex type),				     \
+    offsetof(struct struct_align_complex_##name, x),	     \
+    FFI_TYPE_COMPLEX,					     \
+    (ffi_type **)ffi_elements_complex_##name		     \
+  }
+
+/* Define new complex type descriptors using the macro: */
+/* ffi_type_complex_sint */
+FFI_COMPLEX_TYPEDEF(sint, int, ffi_type_sint);
+/* ffi_type_complex_uchar */
+FFI_COMPLEX_TYPEDEF(uchar, unsigned char, ffi_type_uint8);
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex int tc_arg;
+  _Complex int tc_result;
+  int tc_int_arg_x;
+  int tc_y;
+  int *tc_ptr_arg_y = &tc_y;
+
+  args[0] = &ffi_type_complex_sint;
+  args[1] = &ffi_type_sint;
+  args[2] = &ffi_type_pointer;
+  values[0] = &tc_arg;
+  values[1] = &tc_int_arg_x;
+  values[2] = &tc_ptr_arg_y;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &ffi_type_complex_sint, args)
+	== FFI_OK);
+
+  tc_arg = 1 + 7 * I;
+  tc_int_arg_x = 1234;
+  tc_y = 9876;
+  ffi_call(&cif, FFI_FN(f_complex), &tc_result, values);
+
+  printf ("%d,%di %d,%di, x %d 1234, y %d 11110\n",
+	  (int)tc_result, (int)(tc_result * -I), 2, 8, tc_int_arg_x, tc_y);
+  /* dg-output "-2,8i 2,8i, x 1234 1234, y 11110 11110" */
+  CHECK (creal (tc_result) == -2);
+  CHECK (cimag (tc_result) == 8);
+  CHECK (tc_int_arg_x == 1234);
+  CHECK (*tc_ptr_arg_y == 11110);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex.inc b/libffi-3.4.6/testsuite/libffi.complex/cls_complex.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex.inc	
@@ -0,0 +1,42 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+static void cls_ret_complex_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+ {
+   _Complex T_C_TYPE *pa;
+   _Complex T_C_TYPE *pr;
+   pa = (_Complex T_C_TYPE *)args[0];
+   pr = (_Complex T_C_TYPE *)resp;
+   *pr = *pa;
+
+   printf("%.6f,%.6fi: %.6f,%.6fi\n",
+	  T_CONV creal (*pa), T_CONV cimag (*pa),
+	  T_CONV creal (*pr), T_CONV cimag (*pr));
+ }
+typedef _Complex T_C_TYPE (*cls_ret_complex)(_Complex T_C_TYPE);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  _Complex T_C_TYPE res;
+
+  cl_arg_types[0] = &T_FFI_TYPE;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &T_FFI_TYPE, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_complex_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_complex)code))(0.125 + 128.0 * I);
+  printf("res: %.6f,%.6fi\n", T_CONV creal (res), T_CONV cimag (res));
+  CHECK (res == (0.125 + 128.0 * I));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/complex_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_float.c b/libffi-3.4.6/testsuite/libffi.complex/complex_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check complex types.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/complex_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_double.c b/libffi-3.4.6/testsuite/libffi.complex/complex_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check complex types.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/many_complex.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/many_complex.inc b/libffi-3.4.6/testsuite/libffi.complex/many_complex.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/many_complex.inc	
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <complex.h>
+
+static _Complex T_C_TYPE many(_Complex T_C_TYPE c1,
+			      _Complex T_C_TYPE c2,
+			      _Complex T_C_TYPE c3,
+			      _Complex T_C_TYPE c4,
+			      _Complex T_C_TYPE c5,
+			      _Complex T_C_TYPE c6,
+			      _Complex T_C_TYPE c7,
+			      _Complex T_C_TYPE c8,
+			      _Complex T_C_TYPE c9,
+			      _Complex T_C_TYPE c10,
+			      _Complex T_C_TYPE c11,
+			      _Complex T_C_TYPE c12,
+			      _Complex T_C_TYPE c13)
+{
+  printf("0 :%f,%fi\n"
+	 "1 :%f,%fi\n"
+	 "2 :%f,%fi\n"
+	 "3 :%f,%fi\n"
+	 "4 :%f,%fi\n"
+	 "5 :%f,%fi\n"
+	 "6 :%f,%fi\n"
+	 "7 :%f,%fi\n"
+	 "8 :%f,%fi\n"
+	 "9 :%f,%fi\n"
+	 "10:%f,%fi\n"
+	 "11:%f,%fi\n"
+	 "12:%f,%fi\n",
+	 T_CONV creal (c1), T_CONV cimag (c1),
+	 T_CONV creal (c2), T_CONV cimag (c2),
+	 T_CONV creal (c3), T_CONV cimag (c3),
+	 T_CONV creal (c4), T_CONV cimag (c4),
+	 T_CONV creal (c5), T_CONV cimag (c5),
+	 T_CONV creal (c6), T_CONV cimag (c6),
+	 T_CONV creal (c7), T_CONV cimag (c7),
+	 T_CONV creal (c8), T_CONV cimag (c8),
+	 T_CONV creal (c9), T_CONV cimag (c9),
+	 T_CONV creal (c10), T_CONV cimag (c10),
+	 T_CONV creal (c11), T_CONV cimag (c11),
+	 T_CONV creal (c12), T_CONV cimag (c12),
+	 T_CONV creal (c13), T_CONV cimag (c13));
+
+  return (c1+c2-c3-c4+c5+c6+c7-c8-c9-c10-c11+c12+c13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[13];
+  void *values[13];
+  _Complex T_C_TYPE ca[13];
+  _Complex T_C_TYPE c, cc;
+  int i;
+
+  for (i = 0; i < 13; i++)
+    {
+      args[i] = &T_FFI_TYPE;
+      values[i] = &ca[i];
+      ca[i] = i + (-20 - i) * I;
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, &T_FFI_TYPE, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &c, values);
+
+    cc =  many(ca[0], ca[1], ca[2], ca[3], ca[4], ca[5], ca[6], ca[7], ca[8],
+	       ca[9], ca[10], ca[11], ca[12]);
+    CHECK(creal (cc) == creal (c));
+    CHECK(cimag (cc) == cimag (c));
+
+    exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_va.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va.inc b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va.inc	
@@ -0,0 +1,80 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <complex.h>
+
+static _Complex T_C_TYPE gComplexValue1 = 1 + 2 * I;
+static _Complex T_C_TYPE gComplexValue2 = 3 + 4 * I;
+
+static int cls_variadic(const char *format, ...)
+{
+  va_list ap;
+  _Complex T_C_TYPE p1, p2;
+
+  va_start (ap, format);
+  p1 = va_arg (ap, _Complex T_C_TYPE);
+  p2 = va_arg (ap, _Complex T_C_TYPE);
+  va_end (ap);
+
+  return printf(format, T_CONV creal (p1), T_CONV cimag (p1),
+		T_CONV creal (p2), T_CONV cimag (p2));
+}
+
+static void
+cls_complex_va_fn(ffi_cif* cif __UNUSED__, void* resp,
+		  void** args, void* userdata __UNUSED__)
+{
+  char*	format = *(char**)args[0];
+  gComplexValue1 = *(_Complex T_C_TYPE*)args[1];
+  gComplexValue2 = *(_Complex T_C_TYPE*)args[2];
+
+  *(ffi_arg*)resp =
+    printf(format,
+	   T_CONV creal (gComplexValue1), T_CONV cimag (gComplexValue1),
+	   T_CONV creal (gComplexValue2), T_CONV cimag (gComplexValue2));
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args[4];
+  ffi_type* arg_types[4];
+  char *format = "%.1f,%.1fi %.1f,%.1fi\n";
+
+  _Complex T_C_TYPE complexArg1 = 1.0 + 22.0 *I;
+  _Complex T_C_TYPE complexArg2 = 333.0 + 4444.0 *I;
+  ffi_arg res = 0;
+
+  arg_types[0] = &ffi_type_pointer;
+  arg_types[1] = &T_FFI_TYPE;
+  arg_types[2] = &T_FFI_TYPE;
+  arg_types[3] = NULL;
+
+  /* This printf call is variadic */
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 3, &ffi_type_sint,
+			 arg_types) == FFI_OK);
+
+  args[0] = &format;
+  args[1] = &complexArg1;
+  args[2] = &complexArg2;
+  args[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_variadic), &res, args);
+  printf("res: %d\n", (int) res);
+  CHECK (res == 24);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_complex_va_fn, NULL, code)
+	== FFI_OK);
+
+  res = ((int(*)(char *, ...))(code))(format, complexArg1, complexArg2);
+  CHECK (gComplexValue1 == complexArg1);
+  CHECK (gComplexValue2 == complexArg2);
+  printf("res: %d\n", (int) res);
+  CHECK (res == 24);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex.inc b/libffi-3.4.6/testsuite/libffi.complex/return_complex.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex.inc	
@@ -0,0 +1,37 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+static _Complex T_C_TYPE return_c(_Complex T_C_TYPE c)
+{
+  printf ("%f,%fi\n", T_CONV creal (c), T_CONV cimag (c));
+  return 2 * c;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  _Complex T_C_TYPE c, rc, rc2;
+  T_C_TYPE cr, ci;
+
+  args[0] = &T_FFI_TYPE;
+  values[0] = &c;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &T_FFI_TYPE, args) == FFI_OK);
+
+  for (cr = -127.0; cr <  127; cr++)
+    {
+      ci = 1000.0 - cr;
+      c = cr + ci * I;
+      ffi_call(&cif, FFI_FN(return_c), &rc, values);
+      rc2 = return_c(c);
+      printf ("%f,%fi vs %f,%fi\n",
+	      T_CONV creal (rc), T_CONV cimag (rc),
+	      T_CONV creal (rc2), T_CONV cimag (rc2));
+      CHECK(rc == 2 * c);
+    }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_float.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_float.c	
@@ -0,0 +1,10 @@
+/* Area:	closure_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "cls_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex1.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex1.inc b/libffi-3.4.6/testsuite/libffi.complex/return_complex1.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex1.inc	
@@ -0,0 +1,41 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+static _Complex T_C_TYPE return_c(_Complex T_C_TYPE c1, float fl2, unsigned int in3, _Complex T_C_TYPE c4)
+{
+  return c1 + fl2 + in3 + c4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  _Complex T_C_TYPE c1, c4, rc, rc2;
+  float fl2;
+  unsigned int in3;
+  args[0] = &T_FFI_TYPE;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint;
+  args[3] = &T_FFI_TYPE;
+  values[0] = &c1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &c4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &T_FFI_TYPE, args) == FFI_OK);
+  c1 = 127.0 + 255.0 * I;
+  fl2 = 128.0;
+  in3 = 255;
+  c4 = 512.7 + 1024.1 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &rc, values);
+  rc2 = return_c(c1, fl2, in3, c4);
+  printf ("%f,%fi vs %f,%fi\n",
+	  T_CONV creal (rc), T_CONV cimag (rc),
+	  T_CONV creal (rc2), T_CONV cimag (rc2));
+  CHECK(rc == rc2);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex2.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex2.inc b/libffi-3.4.6/testsuite/libffi.complex/return_complex2.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex2.inc	
@@ -0,0 +1,44 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+_Complex T_C_TYPE
+return_c(_Complex T_C_TYPE c1, _Complex T_C_TYPE c2,
+	 unsigned int in3, _Complex T_C_TYPE c4)
+{
+  volatile _Complex T_C_TYPE r = c1 + c2 + in3 + c4;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  _Complex T_C_TYPE c1, c2, c4, rc, rc2;
+  unsigned int in3;
+  args[0] = &T_FFI_TYPE;
+  args[1] = &T_FFI_TYPE;
+  args[2] = &ffi_type_uint;
+  args[3] = &T_FFI_TYPE;
+  values[0] = &c1;
+  values[1] = &c2;
+  values[2] = &in3;
+  values[3] = &c4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &T_FFI_TYPE, args) == FFI_OK);
+  c1 = 127.0 + 255.0 * I;
+  c2 = 128.0 + 256.0;
+  in3 = 255;
+  c4 = 512.7 + 1024.1 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &rc, values);
+  rc2 = return_c(c1, c2, in3, c4);
+  printf ("%f,%fi vs %f,%fi\n",
+	  T_CONV creal (rc), T_CONV cimag (rc),
+	  T_CONV creal (rc2), T_CONV cimag (rc2));
+  CHECK(rc == rc2);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_double.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_double.c	
@@ -0,0 +1,10 @@
+/* Area:	closure_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "cls_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/complex_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/complex_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check complex types.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/many_complex_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/many_complex_float.c b/libffi-3.4.6/testsuite/libffi.complex/many_complex_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/many_complex_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "many_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_align_complex.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex.inc b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex.inc	
@@ -0,0 +1,91 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  _Complex T_C_TYPE b;
+  unsigned char c;
+} cls_struct_align;
+
+cls_struct_align cls_struct_align_fn(
+	struct cls_struct_align a1, struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %f,%fi %d %d %f,%fi %d: %d %f,%fi %d\n",
+	 a1.a, T_CONV creal (a1.b), T_CONV cimag (a1.b), a1.c,
+	 a2.a, T_CONV creal (a2.b), T_CONV cimag (a2.b), a2.c,
+	 result.a, T_CONV creal (result.b), T_CONV cimag (result.b), result.c);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_c[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* c_arg_types[5];
+
+  struct cls_struct_align g_c = { 12, 4951 + 7 * I, 127 };
+  struct cls_struct_align f_c = { 1, 9320 + 1 * I, 13 };
+  struct cls_struct_align res_c;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &T_FFI_TYPE;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  c_arg_types[0] = &cls_struct_type;
+  c_arg_types[1] = &cls_struct_type;
+  c_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     c_arg_types) == FFI_OK);
+
+  args_c[0] = &g_c;
+  args_c[1] = &f_c;
+  args_c[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_c, args_c);
+  /* { dg-output "12 4951,7i 127 1 9320,1i 13: 13 14271,8i 140" } */
+  printf("res: %d %f,%fi %d\n",
+	 res_c.a, T_CONV  creal (res_c.b), T_CONV  cimag (res_c.b), res_c.c);
+  /* { dg-output "\nres: 13 14271,8i 140" } */
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_c = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_c, f_c);
+  /* { dg-output "\n12 4951,7i 127 1 9320,1i 13: 13 14271,8i 140" } */
+  printf("res: %d %f,%fi %d\n",
+	 res_c.a, T_CONV  creal (res_c.b), T_CONV  cimag (res_c.b), res_c.c);
+  /* { dg-output "\nres: 13 14271,8i 140" } */
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.complex/many_complex_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/many_complex_double.c b/libffi-3.4.6/testsuite/libffi.complex/many_complex_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/many_complex_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "many_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct.inc b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct.inc	
@@ -0,0 +1,71 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+typedef struct Cs {
+  _Complex T_C_TYPE x;
+  _Complex T_C_TYPE y;
+} Cs;
+
+Cs gc;
+
+void
+closure_test_fn(Cs p)
+{
+  printf("%.1f,%.1fi %.1f,%.1fi\n",
+	 T_CONV creal (p.x), T_CONV cimag (p.x),
+	 T_CONV creal (p.y), T_CONV cimag (p.y));
+  gc = p;
+}
+
+void
+closure_test_gn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+		void** args, void* userdata __UNUSED__)
+{
+  closure_test_fn(*(Cs*)args[0]);
+}
+
+int main(int argc __UNUSED__, char** argv __UNUSED__)
+{
+  ffi_cif cif;
+
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type *cl_arg_types[1];
+
+  ffi_type ts1_type;
+  ffi_type* ts1_type_elements[4];
+
+  Cs arg = { 1.0 + 11.0 * I, 2.0 + 22.0 * I};
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+
+  ts1_type_elements[0] = &T_FFI_TYPE;
+  ts1_type_elements[1] = &T_FFI_TYPE;
+  ts1_type_elements[2] = NULL;
+
+  cl_arg_types[0] = &ts1_type;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_void, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);
+
+  gc.x = 0.0 + 0.0 * I;
+  gc.y = 0.0 + 0.0 * I;
+  ((void*(*)(Cs))(code))(arg);
+  /* { dg-output "1.0,11.0i 2.0,22.0i\n" } */
+  CHECK (gc.x == arg.x && gc.y == arg.y);
+
+  gc.x = 0.0 + 0.0 * I;
+  gc.y = 0.0 + 0.0 * I;
+  closure_test_fn(arg);
+  /* { dg-output "1.0,11.0i 2.0,22.0i\n" } */
+  CHECK (gc.x == arg.x && gc.y == arg.y);
+
+  return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_float.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_float.c	
@@ -0,0 +1,16 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Test complex' passed in variable argument lists.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+/* Alpha splits _Complex into two arguments.  It's illegal to pass
+   float through varargs, so _Complex float goes badly.  In sort of
+   gets passed as _Complex double, but the compiler doesn't agree
+   with itself on this issue.  */
+/* { dg-do run { xfail alpha*-*-* } } */
+
+#include "complex_defs_float.inc"
+#include "cls_complex_va.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/complex_defs_float.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_defs_float.inc b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_float.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_float.inc	
@@ -0,0 +1,7 @@
+/* -*-c-*- */
+/* Complex base type.  */
+#define T_FFI_TYPE ffi_type_complex_float
+/* C type corresponding to the base type.  */
+#define T_C_TYPE float
+/* C cast for a value of type T_C_TYPE that is passed to printf.  */
+#define T_CONV (double)
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex_float.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "return_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_double.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Test complex' passed in variable argument lists.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "cls_complex_va.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/complex_defs_double.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_defs_double.inc b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_double.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_double.inc	
@@ -0,0 +1,7 @@
+/* -*-c-*- */
+/* Complex base type.  */
+#define T_FFI_TYPE ffi_type_complex_double
+/* C type corresponding to the base type.  */
+#define T_C_TYPE double
+/* C cast for a value of type T_C_TYPE that is passed to printf.  */
+#define T_CONV
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex1_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex1_float.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "return_complex1.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex2_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex2_float.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "return_complex2.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex_double.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "return_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	closure_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "cls_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex1_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex1_double.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "return_complex1.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex2_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex2_double.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "return_complex2.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_float.c b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "cls_align_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/many_complex_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/many_complex_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/many_complex_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/many_complex_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "many_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_double.c b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "cls_align_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_float.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_float.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check complex arguments in structs.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "cls_complex_struct.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_double.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_double.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check complex arguments in structs.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "cls_complex_struct.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_va_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Test complex' passed in variable argument lists.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "cls_complex_va.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/complex_defs_longdouble.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/complex_defs_longdouble.inc b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_longdouble.inc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/complex_defs_longdouble.inc	
@@ -0,0 +1,7 @@
+/* -*-c-*- */
+/* Complex base type.  */
+#define T_FFI_TYPE ffi_type_complex_longdouble
+/* C type corresponding to the base type.  */
+#define T_C_TYPE long double
+/* C cast for a value of type T_C_TYPE that is passed to printf.  */
+#define T_CONV
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "return_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex1_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex1_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex1_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "return_complex1.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/return_complex2_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/return_complex2_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/return_complex2_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call
+   Purpose:	Check return value complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "return_complex2.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_align_complex_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of complex.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "cls_align_complex.inc"
Index: libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_longdouble.c b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.complex/cls_complex_struct_longdouble.c	
@@ -0,0 +1,10 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check complex arguments in structs.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<vogt@linux.vnet.ibm.com>.  */
+
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "cls_complex_struct.inc"
Index: libffi-3.4.6/testsuite/libffi.closures/ffitest.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/ffitest.h b/libffi-3.4.6/testsuite/libffi.closures/ffitest.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/ffitest.h	
@@ -0,0 +1,1 @@
+#include "../libffi.call/ffitest.h"
Index: libffi-3.4.6/testsuite/libffi.closures/cls_sint.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_sint.c b/libffi-3.4.6/testsuite/libffi.closures/cls_sint.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_sint.c	
@@ -0,0 +1,44 @@
+/* Area:	closure_call
+   Purpose:	Check return value sint32.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20031108	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_sint_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			    void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(signed int *)args[0];
+  printf("%d: %d\n",*(signed int *)args[0],
+	 (int)*(ffi_arg *)(resp));
+  CHECK(*(signed int *)args[0] == 65534);
+  CHECK((int)*(ffi_arg *)(resp) == 65534);
+}
+typedef signed int (*cls_ret_sint)(signed int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  signed int res;
+
+  cl_arg_types[0] = &ffi_type_sint;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sint_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_sint)code))(65534);
+  /* { dg-output "65534: 65534" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 65534" } */
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_uint.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_uint.c b/libffi-3.4.6/testsuite/libffi.closures/cls_uint.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_uint.c	
@@ -0,0 +1,47 @@
+/* Area:	closure_call
+   Purpose:	Check return value uint.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_uint_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			    void* userdata __UNUSED__)
+{
+  *(ffi_arg *)resp = *(unsigned int *)args[0];
+
+  printf("%d: %d\n",*(unsigned int *)args[0],
+	 (int)*(ffi_arg *)(resp));
+
+  CHECK(*(unsigned int *)args[0] == 2147483647);
+  CHECK((int)*(ffi_arg *)(resp) == 2147483647);
+}
+typedef unsigned int (*cls_ret_uint)(unsigned int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  unsigned int res;
+
+  cl_arg_types[0] = &ffi_type_uint;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_uint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uint_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_uint)code))(2147483647);
+  /* { dg-output "2147483647: 2147483647" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 2147483647" } */
+  CHECK(res == 2147483647);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/problem1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/problem1.c b/libffi-3.4.6/testsuite/libffi.closures/problem1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/problem1.c	
@@ -0,0 +1,90 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct my_ffi_struct {
+  double a;
+  double b;
+  double c;
+} my_ffi_struct;
+
+my_ffi_struct callee(struct my_ffi_struct a1, struct my_ffi_struct a2)
+{
+  struct my_ffi_struct result;
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+
+  printf("%g %g %g %g %g %g: %g %g %g\n", a1.a, a1.b, a1.c,
+	 a2.a, a2.b, a2.c, result.a, result.b, result.c);
+
+  return result;
+}
+
+void stub(ffi_cif* cif __UNUSED__, void* resp, void** args,
+	  void* userdata __UNUSED__)
+{
+  struct my_ffi_struct a1;
+  struct my_ffi_struct a2;
+
+  a1 = *(struct my_ffi_struct*)(args[0]);
+  a2 = *(struct my_ffi_struct*)(args[1]);
+
+  *(my_ffi_struct *)resp = callee(a1, a2);
+}
+
+
+int main(void)
+{
+  ffi_type* my_ffi_struct_fields[4];
+  ffi_type my_ffi_struct_type;
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args[4];
+  ffi_type* arg_types[3];
+
+  struct my_ffi_struct g = { 1.0, 2.0, 3.0 };
+  struct my_ffi_struct f = { 1.0, 2.0, 3.0 };
+  struct my_ffi_struct res;
+
+  my_ffi_struct_type.size = 0;
+  my_ffi_struct_type.alignment = 0;
+  my_ffi_struct_type.type = FFI_TYPE_STRUCT;
+  my_ffi_struct_type.elements = my_ffi_struct_fields;
+
+  my_ffi_struct_fields[0] = &ffi_type_double;
+  my_ffi_struct_fields[1] = &ffi_type_double;
+  my_ffi_struct_fields[2] = &ffi_type_double;
+  my_ffi_struct_fields[3] = NULL;
+
+  arg_types[0] = &my_ffi_struct_type;
+  arg_types[1] = &my_ffi_struct_type;
+  arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &my_ffi_struct_type,
+		     arg_types) == FFI_OK);
+
+  args[0] = &g;
+  args[1] = &f;
+  args[2] = NULL;
+  ffi_call(&cif, FFI_FN(callee), &res, args);
+  /* { dg-output "1 2 3 1 2 3: 2 4 6" } */
+  printf("res: %g %g %g\n", res.a, res.b, res.c);
+  /* { dg-output "\nres: 2 4 6" } */
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, stub, NULL, code) == FFI_OK);
+
+  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(code))(g, f);
+  /* { dg-output "\n1 2 3 1 2 3: 2 4 6" } */
+  printf("res: %g %g %g\n", res.a, res.b, res.c);
+  /* { dg-output "\nres: 2 4 6" } */
+
+  exit(0);;
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure.exp b/libffi-3.4.6/testsuite/libffi.closures/closure.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure.exp	
@@ -0,0 +1,67 @@
+# Copyright (C) 2003, 2006, 2009, 2010, 2014, 2019 Free Software Foundation, Inc.
+# Copyright (C) 2019 Anthony Green
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+dg-init
+libffi-init
+
+global srcdir subdir
+
+if { [string match $compiler_vendor "microsoft"] } {
+    # -wd4005  macro redefinition
+    # -wd4244  implicit conversion to type of smaller size
+    # -wd4305  truncation to smaller type
+    # -wd4477  printf %lu of uintptr_t
+    # -wd4312  implicit conversion to type of greater size
+    # -wd4311  pointer truncation to unsigned long
+    # -EHsc    C++ Exception Handling (no SEH exceptions)
+    set additional_options "-wd4005 -wd4244 -wd4305 -wd4477 -wd4312 -wd4311 -EHsc";
+} else {
+    set additional_options "";
+}
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.c]]
+
+if { [libffi_feature_test "#if FFI_CLOSURES"] } {
+    run-many-tests $tlist ""
+} else {
+    foreach test $tlist {
+	unsupported "$test"
+    }
+}
+
+set tlist [lsort [glob -nocomplain -- $srcdir/$subdir/*.cc]]
+
+# No C++ for or1k
+if { [istarget "or1k-*-*"] } {
+    foreach test $tlist {
+        unsupported "$test"
+    }
+} else {
+    if { [libffi_feature_test "#if FFI_CLOSURES"] } {
+        run-many-tests $tlist  $additional_options
+    } else {
+        foreach test $tlist {
+	    unsupported "$test"
+        }
+    }
+}
+
+dg-finish
+
+# Local Variables:
+# tcl-indent-level:4
+# End:
Index: libffi-3.4.6/testsuite/libffi.closures/cls_2byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_2byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_2byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_2byte.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_2byte {
+  unsigned char a;
+  unsigned char b;
+} cls_struct_2byte;
+
+cls_struct_2byte cls_struct_2byte_fn(struct cls_struct_2byte a1,
+			    struct cls_struct_2byte a2)
+{
+  struct cls_struct_2byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+
+  printf("%d %d %d %d: %d %d\n", a1.a, a1.b, a2.a, a2.b, result.a, result.b);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_2byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_2byte a1, a2;
+
+  a1 = *(struct cls_struct_2byte*)(args[0]);
+  a2 = *(struct cls_struct_2byte*)(args[1]);
+
+  *(cls_struct_2byte*)resp = cls_struct_2byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_2byte g_dbl = { 12, 127 };
+  struct cls_struct_2byte f_dbl = { 1, 13 };
+  struct cls_struct_2byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_2byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 127 1 13: 13 140" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 13 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_2byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 127 1 13: 13 140" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 13 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_4byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_4byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_4byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_4byte.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef struct cls_struct_4byte {
+  unsigned short a;
+  unsigned short b;
+} cls_struct_4byte;
+
+cls_struct_4byte cls_struct_4byte_fn(struct cls_struct_4byte a1,
+			    struct cls_struct_4byte a2)
+{
+  struct cls_struct_4byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+
+  printf("%d %d %d %d: %d %d\n", a1.a, a1.b, a2.a, a2.b, result.a, result.b);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+
+  return  result;
+}
+
+static void
+cls_struct_4byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_4byte a1, a2;
+
+  a1 = *(struct cls_struct_4byte*)(args[0]);
+  a2 = *(struct cls_struct_4byte*)(args[1]);
+
+  *(cls_struct_4byte*)resp = cls_struct_4byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_4byte g_dbl = { 127, 120 };
+  struct cls_struct_4byte f_dbl = { 12, 128 };
+  struct cls_struct_4byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_ushort;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_4byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 12 128: 139 248" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 139 248" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 12 128: 139 248" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 139 248" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_5byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_5byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_5byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_5byte.c	
@@ -0,0 +1,116 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_5byte {
+  unsigned short a;
+  unsigned short b;
+  unsigned char c;
+} cls_struct_5byte;
+
+static cls_struct_5byte cls_struct_5byte_fn(struct cls_struct_5byte a1,
+			    struct cls_struct_5byte a2)
+{
+  struct cls_struct_5byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c,
+	 a2.a, a2.b, a2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+
+  return  result;
+}
+
+static void
+cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_5byte a1, a2;
+
+  a1 = *(struct cls_struct_5byte*)(args[0]);
+  a2 = *(struct cls_struct_5byte*)(args[1]);
+
+  *(cls_struct_5byte*)resp = cls_struct_5byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_5byte g_dbl = { 127, 120, 1 };
+  struct cls_struct_5byte f_dbl = { 12, 128, 9 };
+  struct cls_struct_5byte res_dbl = { 0, 0, 0 };
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_ushort;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_5byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 12 128 9: 139 248 10" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 139 248 10" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+
+  res_dbl.a = 0;
+  res_dbl.b = 0;
+  res_dbl.c = 0;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 12 128 9: 139 248 10" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 139 248 10" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_6byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_6byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_6byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_6byte.c	
@@ -0,0 +1,121 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_6byte {
+  unsigned short a;
+  unsigned short b;
+  unsigned char c;
+  unsigned char d;
+} cls_struct_6byte;
+
+static cls_struct_6byte cls_struct_6byte_fn(struct cls_struct_6byte a1,
+			    struct cls_struct_6byte a2)
+{
+  struct cls_struct_6byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+
+  printf("%d %d %d %d %d %d %d %d: %d %d %d %d\n", a1.a, a1.b, a1.c, a1.d,
+	 a2.a, a2.b, a2.c, a2.d,
+	 result.a, result.b, result.c, result.d);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+  CHECK(a1.d == 128);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+  CHECK(a2.d == 127);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+  CHECK(result.d == 255);
+
+  return  result;
+}
+
+static void
+cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_6byte a1, a2;
+
+  a1 = *(struct cls_struct_6byte*)(args[0]);
+  a2 = *(struct cls_struct_6byte*)(args[1]);
+
+  *(cls_struct_6byte*)resp = cls_struct_6byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 128 };
+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 127 };
+  struct cls_struct_6byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_ushort;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_uchar;
+  cls_struct_fields[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_6byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 128 12 128 9 127: 139 248 10 255" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 139 248 10 255" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 255);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 128 12 128 9 127: 139 248 10 255" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 139 248 10 255" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 255);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_7byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_7byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_7byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_7byte.c	
@@ -0,0 +1,121 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_7byte {
+  unsigned short a;
+  unsigned short b;
+  unsigned char c;
+  unsigned short d;
+} cls_struct_7byte;
+
+static cls_struct_7byte cls_struct_7byte_fn(struct cls_struct_7byte a1,
+			    struct cls_struct_7byte a2)
+{
+  struct cls_struct_7byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+
+  printf("%d %d %d %d %d %d %d %d: %d %d %d %d\n", a1.a, a1.b, a1.c, a1.d,
+	 a2.a, a2.b, a2.c, a2.d,
+	 result.a, result.b, result.c, result.d);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+  CHECK(a1.d == 254);
+	
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+  CHECK(a2.d == 255);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+  CHECK(result.d == 509);
+
+
+  return  result;
+}
+
+static void
+cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_7byte a1, a2;
+
+  a1 = *(struct cls_struct_7byte*)(args[0]);
+  a2 = *(struct cls_struct_7byte*)(args[1]);
+
+  *(cls_struct_7byte*)resp = cls_struct_7byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 254 };
+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 255 };
+  struct cls_struct_7byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_ushort;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_ushort;
+  cls_struct_fields[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_7byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 254 12 128 9 255: 139 248 10 509" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 139 248 10 509" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 509);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 254 12 128 9 255: 139 248 10 509" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 139 248 10 509" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 509);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_8byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_8byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_8byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_8byte.c	
@@ -0,0 +1,102 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_8byte {
+  int a;
+  float b;
+} cls_struct_8byte;
+
+cls_struct_8byte cls_struct_8byte_fn(struct cls_struct_8byte a1,
+			    struct cls_struct_8byte a2)
+{
+  struct cls_struct_8byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+
+  printf("%d %g %d %g: %d %g\n", a1.a, a1.b, a2.a, a2.b, result.a, result.b);
+
+  CHECK(a1.a == 1);
+  CHECK_FLOAT_EQ(a1.b, 2);
+
+  CHECK(a2.a == 4);
+  CHECK_FLOAT_EQ(a2.b, 5);
+
+  CHECK(result.a == 5);
+  CHECK_FLOAT_EQ(result.b, 7);
+
+  return  result;
+}
+
+static void
+cls_struct_8byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_8byte a1, a2;
+
+  a1 = *(struct cls_struct_8byte*)(args[0]);
+  a2 = *(struct cls_struct_8byte*)(args[1]);
+
+  *(cls_struct_8byte*)resp = cls_struct_8byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_8byte g_dbl = { 1, 2.0 };
+  struct cls_struct_8byte f_dbl = { 4, 5.0 };
+  struct cls_struct_8byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_8byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 2 4 5: 5 7" } */
+  printf("res: %d %g\n", res_dbl.a, res_dbl.b);
+  CHECK(res_dbl.a == 5);
+  CHECK_FLOAT_EQ(res_dbl.b, 7);
+
+  /* { dg-output "\nres: 5 7" } */
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_8byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 2 4 5: 5 7" } */
+  printf("res: %d %g\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 5 7" } */
+  CHECK(res_dbl.a == 5);
+  CHECK_FLOAT_EQ(res_dbl.b, 7);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_float.c b/libffi-3.4.6/testsuite/libffi.closures/cls_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_float.c	
@@ -0,0 +1,46 @@
+/* Area:	closure_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_float_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
+ {
+   *(float *)resp = *(float *)args[0];
+
+   printf("%g: %g\n",*(float *)args[0],
+	  *(float *)resp);
+
+   CHECK((int)(*(float *)args[0]) == -2122);
+   CHECK((int)(*(float *)resp) == -2122);
+ }
+
+typedef float (*cls_ret_float)(float);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  float res;
+
+  cl_arg_types[0] = &ffi_type_float;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_float, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_float_fn, NULL, code)  == FFI_OK);
+  res = ((((cls_ret_float)code)(-2122.12)));
+  /* { dg-output "\\-2122.12: \\-2122.12" } */
+  printf("res: %.6f\n", res);
+  /* { dg-output "\nres: \-2122.120117" } */
+  CHECK((int)res == -2122);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_schar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_schar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_schar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_schar.c	
@@ -0,0 +1,47 @@
+/* Area:	closure_call
+   Purpose:	Check return value schar.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20031108	 */
+
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_schar_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(signed char *)args[0];
+  printf("%d: %d\n",*(signed char *)args[0],
+	 (int)*(ffi_arg *)(resp));
+  CHECK(*(signed char *)args[0] == 127);
+  CHECK((int)*(ffi_arg *)(resp) == 127);
+}
+typedef signed char (*cls_ret_schar)(signed char);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  signed char res;
+
+  cl_arg_types[0] = &ffi_type_schar;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_schar, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_schar_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_schar)code))(127);
+  /* { dg-output "127: 127" } */
+  printf("res: %d\n", res);
+  /* { dg-output "\nres: 127" } */
+  CHECK(res == 127);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_uchar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_uchar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_uchar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_uchar.c	
@@ -0,0 +1,45 @@
+/* Area:	closure_call
+   Purpose:	Check return value uchar.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_uchar_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(unsigned char *)args[0];
+  printf("%d: %d\n",*(unsigned char *)args[0],
+	 (int)*(ffi_arg *)(resp));
+  CHECK(*(unsigned char *)args[0] == 127);
+  CHECK((int)*(ffi_arg *)(resp) == 127);
+}
+typedef unsigned char (*cls_ret_uchar)(unsigned char);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  unsigned char res;
+
+  cl_arg_types[0] = &ffi_type_uchar;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_uchar, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_uchar_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_uchar)code))(127);
+  /* { dg-output "127: 127" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 127" } */
+  CHECK(res == 127);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_12byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_12byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_12byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_12byte.c	
@@ -0,0 +1,112 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_12byte {
+  int a;
+  int b;
+  int c;
+} cls_struct_12byte;
+
+cls_struct_12byte cls_struct_12byte_fn(struct cls_struct_12byte b1,
+			    struct cls_struct_12byte b2)
+{
+  struct cls_struct_12byte result;
+
+  result.a = b1.a + b2.a;
+  result.b = b1.b + b2.b;
+  result.c = b1.c + b2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", b1.a, b1.b, b1.c, b2.a, b2.b, b2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(b1.a == 7);
+  CHECK(b1.b == 4);
+  CHECK(b1.c == 9);
+
+  CHECK(b2.a == 1);
+  CHECK(b2.b == 5);
+  CHECK(b2.c == 3);
+
+  CHECK(result.a == 8);
+  CHECK(result.b == 9);
+  CHECK(result.c == 12);
+  return result;
+}
+
+static void cls_struct_12byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args , void* userdata __UNUSED__)
+{
+  struct cls_struct_12byte b1, b2;
+
+  b1 = *(struct cls_struct_12byte*)(args[0]);
+  b2 = *(struct cls_struct_12byte*)(args[1]);
+
+  *(cls_struct_12byte*)resp = cls_struct_12byte_fn(b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_12byte h_dbl = { 7, 4, 9 };
+  struct cls_struct_12byte j_dbl = { 1, 5, 3 };
+  struct cls_struct_12byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_sint;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &h_dbl;
+  args_dbl[1] = &j_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_12byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "7 4 9 1 5 3: 8 9 12" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 8 9 12" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 9);
+  CHECK(res_dbl.c == 12);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_12byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl.a = 0;
+  res_dbl.b = 0;
+  res_dbl.c = 0;
+
+  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(code))(h_dbl, j_dbl);
+  /* { dg-output "\n7 4 9 1 5 3: 8 9 12" } */
+
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 8 9 12" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 9);
+  CHECK(res_dbl.c == 12);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_16byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_16byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_16byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_16byte.c	
@@ -0,0 +1,117 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_16byte {
+  int a;
+  double b;
+  int c;
+} cls_struct_16byte;
+
+cls_struct_16byte cls_struct_16byte_fn(struct cls_struct_16byte b1,
+			    struct cls_struct_16byte b2)
+{
+  struct cls_struct_16byte result;
+
+  result.a = b1.a + b2.a;
+  result.b = b1.b + b2.b;
+  result.c = b1.c + b2.c;
+
+  printf("%d %g %d %d %g %d: %d %g %d\n", b1.a, b1.b, b1.c, b2.a, b2.b, b2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(b1.a == 7);
+  CHECK(b1.b == 8);
+  CHECK(b1.c == 9);
+
+  CHECK(b2.a == 1);
+  CHECK(b2.b == 9);
+  CHECK(b2.c == 3);
+
+  CHECK(result.a == 8);
+  CHECK(result.b == 17);
+  CHECK(result.c == 12);
+
+
+  return result;
+}
+
+static void cls_struct_16byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args, void* userdata __UNUSED__)
+{
+  struct cls_struct_16byte b1, b2;
+
+  b1 = *(struct cls_struct_16byte*)(args[0]);
+  b2 = *(struct cls_struct_16byte*)(args[1]);
+
+  *(cls_struct_16byte*)resp = cls_struct_16byte_fn(b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_16byte h_dbl = { 7, 8.0, 9 };
+  struct cls_struct_16byte j_dbl = { 1, 9.0, 3 };
+  struct cls_struct_16byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &h_dbl;
+  args_dbl[1] = &j_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_16byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "7 8 9 1 9 3: 8 17 12" } */
+  printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 8 17 12" } */
+
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+  CHECK(res_dbl.c == 12);
+
+  res_dbl.a = 0;
+  res_dbl.b = 0.0;
+  res_dbl.c = 0;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_16byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(code))(h_dbl, j_dbl);
+  /* { dg-output "\n7 8 9 1 9 3: 8 17 12" } */
+  printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 8 17 12" } */
+
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+  CHECK(res_dbl.c == 12);
+
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_18byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_18byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_18byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_18byte.c	
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Double alignment check on darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030915	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_18byte {
+  double a;
+  unsigned char b;
+  unsigned char c;
+  double d;
+} cls_struct_18byte;
+
+cls_struct_18byte cls_struct_18byte_fn(struct cls_struct_18byte a1,
+			    struct cls_struct_18byte a2)
+{
+  struct cls_struct_18byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+
+
+  printf("%g %d %d %g %g %d %d %g: %g %d %d %g\n", a1.a, a1.b, a1.c, a1.d,
+	 a2.a, a2.b, a2.c, a2.d,
+	 result.a, result.b, result.c, result.d);
+
+  CHECK(a1.a == 1);
+  CHECK(a1.b == 127);
+  CHECK(a1.c == 126);
+  CHECK(a1.d == 3);
+
+  CHECK(a2.a == 4);
+  CHECK(a2.b == 125);
+  CHECK(a2.c == 124);
+  CHECK(a2.d == 5);
+
+  CHECK(result.a == 5);
+  CHECK(result.b == 252);
+  CHECK(result.c == 250);
+  CHECK(result.d == 8);
+
+  return result;
+}
+
+static void
+cls_struct_18byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_18byte a1, a2;
+
+  a1 = *(struct cls_struct_18byte*)(args[0]);
+  a2 = *(struct cls_struct_18byte*)(args[1]);
+
+  *(cls_struct_18byte*)resp = cls_struct_18byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[5];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_18byte g_dbl = { 1.0, 127, 126, 3.0 };
+  struct cls_struct_18byte f_dbl = { 4.0, 125, 124, 5.0 };
+  struct cls_struct_18byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_double;
+  cls_struct_fields[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_18byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 127 126 3 4 125 124 5: 5 252 250 8" } */
+  printf("res: %g %d %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 5 252 250 8" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 252);
+  CHECK(res_dbl.c == 250);
+  CHECK(res_dbl.d == 8);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_18byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_18byte(*)(cls_struct_18byte, cls_struct_18byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 127 126 3 4 125 124 5: 5 252 250 8" } */
+  printf("res: %g %d %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 5 252 250 8" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 252);
+  CHECK(res_dbl.c == 250);
+  CHECK(res_dbl.d == 8);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_19byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_19byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_19byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_19byte.c	
@@ -0,0 +1,131 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Double alignment check on darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030915	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_19byte {
+  double a;
+  unsigned char b;
+  unsigned char c;
+  double d;
+  unsigned char e;
+} cls_struct_19byte;
+
+cls_struct_19byte cls_struct_19byte_fn(struct cls_struct_19byte a1,
+			    struct cls_struct_19byte a2)
+{
+  struct cls_struct_19byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+  result.e = a1.e + a2.e;
+
+
+  printf("%g %d %d %g %d %g %d %d %g %d: %g %d %d %g %d\n",
+	 a1.a, a1.b, a1.c, a1.d, a1.e,
+	 a2.a, a2.b, a2.c, a2.d, a2.e,
+	 result.a, result.b, result.c, result.d, result.e);
+
+  CHECK(a1.a == 1);
+  CHECK(a1.b == 127);
+  CHECK(a1.c == 126);
+  CHECK(a1.d == 3);
+  CHECK(a1.e == 120);
+
+  CHECK(a2.a == 4);
+  CHECK(a2.b == 125);
+  CHECK(a2.c == 124);
+  CHECK(a2.d == 5);
+  CHECK(a2.e == 119);
+
+  CHECK(result.a == 5);
+  CHECK(result.b == 252);
+  CHECK(result.c == 250);
+  CHECK(result.d == 8);
+  CHECK(result.e == 239);
+
+  return result;
+}
+
+static void
+cls_struct_19byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_19byte a1, a2;
+
+  a1 = *(struct cls_struct_19byte*)(args[0]);
+  a2 = *(struct cls_struct_19byte*)(args[1]);
+
+  *(cls_struct_19byte*)resp = cls_struct_19byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[6];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_19byte g_dbl = { 1.0, 127, 126, 3.0, 120 };
+  struct cls_struct_19byte f_dbl = { 4.0, 125, 124, 5.0, 119 };
+  struct cls_struct_19byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_double;
+  cls_struct_fields[4] = &ffi_type_uchar;
+  cls_struct_fields[5] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_19byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239" } */
+  printf("res: %g %d %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e);
+  /* { dg-output "\nres: 5 252 250 8 239" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 252);
+  CHECK(res_dbl.c == 250);
+  CHECK(res_dbl.d == 8);
+  CHECK(res_dbl.e == 239);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_19byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_19byte(*)(cls_struct_19byte, cls_struct_19byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239" } */
+  printf("res: %g %d %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e);
+  /* { dg-output "\nres: 5 252 250 8 239" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 252);
+  CHECK(res_dbl.c == 250);
+  CHECK(res_dbl.d == 8);
+  CHECK(res_dbl.e == 239);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_20byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_20byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_20byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_20byte.c	
@@ -0,0 +1,109 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_20byte {
+  double a;
+  double b;
+  int c;
+} cls_struct_20byte;
+
+static cls_struct_20byte cls_struct_20byte_fn(struct cls_struct_20byte a1,
+			    struct cls_struct_20byte a2)
+{
+  struct cls_struct_20byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%g %g %d %g %g %d: %g %g %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(a1.a == 1);
+  CHECK(a1.b == 2);
+  CHECK(a1.c == 3);
+
+  CHECK(a2.a == 4);
+  CHECK(a2.b == 5);
+  CHECK(a2.c == 7);
+
+  CHECK(result.a == 5);
+  CHECK(result.b == 7);
+  CHECK(result.c == 10);
+  return result;
+}
+
+static void
+cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_20byte a1, a2;
+
+  a1 = *(struct cls_struct_20byte*)(args[0]);
+  a2 = *(struct cls_struct_20byte*)(args[1]);
+
+  *(cls_struct_20byte*)resp = cls_struct_20byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_20byte g_dbl = { 1.0, 2.0, 3 };
+  struct cls_struct_20byte f_dbl = { 4.0, 5.0, 7 };
+  struct cls_struct_20byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_20byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 2 3 4 5 7: 5 7 10" } */
+  printf("res: %g %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 5 7 10" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 7);
+  CHECK(res_dbl.c == 10);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 2 3 4 5 7: 5 7 10" } */
+  printf("res: %g %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 5 7 10" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 7);
+  CHECK(res_dbl.c == 10);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_24byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_24byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_24byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_24byte.c	
@@ -0,0 +1,145 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_24byte {
+  double a;
+  double b;
+  int c;
+  float d;
+} cls_struct_24byte;
+
+cls_struct_24byte cls_struct_24byte_fn(struct cls_struct_24byte b0,
+			    struct cls_struct_24byte b1,
+			    struct cls_struct_24byte b2,
+			    struct cls_struct_24byte b3)
+{
+  struct cls_struct_24byte result;
+
+  result.a = b0.a + b1.a + b2.a + b3.a;
+  result.b = b0.b + b1.b + b2.b + b3.b;
+  result.c = b0.c + b1.c + b2.c + b3.c;
+  result.d = b0.d + b1.d + b2.d + b3.d;
+
+  printf("%g %g %d %g %g %g %d %g %g %g %d %g %g %g %d %g: %g %g %d %g\n",
+	 b0.a, b0.b, b0.c, b0.d,
+	 b1.a, b1.b, b1.c, b1.d,
+	 b2.a, b2.b, b2.c, b2.d,
+	 b3.a, b3.b, b3.c, b3.d,
+	 result.a, result.b, result.c, result.d);
+  CHECK_DOUBLE_EQ(b0.a, 9);
+  CHECK_DOUBLE_EQ(b0.b, 2);
+  CHECK(b0.c == 6);
+  CHECK_FLOAT_EQ(b0.d, 5);
+
+  CHECK_DOUBLE_EQ(b1.a, 1);
+  CHECK_DOUBLE_EQ(b1.b, 2);
+  CHECK(b1.c == 3);
+  CHECK_FLOAT_EQ(b1.d, 7);
+
+  CHECK_DOUBLE_EQ(b2.a, 4);
+  CHECK_DOUBLE_EQ(b2.b, 5);
+  CHECK(b2.c == 7);
+  CHECK_FLOAT_EQ(b2.d, 9);
+
+  CHECK_DOUBLE_EQ(b3.a, 8);
+  CHECK_DOUBLE_EQ(b3.b, 6);
+  CHECK(b3.c == 1);
+  CHECK_FLOAT_EQ(b3.d, 4);
+
+  CHECK_DOUBLE_EQ(result.a, 22);
+  CHECK_DOUBLE_EQ(result.b, 15);
+  CHECK(result.c == 17);
+  CHECK_FLOAT_EQ(result.d, 25);
+
+  return result;
+}
+
+static void
+cls_struct_24byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_24byte b0, b1, b2, b3;
+
+  b0 = *(struct cls_struct_24byte*)(args[0]);
+  b1 = *(struct cls_struct_24byte*)(args[1]);
+  b2 = *(struct cls_struct_24byte*)(args[2]);
+  b3 = *(struct cls_struct_24byte*)(args[3]);
+
+  *(cls_struct_24byte*)resp = cls_struct_24byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_24byte e_dbl = { 9.0, 2.0, 6, 5.0 };
+  struct cls_struct_24byte f_dbl = { 1.0, 2.0, 3, 7.0 };
+  struct cls_struct_24byte g_dbl = { 4.0, 5.0, 7, 9.0 };
+  struct cls_struct_24byte h_dbl = { 8.0, 6.0, 1, 4.0 };
+  struct cls_struct_24byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = &ffi_type_float;
+  cls_struct_fields[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = &cls_struct_type;
+  dbl_arg_types[3] = &cls_struct_type;
+  dbl_arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = &h_dbl;
+  args_dbl[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_24byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 4: 22 15 17 25" } */
+  printf("res: %g %g %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 22 15 17 25" } */
+  CHECK_DOUBLE_EQ(res_dbl.a, 22);
+  CHECK_DOUBLE_EQ(res_dbl.b, 15);
+  CHECK(res_dbl.c == 17);
+  CHECK_FLOAT_EQ(res_dbl.d, 25);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_24byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_24byte(*)(cls_struct_24byte,
+				   cls_struct_24byte,
+				   cls_struct_24byte,
+				   cls_struct_24byte))
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
+  /* { dg-output "\n9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 4: 22 15 17 25" } */
+  printf("res: %g %g %d %g\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 22 15 17 25" } */
+  CHECK_DOUBLE_EQ(res_dbl.a, 22);
+  CHECK_DOUBLE_EQ(res_dbl.b, 15);
+  CHECK(res_dbl.c == 17);
+  CHECK_FLOAT_EQ(res_dbl.d, 25);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_3byte1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_3byte1.c b/libffi-3.4.6/testsuite/libffi.closures/cls_3byte1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_3byte1.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_3byte {
+  unsigned short a;
+  unsigned char b;
+} cls_struct_3byte;
+
+cls_struct_3byte cls_struct_3byte_fn(struct cls_struct_3byte a1,
+			    struct cls_struct_3byte a2)
+{
+  struct cls_struct_3byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+
+  printf("%d %d %d %d: %d %d\n", a1.a, a1.b, a2.a, a2.b, result.a, result.b);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 119);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 15);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 134);
+
+  return  result;
+}
+
+static void
+cls_struct_3byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_3byte a1, a2;
+
+  a1 = *(struct cls_struct_3byte*)(args[0]);
+  a2 = *(struct cls_struct_3byte*)(args[1]);
+
+  *(cls_struct_3byte*)resp = cls_struct_3byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_3byte g_dbl = { 12, 119 };
+  struct cls_struct_3byte f_dbl = { 1, 15 };
+  struct cls_struct_3byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_ushort;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_3byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 119 1 15: 13 134" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 13 134" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 134);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 119 1 15: 13 134" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 13 134" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 134);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_3byte2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_3byte2.c b/libffi-3.4.6/testsuite/libffi.closures/cls_3byte2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_3byte2.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_3byte_1 {
+  unsigned char a;
+  unsigned short b;
+} cls_struct_3byte_1;
+
+cls_struct_3byte_1 cls_struct_3byte_fn1(struct cls_struct_3byte_1 a1,
+			    struct cls_struct_3byte_1 a2)
+{
+  struct cls_struct_3byte_1 result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+
+  printf("%d %d %d %d: %d %d\n", a1.a, a1.b, a2.a, a2.b, result.a, result.b);
+
+  CHECK(a1.a == 15);
+  CHECK(a1.b == 125);
+
+  CHECK(a2.a == 9);
+  CHECK(a2.b == 19);
+
+  CHECK(result.a == 24);
+  CHECK(result.b == 144);
+
+  return  result;
+}
+
+static void
+cls_struct_3byte_gn1(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+
+  struct cls_struct_3byte_1 a1, a2;
+
+  a1 = *(struct cls_struct_3byte_1*)(args[0]);
+  a2 = *(struct cls_struct_3byte_1*)(args[1]);
+
+  *(cls_struct_3byte_1*)resp = cls_struct_3byte_fn1(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_3byte_1 g_dbl = { 15, 125 };
+  struct cls_struct_3byte_1 f_dbl = { 9, 19 };
+  struct cls_struct_3byte_1 res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_3byte_fn1), &res_dbl, args_dbl);
+  /* { dg-output "15 125 9 19: 24 144" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 24 144" } */
+  CHECK(res_dbl.a == 24);
+  CHECK(res_dbl.b == 144);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3byte_gn1, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n15 125 9 19: 24 144" } */
+  printf("res: %d %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 24 144" } */
+  CHECK(res_dbl.a == 24);
+  CHECK(res_dbl.b == 144);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_3float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_3float.c b/libffi-3.4.6/testsuite/libffi.closures/cls_3float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_3float.c	
@@ -0,0 +1,113 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:>none.
+   PR:		none.
+   Originator:	<compnerd@compnerd.org> 20171026	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef struct cls_struct_3float {
+  float f;
+  float g;
+  float h;
+} cls_struct_3float;
+
+cls_struct_3float cls_struct_3float_fn(struct cls_struct_3float a1,
+				       struct cls_struct_3float a2)
+{
+  struct cls_struct_3float result;
+
+  result.f = a1.f + a2.f;
+  result.g = a1.g + a2.g;
+  result.h = a1.h + a2.h;
+
+  printf("%g %g %g %g %g %g: %g %g %g\n", a1.f, a1.g, a1.h,
+	 a2.f, a2.g, a2.h, result.f, result.g, result.h);
+
+  CHECK_FLOAT_EQ(a1.f, 1);
+  CHECK_FLOAT_EQ(a1.g, 2);
+  CHECK_FLOAT_EQ(a1.h, 3);
+
+  CHECK_FLOAT_EQ(a2.f, 1);
+  CHECK_FLOAT_EQ(a2.g, 2);
+  CHECK_FLOAT_EQ(a2.h, 3);
+
+  CHECK_FLOAT_EQ(result.f, 2);
+  CHECK_FLOAT_EQ(result.g, 4);
+  CHECK_FLOAT_EQ(result.h, 6);
+
+  return result;
+}
+
+static void
+cls_struct_3float_gn(ffi_cif *cif __UNUSED__, void* resp, void **args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_3float a1, a2;
+
+  a1 = *(struct cls_struct_3float*)(args[0]);
+  a2 = *(struct cls_struct_3float*)(args[1]);
+
+  *(cls_struct_3float*)resp = cls_struct_3float_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void *args_dbl[3];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_3float g_dbl = { 1.0f, 2.0f, 3.0f };
+  struct cls_struct_3float f_dbl = { 1.0f, 2.0f, 3.0f };
+  struct cls_struct_3float res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_float;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = &ffi_type_float;
+  cls_struct_fields[3] = NULL;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_3float_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 2 3 1 2 3: 2 4 6" } */
+  printf("res: %g %g %g\n", res_dbl.f, res_dbl.g, res_dbl.h);
+  /* { dg-output "\nres: 2 4 6" } */
+  CHECK_FLOAT_EQ(res_dbl.f, 2);
+  CHECK_FLOAT_EQ(res_dbl.g, 4);
+  CHECK_FLOAT_EQ(res_dbl.h, 6);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3float_gn, NULL, code) ==
+	FFI_OK);
+
+  res_dbl = ((cls_struct_3float(*)(cls_struct_3float,
+				   cls_struct_3float))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 2 3 1 2 3: 2 4 6" } */
+  printf("res: %g %g %g\n", res_dbl.f, res_dbl.g, res_dbl.h);
+  /* { dg-output "\nres: 2 4 6" } */
+  CHECK_FLOAT_EQ(res_dbl.f, 2);
+  CHECK_FLOAT_EQ(res_dbl.g, 4);
+  CHECK_FLOAT_EQ(res_dbl.h, 6);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_64byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_64byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_64byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_64byte.c	
@@ -0,0 +1,148 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check bigger struct which overlaps
+		the gp and fp register count on Darwin/AIX/ppc64.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_64byte {
+  double a;
+  double b;
+  double c;
+  double d;
+  double e;
+  double f;
+  double g;
+  double h;
+} cls_struct_64byte;
+
+cls_struct_64byte cls_struct_64byte_fn(struct cls_struct_64byte b0,
+			    struct cls_struct_64byte b1,
+			    struct cls_struct_64byte b2,
+			    struct cls_struct_64byte b3)
+{
+  struct cls_struct_64byte result;
+
+  result.a = b0.a + b1.a + b2.a + b3.a;
+  result.b = b0.b + b1.b + b2.b + b3.b;
+  result.c = b0.c + b1.c + b2.c + b3.c;
+  result.d = b0.d + b1.d + b2.d + b3.d;
+  result.e = b0.e + b1.e + b2.e + b3.e;
+  result.f = b0.f + b1.f + b2.f + b3.f;
+  result.g = b0.g + b1.g + b2.g + b3.g;
+  result.h = b0.h + b1.h + b2.h + b3.h;
+
+  printf("%g %g %g %g %g %g %g %g\n", result.a, result.b, result.c,
+	 result.d, result.e, result.f, result.g, result.h);
+  CHECK(result.a == 22);
+  CHECK(result.b == 15);
+  CHECK(result.c == 17);
+  CHECK(result.d == 25);
+  CHECK(result.e == 6);
+  CHECK(result.f == 13);
+  CHECK(result.g == 19);
+  CHECK(result.h == 18);
+
+  return result;
+}
+
+static void
+cls_struct_64byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_64byte b0, b1, b2, b3;
+
+  b0 = *(struct cls_struct_64byte*)(args[0]);
+  b1 = *(struct cls_struct_64byte*)(args[1]);
+  b2 = *(struct cls_struct_64byte*)(args[2]);
+  b3 = *(struct cls_struct_64byte*)(args[3]);
+
+  *(cls_struct_64byte*)resp = cls_struct_64byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[9];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_64byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0 };
+  struct cls_struct_64byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0 };
+  struct cls_struct_64byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0 };
+  struct cls_struct_64byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0 };
+  struct cls_struct_64byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_double;
+  cls_struct_fields[3] = &ffi_type_double;
+  cls_struct_fields[4] = &ffi_type_double;
+  cls_struct_fields[5] = &ffi_type_double;
+  cls_struct_fields[6] = &ffi_type_double;
+  cls_struct_fields[7] = &ffi_type_double;
+  cls_struct_fields[8] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = &cls_struct_type;
+  dbl_arg_types[3] = &cls_struct_type;
+  dbl_arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = &h_dbl;
+  args_dbl[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_64byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "22 15 17 25 6 13 19 18" } */
+  printf("res: %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);
+  /* { dg-output "\nres: 22 15 17 25 6 13 19 18" } */
+  CHECK(res_dbl.a == 22);
+  CHECK(res_dbl.b == 15);
+  CHECK(res_dbl.c == 17);
+  CHECK(res_dbl.d == 25);
+  CHECK(res_dbl.e == 6);
+  CHECK(res_dbl.f == 13);
+  CHECK(res_dbl.g == 19);
+  CHECK(res_dbl.h == 18);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_64byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_64byte(*)(cls_struct_64byte,
+				   cls_struct_64byte,
+				   cls_struct_64byte,
+				   cls_struct_64byte))
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
+  /* { dg-output "\n22 15 17 25 6 13 19 18" } */
+  printf("res: %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h);
+  /* { dg-output "\nres: 22 15 17 25 6 13 19 18" } */
+  CHECK(res_dbl.a == 22);
+  CHECK(res_dbl.b == 15);
+  CHECK(res_dbl.c == 17);
+  CHECK(res_dbl.d == 25);
+  CHECK(res_dbl.e == 6);
+  CHECK(res_dbl.f == 13);
+  CHECK(res_dbl.g == 19);
+  CHECK(res_dbl.h == 18);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_9byte1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_9byte1.c b/libffi-3.4.6/testsuite/libffi.closures/cls_9byte1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_9byte1.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Darwin/AIX do double-word
+		alignment of the struct if the first element is a double.
+		Check that it does not here.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030914	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_9byte {
+  int a;
+  double b;
+} cls_struct_9byte;
+
+static cls_struct_9byte cls_struct_9byte_fn(struct cls_struct_9byte b1,
+			    struct cls_struct_9byte b2)
+{
+  struct cls_struct_9byte result;
+
+  result.a = b1.a + b2.a;
+  result.b = b1.b + b2.b;
+
+  printf("%d %g %d %g: %d %g\n", b1.a, b1.b,  b2.a, b2.b,
+	 result.a, result.b);
+
+  CHECK(b1.a == 7);
+  CHECK(b1.b == 8);
+
+  CHECK(b2.a == 1);
+  CHECK(b2.b == 9);
+
+  CHECK(result.a == 8);
+  CHECK(result.b == 17);
+
+  return result;
+}
+
+static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				void** args, void* userdata __UNUSED__)
+{
+  struct cls_struct_9byte b1, b2;
+
+  b1 = *(struct cls_struct_9byte*)(args[0]);
+  b2 = *(struct cls_struct_9byte*)(args[1]);
+
+  *(cls_struct_9byte*)resp = cls_struct_9byte_fn(b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_9byte h_dbl = { 7, 8.0};
+  struct cls_struct_9byte j_dbl = { 1, 9.0};
+  struct cls_struct_9byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &h_dbl;
+  args_dbl[1] = &j_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_9byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "7 8 1 9: 8 17" } */
+  printf("res: %d %g\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 8 17" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);
+  /* { dg-output "\n7 8 1 9: 8 17" } */
+  printf("res: %d %g\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 8 17" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_9byte2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_9byte2.c b/libffi-3.4.6/testsuite/libffi.closures/cls_9byte2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_9byte2.c	
@@ -0,0 +1,103 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Darwin/AIX do double-word
+		alignment of the struct if the first element is a double.
+		Check that it does here.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030914	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_9byte {
+  double a;
+  int b;
+} cls_struct_9byte;
+
+static cls_struct_9byte cls_struct_9byte_fn(struct cls_struct_9byte b1,
+			    struct cls_struct_9byte b2)
+{
+  struct cls_struct_9byte result;
+
+  result.a = b1.a + b2.a;
+  result.b = b1.b + b2.b;
+
+  printf("%g %d %g %d: %g %d\n", b1.a, b1.b,  b2.a, b2.b,
+	 result.a, result.b);
+
+  CHECK(b1.a == 7);
+  CHECK(b1.b == 8);
+
+  CHECK(b2.a == 1);
+  CHECK(b2.b == 9);
+
+  CHECK(result.a == 8);
+  CHECK(result.b == 17);
+
+  return result;
+}
+
+static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				void** args, void* userdata __UNUSED__)
+{
+  struct cls_struct_9byte b1, b2;
+
+  b1 = *(struct cls_struct_9byte*)(args[0]);
+  b2 = *(struct cls_struct_9byte*)(args[1]);
+
+  *(cls_struct_9byte*)resp = cls_struct_9byte_fn(b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_9byte h_dbl = { 7.0, 8};
+  struct cls_struct_9byte j_dbl = { 1.0, 9};
+  struct cls_struct_9byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_sint;
+  cls_struct_fields[2] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &h_dbl;
+  args_dbl[1] = &j_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_9byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "7 8 1 9: 8 17" } */
+  printf("res: %g %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 8 17" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_9byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_9byte(*)(cls_struct_9byte, cls_struct_9byte))(code))(h_dbl, j_dbl);
+  /* { dg-output "\n7 8 1 9: 8 17" } */
+  printf("res: %g %d\n", res_dbl.a, res_dbl.b);
+  /* { dg-output "\nres: 8 17" } */
+  CHECK(res_dbl.a == 8);
+  CHECK(res_dbl.b == 17);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_double.c b/libffi-3.4.6/testsuite/libffi.closures/cls_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_double.c	
@@ -0,0 +1,43 @@
+/* Area:	closure_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_double_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+ {
+   *(double *)resp = *(double *)args[0];
+
+   printf("%f: %f\n",*(double *)args[0],
+	  *(double *)resp);
+ }
+typedef double (*cls_ret_double)(double);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  double res;
+
+  cl_arg_types[0] = &ffi_type_double;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_double_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_double)code))(21474.789);
+  /* { dg-output "21474.789000: 21474.789000" } */
+  printf("res: %.6f\n", res);
+  /* { dg-output "\nres: 21474.789000" } */
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_sshort.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_sshort.c b/libffi-3.4.6/testsuite/libffi.closures/cls_sshort.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_sshort.c	
@@ -0,0 +1,45 @@
+/* Area:	closure_call
+   Purpose:	Check return value sshort.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20031108	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_sshort_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(signed short *)args[0];
+  printf("%d: %d\n",*(signed short *)args[0],
+	 (int)*(ffi_arg *)(resp));
+  CHECK(*(signed short *)args[0] == 255);
+  CHECK((int)*(ffi_arg *)(resp) == 255);
+}
+typedef signed short (*cls_ret_sshort)(signed short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  signed short res;
+
+  cl_arg_types[0] = &ffi_type_sshort;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_sshort, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_sshort_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_sshort)code))(255);
+  /* { dg-output "255: 255" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 255" } */
+  CHECK(res == 255);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_ushort.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_ushort.c b/libffi-3.4.6/testsuite/libffi.closures/cls_ushort.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_ushort.c	
@@ -0,0 +1,46 @@
+/* Area:	closure_call
+   Purpose:	Check return value ushort.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void cls_ret_ushort_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(unsigned short *)args[0];
+
+  printf("%d: %d\n",*(unsigned short *)args[0],
+	 (int)*(ffi_arg *)(resp));
+  CHECK(*(unsigned short *)args[0] == 65535);
+  CHECK((int)*(ffi_arg *)(resp) == 65535);
+}
+typedef unsigned short (*cls_ret_ushort)(unsigned short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  unsigned short res;
+
+  cl_arg_types[0] = &ffi_type_ushort;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_ushort, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ushort_fn, NULL, code)  == FFI_OK);
+
+  res = (*((cls_ret_ushort)code))(65535);
+  /* { dg-output "65535: 65535" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 65535" } */
+  CHECK(res == 65535);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn0.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn0.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn0.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn0.c	
@@ -0,0 +1,90 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +
+    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +
+    (int)(*(signed short *)args[4]) +
+    (int)(*(unsigned long long *)args[5]) +
+    (int)*(int *)args[6] + (int)(*(int *)args[7]) +
+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+    (int)(*(int *)args[14]) +  *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]),
+	 (int)(*(unsigned long long *)args[2]),
+	 (int)*(int *)args[3], (int)(*(signed short *)args[4]),
+	 (int)(*(unsigned long long *)args[5]),
+	 (int)*(int *)args[6], (int)(*(int *)args[7]),
+	 (int)(*(double *)args[8]), (int)*(int *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(int *)args[13]),
+	 (int)(*(int *)args[14]),*(int *)args[15],
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 680);
+}
+
+typedef int (*closure_test_type0)(unsigned long long, int, unsigned long long,
+				  int, signed short, unsigned long long, int,
+				  int, double, int, int, float, int, int,
+				  int, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void * code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_uint64;
+  cl_arg_types[1] = &ffi_type_sint;
+  cl_arg_types[2] = &ffi_type_uint64;
+  cl_arg_types[3] = &ffi_type_sint;
+  cl_arg_types[4] = &ffi_type_sshort;
+  cl_arg_types[5] = &ffi_type_uint64;
+  cl_arg_types[6] = &ffi_type_sint;
+  cl_arg_types[7] = &ffi_type_sint;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_sint;
+  cl_arg_types[10] = &ffi_type_sint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_sint;
+  cl_arg_types[14] = &ffi_type_sint;
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*((closure_test_type0)code))
+    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13,
+     19, 21, 1);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  CHECK(res == 680);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn1.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn1.c	
@@ -0,0 +1,83 @@
+/* Area:	closure_call.
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+
+static void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(float *)args[0] +(int)(*(float *)args[1]) +
+    (int)(*(float *)args[2]) + (int)*(float *)args[3] +
+    (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +
+    (int)*(float *)args[6] + (int)(*(int *)args[7]) +
+    (int)(*(double*)args[8]) + (int)*(int *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+    (int)(*(int *)args[14]) + *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(float *)args[0], (int)(*(float *)args[1]),
+	 (int)(*(float *)args[2]), (int)*(float *)args[3],
+	 (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),
+	 (int)*(float *)args[6], (int)(*(int *)args[7]),
+	 (int)(*(double *)args[8]), (int)*(int *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(int *)args[13]),
+	 (int)(*(int *)args[14]), *(int *)args[15],
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 255);
+}
+
+typedef int (*closure_test_type1)(float, float, float, float, signed short,
+				  float, float, int, double, int, int, float,
+				  int, int, int, int);
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_float;
+  cl_arg_types[1] = &ffi_type_float;
+  cl_arg_types[2] = &ffi_type_float;
+  cl_arg_types[3] = &ffi_type_float;
+  cl_arg_types[4] = &ffi_type_sshort;
+  cl_arg_types[5] = &ffi_type_float;
+  cl_arg_types[6] = &ffi_type_float;
+  cl_arg_types[7] = &ffi_type_sint;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_sint;
+  cl_arg_types[10] = &ffi_type_sint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_sint;
+  cl_arg_types[14] = &ffi_type_sint;
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,
+                             (void *) 3 /* userdata */, code)  == FFI_OK);
+
+  res = (*((closure_test_type1)code))
+    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
+     19, 21, 1);
+  /* { dg-output "1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 255" } */
+  CHECK(res == 255);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn2.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn2.c	
@@ -0,0 +1,83 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void closure_test_fn2(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(double *)args[0] +(int)(*(double *)args[1]) +
+    (int)(*(double *)args[2]) + (int)*(double *)args[3] +
+    (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +
+    (int)*(double *)args[6] + (int)(*(int *)args[7]) +
+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(float *)args[13]) +
+    (int)(*(int *)args[14]) + *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(double *)args[0], (int)(*(double *)args[1]),
+	 (int)(*(double *)args[2]), (int)*(double *)args[3],
+	 (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),
+	 (int)*(double *)args[6], (int)(*(int *)args[7]),
+	 (int)(*(double*)args[8]), (int)*(int *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(float *)args[13]),
+	 (int)(*(int *)args[14]), *(int *)args[15], (int)(intptr_t)userdata,
+	 (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 255);
+}
+
+typedef int (*closure_test_type2)(double, double, double, double, signed short,
+				  double, double, int, double, int, int, float,
+				  int, float, int, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_double;
+  cl_arg_types[1] = &ffi_type_double;
+  cl_arg_types[2] = &ffi_type_double;
+  cl_arg_types[3] = &ffi_type_double;
+  cl_arg_types[4] = &ffi_type_sshort;
+  cl_arg_types[5] = &ffi_type_double;
+  cl_arg_types[6] = &ffi_type_double;
+  cl_arg_types[7] = &ffi_type_sint;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_sint;
+  cl_arg_types[10] = &ffi_type_sint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_float;
+  cl_arg_types[14] = &ffi_type_sint;
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn2,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*((closure_test_type2)code))
+    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,
+     19.0, 21, 1);
+  /* { dg-output "1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 255" } */
+  CHECK(res == 255);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn3.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn3.c	
@@ -0,0 +1,102 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void closure_test_fn3(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata)
+ {
+   *(ffi_arg*)resp =
+     (int)*(float *)args[0] +(int)(*(float *)args[1]) +
+     (int)(*(float *)args[2]) + (int)*(float *)args[3] +
+     (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +
+     (int)*(float *)args[6] + (int)(*(float *)args[7]) +
+     (int)(*(double *)args[8]) + (int)*(int *)args[9] +
+     (int)(*(float *)args[10]) + (int)(*(float *)args[11]) +
+     (int)*(int *)args[12] + (int)(*(float *)args[13]) +
+     (int)(*(float *)args[14]) +  *(int *)args[15] + (intptr_t)userdata;
+
+   printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	  (int)*(float *)args[0], (int)(*(float *)args[1]),
+	  (int)(*(float *)args[2]), (int)*(float *)args[3],
+	  (int)(*(float *)args[4]), (int)(*(float *)args[5]),
+	  (int)*(float *)args[6], (int)(*(float *)args[7]),
+	  (int)(*(double *)args[8]), (int)*(int *)args[9],
+	  (int)(*(float *)args[10]), (int)(*(float *)args[11]),
+	  (int)*(int *)args[12], (int)(*(float *)args[13]),
+	  (int)(*(float *)args[14]), *(int *)args[15], (int)(intptr_t)userdata,
+    (int)*(ffi_arg *)resp);
+
+    CHECK((int)*(float *)args[0] == 1);
+    CHECK((int)(*(float *)args[1]) == 2);
+    CHECK((int)(*(float *)args[2]) == 3);
+    CHECK((int)(*(float *)args[3]) == 4);
+    CHECK((int)(*(float *)args[4]) == 5);
+    CHECK((int)(*(float *)args[5]) == 6);
+    CHECK((int)*(float *)args[6] == 7);
+    CHECK((int)(*(float *)args[7]) == 8);
+    CHECK((int)(*(double *)args[8]) == 9);
+    CHECK((int)*(int *)args[9] == 10);
+    CHECK((int)(*(float *)args[10]) == 11);
+    CHECK((int)(*(float *)args[11]) == 12);
+    CHECK((int)*(int *)args[12] == 13);
+    CHECK((int)(*(float *)args[13]) == 19);
+    CHECK((int)(*(float *)args[14]) == 21);
+    CHECK(*(int *)args[15] == 1);
+    CHECK((int)(intptr_t)userdata == 3);
+
+    CHECK((int)*(ffi_arg *)resp == 135);
+ }
+
+typedef int (*closure_test_type3)(float, float, float, float, float, float,
+				  float, float, double, int, float, float, int,
+				  float, float, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_float;
+  cl_arg_types[1] = &ffi_type_float;
+  cl_arg_types[2] = &ffi_type_float;
+  cl_arg_types[3] = &ffi_type_float;
+  cl_arg_types[4] = &ffi_type_float;
+  cl_arg_types[5] = &ffi_type_float;
+  cl_arg_types[6] = &ffi_type_float;
+  cl_arg_types[7] = &ffi_type_float;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_sint;
+  cl_arg_types[10] = &ffi_type_float;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_float;
+  cl_arg_types[14] = &ffi_type_float;
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn3,
+                             (void *) 3 /* userdata */, code)  == FFI_OK);
+
+  res = (*((closure_test_type3)code))
+    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,
+     19.19, 21.21, 1);
+  /* { dg-output "1 2 3 4 5 6 7 8 9 10 11 12 13 19 21 1 3: 135" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 135" } */
+  CHECK(res == 135);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn4.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn4.c	
@@ -0,0 +1,91 @@
+/* Area:	closure_call
+   Purpose:	Check multiple long long values passing.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20031026	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static void
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +
+    (int)*(unsigned long long *)args[2] + (int)*(unsigned long long *)args[3] +
+    (int)*(unsigned long long *)args[4] + (int)*(unsigned long long *)args[5] +
+    (int)*(unsigned long long *)args[6] + (int)*(unsigned long long *)args[7] +
+    (int)*(unsigned long long *)args[8] + (int)*(unsigned long long *)args[9] +
+    (int)*(unsigned long long *)args[10] +
+    (int)*(unsigned long long *)args[11] +
+    (int)*(unsigned long long *)args[12] +
+    (int)*(unsigned long long *)args[13] +
+    (int)*(unsigned long long *)args[14] +
+    *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long *)args[0],
+	 (int)*(unsigned long long *)args[1],
+	 (int)*(unsigned long long *)args[2],
+	 (int)*(unsigned long long *)args[3],
+	 (int)*(unsigned long long *)args[4],
+	 (int)*(unsigned long long *)args[5],
+	 (int)*(unsigned long long *)args[6],
+	 (int)*(unsigned long long *)args[7],
+	 (int)*(unsigned long long *)args[8],
+	 (int)*(unsigned long long *)args[9],
+	 (int)*(unsigned long long *)args[10],
+	 (int)*(unsigned long long *)args[11],
+	 (int)*(unsigned long long *)args[12],
+	 (int)*(unsigned long long *)args[13],
+	 (int)*(unsigned long long *)args[14],
+	 *(int *)args[15],
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 680);
+
+}
+
+typedef int (*closure_test_type0)(unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int i, res;
+
+  for (i = 0; i < 15; i++) {
+    cl_arg_types[i] = &ffi_type_uint64;
+  }
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*((closure_test_type0)code))
+    (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11LL, 12LL,
+     13LL, 19LL, 21LL, 1);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  CHECK(res == 680);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn5.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn5.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn5.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn5.c	
@@ -0,0 +1,94 @@
+/* Area:	closure_call
+   Purpose:	Check multiple long long values passing.
+		Exceed the limit of gpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20031026	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void
+closure_test_fn5(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +
+    (int)*(unsigned long long *)args[2] + (int)*(unsigned long long *)args[3] +
+    (int)*(unsigned long long *)args[4] + (int)*(unsigned long long *)args[5] +
+    (int)*(unsigned long long *)args[6] + (int)*(unsigned long long *)args[7] +
+    (int)*(unsigned long long *)args[8] + (int)*(unsigned long long *)args[9] +
+    (int)*(int *)args[10] +
+    (int)*(unsigned long long *)args[11] +
+    (int)*(unsigned long long *)args[12] +
+    (int)*(unsigned long long *)args[13] +
+    (int)*(unsigned long long *)args[14] +
+    *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long *)args[0],
+	 (int)*(unsigned long long *)args[1],
+	 (int)*(unsigned long long *)args[2],
+	 (int)*(unsigned long long *)args[3],
+	 (int)*(unsigned long long *)args[4],
+	 (int)*(unsigned long long *)args[5],
+	 (int)*(unsigned long long *)args[6],
+	 (int)*(unsigned long long *)args[7],
+	 (int)*(unsigned long long *)args[8],
+	 (int)*(unsigned long long *)args[9],
+	 (int)*(int *)args[10],
+	 (int)*(unsigned long long *)args[11],
+	 (int)*(unsigned long long *)args[12],
+	 (int)*(unsigned long long *)args[13],
+	 (int)*(unsigned long long *)args[14],
+	 *(int *)args[15],
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 680);
+
+}
+
+typedef int (*closure_test_type0)(unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  int, unsigned long long,
+				  unsigned long long, unsigned long long,
+				  unsigned long long, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int i, res;
+
+  for (i = 0; i < 10; i++) {
+    cl_arg_types[i] = &ffi_type_uint64;
+  }
+  cl_arg_types[10] = &ffi_type_sint;
+  for (i = 11; i < 15; i++) {
+    cl_arg_types[i] = &ffi_type_uint64;
+  }
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn5,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*((closure_test_type0)code))
+    (1LL, 2LL, 3LL, 4LL, 127LL, 429LL, 7LL, 8LL, 9LL, 10LL, 11, 12LL,
+     13LL, 19LL, 21LL, 1);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  CHECK(res == 680);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_fn6.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_fn6.c b/libffi-3.4.6/testsuite/libffi.closures/closure_fn6.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_fn6.c	
@@ -0,0 +1,92 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC.
+   Limitations:	none.
+   PR:		PR23404
+   Originator:	<andreast@gcc.gnu.org> 20050830	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] +
+    (int)(*(unsigned long long *)args[1]) +
+    (int)(*(unsigned long long *)args[2]) +
+    (int)*(unsigned long long *)args[3] +
+    (int)(*(int *)args[4]) + (int)(*(double *)args[5]) +
+    (int)*(double *)args[6] + (int)(*(float *)args[7]) +
+    (int)(*(double *)args[8]) + (int)*(double *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+    (int)(*(double *)args[14]) +  (int)*(double *)args[15] +
+    (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long  *)args[0],
+	 (int)(*(unsigned long long  *)args[1]),
+	 (int)(*(unsigned long long  *)args[2]),
+	 (int)*(unsigned long long  *)args[3],
+	 (int)(*(int *)args[4]), (int)(*(double *)args[5]),
+	 (int)*(double *)args[6], (int)(*(float *)args[7]),
+	 (int)(*(double *)args[8]), (int)*(double *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(int *)args[13]),
+	 (int)(*(double *)args[14]), (int)(*(double *)args[15]),
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+  CHECK((int)*(ffi_arg *)resp == 680);
+
+}
+
+typedef int (*closure_test_type0)(unsigned long long,
+				  unsigned long long,
+				  unsigned long long,
+				  unsigned long long,
+				  int, double, double, float, double, double,
+				  int, float, int, int, double, double);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_uint64;
+  cl_arg_types[1] = &ffi_type_uint64;
+  cl_arg_types[2] = &ffi_type_uint64;
+  cl_arg_types[3] = &ffi_type_uint64;
+  cl_arg_types[4] = &ffi_type_sint;
+  cl_arg_types[5] = &ffi_type_double;
+  cl_arg_types[6] = &ffi_type_double;
+  cl_arg_types[7] = &ffi_type_float;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_double;
+  cl_arg_types[10] = &ffi_type_sint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_sint;
+  cl_arg_types[14] = &ffi_type_double;
+  cl_arg_types[15] = &ffi_type_double;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn0,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*((closure_test_type0)code))
+    (1, 2, 3, 4, 127, 429., 7., 8., 9.5, 10., 11, 12., 13,
+     19, 21., 1.);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  CHECK(res == 680);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_1_1byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_1_1byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_1_1byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_1_1byte.c	
@@ -0,0 +1,93 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030902	 */
+
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_1_1byte {
+  unsigned char a;
+} cls_struct_1_1byte;
+
+cls_struct_1_1byte cls_struct_1_1byte_fn(struct cls_struct_1_1byte a1,
+			    struct cls_struct_1_1byte a2)
+{
+  struct cls_struct_1_1byte result;
+
+  result.a = a1.a + a2.a;
+
+  printf("%d %d: %d\n", a1.a, a2.a, result.a);
+  CHECK(a1.a == 12);
+  CHECK(a2.a == 178);
+  CHECK(result.a == 190);
+
+  return  result;
+}
+
+static void
+cls_struct_1_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
+{
+
+  struct cls_struct_1_1byte a1, a2;
+
+  a1 = *(struct cls_struct_1_1byte*)(args[0]);
+  a2 = *(struct cls_struct_1_1byte*)(args[1]);
+
+  *(cls_struct_1_1byte*)resp = cls_struct_1_1byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[2];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_1_1byte g_dbl = { 12 };
+  struct cls_struct_1_1byte f_dbl = { 178 };
+  struct cls_struct_1_1byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_1_1byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 178: 190" } */
+  printf("res: %d\n", res_dbl.a);
+  /* { dg-output "\nres: 190" } */
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_1_1byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 178: 190" } */
+  printf("res: %d\n", res_dbl.a);
+  /* { dg-output "\nres: 190" } */
+  CHECK(res_dbl.a == 190);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_20byte1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_20byte1.c b/libffi-3.4.6/testsuite/libffi.closures/cls_20byte1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_20byte1.c	
@@ -0,0 +1,113 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_20byte {
+  int a;
+  double b;
+  double c;
+} cls_struct_20byte;
+
+static cls_struct_20byte cls_struct_20byte_fn(struct cls_struct_20byte a1,
+			    struct cls_struct_20byte a2)
+{
+  struct cls_struct_20byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %g %g %d %g %g: %d %g %g\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(a1.a == 1);
+  CHECK(a1.b == 2);
+  CHECK(a1.c == 3);
+
+  CHECK(a2.a == 4);
+  CHECK(a2.b == 5);
+  CHECK(a2.c == 7);
+
+  CHECK(result.a == 5);
+  CHECK(result.b == 7);
+  CHECK(result.c == 10);
+
+  return result;
+}
+
+static void
+cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
+{
+  struct cls_struct_20byte a1, a2;
+
+  a1 = *(struct cls_struct_20byte*)(args[0]);
+  a2 = *(struct cls_struct_20byte*)(args[1]);
+
+  *(cls_struct_20byte*)resp = cls_struct_20byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  struct cls_struct_20byte g_dbl = { 1, 2.0, 3.0 };
+  struct cls_struct_20byte f_dbl = { 4, 5.0, 7.0 };
+  struct cls_struct_20byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_double;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_20byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 2 3 4 5 7: 5 7 10" } */
+  printf("res: %d %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 5 7 10" } */
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 7);
+  CHECK(res_dbl.c == 10);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_20byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n1 2 3 4 5 7: 5 7 10" } */
+  printf("res: %d %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 5 7 10" } */
+
+  CHECK(res_dbl.a == 5);
+  CHECK(res_dbl.b == 7);
+  CHECK(res_dbl.c == 10);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_3_1byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_3_1byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_3_1byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_3_1byte.c	
@@ -0,0 +1,114 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030902	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_3_1byte {
+  unsigned char a;
+  unsigned char b;
+  unsigned char c;
+} cls_struct_3_1byte;
+
+cls_struct_3_1byte cls_struct_3_1byte_fn(struct cls_struct_3_1byte a1,
+			    struct cls_struct_3_1byte a2)
+{
+  struct cls_struct_3_1byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c,
+	 a2.a, a2.b, a2.c,
+	 result.a, result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 13);
+  CHECK(a1.c == 14);
+
+  CHECK(a2.a == 178);
+  CHECK(a2.b == 179);
+  CHECK(a2.c == 180);
+
+  CHECK(result.a == 190);
+  CHECK(result.b == 192);
+  CHECK(result.c == 194);
+
+  return  result;
+}
+
+static void
+cls_struct_3_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
+{
+
+  struct cls_struct_3_1byte a1, a2;
+
+  a1 = *(struct cls_struct_3_1byte*)(args[0]);
+  a2 = *(struct cls_struct_3_1byte*)(args[1]);
+
+  *(cls_struct_3_1byte*)resp = cls_struct_3_1byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_3_1byte g_dbl = { 12, 13, 14 };
+  struct cls_struct_3_1byte f_dbl = { 178, 179, 180 };
+  struct cls_struct_3_1byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_3_1byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 13 14 178 179 180: 190 192 194" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 190 192 194" } */
+  CHECK(res_dbl.a == 190);
+  CHECK(res_dbl.b == 192);
+  CHECK(res_dbl.c == 194);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_3_1byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 13 14 178 179 180: 190 192 194" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 190 192 194" } */
+
+  CHECK(res_dbl.a == 190);
+  CHECK(res_dbl.b == 192);
+  CHECK(res_dbl.c == 194);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_4_1byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_4_1byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_4_1byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_4_1byte.c	
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Especially with small structures which may fit in one
+		register. Depending on the ABI.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030902	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_4_1byte {
+  unsigned char a;
+  unsigned char b;
+  unsigned char c;
+  unsigned char d;
+} cls_struct_4_1byte;
+
+cls_struct_4_1byte cls_struct_4_1byte_fn(struct cls_struct_4_1byte a1,
+			    struct cls_struct_4_1byte a2)
+{
+  struct cls_struct_4_1byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+
+  printf("%d %d %d %d %d %d %d %d: %d %d %d %d\n", a1.a, a1.b, a1.c, a1.d,
+	 a2.a, a2.b, a2.c, a2.d,
+	 result.a, result.b, result.c, result.d);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 13);
+  CHECK(a1.c == 14);
+  CHECK(a1.d == 15);
+
+  CHECK(a2.a == 178);
+  CHECK(a2.b == 179);
+  CHECK(a2.c == 180);
+  CHECK(a2.d == 181);
+
+  CHECK(result.a == 190);
+  CHECK(result.b == 192);
+  CHECK(result.c == 194);
+  CHECK(result.d == 196);
+  return  result;
+}
+
+static void
+cls_struct_4_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
+{
+
+  struct cls_struct_4_1byte a1, a2;
+
+  a1 = *(struct cls_struct_4_1byte*)(args[0]);
+  a2 = *(struct cls_struct_4_1byte*)(args[1]);
+
+  *(cls_struct_4_1byte*)resp = cls_struct_4_1byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_4_1byte g_dbl = { 12, 13, 14, 15 };
+  struct cls_struct_4_1byte f_dbl = { 178, 179, 180, 181 };
+  struct cls_struct_4_1byte res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_uchar;
+  cls_struct_fields[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_4_1byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 13 14 15 178 179 180 181: 190 192 194 196" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 190 192 194 196" } */
+  CHECK(res_dbl.a == 190);
+  CHECK(res_dbl.b == 192);
+  CHECK(res_dbl.c == 194);
+  CHECK(res_dbl.d == 196);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_4_1byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 13 14 15 178 179 180 181: 190 192 194 196" } */
+  printf("res: %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c, res_dbl.d);
+  /* { dg-output "\nres: 190 192 194 196" } */
+  CHECK(res_dbl.a == 190);
+  CHECK(res_dbl.b == 192);
+  CHECK(res_dbl.c == 194);
+  CHECK(res_dbl.d == 196);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_pointer.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_pointer.c b/libffi-3.4.6/testsuite/libffi.closures/cls_pointer.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_pointer.c	
@@ -0,0 +1,79 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check pointer arguments.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+void* cls_pointer_fn(void* a1, void* a2)
+{
+	void*	result	= (void*)((intptr_t)a1 + (intptr_t)a2);
+
+	printf("0x%08x 0x%08x: 0x%08x\n", 
+	       (unsigned int)(uintptr_t) a1,
+               (unsigned int)(uintptr_t) a2,
+               (unsigned int)(uintptr_t) result);
+
+	CHECK((unsigned int)(uintptr_t) a1 == 0x12345678);
+	CHECK((unsigned int)(uintptr_t) a2 == 0x89abcdef);
+	CHECK((unsigned int)(uintptr_t) result == 0x9be02467);
+
+	return result;
+}
+
+static void
+cls_pointer_gn(ffi_cif* cif __UNUSED__, void* resp, 
+	       void** args, void* userdata __UNUSED__)
+{
+	void*	a1	= *(void**)(args[0]);
+	void*	a2	= *(void**)(args[1]);
+
+	*(void**)resp = cls_pointer_fn(a1, a2);
+}
+
+int main (void)
+{
+	ffi_cif	cif;
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void*			args[3];
+	/*	ffi_type		cls_pointer_type; */
+	ffi_type*		arg_types[3];
+
+/*	cls_pointer_type.size = sizeof(void*);
+	cls_pointer_type.alignment = 0;
+	cls_pointer_type.type = FFI_TYPE_POINTER;
+	cls_pointer_type.elements = NULL;*/
+
+	void*	arg1	= (void*)0x12345678;
+	void*	arg2	= (void*)0x89abcdef;
+	ffi_arg	res		= 0;
+
+	arg_types[0] = &ffi_type_pointer;
+	arg_types[1] = &ffi_type_pointer;
+	arg_types[2] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_pointer,
+		arg_types) == FFI_OK);
+
+	args[0] = &arg1;
+	args[1] = &arg2;
+	args[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_pointer_fn), &res, args);
+	/* { dg-output "0x12345678 0x89abcdef: 0x9be02467" } */
+	printf("res: 0x%08x\n", (unsigned int) res);
+	/* { dg-output "\nres: 0x9be02467" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
+
+	res = (ffi_arg)(uintptr_t)((void*(*)(void*, void*))(code))(arg1, arg2);
+	/* { dg-output "\n0x12345678 0x89abcdef: 0x9be02467" } */
+	printf("res: 0x%08x\n", (unsigned int) res);
+	/* { dg-output "\nres: 0x9be02467" } */
+	CHECK(res == 0x9be02467);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_uint_va.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_uint_va.c b/libffi-3.4.6/testsuite/libffi.closures/cls_uint_va.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_uint_va.c	
@@ -0,0 +1,49 @@
+/* Area:	closure_call
+   Purpose:	Test anonymous unsigned int argument.
+   Limitations:	none.
+   PR:		none.
+   Originator:	ARM Ltd. */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef unsigned int T;
+
+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			 void* userdata __UNUSED__)
+ {
+   *(ffi_arg *)resp = *(T *)args[0];
+
+   printf("%d: %d %d\n", (int)*(ffi_arg *)resp, *(T *)args[0], *(T *)args[1]);
+   CHECK(*(T *)args[0] == 67);
+   CHECK(*(T *)args[1] == 4);
+   CHECK((int)*(ffi_arg *)resp == 67);
+ }
+
+typedef T (*cls_ret_T)(T, ...);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[3];
+  T res;
+
+  cl_arg_types[0] = &ffi_type_uint;
+  cl_arg_types[1] = &ffi_type_uint;
+  cl_arg_types[2] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,
+			 &ffi_type_uint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);
+  res = ((((cls_ret_T)code)(67, 4)));
+  /* { dg-output "67: 67 4" } */
+  printf("res: %d\n", res);
+  /* { dg-output "\nres: 67" } */
+  CHECK(res == 67);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/err_bad_abi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/err_bad_abi.c b/libffi-3.4.6/testsuite/libffi.closures/err_bad_abi.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/err_bad_abi.c	
@@ -0,0 +1,36 @@
+/* Area:		ffi_prep_cif, ffi_prep_closure
+   Purpose:		Test error return for bad ABIs.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+static void
+dummy_fn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__, 
+	 void** args __UNUSED__, void* userdata __UNUSED__)
+{}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	ffi_type* arg_types[1];
+
+	arg_types[0] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, 255, 0, &ffi_type_void,
+		arg_types) == FFI_BAD_ABI);
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0, &ffi_type_void,
+		arg_types) == FFI_OK);
+
+	cif.abi= 255;
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, dummy_fn, NULL, code) == FFI_BAD_ABI);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/huge_struct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/huge_struct.c b/libffi-3.4.6/testsuite/libffi.closures/huge_struct.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/huge_struct.c	
@@ -0,0 +1,343 @@
+/*	Area:			ffi_call, closure_call
+	Purpose:		Check large structure returns.
+	Limitations:	none.
+	PR:				none.
+	Originator:		Blake Chaffin	6/18/2007
+*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-options -mlong-double-128 { target powerpc64*-*-linux-gnu* } } */
+/* { dg-options -Wformat=0 { target moxie*-*-elf or1k-*-* } } */
+
+#include <inttypes.h>
+
+#include "ffitest.h"
+
+typedef	struct BigStruct{
+	uint8_t		a;
+	int8_t		b;
+	uint16_t	c;
+	int16_t		d;
+	uint32_t	e;
+	int32_t		f;
+	uint64_t	g;
+	int64_t		h;
+	float		i;
+	double		j;
+	long double	k;
+	char*		l;
+	uint8_t		m;
+	int8_t		n;
+	uint16_t	o;
+	int16_t		p;
+	uint32_t	q;
+	int32_t		r;
+	uint64_t	s;
+	int64_t		t;
+	float		u;
+	double		v;
+	long double	w;
+	char*		x;
+	uint8_t		y;
+	int8_t		z;
+	uint16_t	aa;
+	int16_t		bb;
+	uint32_t	cc;
+	int32_t		dd;
+	uint64_t	ee;
+	int64_t		ff;
+	float		gg;
+	double		hh;
+	long double	ii;
+	char*		jj;
+	uint8_t		kk;
+	int8_t		ll;
+	uint16_t	mm;
+	int16_t		nn;
+	uint32_t	oo;
+	int32_t		pp;
+	uint64_t	qq;
+	int64_t		rr;
+	float		ss;
+	double		tt;
+	long double	uu;
+	char*		vv;
+	uint8_t		ww;
+	int8_t		xx;
+} BigStruct;
+
+BigStruct
+test_large_fn(
+	uint8_t		ui8_1,
+	int8_t		si8_1,
+	uint16_t	ui16_1,
+	int16_t		si16_1,
+	uint32_t	ui32_1,
+	int32_t		si32_1,
+	uint64_t	ui64_1,
+	int64_t		si64_1,
+	float		f_1,
+	double		d_1,
+	long double	ld_1,
+	char*		p_1,
+	uint8_t		ui8_2,
+	int8_t		si8_2,
+	uint16_t	ui16_2,
+	int16_t		si16_2,
+	uint32_t	ui32_2,
+	int32_t		si32_2,
+	uint64_t	ui64_2,
+	int64_t		si64_2,
+	float		f_2,
+	double		d_2,
+	long double	ld_2,
+	char*		p_2,
+	uint8_t		ui8_3,
+	int8_t		si8_3,
+	uint16_t	ui16_3,
+	int16_t		si16_3,
+	uint32_t	ui32_3,
+	int32_t		si32_3,
+	uint64_t	ui64_3,
+	int64_t		si64_3,
+	float		f_3,
+	double		d_3,
+	long double	ld_3,
+	char*		p_3,
+	uint8_t		ui8_4,
+	int8_t		si8_4,
+	uint16_t	ui16_4,
+	int16_t		si16_4,
+	uint32_t	ui32_4,
+	int32_t		si32_4,
+	uint64_t	ui64_4,
+	int64_t		si64_4,
+	float		f_4,
+	double		d_4,
+	long double	ld_4,
+	char*		p_4,
+	uint8_t		ui8_5,
+	int8_t		si8_5)
+{
+	BigStruct	retVal	= {
+		ui8_1 + 1, si8_1 + 1, ui16_1 + 1, si16_1 + 1, ui32_1 + 1, si32_1 + 1,
+			ui64_1 + 1, si64_1 + 1, f_1 + 1, d_1 + 1, ld_1 + 1, (char*)((intptr_t)p_1 + 1),
+		ui8_2 + 2, si8_2 + 2, ui16_2 + 2, si16_2 + 2, ui32_2 + 2, si32_2 + 2,
+			ui64_2 + 2, si64_2 + 2, f_2 + 2, d_2 + 2, ld_2 + 2, (char*)((intptr_t)p_2 + 2),
+		ui8_3 + 3, si8_3 + 3, ui16_3 + 3, si16_3 + 3, ui32_3 + 3, si32_3 + 3,
+			ui64_3 + 3, si64_3 + 3, f_3 + 3, d_3 + 3, ld_3 + 3, (char*)((intptr_t)p_3 + 3),
+		ui8_4 + 4, si8_4 + 4, ui16_4 + 4, si16_4 + 4, ui32_4 + 4, si32_4 + 4,
+			ui64_4 + 4, si64_4 + 4, f_4 + 4, d_4 + 4, ld_4 + 4, (char*)((intptr_t)p_4 + 4),
+		ui8_5 + 5, si8_5 + 5};
+
+	printf("%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx %" PRIu8 " %" PRId8 ": "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx %" PRIu8 " %" PRId8 "\n",
+	       ui8_1, si8_1, ui16_1, si16_1, ui32_1, si32_1, ui64_1, si64_1, f_1, d_1, ld_1, (long)(intptr_t)p_1,
+		ui8_2, si8_2, ui16_2, si16_2, ui32_2, si32_2, ui64_2, si64_2, f_2, d_2, ld_2, (long)(intptr_t)p_2,
+		ui8_3, si8_3, ui16_3, si16_3, ui32_3, si32_3, ui64_3, si64_3, f_3, d_3, ld_3, (long)(intptr_t)p_3,
+		ui8_4, si8_4, ui16_4, si16_4, ui32_4, si32_4, ui64_4, si64_4, f_4, d_4, ld_4, (long)(intptr_t)p_4, ui8_5, si8_5,
+		retVal.a, retVal.b, retVal.c, retVal.d, retVal.e, retVal.f,
+	       retVal.g, retVal.h, retVal.i, retVal.j, retVal.k, (long)(intptr_t)retVal.l,
+		retVal.m, retVal.n, retVal.o, retVal.p, retVal.q, retVal.r,
+	       retVal.s, retVal.t, retVal.u, retVal.v, retVal.w, (long)(intptr_t)retVal.x,
+		retVal.y, retVal.z, retVal.aa, retVal.bb, retVal.cc, retVal.dd,
+	       retVal.ee, retVal.ff, retVal.gg, retVal.hh, retVal.ii, (long)(intptr_t)retVal.jj,
+		retVal.kk, retVal.ll, retVal.mm, retVal.nn, retVal.oo, retVal.pp,
+	       retVal.qq, retVal.rr, retVal.ss, retVal.tt, retVal.uu, (long)(intptr_t)retVal.vv, retVal.ww, retVal.xx);
+
+	return	retVal;
+}
+
+static void
+cls_large_fn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
+{
+	uint8_t		ui8_1	= *(uint8_t*)args[0];
+	int8_t		si8_1	= *(int8_t*)args[1];
+	uint16_t	ui16_1	= *(uint16_t*)args[2];
+	int16_t		si16_1	= *(int16_t*)args[3];
+	uint32_t	ui32_1	= *(uint32_t*)args[4];
+	int32_t		si32_1	= *(int32_t*)args[5];
+	uint64_t	ui64_1	= *(uint64_t*)args[6];
+	int64_t		si64_1	= *(int64_t*)args[7];
+	float		f_1		= *(float*)args[8];
+	double		d_1		= *(double*)args[9];
+	long double	ld_1	= *(long double*)args[10];
+	char*		p_1		= *(char**)args[11];
+	uint8_t		ui8_2	= *(uint8_t*)args[12];
+	int8_t		si8_2	= *(int8_t*)args[13];
+	uint16_t	ui16_2	= *(uint16_t*)args[14];
+	int16_t		si16_2	= *(int16_t*)args[15];
+	uint32_t	ui32_2	= *(uint32_t*)args[16];
+	int32_t		si32_2	= *(int32_t*)args[17];
+	uint64_t	ui64_2	= *(uint64_t*)args[18];
+	int64_t		si64_2	= *(int64_t*)args[19];
+	float		f_2		= *(float*)args[20];
+	double		d_2		= *(double*)args[21];
+	long double	ld_2	= *(long double*)args[22];
+	char*		p_2		= *(char**)args[23];
+	uint8_t		ui8_3	= *(uint8_t*)args[24];
+	int8_t		si8_3	= *(int8_t*)args[25];
+	uint16_t	ui16_3	= *(uint16_t*)args[26];
+	int16_t		si16_3	= *(int16_t*)args[27];
+	uint32_t	ui32_3	= *(uint32_t*)args[28];
+	int32_t		si32_3	= *(int32_t*)args[29];
+	uint64_t	ui64_3	= *(uint64_t*)args[30];
+	int64_t		si64_3	= *(int64_t*)args[31];
+	float		f_3		= *(float*)args[32];
+	double		d_3		= *(double*)args[33];
+	long double	ld_3	= *(long double*)args[34];
+	char*		p_3		= *(char**)args[35];
+	uint8_t		ui8_4	= *(uint8_t*)args[36];
+	int8_t		si8_4	= *(int8_t*)args[37];
+	uint16_t	ui16_4	= *(uint16_t*)args[38];
+	int16_t		si16_4	= *(int16_t*)args[39];
+	uint32_t	ui32_4	= *(uint32_t*)args[40];
+	int32_t		si32_4	= *(int32_t*)args[41];
+	uint64_t	ui64_4	= *(uint64_t*)args[42];
+	int64_t		si64_4	= *(int64_t*)args[43];
+	float		f_4		= *(float*)args[44];
+	double		d_4		= *(double*)args[45];
+	long double	ld_4	= *(long double*)args[46];
+	char*		p_4		= *(char**)args[47];
+	uint8_t		ui8_5	= *(uint8_t*)args[48];
+	int8_t		si8_5	= *(int8_t*)args[49];
+
+	*(BigStruct*)resp = test_large_fn(
+		ui8_1, si8_1, ui16_1, si16_1, ui32_1, si32_1, ui64_1, si64_1, f_1, d_1, ld_1, p_1,
+		ui8_2, si8_2, ui16_2, si16_2, ui32_2, si32_2, ui64_2, si64_2, f_2, d_2, ld_2, p_2,
+		ui8_3, si8_3, ui16_3, si16_3, ui32_3, si32_3, ui64_3, si64_3, f_3, d_3, ld_3, p_3,
+		ui8_4, si8_4, ui16_4, si16_4, ui32_4, si32_4, ui64_4, si64_4, f_4, d_4, ld_4, p_4,
+		ui8_5, si8_5);
+}
+
+int
+main(int argc __UNUSED__, const char** argv __UNUSED__)
+{
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+
+	ffi_cif		cif;
+	ffi_type*	argTypes[51];
+	void*		argValues[51];
+
+	ffi_type	ret_struct_type;
+	ffi_type*	st_fields[51];
+	BigStruct	retVal;
+
+	uint8_t		ui8		= 1;
+	int8_t		si8		= 2;
+	uint16_t	ui16	= 3;
+	int16_t		si16	= 4;
+	uint32_t	ui32	= 5;
+	int32_t		si32	= 6;
+	uint64_t	ui64	= 7;
+	int64_t		si64	= 8;
+	float		f		= 9;
+	double		d		= 10;
+	long double	ld		= 11;
+	char*		p		= (char*)0x12345678;
+
+	memset (&retVal, 0, sizeof(retVal));
+
+	ret_struct_type.size = 0;
+	ret_struct_type.alignment = 0;
+	ret_struct_type.type = FFI_TYPE_STRUCT;
+	ret_struct_type.elements = st_fields;
+
+	st_fields[0]	= st_fields[12]	= st_fields[24]	= st_fields[36]	= st_fields[48]	= &ffi_type_uint8;
+	st_fields[1]	= st_fields[13]	= st_fields[25]	= st_fields[37]	= st_fields[49]	= &ffi_type_sint8;
+	st_fields[2]	= st_fields[14]	= st_fields[26]	= st_fields[38]	= &ffi_type_uint16;
+	st_fields[3]	= st_fields[15]	= st_fields[27]	= st_fields[39]	= &ffi_type_sint16;
+	st_fields[4]	= st_fields[16]	= st_fields[28]	= st_fields[40]	= &ffi_type_uint32;
+	st_fields[5]	= st_fields[17]	= st_fields[29]	= st_fields[41]	= &ffi_type_sint32;
+	st_fields[6]	= st_fields[18]	= st_fields[30]	= st_fields[42]	= &ffi_type_uint64;
+	st_fields[7]	= st_fields[19]	= st_fields[31]	= st_fields[43]	= &ffi_type_sint64;
+	st_fields[8]	= st_fields[20]	= st_fields[32]	= st_fields[44]	= &ffi_type_float;
+	st_fields[9]	= st_fields[21]	= st_fields[33]	= st_fields[45]	= &ffi_type_double;
+	st_fields[10]	= st_fields[22]	= st_fields[34]	= st_fields[46]	= &ffi_type_longdouble;
+	st_fields[11]	= st_fields[23]	= st_fields[35]	= st_fields[47]	= &ffi_type_pointer;
+
+	st_fields[50] = NULL;
+
+	argTypes[0]		= argTypes[12]	= argTypes[24]	= argTypes[36]	= argTypes[48]	= &ffi_type_uint8;
+	argValues[0]	= argValues[12]	= argValues[24]	= argValues[36]	= argValues[48]	= &ui8;
+	argTypes[1]		= argTypes[13]	= argTypes[25]	= argTypes[37]	= argTypes[49]	= &ffi_type_sint8;
+	argValues[1]	= argValues[13]	= argValues[25]	= argValues[37]	= argValues[49]	= &si8;
+	argTypes[2]		= argTypes[14]	= argTypes[26]	= argTypes[38]	= &ffi_type_uint16;
+	argValues[2]	= argValues[14]	= argValues[26]	= argValues[38]	= &ui16;
+	argTypes[3]		= argTypes[15]	= argTypes[27]	= argTypes[39]	= &ffi_type_sint16;
+	argValues[3]	= argValues[15]	= argValues[27]	= argValues[39]	= &si16;
+	argTypes[4]		= argTypes[16]	= argTypes[28]	= argTypes[40]	= &ffi_type_uint32;
+	argValues[4]	= argValues[16]	= argValues[28]	= argValues[40]	= &ui32;
+	argTypes[5]		= argTypes[17]	= argTypes[29]	= argTypes[41]	= &ffi_type_sint32;
+	argValues[5]	= argValues[17]	= argValues[29]	= argValues[41]	= &si32;
+	argTypes[6]		= argTypes[18]	= argTypes[30]	= argTypes[42]	= &ffi_type_uint64;
+	argValues[6]	= argValues[18]	= argValues[30]	= argValues[42]	= &ui64;
+	argTypes[7]		= argTypes[19]	= argTypes[31]	= argTypes[43]	= &ffi_type_sint64;
+	argValues[7]	= argValues[19]	= argValues[31]	= argValues[43]	= &si64;
+	argTypes[8]		= argTypes[20]	= argTypes[32]	= argTypes[44]	= &ffi_type_float;
+	argValues[8]	= argValues[20]	= argValues[32]	= argValues[44]	= &f;
+	argTypes[9]		= argTypes[21]	= argTypes[33]	= argTypes[45]	= &ffi_type_double;
+	argValues[9]	= argValues[21]	= argValues[33]	= argValues[45]	= &d;
+	argTypes[10]	= argTypes[22]	= argTypes[34]	= argTypes[46]	= &ffi_type_longdouble;
+	argValues[10]	= argValues[22]	= argValues[34]	= argValues[46]	= &ld;
+	argTypes[11]	= argTypes[23]	= argTypes[35]	= argTypes[47]	= &ffi_type_pointer;
+	argValues[11]	= argValues[23]	= argValues[35]	= argValues[47]	= &p;
+
+	argTypes[50]	= NULL;
+	argValues[50]	= NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 50, &ret_struct_type, argTypes) == FFI_OK);
+
+	ffi_call(&cif, FFI_FN(test_large_fn), &retVal, argValues);
+	/* { dg-output "1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" } */
+	printf("res: %" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx %" PRIu8 " %" PRId8 "\n",
+		retVal.a, retVal.b, retVal.c, retVal.d, retVal.e, retVal.f,
+	       retVal.g, retVal.h, retVal.i, retVal.j, retVal.k, (long)(intptr_t)retVal.l,
+		retVal.m, retVal.n, retVal.o, retVal.p, retVal.q, retVal.r,
+	       retVal.s, retVal.t, retVal.u, retVal.v, retVal.w, (long)(intptr_t)retVal.x,
+		retVal.y, retVal.z, retVal.aa, retVal.bb, retVal.cc, retVal.dd,
+	       retVal.ee, retVal.ff, retVal.gg, retVal.hh, retVal.ii, (long)(intptr_t)retVal.jj,
+		retVal.kk, retVal.ll, retVal.mm, retVal.nn, retVal.oo, retVal.pp,
+	       retVal.qq, retVal.rr, retVal.ss, retVal.tt, retVal.uu, (long)(intptr_t)retVal.vv, retVal.ww, retVal.xx);
+	/* { dg-output "\nres: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_large_fn, NULL, code) == FFI_OK);
+
+	retVal	= ((BigStruct(*)(
+		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
+		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
+		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
+		uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, long double, char*,
+		uint8_t, int8_t))(code))(
+		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
+		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
+		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
+		ui8, si8, ui16, si16, ui32, si32, ui64, si64, f, d, ld, p,
+		ui8, si8);
+	/* { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2 3 4 5 6 7 8 9 10 11 0x12345678 1 2: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" } */
+	printf("res: %" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx "
+		"%" PRIu8 " %" PRId8 " %hu %hd %u %d %" PRIu64 " %" PRId64 " %.0f %.0f %.0Lf %#lx %" PRIu8 " %" PRId8 "\n",
+		retVal.a, retVal.b, retVal.c, retVal.d, retVal.e, retVal.f,
+	       retVal.g, retVal.h, retVal.i, retVal.j, retVal.k, (long)(intptr_t)retVal.l,
+		retVal.m, retVal.n, retVal.o, retVal.p, retVal.q, retVal.r,
+	       retVal.s, retVal.t, retVal.u, retVal.v, retVal.w, (long)(intptr_t)retVal.x,
+		retVal.y, retVal.z, retVal.aa, retVal.bb, retVal.cc, retVal.dd,
+	       retVal.ee, retVal.ff, retVal.gg, retVal.hh, retVal.ii, (long)(intptr_t)retVal.jj,
+		retVal.kk, retVal.ll, retVal.mm, retVal.nn, retVal.oo, retVal.pp,
+	       retVal.qq, retVal.rr, retVal.ss, retVal.tt, retVal.uu, (long)(intptr_t)retVal.vv, retVal.ww, retVal.xx);
+	/* { dg-output "\nres: 2 3 4 5 6 7 8 9 10 11 12 0x12345679 3 4 5 6 7 8 9 10 11 12 13 0x1234567a 4 5 6 7 8 9 10 11 12 13 14 0x1234567b 5 6 7 8 9 10 11 12 13 14 15 0x1234567c 6 7" } */
+
+    return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.closures/stret_large.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/stret_large.c b/libffi-3.4.6/testsuite/libffi.closures/stret_large.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/stret_large.c	
@@ -0,0 +1,145 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check structure returning with different structure size.
+				Depending on the ABI. Check bigger struct which overlaps
+				the gp and fp register count on Darwin/AIX/ppc64.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin	6/21/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-*  } } */
+#include "ffitest.h"
+
+/* 13 FPRs: 104 bytes */
+/* 14 FPRs: 112 bytes */
+
+typedef struct struct_108byte {
+	double a;
+	double b;
+	double c;
+	double d;
+	double e;
+	double f;
+	double g;
+	double h;
+	double i;
+	double j;
+	double k;
+	double l;
+	double m;
+	int n;
+} struct_108byte;
+
+struct_108byte cls_struct_108byte_fn(
+	struct_108byte b0,
+	struct_108byte b1,
+	struct_108byte b2,
+	struct_108byte b3)
+{
+	struct_108byte	result;
+
+	result.a = b0.a + b1.a + b2.a + b3.a;
+	result.b = b0.b + b1.b + b2.b + b3.b;
+	result.c = b0.c + b1.c + b2.c + b3.c;
+	result.d = b0.d + b1.d + b2.d + b3.d;
+	result.e = b0.e + b1.e + b2.e + b3.e;
+	result.f = b0.f + b1.f + b2.f + b3.f;
+	result.g = b0.g + b1.g + b2.g + b3.g;
+	result.h = b0.h + b1.h + b2.h + b3.h;
+	result.i = b0.i + b1.i + b2.i + b3.i;
+	result.j = b0.j + b1.j + b2.j + b3.j;
+	result.k = b0.k + b1.k + b2.k + b3.k;
+	result.l = b0.l + b1.l + b2.l + b3.l;
+	result.m = b0.m + b1.m + b2.m + b3.m;
+	result.n = b0.n + b1.n + b2.n + b3.n;
+
+	printf("%g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", result.a, result.b, result.c,
+		result.d, result.e, result.f, result.g, result.h, result.i,
+		result.j, result.k, result.l, result.m, result.n);
+
+	return result;
+}
+
+static void
+cls_struct_108byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
+{
+	struct_108byte	b0, b1, b2, b3;
+
+	b0 = *(struct_108byte*)(args[0]);
+	b1 = *(struct_108byte*)(args[1]);
+	b2 = *(struct_108byte*)(args[2]);
+	b3 = *(struct_108byte*)(args[3]);
+
+	*(struct_108byte*)resp = cls_struct_108byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[5];
+	ffi_type* cls_struct_fields[15];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[5];
+
+	struct_108byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 1.0, 2.0, 3.0, 7.0, 2.0, 7 };
+	struct_108byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0, 5.0, 7.0, 9.0, 1.0, 4 };
+	struct_108byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 8.0, 6.0, 1.0, 4.0, 0.0, 3 };
+	struct_108byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 9.0, 2.0, 6.0, 5.0, 3.0, 2 };
+	struct_108byte res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_double;
+	cls_struct_fields[1] = &ffi_type_double;
+	cls_struct_fields[2] = &ffi_type_double;
+	cls_struct_fields[3] = &ffi_type_double;
+	cls_struct_fields[4] = &ffi_type_double;
+	cls_struct_fields[5] = &ffi_type_double;
+	cls_struct_fields[6] = &ffi_type_double;
+	cls_struct_fields[7] = &ffi_type_double;
+	cls_struct_fields[8] = &ffi_type_double;
+	cls_struct_fields[9] = &ffi_type_double;
+	cls_struct_fields[10] = &ffi_type_double;
+	cls_struct_fields[11] = &ffi_type_double;
+	cls_struct_fields[12] = &ffi_type_double;
+	cls_struct_fields[13] = &ffi_type_sint32;
+	cls_struct_fields[14] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = &cls_struct_type;
+	dbl_arg_types[3] = &cls_struct_type;
+	dbl_arg_types[4] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &e_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = &g_dbl;
+	args_dbl[3] = &h_dbl;
+	args_dbl[4] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_108byte_fn), &res_dbl, args_dbl);
+	/* { dg-output "22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
+		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_108byte_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((struct_108byte(*)(struct_108byte, struct_108byte,
+		struct_108byte, struct_108byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
+	/* { dg-output "\n22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
+		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 16" } */
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/testclosure.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/testclosure.c b/libffi-3.4.6/testsuite/libffi.closures/testclosure.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/testclosure.c	
@@ -0,0 +1,75 @@
+/* Area:	closure_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		41908.
+   Originator:	<rfm@gnu.org> 20091102	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_combined {
+  float a;
+  float b;
+  float c;
+  float d;
+} cls_struct_combined;
+
+static void cls_struct_combined_fn(struct cls_struct_combined arg)
+{
+  printf("%g %g %g %g\n",
+	 arg.a, arg.b,
+	 arg.c, arg.d);
+  fflush(stdout);
+
+  CHECK_FLOAT_EQ(arg.a, 4);
+  CHECK_FLOAT_EQ(arg.b, 5);
+  CHECK_FLOAT_EQ(arg.c, 1);
+  CHECK_FLOAT_EQ(arg.d, 8);
+}
+
+static void
+cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+        void** args, void* userdata __UNUSED__)
+{
+  struct cls_struct_combined a0;
+
+  a0 = *(struct cls_struct_combined*)(args[0]);
+
+  cls_struct_combined_fn(a0);
+}
+
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type* cls_struct_fields0[5];
+  ffi_type cls_struct_type0;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_combined g_dbl = {4.0, 5.0, 1.0, 8.0};
+
+  cls_struct_type0.size = 0;
+  cls_struct_type0.alignment = 0;
+  cls_struct_type0.type = FFI_TYPE_STRUCT;
+  cls_struct_type0.elements = cls_struct_fields0;
+
+  cls_struct_fields0[0] = &ffi_type_float;
+  cls_struct_fields0[1] = &ffi_type_float;
+  cls_struct_fields0[2] = &ffi_type_float;
+  cls_struct_fields0[3] = &ffi_type_float;
+  cls_struct_fields0[4] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type0;
+  dbl_arg_types[1] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ffi_type_void,
+		     dbl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);
+
+  ((void(*)(cls_struct_combined)) (code))(g_dbl);
+  /* { dg-output "4 5 1 8" } */
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/unwindtest.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/unwindtest.cc b/libffi-3.4.6/testsuite/libffi.closures/unwindtest.cc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/unwindtest.cc	
@@ -0,0 +1,118 @@
+/* Area:	ffi_closure, unwind info
+   Purpose:	Check if the unwind information is passed correctly.
+   Limitations:	none.
+   PR:		none.
+   Originator:	Jeff Sturm <jsturm@one-point.com>  */
+
+/* { dg-do run { xfail moxie*-*-* } } */
+
+#include "ffitest.h"
+
+void ABI_ATTR
+closure_test_fn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+		void** args __UNUSED__, void* userdata __UNUSED__)
+{
+  throw 9;
+}
+
+typedef void (*closure_test_type)();
+
+void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp,
+		      void** args, void* userdata __UNUSED__)
+ {
+    *(ffi_arg*)resp =
+      (int)*(float *)args[0] +(int)(*(float *)args[1]) +
+      (int)(*(float *)args[2]) + (int)*(float *)args[3] +
+      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +
+      (int)*(float *)args[6] + (int)(*(int *)args[7]) +
+      (int)(*(double*)args[8]) + (int)*(int *)args[9] +
+      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+      (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(intptr_t)userdata;
+
+    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	   (int)*(float *)args[0], (int)(*(float *)args[1]),
+	   (int)(*(float *)args[2]), (int)*(float *)args[3],
+	   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),
+	   (int)*(float *)args[6], (int)(*(int *)args[7]),
+	   (int)(*(double *)args[8]), (int)*(int *)args[9],
+	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	   (int)*(int *)args[12], (int)(*(int *)args[13]),
+	   (int)(*(int *)args[14]), *(int *)args[15],
+	   (int)(intptr_t)userdata, (int)*(ffi_arg*)resp);
+
+    throw (int)*(ffi_arg*)resp;
+}
+
+typedef int (*closure_test_type1)(float, float, float, float, signed short,
+				  float, float, int, double, int, int, float,
+				  int, int, int, int);
+
+extern "C"
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = (ffi_closure *)ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+
+  {
+    cl_arg_types[1] = NULL;
+
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0,
+		       &ffi_type_void, cl_arg_types) == FFI_OK);
+    CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn, NULL, code) == FFI_OK);
+
+    try
+      {
+	(*((closure_test_type)(code)))();
+      } catch (int exception_code)
+      {
+	CHECK(exception_code == 9);
+      }
+
+    printf("part one OK\n");
+    /* { dg-output "part one OK" } */
+    }
+
+    {
+
+      cl_arg_types[0] = &ffi_type_float;
+      cl_arg_types[1] = &ffi_type_float;
+      cl_arg_types[2] = &ffi_type_float;
+      cl_arg_types[3] = &ffi_type_float;
+      cl_arg_types[4] = &ffi_type_sshort;
+      cl_arg_types[5] = &ffi_type_float;
+      cl_arg_types[6] = &ffi_type_float;
+      cl_arg_types[7] = &ffi_type_uint;
+      cl_arg_types[8] = &ffi_type_double;
+      cl_arg_types[9] = &ffi_type_uint;
+      cl_arg_types[10] = &ffi_type_uint;
+      cl_arg_types[11] = &ffi_type_float;
+      cl_arg_types[12] = &ffi_type_uint;
+      cl_arg_types[13] = &ffi_type_uint;
+      cl_arg_types[14] = &ffi_type_uint;
+      cl_arg_types[15] = &ffi_type_uint;
+      cl_arg_types[16] = NULL;
+
+      /* Initialize the cif */
+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+			 &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+      CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_fn1,
+                                 (void *) 3 /* userdata */, code)  == FFI_OK);
+      try
+	{
+	  (*((closure_test_type1)code))
+	    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
+	     19, 21, 1);
+	  /* { dg-output "\n1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255" } */
+	} catch (int exception_code)
+	{
+	  CHECK(exception_code == 255);
+	}
+      printf("part two OK\n");
+      /* { dg-output "\npart two OK" } */
+    }
+    exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_5_1_byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_5_1_byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_5_1_byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_5_1_byte.c	
@@ -0,0 +1,137 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050708	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_5byte {
+  unsigned char a;
+  unsigned char b;
+  unsigned char c;
+  unsigned char d;
+  unsigned char e;
+} cls_struct_5byte;
+
+static cls_struct_5byte cls_struct_5byte_fn(struct cls_struct_5byte a1,
+			    struct cls_struct_5byte a2)
+{
+  struct cls_struct_5byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+  result.e = a1.e + a2.e;
+
+  printf("%d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d\n",
+	 a1.a, a1.b, a1.c, a1.d, a1.e,
+	 a2.a, a2.b, a2.c, a2.d, a2.e,
+	 result.a, result.b, result.c, result.d, result.e);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+  CHECK(a1.d == 3);
+  CHECK(a1.e == 4);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+  CHECK(a2.d == 3);
+  CHECK(a2.e == 4);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+  CHECK(result.d == 6);
+  CHECK(result.e == 8);
+
+  return  result;
+}
+
+static void
+cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_5byte a1, a2;
+
+  a1 = *(struct cls_struct_5byte*)(args[0]);
+  a2 = *(struct cls_struct_5byte*)(args[1]);
+
+  *(cls_struct_5byte*)resp = cls_struct_5byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[6];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_5byte g_dbl = { 127, 120, 1, 3, 4 };
+  struct cls_struct_5byte f_dbl = { 12, 128, 9, 3, 4 };
+  struct cls_struct_5byte res_dbl = { 0, 0, 0, 0, 0 };
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_uchar;
+  cls_struct_fields[4] = &ffi_type_uchar;
+  cls_struct_fields[5] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_5byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8" } */
+  printf("res: %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e);
+  /* { dg-output "\nres: 139 248 10 6 8" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 6);
+  CHECK(res_dbl.e == 8);
+
+  res_dbl.a = 0;
+  res_dbl.b = 0;
+  res_dbl.c = 0;
+  res_dbl.d = 0;
+  res_dbl.e = 0;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_5byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 3 4 12 128 9 3 4: 139 248 10 6 8" } */
+  printf("res: %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e);
+  /* { dg-output "\nres: 139 248 10 6 8" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 6);
+  CHECK(res_dbl.e == 8);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_6_1_byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_6_1_byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_6_1_byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_6_1_byte.c	
@@ -0,0 +1,140 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050708	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_6byte {
+  unsigned char a;
+  unsigned char b;
+  unsigned char c;
+  unsigned char d;
+  unsigned char e;
+  unsigned char f;
+} cls_struct_6byte;
+
+static cls_struct_6byte cls_struct_6byte_fn(struct cls_struct_6byte a1,
+			    struct cls_struct_6byte a2)
+{
+  struct cls_struct_6byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+  result.e = a1.e + a2.e;
+  result.f = a1.f + a2.f;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d %d\n",
+	 a1.a, a1.b, a1.c, a1.d, a1.e, a1.f,
+	 a2.a, a2.b, a2.c, a2.d, a2.e, a2.f,
+	 result.a, result.b, result.c, result.d, result.e, result.f);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+  CHECK(a1.d == 3);
+  CHECK(a1.e == 4);
+  CHECK(a1.f == 5);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+  CHECK(a2.d == 3);
+  CHECK(a2.e == 4);
+  CHECK(a2.f == 5);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+  CHECK(result.d == 6);
+  CHECK(result.e == 8);
+  CHECK(result.f == 10);
+
+  return  result;
+}
+
+static void
+cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_6byte a1, a2;
+
+  a1 = *(struct cls_struct_6byte*)(args[0]);
+  a2 = *(struct cls_struct_6byte*)(args[1]);
+
+  *(cls_struct_6byte*)resp = cls_struct_6byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[7];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 3, 4, 5 };
+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 3, 4, 5 };
+  struct cls_struct_6byte res_dbl = { 0, 0, 0, 0, 0, 0 };
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_uchar;
+  cls_struct_fields[4] = &ffi_type_uchar;
+  cls_struct_fields[5] = &ffi_type_uchar;
+  cls_struct_fields[6] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_6byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10" } */
+  printf("res: %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f);
+  /* { dg-output "\nres: 139 248 10 6 8 10" } */
+
+  res_dbl.a = 0;
+  res_dbl.b = 0;
+  res_dbl.c = 0;
+  res_dbl.d = 0;
+  res_dbl.e = 0;
+  res_dbl.f = 0;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_6byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 3 4 5 12 128 9 3 4 5: 139 248 10 6 8 10" } */
+  printf("res: %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f);
+  /* { dg-output "\nres: 139 248 10 6 8 10" } */
+
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 6);
+  CHECK(res_dbl.e == 8);
+  CHECK(res_dbl.f == 10);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_7_1_byte.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_7_1_byte.c b/libffi-3.4.6/testsuite/libffi.closures/cls_7_1_byte.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_7_1_byte.c	
@@ -0,0 +1,155 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Depending on the ABI. Check overlapping.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050708	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_7byte {
+  unsigned char a;
+  unsigned char b;
+  unsigned char c;
+  unsigned char d;
+  unsigned char e;
+  unsigned char f;
+  unsigned char g;
+} cls_struct_7byte;
+
+static cls_struct_7byte cls_struct_7byte_fn(struct cls_struct_7byte a1,
+			    struct cls_struct_7byte a2)
+{
+  struct cls_struct_7byte result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+  result.d = a1.d + a2.d;
+  result.e = a1.e + a2.e;
+  result.f = a1.f + a2.f;
+  result.g = a1.g + a2.g;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d %d %d %d %d %d %d\n",
+	 a1.a, a1.b, a1.c, a1.d, a1.e, a1.f, a1.g,
+	 a2.a, a2.b, a2.c, a2.d, a2.e, a2.f, a2.g,
+	 result.a, result.b, result.c, result.d, result.e, result.f, result.g);
+
+  CHECK(a1.a == 127);
+  CHECK(a1.b == 120);
+  CHECK(a1.c == 1);
+  CHECK(a1.d == 3);
+  CHECK(a1.e == 4);
+  CHECK(a1.f == 5);
+  CHECK(a1.g == 6);
+
+  CHECK(a2.a == 12);
+  CHECK(a2.b == 128);
+  CHECK(a2.c == 9);
+  CHECK(a2.d == 3);
+  CHECK(a2.e == 4);
+  CHECK(a2.f == 5);
+  CHECK(a2.g == 6);
+
+  CHECK(result.a == 139);
+  CHECK(result.b == 248);
+  CHECK(result.c == 10);
+  CHECK(result.d == 6);
+  CHECK(result.e == 8);
+  CHECK(result.f == 10);
+  CHECK(result.g == 12);
+
+  return  result;
+}
+
+static void
+cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_7byte a1, a2;
+
+  a1 = *(struct cls_struct_7byte*)(args[0]);
+  a2 = *(struct cls_struct_7byte*)(args[1]);
+
+  *(cls_struct_7byte*)resp = cls_struct_7byte_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[8];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 3, 4, 5, 6 };
+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 3, 4, 5, 6 };
+  struct cls_struct_7byte res_dbl = { 0, 0, 0, 0, 0, 0, 0 };
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = &ffi_type_uchar;
+  cls_struct_fields[4] = &ffi_type_uchar;
+  cls_struct_fields[5] = &ffi_type_uchar;
+  cls_struct_fields[6] = &ffi_type_uchar;
+  cls_struct_fields[7] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_7byte_fn), &res_dbl, args_dbl);
+  /* { dg-output "127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12" } */
+  printf("res: %d %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+  /* { dg-output "\nres: 139 248 10 6 8 10 12" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 6);
+  CHECK(res_dbl.e == 8);
+  CHECK(res_dbl.f == 10);
+  CHECK(res_dbl.g == 12);
+
+  res_dbl.a = 0;
+  res_dbl.b = 0;
+  res_dbl.c = 0;
+  res_dbl.d = 0;
+  res_dbl.e = 0;
+  res_dbl.f = 0;
+  res_dbl.g = 0;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_7byte_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n127 120 1 3 4 5 6 12 128 9 3 4 5 6: 139 248 10 6 8 10 12" } */
+  printf("res: %d %d %d %d %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c,
+	 res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+  /* { dg-output "\nres: 139 248 10 6 8 10 12" } */
+  CHECK(res_dbl.a == 139);
+  CHECK(res_dbl.b == 248);
+  CHECK(res_dbl.c == 10);
+  CHECK(res_dbl.d == 6);
+  CHECK(res_dbl.e == 8);
+  CHECK(res_dbl.f == 10);
+  CHECK(res_dbl.g == 12);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_ulong_va.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_ulong_va.c b/libffi-3.4.6/testsuite/libffi.closures/cls_ulong_va.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_ulong_va.c	
@@ -0,0 +1,49 @@
+/* Area:	closure_call
+   Purpose:	Test anonymous unsigned long argument.
+   Limitations:	none.
+   PR:		none.
+   Originator:	ARM Ltd. */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef unsigned long T;
+
+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			 void* userdata __UNUSED__)
+ {
+   *(T *)resp = *(T *)args[0];
+
+   printf("%ld: %ld %ld\n", *(T *)resp, *(T *)args[0], *(T *)args[1]);
+   CHECK(*(T *)args[0] == 67);
+   CHECK(*(T *)args[1] == 4);
+   CHECK(*(T *)resp == 67);
+ }
+
+typedef T (*cls_ret_T)(T, ...);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[3];
+  T res;
+
+  cl_arg_types[0] = &ffi_type_ulong;
+  cl_arg_types[1] = &ffi_type_ulong;
+  cl_arg_types[2] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,
+			 &ffi_type_ulong, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);
+  res = ((((cls_ret_T)code)(67, 4)));
+  /* { dg-output "67: 67 4" } */
+  printf("res: %ld\n", res);
+  /* { dg-output "\nres: 67" } */
+  CHECK(res == 67);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/stret_large2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/stret_large2.c b/libffi-3.4.6/testsuite/libffi.closures/stret_large2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/stret_large2.c	
@@ -0,0 +1,148 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check structure returning with different structure size.
+				Depending on the ABI. Check bigger struct which overlaps
+				the gp and fp register count on Darwin/AIX/ppc64.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin	6/21/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-*  } } */
+#include "ffitest.h"
+
+/* 13 FPRs: 104 bytes */
+/* 14 FPRs: 112 bytes */
+
+typedef struct struct_116byte {
+	double a;
+	double b;
+	double c;
+	double d;
+	double e;
+	double f;
+	double g;
+	double h;
+	double i;
+	double j;
+	double k;
+	double l;
+	double m;
+	double n;
+	int o;
+} struct_116byte;
+
+struct_116byte cls_struct_116byte_fn(
+	struct_116byte b0,
+	struct_116byte b1,
+	struct_116byte b2,
+	struct_116byte b3)
+{
+	struct_116byte	result;
+
+	result.a = b0.a + b1.a + b2.a + b3.a;
+	result.b = b0.b + b1.b + b2.b + b3.b;
+	result.c = b0.c + b1.c + b2.c + b3.c;
+	result.d = b0.d + b1.d + b2.d + b3.d;
+	result.e = b0.e + b1.e + b2.e + b3.e;
+	result.f = b0.f + b1.f + b2.f + b3.f;
+	result.g = b0.g + b1.g + b2.g + b3.g;
+	result.h = b0.h + b1.h + b2.h + b3.h;
+	result.i = b0.i + b1.i + b2.i + b3.i;
+	result.j = b0.j + b1.j + b2.j + b3.j;
+	result.k = b0.k + b1.k + b2.k + b3.k;
+	result.l = b0.l + b1.l + b2.l + b3.l;
+	result.m = b0.m + b1.m + b2.m + b3.m;
+	result.n = b0.n + b1.n + b2.n + b3.n;
+	result.o = b0.o + b1.o + b2.o + b3.o;
+
+	printf("%g %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", result.a, result.b, result.c,
+		result.d, result.e, result.f, result.g, result.h, result.i,
+		result.j, result.k, result.l, result.m, result.n, result.o);
+
+	return result;
+}
+
+static void
+cls_struct_116byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
+{
+	struct_116byte	b0, b1, b2, b3;
+
+	b0 = *(struct_116byte*)(args[0]);
+	b1 = *(struct_116byte*)(args[1]);
+	b2 = *(struct_116byte*)(args[2]);
+	b3 = *(struct_116byte*)(args[3]);
+
+	*(struct_116byte*)resp = cls_struct_116byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[5];
+	ffi_type* cls_struct_fields[16];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[5];
+
+	struct_116byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 7 };
+	struct_116byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0, 5.0, 7.0, 9.0, 1.0, 6.0, 4 };
+	struct_116byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 8.0, 6.0, 1.0, 4.0, 0.0, 7.0, 3 };
+	struct_116byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 9.0, 2.0, 6.0, 5.0, 3.0, 8.0, 2 };
+	struct_116byte res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_double;
+	cls_struct_fields[1] = &ffi_type_double;
+	cls_struct_fields[2] = &ffi_type_double;
+	cls_struct_fields[3] = &ffi_type_double;
+	cls_struct_fields[4] = &ffi_type_double;
+	cls_struct_fields[5] = &ffi_type_double;
+	cls_struct_fields[6] = &ffi_type_double;
+	cls_struct_fields[7] = &ffi_type_double;
+	cls_struct_fields[8] = &ffi_type_double;
+	cls_struct_fields[9] = &ffi_type_double;
+	cls_struct_fields[10] = &ffi_type_double;
+	cls_struct_fields[11] = &ffi_type_double;
+	cls_struct_fields[12] = &ffi_type_double;
+	cls_struct_fields[13] = &ffi_type_double;
+	cls_struct_fields[14] = &ffi_type_sint32;
+	cls_struct_fields[15] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = &cls_struct_type;
+	dbl_arg_types[3] = &cls_struct_type;
+	dbl_arg_types[4] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &e_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = &g_dbl;
+	args_dbl[3] = &h_dbl;
+	args_dbl[4] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_116byte_fn), &res_dbl, args_dbl);
+	/* { dg-output "22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
+		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n, res_dbl.o);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_116byte_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((struct_116byte(*)(struct_116byte, struct_116byte,
+		struct_116byte, struct_116byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
+	/* { dg-output "\n22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g %g %g %g %g %g %d\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i,
+		res_dbl.j, res_dbl.k, res_dbl.l, res_dbl.m, res_dbl.n, res_dbl.o);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 22 15 17 25 6 26 16" } */
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/stret_medium.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/stret_medium.c b/libffi-3.4.6/testsuite/libffi.closures/stret_medium.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/stret_medium.c	
@@ -0,0 +1,124 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check structure returning with different structure size.
+				Depending on the ABI. Check bigger struct which overlaps
+				the gp and fp register count on Darwin/AIX/ppc64.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin	6/21/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-*  } } */
+#include "ffitest.h"
+
+typedef struct struct_72byte {
+	double a;
+	double b;
+	double c;
+	double d;
+	double e;
+	double f;
+	double g;
+	double h;
+	double i;
+} struct_72byte;
+
+static struct_72byte cls_struct_72byte_fn(
+	struct_72byte b0,
+	struct_72byte b1,
+	struct_72byte b2,
+	struct_72byte b3)
+{
+	struct_72byte	result;
+
+	result.a = b0.a + b1.a + b2.a + b3.a;
+	result.b = b0.b + b1.b + b2.b + b3.b;
+	result.c = b0.c + b1.c + b2.c + b3.c;
+	result.d = b0.d + b1.d + b2.d + b3.d;
+	result.e = b0.e + b1.e + b2.e + b3.e;
+	result.f = b0.f + b1.f + b2.f + b3.f;
+	result.g = b0.g + b1.g + b2.g + b3.g;
+	result.h = b0.h + b1.h + b2.h + b3.h;
+	result.i = b0.i + b1.i + b2.i + b3.i;
+
+	printf("%g %g %g %g %g %g %g %g %g\n", result.a, result.b, result.c,
+		result.d, result.e, result.f, result.g, result.h, result.i);
+
+	return result;
+}
+
+static void
+cls_struct_72byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
+{
+	struct_72byte	b0, b1, b2, b3;
+
+	b0 = *(struct_72byte*)(args[0]);
+	b1 = *(struct_72byte*)(args[1]);
+	b2 = *(struct_72byte*)(args[2]);
+	b3 = *(struct_72byte*)(args[3]);
+
+	*(struct_72byte*)resp = cls_struct_72byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[5];
+	ffi_type* cls_struct_fields[10];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[5];
+
+	struct_72byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 7.0 };
+	struct_72byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0 };
+	struct_72byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 3.0 };
+	struct_72byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 2.0 };
+	struct_72byte res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_double;
+	cls_struct_fields[1] = &ffi_type_double;
+	cls_struct_fields[2] = &ffi_type_double;
+	cls_struct_fields[3] = &ffi_type_double;
+	cls_struct_fields[4] = &ffi_type_double;
+	cls_struct_fields[5] = &ffi_type_double;
+	cls_struct_fields[6] = &ffi_type_double;
+	cls_struct_fields[7] = &ffi_type_double;
+	cls_struct_fields[8] = &ffi_type_double;
+	cls_struct_fields[9] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = &cls_struct_type;
+	dbl_arg_types[3] = &cls_struct_type;
+	dbl_arg_types[4] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &e_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = &g_dbl;
+	args_dbl[3] = &h_dbl;
+	args_dbl[4] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_72byte_fn), &res_dbl, args_dbl);
+	/* { dg-output "22 15 17 25 6 13 19 18 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
+		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,
+		struct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
+	/* { dg-output "\n22 15 17 25 6 13 19 18 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %g\n", res_dbl.a, res_dbl.b, res_dbl.c,
+		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_double_va.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_double_va.c b/libffi-3.4.6/testsuite/libffi.closures/cls_double_va.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_double_va.c	
@@ -0,0 +1,69 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Test doubles passed in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+/* { dg-output "" { xfail mips-sgi-irix6* } } PR libffi/46660 */
+
+#include "ffitest.h"
+
+#define BUF_SIZE 50
+static char buffer[BUF_SIZE];
+
+static void
+cls_double_va_fn(ffi_cif* cif __UNUSED__, void* resp,
+		 void** args, void* userdata __UNUSED__)
+{
+	char*	format		= *(char**)args[0];
+	double	doubleValue	= *(double*)args[1];
+
+	*(ffi_arg*)resp = printf(format, doubleValue);
+	CHECK(*(ffi_arg*)resp == 4);
+	snprintf(buffer, BUF_SIZE, format, doubleValue);
+	CHECK(strncmp(buffer, "7.0\n", 4) == 0);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args[3];
+	ffi_type* arg_types[3];
+
+	char*	format		= "%.1f\n";
+	double	doubleArg	= 7;
+	ffi_arg	res			= 0;
+
+	arg_types[0] = &ffi_type_pointer;
+	arg_types[1] = &ffi_type_double;
+	arg_types[2] = NULL;
+
+	/* This printf call is variadic */
+	CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,
+			       arg_types) == FFI_OK);
+
+	args[0] = &format;
+	args[1] = &doubleArg;
+	args[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(printf), &res, args);
+	/* { dg-output "7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+	CHECK(res == 4);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL,
+				   code) == FFI_OK);
+
+	res = ((int(*)(char*, ...))(code))(format, doubleArg);
+	/* { dg-output "\n7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+	CHECK(res == 4);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_ulonglong.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_ulonglong.c b/libffi-3.4.6/testsuite/libffi.closures/cls_ulonglong.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_ulonglong.c	
@@ -0,0 +1,49 @@
+/* Area:	closure_call
+   Purpose:	Check return value long long.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+/* { dg-options "-Wno-format" { target alpha*-dec-osf* } } */
+#include "ffitest.h"
+
+static void cls_ret_ulonglong_fn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args, void* userdata __UNUSED__)
+{
+  *(unsigned long long *)resp= 0xfffffffffffffffLL ^ *(unsigned long long *)args[0];
+
+  printf("%" PRIuLL ": %" PRIuLL "\n",*(unsigned long long *)args[0],
+	 *(unsigned long long *)(resp));
+}
+typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[2];
+  unsigned long long res;
+
+  cl_arg_types[0] = &ffi_type_uint64;
+  cl_arg_types[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_uint64, cl_arg_types) == FFI_OK);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_ulonglong_fn, NULL, code)  == FFI_OK);
+  res = (*((cls_ret_ulonglong)code))(214LL);
+  /* { dg-output "214: 1152921504606846761" } */
+  printf("res: %" PRIdLL "\n", res);
+  /* { dg-output "\nres: 1152921504606846761" } */
+  CHECK(res == 1152921504606846761LL);
+
+  res = (*((cls_ret_ulonglong)code))(9223372035854775808LL);
+  /* { dg-output "\n9223372035854775808: 8070450533247928831" } */
+  printf("res: %" PRIdLL "\n", res);
+  /* { dg-output "\nres: 8070450533247928831" } */
+  CHECK(res == 8070450533247928831LL);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct.c	
@@ -0,0 +1,175 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_16byte1 {
+  double a;
+  float b;
+  int c;
+} cls_struct_16byte1;
+
+typedef struct cls_struct_16byte2 {
+  int ii;
+  double dd;
+  float ff;
+} cls_struct_16byte2;
+
+typedef struct cls_struct_combined {
+  cls_struct_16byte1 d;
+  cls_struct_16byte2 e;
+} cls_struct_combined;
+
+static cls_struct_combined cls_struct_combined_fn(struct cls_struct_16byte1 b0,
+			    struct cls_struct_16byte2 b1,
+			    struct cls_struct_combined b2)
+{
+  struct cls_struct_combined result;
+
+  result.d.a = b0.a + b1.dd + b2.d.a;
+  result.d.b = b0.b + b1.ff + b2.d.b;
+  result.d.c = b0.c + b1.ii + b2.d.c;
+  result.e.ii = b0.c + b1.ii + b2.e.ii;
+  result.e.dd = b0.a + b1.dd + b2.e.dd;
+  result.e.ff = b0.b + b1.ff + b2.e.ff;
+
+  printf("%g %g %d %d %g %g %g %g %d %d %g %g: %g %g %d %d %g %g\n",
+	 b0.a, b0.b, b0.c,
+	 b1.ii, b1.dd, b1.ff,
+	 b2.d.a, b2.d.b, b2.d.c,
+	 b2.e.ii, b2.e.dd, b2.e.ff,
+	 result.d.a, result.d.b, result.d.c,
+	 result.e.ii, result.e.dd, result.e.ff);
+
+  CHECK_DOUBLE_EQ(b0.a, 9);
+  CHECK_FLOAT_EQ(b0.b, 2);
+  CHECK(b0.c == 6);
+
+  CHECK(b1.ii == 1);
+  CHECK_DOUBLE_EQ(b1.dd, 2);
+  CHECK_FLOAT_EQ(b1.ff, 3);
+
+  CHECK_DOUBLE_EQ(b2.d.a, 4);
+  CHECK_FLOAT_EQ(b2.d.b, 5);
+  CHECK(b2.d.c == 6);
+
+  CHECK(b2.e.ii == 3);
+  CHECK_DOUBLE_EQ(b2.e.dd, 1);
+  CHECK_FLOAT_EQ(b2.e.ff, 8);
+
+  CHECK_DOUBLE_EQ(result.d.a, 15);
+  CHECK_FLOAT_EQ(result.d.b, 10);
+  CHECK(result.d.c == 13);
+  CHECK(result.e.ii == 10);
+  CHECK_DOUBLE_EQ(result.e.dd, 12);
+  CHECK_FLOAT_EQ(result.e.ff, 13);
+
+  return result;
+}
+
+static void
+cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		       void* userdata __UNUSED__)
+{
+  struct cls_struct_16byte1 b0;
+  struct cls_struct_16byte2 b1;
+  struct cls_struct_combined b2;
+
+  b0 = *(struct cls_struct_16byte1*)(args[0]);
+  b1 = *(struct cls_struct_16byte2*)(args[1]);
+  b2 = *(struct cls_struct_combined*)(args[2]);
+
+
+  *(cls_struct_combined*)resp = cls_struct_combined_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type* cls_struct_fields1[5];
+  ffi_type* cls_struct_fields2[5];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};
+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};
+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},
+				      {3, 1.0, 8.0}};
+  struct cls_struct_combined res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_sint;
+  cls_struct_fields1[1] = &ffi_type_double;
+  cls_struct_fields1[2] = &ffi_type_float;
+  cls_struct_fields1[3] = NULL;
+
+  cls_struct_fields2[0] = &cls_struct_type;
+  cls_struct_fields2[1] = &cls_struct_type1;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type2,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_combined_fn), &res_dbl, args_dbl);
+  /* { dg-output "9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13" } */
+  CHECK_DOUBLE_EQ( res_dbl.d.a, (e_dbl.a + f_dbl.dd + g_dbl.d.a));
+  CHECK_FLOAT_EQ( res_dbl.d.b,  (e_dbl.b + f_dbl.ff + g_dbl.d.b));
+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));
+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));
+  CHECK_DOUBLE_EQ( res_dbl.e.dd, (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
+  CHECK_FLOAT_EQ( res_dbl.e.ff, (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,
+				     cls_struct_16byte2,
+				     cls_struct_combined))
+	     (code))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13" } */
+  CHECK_DOUBLE_EQ( res_dbl.d.a, (e_dbl.a + f_dbl.dd + g_dbl.d.a));
+  CHECK_FLOAT_EQ( res_dbl.d.b,  (e_dbl.b + f_dbl.ff + g_dbl.d.b));
+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));
+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));
+  CHECK_DOUBLE_EQ( res_dbl.e.dd, (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
+  CHECK_FLOAT_EQ( res_dbl.e.ff, (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/stret_medium2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/stret_medium2.c b/libffi-3.4.6/testsuite/libffi.closures/stret_medium2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/stret_medium2.c	
@@ -0,0 +1,125 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check structure returning with different structure size.
+				Depending on the ABI. Check bigger struct which overlaps
+				the gp and fp register count on Darwin/AIX/ppc64.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin	6/21/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-*  } } */
+/* { dg-options "-Wno-format" { target alpha*-dec-osf* } } */
+#include "ffitest.h"
+
+typedef struct struct_72byte {
+	double a;
+	double b;
+	double c;
+	double d;
+	double e;
+	double f;
+	double g;
+	double h;
+	long long i;
+} struct_72byte;
+
+static struct_72byte cls_struct_72byte_fn(
+	struct_72byte b0,
+	struct_72byte b1,
+	struct_72byte b2,
+	struct_72byte b3)
+{
+	struct_72byte	result;
+
+	result.a = b0.a + b1.a + b2.a + b3.a;
+	result.b = b0.b + b1.b + b2.b + b3.b;
+	result.c = b0.c + b1.c + b2.c + b3.c;
+	result.d = b0.d + b1.d + b2.d + b3.d;
+	result.e = b0.e + b1.e + b2.e + b3.e;
+	result.f = b0.f + b1.f + b2.f + b3.f;
+	result.g = b0.g + b1.g + b2.g + b3.g;
+	result.h = b0.h + b1.h + b2.h + b3.h;
+	result.i = b0.i + b1.i + b2.i + b3.i;
+
+	printf("%g %g %g %g %g %g %g %g %" PRIdLL "\n", result.a, result.b, result.c,
+		result.d, result.e, result.f, result.g, result.h, result.i);
+
+	return result;
+}
+
+static void
+cls_struct_72byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata __UNUSED__)
+{
+	struct_72byte	b0, b1, b2, b3;
+
+	b0 = *(struct_72byte*)(args[0]);
+	b1 = *(struct_72byte*)(args[1]);
+	b2 = *(struct_72byte*)(args[2]);
+	b3 = *(struct_72byte*)(args[3]);
+
+	*(struct_72byte*)resp = cls_struct_72byte_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[5];
+	ffi_type* cls_struct_fields[10];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[5];
+
+	struct_72byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 7 };
+	struct_72byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4 };
+	struct_72byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 3 };
+	struct_72byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 2 };
+	struct_72byte res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_double;
+	cls_struct_fields[1] = &ffi_type_double;
+	cls_struct_fields[2] = &ffi_type_double;
+	cls_struct_fields[3] = &ffi_type_double;
+	cls_struct_fields[4] = &ffi_type_double;
+	cls_struct_fields[5] = &ffi_type_double;
+	cls_struct_fields[6] = &ffi_type_double;
+	cls_struct_fields[7] = &ffi_type_double;
+	cls_struct_fields[8] = &ffi_type_sint64;
+	cls_struct_fields[9] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = &cls_struct_type;
+	dbl_arg_types[3] = &cls_struct_type;
+	dbl_arg_types[4] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &e_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = &g_dbl;
+	args_dbl[3] = &h_dbl;
+	args_dbl[4] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_72byte_fn), &res_dbl, args_dbl);
+	/* { dg-output "22 15 17 25 6 13 19 18 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %" PRIdLL "\n", res_dbl.a, res_dbl.b, res_dbl.c,
+		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_72byte_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((struct_72byte(*)(struct_72byte, struct_72byte,
+		struct_72byte, struct_72byte))(code))(e_dbl, f_dbl, g_dbl, h_dbl);
+	/* { dg-output "\n22 15 17 25 6 13 19 18 16" } */
+	printf("res: %g %g %g %g %g %g %g %g %" PRIdLL "\n", res_dbl.a, res_dbl.b, res_dbl.c,
+		res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g, res_dbl.h, res_dbl.i);
+	/* { dg-output "\nres: 22 15 17 25 6 13 19 18 16" } */
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_simple.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_simple.c b/libffi-3.4.6/testsuite/libffi.closures/closure_simple.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_simple.c	
@@ -0,0 +1,61 @@
+/* Area:	closure_call
+   Purpose:	Check simple closure handling with all ABIs
+   Limitations:	none.
+   PR:		none.
+   Originator:	<twalljava@dev.java.net> */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static void
+closure_test(ffi_cif* cif __UNUSED__, void* resp, void** args, void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(int *)args[0] + (int)(*(int *)args[1])
+    + (int)(*(int *)args[2])  + (int)(*(int *)args[3])
+    + (int)(intptr_t)userdata;
+
+  printf("%d %d %d %d: %d\n",
+	 (int)*(int *)args[0], (int)(*(int *)args[1]),
+	 (int)(*(int *)args[2]), (int)(*(int *)args[3]),
+         (int)*(ffi_arg *)resp);
+
+  CHECK((int)*(int *)args[0] == 0);
+  CHECK((int)*(int *)args[1] == 1);
+  CHECK((int)*(int *)args[2] == 2);
+  CHECK((int)*(int *)args[3] == 3);
+  CHECK((int)*(ffi_arg *)resp == 9);
+}
+
+typedef int (ABI_ATTR *closure_test_type0)(int, int, int, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[17];
+  int res;
+
+  cl_arg_types[0] = &ffi_type_uint;
+  cl_arg_types[1] = &ffi_type_uint;
+  cl_arg_types[2] = &ffi_type_uint;
+  cl_arg_types[3] = &ffi_type_uint;
+  cl_arg_types[4] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 4,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test,
+                             (void *) 3 /* userdata */, code) == FFI_OK);
+
+  res = (*(closure_test_type0)code)(0, 1, 2, 3);
+  /* { dg-output "0 1 2 3: 9" } */
+
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 9" } */
+  CHECK(res == 9);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble.c b/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble.c	
@@ -0,0 +1,115 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check long double arguments.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin	*/
+
+/* This test is known to PASS on armv7l-unknown-linux-gnueabihf, so I have
+   remove the xfail for arm*-*-* below, until we know more.  */
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-options -mlong-double-128 { target powerpc64*-*-linux-gnu* } } */
+
+#include "ffitest.h"
+
+long double cls_ldouble_fn(
+	long double	a1,
+	long double	a2,
+	long double	a3,
+	long double	a4,
+	long double	a5,
+	long double	a6,
+	long double	a7,
+	long double	a8)
+{
+	long double	r = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
+
+	printf("%Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg: %Lg\n",
+		a1, a2, a3, a4, a5, a6, a7, a8, r);
+	CHECK(a1 == 1);
+	CHECK(a2 == 2);
+	CHECK(a3 == 3);
+	CHECK(a4 == 4);
+	CHECK(a5 == 5);
+	CHECK(a6 == 6);
+	CHECK(a7 == 7);
+	CHECK(a8 == 8);
+
+	return r;
+}
+
+static void
+cls_ldouble_gn(ffi_cif* cif __UNUSED__, void* resp, 
+	       void** args, void* userdata __UNUSED__)
+{
+	long double	a1	= *(long double*)args[0];
+	long double	a2	= *(long double*)args[1];
+	long double	a3	= *(long double*)args[2];
+	long double	a4	= *(long double*)args[3];
+	long double	a5	= *(long double*)args[4];
+	long double	a6	= *(long double*)args[5];
+	long double	a7	= *(long double*)args[6];
+	long double	a8	= *(long double*)args[7];
+
+	*(long double*)resp = cls_ldouble_fn(
+		a1, a2, a3, a4, a5, a6, a7, a8);
+}
+
+int main(void)
+{
+	ffi_cif	cif;
+        void* code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void*			args[9];
+	ffi_type*		arg_types[9];
+	long double		res	= 0;
+
+	long double	arg1	= 1;
+	long double	arg2	= 2;
+	long double	arg3	= 3;
+	long double	arg4	= 4;
+	long double	arg5	= 5;
+	long double	arg6	= 6;
+	long double	arg7	= 7;
+	long double	arg8	= 8;
+
+	arg_types[0] = &ffi_type_longdouble;
+	arg_types[1] = &ffi_type_longdouble;
+	arg_types[2] = &ffi_type_longdouble;
+	arg_types[3] = &ffi_type_longdouble;
+	arg_types[4] = &ffi_type_longdouble;
+	arg_types[5] = &ffi_type_longdouble;
+	arg_types[6] = &ffi_type_longdouble;
+	arg_types[7] = &ffi_type_longdouble;
+	arg_types[8] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 8, &ffi_type_longdouble,
+		arg_types) == FFI_OK);
+
+	args[0] = &arg1;
+	args[1] = &arg2;
+	args[2] = &arg3;
+	args[3] = &arg4;
+	args[4] = &arg5;
+	args[5] = &arg6;
+	args[6] = &arg7;
+	args[7] = &arg8;
+	args[8] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_ldouble_fn), &res, args);
+	/* { dg-output "1 2 3 4 5 6 7 8: 36" } */
+	printf("res: %Lg\n", res);
+	/* { dg-output "\nres: 36" } */
+	CHECK(res == 36);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ldouble_gn, NULL, code) == FFI_OK);
+
+	res = ((long double(*)(long double, long double, long double, long double,
+		long double, long double, long double, long double))(code))(arg1, arg2,
+		arg3, arg4, arg5, arg6, arg7, arg8);
+	/* { dg-output "\n1 2 3 4 5 6 7 8: 36" } */
+	printf("res: %Lg\n", res);
+	/* { dg-output "\nres: 36" } */
+	CHECK(res == 36);
+
+	return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_struct_va1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_struct_va1.c b/libffi-3.4.6/testsuite/libffi.closures/cls_struct_va1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_struct_va1.c	
@@ -0,0 +1,125 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Test doubles passed in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+#include "ffitest.h"
+
+struct small_tag
+{
+  unsigned char a;
+  unsigned char b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static void
+test_fn (ffi_cif* cif __UNUSED__, void* resp,
+	 void** args, void* userdata __UNUSED__)
+{
+  int n = *(int*)args[0];
+  struct small_tag s1 = * (struct small_tag *) args[1];
+  struct large_tag l1 = * (struct large_tag *) args[2];
+  struct small_tag s2 = * (struct small_tag *) args[3];
+
+  printf ("%d %d %d %d %d %d %d %d %d %d\n", n, s1.a, s1.b,
+	  l1.a, l1.b, l1.c, l1.d, l1.e,
+	  s2.a, s2.b);
+  CHECK(n == 4);
+  CHECK(s1.a == 5);
+  CHECK(s1.b == 6);
+  CHECK(l1.a == 10);
+  CHECK(l1.b == 11);
+  CHECK(l1.c == 12);
+  CHECK(l1.d == 13);
+  CHECK(l1.e == 14);
+  CHECK(s2.a == 20);
+  CHECK(s2.b == 21);
+  * (ffi_arg*) resp = 42;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc (sizeof (ffi_closure), &code);
+  ffi_type* arg_types[5];
+
+  ffi_arg res = 0;
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int si;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_uchar;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &ffi_type_sint,
+			 arg_types) == FFI_OK);
+
+  si = 4;
+  s1.a = 5;
+  s1.b = 6;
+
+  s2.a = 20;
+  s2.b = 21;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_fn, NULL, code) == FFI_OK);
+
+  res = ((int (*)(int, ...))(code))(si, s1, l1, s2);
+  /* { dg-output "4 5 6 10 11 12 13 14 20 21" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+  CHECK(res == 42);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct1.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct1.c	
@@ -0,0 +1,161 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_16byte1 {
+  double a;
+  float b;
+  int c;
+} cls_struct_16byte1;
+
+typedef struct cls_struct_16byte2 {
+  int ii;
+  double dd;
+  float ff;
+} cls_struct_16byte2;
+
+typedef struct cls_struct_combined {
+  cls_struct_16byte1 d;
+  cls_struct_16byte2 e;
+} cls_struct_combined;
+
+static cls_struct_combined cls_struct_combined_fn(struct cls_struct_16byte1 b0,
+					   struct cls_struct_16byte2 b1,
+					   struct cls_struct_combined b2,
+					   struct cls_struct_16byte1 b3)
+{
+  struct cls_struct_combined result;
+
+  result.d.a = b0.a + b1.dd + b2.d.a;
+  result.d.b = b0.b + b1.ff + b2.d.b;
+  result.d.c = b0.c + b1.ii + b2.d.c;
+  result.e.ii = b0.c + b1.ii + b2.e.ii;
+  result.e.dd = b0.a + b1.dd + b2.e.dd;
+  result.e.ff = b0.b + b1.ff + b2.e.ff;
+
+  printf("%g %g %d %d %g %g %g %g %d %d %g %g %g %g %d: %g %g %d %d %g %g\n",
+	 b0.a, b0.b, b0.c,
+	 b1.ii, b1.dd, b1.ff,
+	 b2.d.a, b2.d.b, b2.d.c,
+	 b2.e.ii, b2.e.dd, b2.e.ff,
+	 b3.a, b3.b, b3.c,
+	 result.d.a, result.d.b, result.d.c,
+	 result.e.ii, result.e.dd, result.e.ff);
+
+  return result;
+}
+
+static void
+cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		       void* userdata __UNUSED__)
+{
+  struct cls_struct_16byte1 b0;
+  struct cls_struct_16byte2 b1;
+  struct cls_struct_combined b2;
+  struct cls_struct_16byte1 b3;
+
+  b0 = *(struct cls_struct_16byte1*)(args[0]);
+  b1 = *(struct cls_struct_16byte2*)(args[1]);
+  b2 = *(struct cls_struct_combined*)(args[2]);
+  b3 = *(struct cls_struct_16byte1*)(args[3]);
+
+
+  *(cls_struct_combined*)resp = cls_struct_combined_fn(b0, b1, b2, b3);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[5];
+  ffi_type* cls_struct_fields1[5];
+  ffi_type* cls_struct_fields2[5];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};
+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};
+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},
+				      {3, 1.0, 8.0}};
+  struct cls_struct_16byte1 h_dbl = { 3.0, 2.0, 4};
+  struct cls_struct_combined res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = &ffi_type_sint;
+  cls_struct_fields[3] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_sint;
+  cls_struct_fields1[1] = &ffi_type_double;
+  cls_struct_fields1[2] = &ffi_type_float;
+  cls_struct_fields1[3] = NULL;
+
+  cls_struct_fields2[0] = &cls_struct_type;
+  cls_struct_fields2[1] = &cls_struct_type1;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = &cls_struct_type;
+  dbl_arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type2,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = &h_dbl;
+  args_dbl[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_combined_fn), &res_dbl, args_dbl);
+  /* { dg-output "9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13" } */
+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));
+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));
+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));
+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));
+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_combined_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1,
+				     cls_struct_16byte2,
+				     cls_struct_combined,
+				     cls_struct_16byte1))
+	     (code))(e_dbl, f_dbl, g_dbl, h_dbl);
+  /* { dg-output "\n9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13" } */
+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));
+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));
+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));
+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));
+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));
+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));
+  /*  CHECK( 1 == 0); */
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct2.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct2.c	
@@ -0,0 +1,119 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030911	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b0, struct B b1)
+{
+  struct B result;
+
+  result.x.a = b0.a + b1.x.a;
+  result.x.b = b0.b + b1.x.b + b1.y;
+  result.y = b0.b + b1.x.b;
+
+  printf("%lu %d %lu %d %d: %lu %d %d\n", b0.a, b0.b, b1.x.a, b1.x.b, b1.y,
+	 result.x.a, result.x.b, result.y);
+
+  CHECK(b0.a == 1);
+  CHECK(b0.b == 7);
+  CHECK(b1.x.a == 12);
+  CHECK(b1.x.b == 127);
+  CHECK(b1.y == 99);
+  CHECK(result.x.a == 13);
+  CHECK(result.x.b == 233);
+  CHECK(result.y == 134);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  struct A e_dbl = { 1, 7};
+  struct B f_dbl = {{12 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_ulong;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct3.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct3.c	
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030911	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b0, struct B b1)
+{
+  struct B result;
+
+  result.x.a = b0.a + b1.x.a;
+  result.x.b = b0.b + b1.x.b + b1.y;
+  result.y = b0.b + b1.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b0.a, b0.b,
+	 (int)b1.x.a, b1.x.b, b1.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b0.a == 1);
+  CHECK(b0.b == 7);
+  CHECK((int)b1.x.a == 12);
+  CHECK(b1.x.b == 127);
+  CHECK(b1.y == 99);
+  CHECK((int)result.x.a == 13);
+  CHECK(result.x.b == 233);
+  CHECK(result.y == 134);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = {{12LL , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct4.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct4.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct4.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct4.c	
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		PR 25630.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)result.x.a == 13);
+  CHECK(result.x.b == 233);
+  CHECK(result.y == 134);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct5.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct5.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct5.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct5.c	
@@ -0,0 +1,121 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  long double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)result.x.a == 13);
+  CHECK(result.x.b == 233);
+  CHECK(result.y == 134);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_longdouble;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct6.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct6.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct6.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct6.c	
@@ -0,0 +1,142 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		PR 25630.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)b4.d == 2);
+  CHECK(b4.e == 9);
+  CHECK((int)result.x.a == 15);
+  CHECK(result.x.b == 242);
+  CHECK(result.y == 143);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+  struct C g_dbl = { 2, 9};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_slong;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct7.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct7.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct7.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct7.c	
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)result.x.a == 13);
+  CHECK(result.x.b == 233);
+  CHECK(result.y == 134);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct8.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct8.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct8.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct8.c	
@@ -0,0 +1,142 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  unsigned long long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)b4.d == 2);
+  CHECK(b4.e == 9);
+  CHECK((int)result.x.a == 15);
+  CHECK(result.x.b == 242);
+  CHECK(result.y == 143);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = {{12LL , 127}, 99};
+  struct C g_dbl = { 2LL, 9};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_uint64;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct9.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct9.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct9.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct9.c	
@@ -0,0 +1,142 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned char a;
+  unsigned long long b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  unsigned long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", b2.a, (int)b2.b,
+	 b3.x.a, (int)b3.x.b, b3.y, (int)b4.d, b4.e,
+	 result.x.a, (int)result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK((int)b4.d == 2); 
+  CHECK(b4.e == 9);
+  CHECK((int)result.x.a == 15);
+  CHECK(result.x.b == 242);
+  CHECK(result.y == 143);
+  
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+  struct A e_dbl = { 1, 7LL};
+  struct B f_dbl = {{12.0 , 127}, 99};
+  struct C g_dbl = { 2, 9};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uint64;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_ulong;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/closure_loc_fn0.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/closure_loc_fn0.c b/libffi-3.4.6/testsuite/libffi.closures/closure_loc_fn0.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/closure_loc_fn0.c	
@@ -0,0 +1,96 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC
+		Darwin.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20030828	 */
+
+
+#include "ffitest.h"
+
+static void
+closure_loc_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +
+    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +
+    (int)(*(signed short *)args[4]) +
+    (int)(*(unsigned long long *)args[5]) +
+    (int)*(int *)args[6] + (int)(*(int *)args[7]) +
+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+    (int)(*(int *)args[14]) +  *(int *)args[15] + (intptr_t)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]),
+	 (int)(*(unsigned long long *)args[2]),
+	 (int)*(int *)args[3], (int)(*(signed short *)args[4]),
+	 (int)(*(unsigned long long *)args[5]),
+	 (int)*(int *)args[6], (int)(*(int *)args[7]),
+	 (int)(*(double *)args[8]), (int)*(int *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(int *)args[13]),
+	 (int)(*(int *)args[14]),*(int *)args[15],
+	 (int)(intptr_t)userdata, (int)*(ffi_arg *)resp);
+
+}
+
+typedef int (*closure_loc_test_type0)(unsigned long long, int, unsigned long long,
+				  int, signed short, unsigned long long, int,
+				  int, double, int, int, float, int, int,
+				  int, int);
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_closure *pcl;
+  ffi_type * cl_arg_types[17];
+  int res;
+  void *codeloc;
+
+  cl_arg_types[0] = &ffi_type_uint64;
+  cl_arg_types[1] = &ffi_type_sint;
+  cl_arg_types[2] = &ffi_type_uint64;
+  cl_arg_types[3] = &ffi_type_sint;
+  cl_arg_types[4] = &ffi_type_sshort;
+  cl_arg_types[5] = &ffi_type_uint64;
+  cl_arg_types[6] = &ffi_type_sint;
+  cl_arg_types[7] = &ffi_type_sint;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_sint;
+  cl_arg_types[10] = &ffi_type_sint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_sint;
+  cl_arg_types[13] = &ffi_type_sint;
+  cl_arg_types[14] = &ffi_type_sint;
+  cl_arg_types[15] = &ffi_type_sint;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  pcl = ffi_closure_alloc(sizeof(ffi_closure), &codeloc);
+  CHECK(pcl != NULL);
+  CHECK(codeloc != NULL);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_loc_test_fn0,
+			 (void *) 3 /* userdata */, codeloc) == FFI_OK);
+
+#if !defined(FFI_EXEC_STATIC_TRAMP) && !defined(__EMSCRIPTEN__)
+  /* With static trampolines, the codeloc does not point to closure */
+  CHECK(memcmp(pcl, FFI_CL(codeloc), sizeof(*pcl)) == 0);
+#endif
+
+  res = (*((closure_loc_test_type0)codeloc))
+    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13,
+     19, 21, 1);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  CHECK(res == 680);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_float.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_float.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_float.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_float.c	
@@ -0,0 +1,109 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  float b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %g %d %d %g %d: %d %g %d\n", a1.a, (double)a1.b, a1.c, a2.a, (double)a2.b, a2.c, result.a, (double)result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK_FLOAT_EQ(a1.b, 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK_FLOAT_EQ(a2.b, 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK_FLOAT_EQ(result.b, 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK_FLOAT_EQ(res_dbl.b, 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK_FLOAT_EQ(res_dbl.b, 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_dbls_struct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_dbls_struct.c b/libffi-3.4.6/testsuite/libffi.closures/cls_dbls_struct.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_dbls_struct.c	
@@ -0,0 +1,68 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check double arguments in structs.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/23/2007	*/
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef struct Dbls {
+	double x;
+	double y;
+} Dbls;
+
+void
+closure_test_fn(Dbls p)
+{
+	printf("%.1f %.1f\n", p.x, p.y);
+	CHECK(p.x == 1);
+	CHECK(p.y == 2);
+}
+
+void
+closure_test_gn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+		void** args, void* userdata __UNUSED__)
+{
+	closure_test_fn(*(Dbls*)args[0]);
+}
+
+int main(int argc __UNUSED__, char** argv __UNUSED__)
+{
+	ffi_cif cif;
+
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	ffi_type*		cl_arg_types[1];
+
+	ffi_type	ts1_type;
+	ffi_type*	ts1_type_elements[4];
+
+	Dbls arg = { 1.0, 2.0 };
+
+	ts1_type.size = 0;
+	ts1_type.alignment = 0;
+	ts1_type.type = FFI_TYPE_STRUCT;
+	ts1_type.elements = ts1_type_elements;
+
+	ts1_type_elements[0] = &ffi_type_double;
+	ts1_type_elements[1] = &ffi_type_double;
+	ts1_type_elements[2] = NULL;
+
+	cl_arg_types[0] = &ts1_type;
+
+	/* Initialize the cif */
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+				 &ffi_type_void, cl_arg_types) == FFI_OK);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);
+
+	((void (*)(Dbls))(code))(arg);
+	/* { dg-output "1.0 2.0" } */
+
+	closure_test_fn(arg);
+	/* { dg-output "\n1.0 2.0" } */
+
+	return 0;
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_schar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_schar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_schar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_schar.c	
@@ -0,0 +1,78 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple signed char values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<hos@tamanegi.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static signed char test_func_fn(signed char a1, signed char a2)
+{
+  signed char result;
+
+  result = a1 + a2;
+
+  printf("%d %d: %d\n", a1, a2, result);
+
+  return result;
+
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  signed char a1, a2;
+
+  a1 = *(signed char *)avals[0];
+  a2 = *(signed char *)avals[1];
+  CHECK(a1 == 2);
+  CHECK(a2 == 125);
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2);
+
+}
+
+typedef signed char (*test_type)(signed char, signed char);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[3];
+  ffi_type * cl_arg_types[3];
+  ffi_arg res_call;
+  signed char a, b, res_closure;
+
+  a = 2;
+  b = 125;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = NULL;
+
+  cl_arg_types[0] = &ffi_type_schar;
+  cl_arg_types[1] = &ffi_type_schar;
+  cl_arg_types[2] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_schar, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "2 125: 127" } */
+  printf("res: %d\n", (signed char)res_call);
+  /* { dg-output "\nres: 127" } */
+  CHECK((signed char)res_call == 127);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(2, 125);
+  /* { dg-output "\n2 125: 127" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 127" } */
+  CHECK(res_closure == 127);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_uchar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_uchar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_uchar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_uchar.c	
@@ -0,0 +1,99 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple unsigned char values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<andreast@gcc.gnu.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static unsigned char test_func_fn(unsigned char a1, unsigned char a2,
+			   unsigned char a3, unsigned char a4)
+{
+  unsigned char result;
+
+  result = a1 + a2 + a3 + a4;
+
+  printf("%d %d %d %d: %d\n", a1, a2, a3, a4, result);
+
+  CHECK(a1 == 1);
+  CHECK(a2 == 2);
+  CHECK(a3 == 127);
+  CHECK(a4 == 125);
+  CHECK(result == 255);
+
+  return result;
+
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  unsigned char a1, a2, a3, a4;
+
+  a1 = *(unsigned char *)avals[0];
+  a2 = *(unsigned char *)avals[1];
+  a3 = *(unsigned char *)avals[2];
+  a4 = *(unsigned char *)avals[3];
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);
+
+}
+
+typedef unsigned char (*test_type)(unsigned char, unsigned char,
+				   unsigned char, unsigned char);
+
+void test_func(ffi_cif *cif __UNUSED__, void *rval __UNUSED__, void **avals,
+	       void *data __UNUSED__)
+{
+  printf("%d %d %d %d\n", *(unsigned char *)avals[0],
+	 *(unsigned char *)avals[1], *(unsigned char *)avals[2],
+	 *(unsigned char *)avals[3]);
+}
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[5];
+  ffi_type * cl_arg_types[5];
+  ffi_arg res_call;
+  unsigned char a, b, c, d, res_closure;
+
+  a = 1;
+  b = 2;
+  c = 127;
+  d = 125;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = &c;
+  args_dbl[3] = &d;
+  args_dbl[4] = NULL;
+
+  cl_arg_types[0] = &ffi_type_uchar;
+  cl_arg_types[1] = &ffi_type_uchar;
+  cl_arg_types[2] = &ffi_type_uchar;
+  cl_arg_types[3] = &ffi_type_uchar;
+  cl_arg_types[4] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_uchar, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "1 2 127 125: 255" } */
+  printf("res: %d\n", (unsigned char)res_call);
+  /* { dg-output "\nres: 255" } */
+  CHECK((unsigned char)res_call == 255);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(1, 2, 127, 125);
+  /* { dg-output "\n1 2 127 125: 255" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 255" } */
+  CHECK(res_closure == 255);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct10.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct10.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct10.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct10.c	
@@ -0,0 +1,146 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  unsigned char y;
+  struct A x;
+  unsigned int z;
+} B;
+
+typedef struct C {
+  unsigned long long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b3.z + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+  result.z = 0;
+
+  printf("%d %d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, b3.z, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  CHECK((int)b2.a == 1);
+  CHECK(b2.b == 7);
+  CHECK((int)b3.x.a == 12);
+  CHECK(b3.x.b == 127);
+  CHECK(b3.y == 99);
+  CHECK(b3.z == 255);
+  CHECK((int)b4.d == 2);
+  CHECK(b4.e == 9);
+  CHECK((int)result.x.a == 270);
+  CHECK(result.x.b == 242);
+  CHECK(result.y == 143);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[4];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = { 99, {12LL , 127}, 255};
+  struct C g_dbl = { 2LL, 9};
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_uchar;
+  cls_struct_fields1[1] = &cls_struct_type;
+  cls_struct_fields1[2] = &ffi_type_uint;
+  cls_struct_fields1[3] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_uint64;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 255 2 9: 270 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(code))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 255 2 9: 270 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct11.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct11.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct11.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct11.c	
@@ -0,0 +1,137 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check parameter passing with nested structs
+		of a single type.  This tests the special cases
+		for homogeneous floating-point aggregates in the
+		AArch64 PCS.
+   Limitations:	none.
+   PR:		none.
+   Originator:  ARM Ltd.  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  float a_x;
+  float a_y;
+} A;
+
+typedef struct B {
+  float b_x;
+  float b_y;
+} B;
+
+typedef struct C {
+  A a;
+  B b;
+} C;
+
+static C C_fn (int x, int y, int z, C source, int i, int j, int k)
+{
+  C result;
+  result.a.a_x = source.a.a_x;
+  result.a.a_y = source.a.a_y;
+  result.b.b_x = source.b.b_x;
+  result.b.b_y = source.b.b_y;
+
+  printf ("%d, %d, %d, %d, %d, %d\n", x, y, z, i, j, k);
+
+  CHECK(x == 1);
+  CHECK(y == 1);
+  CHECK(z == 1);
+  CHECK(i == 1);
+  CHECK(j == 1);
+  CHECK(k == 1);
+
+  printf ("%.1f, %.1f, %.1f, %.1f, "
+	  "%.1f, %.1f, %.1f, %.1f\n",
+	  source.a.a_x, source.a.a_y,
+	  source.b.b_x, source.b.b_y,
+	  result.a.a_x, result.a.a_y,
+	  result.b.b_x, result.b.b_y);
+
+    CHECK_FLOAT_EQ(source.a.a_x, 1.0);
+    CHECK_FLOAT_EQ(source.a.a_y, 2.0);
+    CHECK_FLOAT_EQ(source.b.b_x, 4.0);
+    CHECK_FLOAT_EQ(source.b.b_y, 8.0);
+    CHECK_FLOAT_EQ(result.a.a_x, 1.0);
+    CHECK_FLOAT_EQ(result.a.a_y, 2.0);
+    CHECK_FLOAT_EQ(result.b.b_x, 4.0);
+    CHECK_FLOAT_EQ(result.b.b_y, 8.0);
+
+  return result;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+
+  ffi_type* struct_fields_source_a[3];
+  ffi_type* struct_fields_source_b[3];
+  ffi_type* struct_fields_source_c[3];
+  ffi_type* arg_types[8];
+
+  ffi_type struct_type_a, struct_type_b, struct_type_c;
+
+  struct A source_fld_a = {1.0, 2.0};
+  struct B source_fld_b = {4.0, 8.0};
+  int k = 1;
+
+  struct C result;
+  struct C source = {source_fld_a, source_fld_b};
+
+  struct_type_a.size = 0;
+  struct_type_a.alignment = 0;
+  struct_type_a.type = FFI_TYPE_STRUCT;
+  struct_type_a.elements = struct_fields_source_a;
+
+  struct_type_b.size = 0;
+  struct_type_b.alignment = 0;
+  struct_type_b.type = FFI_TYPE_STRUCT;
+  struct_type_b.elements = struct_fields_source_b;
+
+  struct_type_c.size = 0;
+  struct_type_c.alignment = 0;
+  struct_type_c.type = FFI_TYPE_STRUCT;
+  struct_type_c.elements = struct_fields_source_c;
+
+  struct_fields_source_a[0] = &ffi_type_float;
+  struct_fields_source_a[1] = &ffi_type_float;
+  struct_fields_source_a[2] = NULL;
+
+  struct_fields_source_b[0] = &ffi_type_float;
+  struct_fields_source_b[1] = &ffi_type_float;
+  struct_fields_source_b[2] = NULL;
+
+  struct_fields_source_c[0] = &struct_type_a;
+  struct_fields_source_c[1] = &struct_type_b;
+  struct_fields_source_c[2] = NULL;
+
+  arg_types[0] = &ffi_type_sint32;
+  arg_types[1] = &ffi_type_sint32;
+  arg_types[2] = &ffi_type_sint32;
+  arg_types[3] = &struct_type_c;
+  arg_types[4] = &ffi_type_sint32;
+  arg_types[5] = &ffi_type_sint32;
+  arg_types[6] = &ffi_type_sint32;
+  arg_types[7] = NULL;
+
+  void *args[7];
+  args[0] = &k;
+  args[1] = &k;
+  args[2] = &k;
+  args[3] = &source;
+  args[4] = &k;
+  args[5] = &k;
+  args[6] = &k;
+  CHECK (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, 7, &struct_type_c,
+		       arg_types) == FFI_OK);
+
+  ffi_call (&cif, FFI_FN (C_fn), &result, args);
+  /* { dg-output "1, 1, 1, 1, 1, 1\n" } */
+  /* { dg-output "1.0, 2.0, 4.0, 8.0, 1.0, 2.0, 4.0, 8.0" } */
+  CHECK_FLOAT_EQ(result.a.a_x, source.a.a_x);
+  CHECK_FLOAT_EQ(result.a.a_y, source.a.a_y);
+  CHECK_FLOAT_EQ(result.b.b_x, source.b.b_x);
+  CHECK_FLOAT_EQ(result.b.b_y, source.b.b_y);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct12.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct12.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct12.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct12.c	
@@ -0,0 +1,86 @@
+/* Area:	ffi_call
+   Purpose:	Check nested float struct.
+   Limitations:	none.
+   PR:		none.
+   Originator:	Cheng Jin <jincheng@ca.ibm.com>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct stru_FF stru_FF;
+typedef struct stru_Nested_F stru_Nested_F;
+
+struct stru_FF {
+	float elem1;
+	float elem2;
+};
+
+struct stru_Nested_F {
+	float elem1;
+	stru_FF elem2;
+};
+
+static float testNestedFloatStruct(float arg1, stru_Nested_F arg2)
+{
+	float floatSum = arg1 + arg2.elem1 + arg2.elem2.elem1 + arg2.elem2.elem2;
+	return floatSum;
+}
+
+int main (void)
+{
+	float ts12_result = 0;
+	int structElemNum = 2;
+	int nestedStructElemNum = 2;
+	int argNum = 2;
+
+	ffi_cif cif;
+	ffi_type **struct_float1 = (ffi_type **)malloc(sizeof(ffi_type *) * (structElemNum + 1));
+	ffi_type **struct_float2 = (ffi_type **)malloc(sizeof(ffi_type *) * (nestedStructElemNum + 1));
+	ffi_type **args = (ffi_type **)malloc(sizeof(ffi_type *) * (argNum + 1));
+	void **values = (void **)malloc(sizeof(void *) * (argNum + 1));
+	ffi_type struct_float_type1, struct_float_type2;
+	ffi_type *retType = &ffi_type_float;
+	float arg1;
+	float *arg2 = (float *)malloc(sizeof(stru_Nested_F));
+
+	struct_float2[0] = &ffi_type_float;
+	struct_float2[1] = &ffi_type_float;
+	struct_float2[2] = NULL;
+
+	struct_float_type2.size = 0;
+	struct_float_type2.alignment = 0;
+	struct_float_type2.type = FFI_TYPE_STRUCT;
+	struct_float_type2.elements = struct_float2;
+
+	struct_float1[0] = &ffi_type_float;
+	struct_float1[1] = &struct_float_type2;
+	struct_float1[2] = NULL;
+
+	struct_float_type1.size = 0;
+	struct_float_type1.alignment = 0;
+	struct_float_type1.type = FFI_TYPE_STRUCT;
+	struct_float_type1.elements = struct_float1;
+
+	args[0] = &ffi_type_float;
+	args[1] = &struct_float_type1;
+	args[2] = NULL;
+
+	arg1 = 37.88;
+	arg2[0] = 31.22;
+	arg2[1] = 33.44;
+	arg2[2] = 35.66;
+	values[0] = &arg1;
+	values[1] = arg2;
+	values[2] = NULL;
+
+	CHECK( ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, retType, args) == FFI_OK);
+	ffi_call(&cif, FFI_FN(testNestedFloatStruct), &ts12_result, values);
+	CHECK_FLOAT_EQ(ts12_result, 138.2f);
+
+	free(struct_float1);
+	free(struct_float2);
+	free(args);
+	free(values);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/nested_struct13.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/nested_struct13.c b/libffi-3.4.6/testsuite/libffi.closures/nested_struct13.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/nested_struct13.c	
@@ -0,0 +1,115 @@
+/* Area:       ffi_call, closure_call
+   Purpose:    Check structure passing.
+   Limitations:        none.
+   PR:         none.
+   Originator: <jincheng@ca.ibm.com> and <jakub@redhat.com> 20210609    */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  float a, b;
+} A;
+
+typedef struct B {
+  float x;
+  struct A y;
+} B;
+
+B B_fn(float b0, struct B b1)
+{
+  struct B result;
+
+  result.x = b0 + b1.x;
+  result.y.a = b0 + b1.y.a;
+  result.y.b = b0 + b1.y.b;
+
+  printf("%g %g %g %g: %g %g %g\n", b0, b1.x, b1.y.a, b1.y.b,
+        result.x, result.y.a, result.y.b);
+
+  CHECK_FLOAT_EQ(b0, 12.125);
+  CHECK_FLOAT_EQ(b1.x, 24.75);
+  CHECK_FLOAT_EQ(b1.y.a, 31.625);
+  CHECK_FLOAT_EQ(b1.y.b, 32.25);
+  CHECK_FLOAT_EQ(result.x, 36.875);
+  CHECK_FLOAT_EQ(result.y.a, 43.75);
+  CHECK_FLOAT_EQ(result.y.b, 44.375);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  float b0;
+  struct B b1;
+
+  b0 = *(float*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  float e_dbl = 12.125f;
+  struct B f_dbl = { 24.75f, { 31.625f, 32.25f } };
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_float;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_float;
+  cls_struct_fields1[1] = &cls_struct_type;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &ffi_type_float;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+                    dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "12.125 24.75 31.625 32.25: 36.875 43.75 44.375" } */
+  CHECK_FLOAT_EQ( res_dbl.x, (e_dbl + f_dbl.x));
+  CHECK_FLOAT_EQ( res_dbl.y.a, (e_dbl + f_dbl.y.a));
+  CHECK_FLOAT_EQ( res_dbl.y.b, (e_dbl + f_dbl.y.b));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(float, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n12.125 24.75 31.625 32.25: 36.875 43.75 44.375" } */
+  CHECK_FLOAT_EQ( res_dbl.x, (e_dbl + f_dbl.x));
+  CHECK_FLOAT_EQ( res_dbl.y.a, (e_dbl + f_dbl.y.a));
+  CHECK_FLOAT_EQ( res_dbl.y.b, (e_dbl + f_dbl.y.b));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_double.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_double.c	
@@ -0,0 +1,111 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  double b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %g %d %d %g %d: %d %g %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_double;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_sint16.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint16.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint16.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint16.c	
@@ -0,0 +1,108 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of sint16.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  signed short b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_sshort;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_sint32.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint32.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint32.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint32.c	
@@ -0,0 +1,106 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of sint32.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  signed int b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_sint;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_sint64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint64.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_sint64.c	
@@ -0,0 +1,109 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of sint64.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+/* { dg-options "-Wno-format" { target alpha*-dec-osf* } } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  signed long long b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %" PRIdLL " %d %d %" PRIdLL " %d: %d %" PRIdLL " %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_sint64;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIdLL " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIdLL " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_uint16.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint16.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint16.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint16.c	
@@ -0,0 +1,108 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of uint16.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  unsigned short b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_ushort;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_uint32.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint32.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint32.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint32.c	
@@ -0,0 +1,109 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of uint32.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  unsigned int b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uint;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %d %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_uint64.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint64.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint64.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_uint64.c	
@@ -0,0 +1,111 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of uint64.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+
+/* { dg-do run } */
+/* { dg-options "-Wno-format" { target alpha*-dec-osf* } } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  unsigned long long b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %" PRIdLL " %d %d %" PRIdLL " %d: %d %" PRIdLL " %d\n", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c, result.a, result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uint64;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIdLL " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIdLL " %d\n", res_dbl.a, res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshort.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshort.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshort.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshort.c	
@@ -0,0 +1,79 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple signed short values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<andreast@gcc.gnu.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static signed short test_func_fn(signed short a1, signed short a2)
+{
+  signed short result;
+
+  result = a1 + a2;
+
+  printf("%d %d: %d\n", a1, a2, result);
+  CHECK(a1 == 2);
+  CHECK(a2 == 32765);
+  CHECK(result == 32767);
+
+  return result;
+
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  signed short a1, a2;
+
+  a1 = *(signed short *)avals[0];
+  a2 = *(signed short *)avals[1];
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2);
+
+}
+
+typedef signed short (*test_type)(signed short, signed short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[3];
+  ffi_type * cl_arg_types[3];
+  ffi_arg res_call;
+  unsigned short a, b, res_closure;
+
+  a = 2;
+  b = 32765;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = NULL;
+
+  cl_arg_types[0] = &ffi_type_sshort;
+  cl_arg_types[1] = &ffi_type_sshort;
+  cl_arg_types[2] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_sshort, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "2 32765: 32767" } */
+  printf("res: %d\n", (unsigned short)res_call);
+  /* { dg-output "\nres: 32767" } */
+  CHECK((unsigned short)res_call == 32767);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(2, 32765);
+  /* { dg-output "\n2 32765: 32767" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 32767" } */
+  CHECK(res_closure == 32767);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushort.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushort.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushort.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushort.c	
@@ -0,0 +1,78 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple unsigned short values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<andreast@gcc.gnu.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static unsigned short test_func_fn(unsigned short a1, unsigned short a2)
+{
+  unsigned short result;
+
+  result = a1 + a2;
+
+  printf("%d %d: %d\n", a1, a2, result);
+
+  CHECK(a1 == 2);
+  CHECK(a2 == 32765);
+  CHECK(result == 32767);
+
+  return result;
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  unsigned short a1, a2;
+
+  a1 = *(unsigned short *)avals[0];
+  a2 = *(unsigned short *)avals[1];
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2);
+
+}
+
+typedef unsigned short (*test_type)(unsigned short, unsigned short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[3];
+  ffi_type * cl_arg_types[3];
+  ffi_arg res_call;
+  unsigned short a, b, res_closure;
+
+  a = 2;
+  b = 32765;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = NULL;
+
+  cl_arg_types[0] = &ffi_type_ushort;
+  cl_arg_types[1] = &ffi_type_ushort;
+  cl_arg_types[2] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_ushort, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "2 32765: 32767" } */
+  printf("res: %d\n", (unsigned short)res_call);
+  /* { dg-output "\nres: 32767" } */
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(2, 32765);
+  /* { dg-output "\n2 32765: 32767" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 32767" } */
+  CHECK(res_closure == 32767);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_pointer.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_pointer.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_pointer.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_pointer.c	
@@ -0,0 +1,113 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of pointer.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  void *b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = (void *)((uintptr_t)a1.b + (uintptr_t)a2.b);
+  result.c = a1.c + a2.c;
+
+  printf("%d %" PRIuPTR " %d %d %" PRIuPTR " %d: %d %" PRIuPTR " %d\n", 
+         a1.a, (uintptr_t)a1.b, a1.c,
+	 a2.a, (uintptr_t)a2.b, a2.c,
+         result.a, (uintptr_t)result.b,
+	 result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == (void *)4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == (void *)9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == (void *)14271);
+  CHECK(result.c == 140);
+
+  return result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, (void *)4951, 127 };
+  struct cls_struct_align f_dbl = { 1, (void *)9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_pointer;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIuPTR " %d\n", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == (void *)14271);
+  CHECK(res_dbl.c == 140);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %" PRIuPTR " %d\n", res_dbl.a, (uintptr_t)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == (void *)14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_longdouble_va.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble_va.c b/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble_va.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_longdouble_va.c	
@@ -0,0 +1,80 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Test long doubles passed in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+/* { dg-output "" { xfail mips-sgi-irix6* } } PR libffi/46660 */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+#define BUF_SIZE 50
+static char buffer[BUF_SIZE];
+
+static int
+wrap_printf(char* fmt, ...) {
+	va_list ap;
+	va_start(ap, fmt);
+	long double ldArg = va_arg(ap, long double);
+	va_end(ap);
+	CHECK((int)ldArg == 7);
+	return printf(fmt, ldArg);	
+}
+
+static void
+cls_longdouble_va_fn(ffi_cif* cif __UNUSED__, void* resp,
+		     void** args, void* userdata __UNUSED__)
+{
+	char*		format	= *(char**)args[0];
+	long double	ldValue	= *(long double*)args[1];
+
+	*(ffi_arg*)resp = printf(format, ldValue);
+	CHECK(*(ffi_arg*)resp == 4);
+	snprintf(buffer, BUF_SIZE, format, ldValue);
+	CHECK(strncmp(buffer, "7.0\n", BUF_SIZE) == 0);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args[3];
+	ffi_type* arg_types[3];
+
+	char*		format	= "%.1Lf\n";
+	long double	ldArg	= 7;
+	ffi_arg		res		= 0;
+
+	arg_types[0] = &ffi_type_pointer;
+	arg_types[1] = &ffi_type_longdouble;
+	arg_types[2] = NULL;
+
+	/* This printf call is variadic */
+	CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,
+			       arg_types) == FFI_OK);
+
+	args[0] = &format;
+	args[1] = &ldArg;
+	args[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(wrap_printf), &res, args);
+	/* { dg-output "7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+	CHECK(res == 4);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL,
+				   code) == FFI_OK);
+
+	res = ((int(*)(char*, ...))(code))(format, ldArg);
+	/* { dg-output "\n7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+	CHECK(res == 4);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_pointer_stack.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_pointer_stack.c b/libffi-3.4.6/testsuite/libffi.closures/cls_pointer_stack.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_pointer_stack.c	
@@ -0,0 +1,152 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Check pointer arguments across multiple hideous stack frames.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/7/2007	*/
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+static	long dummyVar;
+
+long dummy_func(
+	long double a1, char b1,
+	long double a2, char b2,
+	long double a3, char b3,
+	long double a4, char b4)
+{
+	return a1 + b1 + a2 + b2 + a3 + b3 + a4 + b4;
+}
+
+void* cls_pointer_fn2(void* a1, void* a2)
+{
+	long double	trample1	= (intptr_t)a1 + (intptr_t)a2;
+	char		trample2	= ((char*)&a1)[0] + ((char*)&a2)[0];
+	long double	trample3	= (intptr_t)trample1 + (intptr_t)a1;
+	char		trample4	= trample2 + ((char*)&a1)[1];
+	long double	trample5	= (intptr_t)trample3 + (intptr_t)a2;
+	char		trample6	= trample4 + ((char*)&a2)[1];
+	long double	trample7	= (intptr_t)trample5 + (intptr_t)trample1;
+	char		trample8	= trample6 + trample2;
+	void*		result;
+
+	dummyVar	= dummy_func(trample1, trample2, trample3, trample4,
+		trample5, trample6, trample7, trample8);
+
+	result	= (void*)((intptr_t)a1 + (intptr_t)a2);
+
+	printf("0x%08x 0x%08x: 0x%08x\n", 
+	       (unsigned int)(uintptr_t) a1,
+               (unsigned int)(uintptr_t) a2,
+               (unsigned int)(uintptr_t) result);
+
+	CHECK((unsigned int)(uintptr_t) a1 == 0x8acf1356);
+	CHECK((unsigned int)(uintptr_t) a2 == 0x01234567);
+	CHECK((unsigned int)(uintptr_t) result == 0x8bf258bd);
+
+	return result;
+}
+
+void* cls_pointer_fn1(void* a1, void* a2)
+{
+	long double	trample1	= (intptr_t)a1 + (intptr_t)a2;
+	char		trample2	= ((char*)&a1)[0] + ((char*)&a2)[0];
+	long double	trample3	= (intptr_t)trample1 + (intptr_t)a1;
+	char		trample4	= trample2 + ((char*)&a1)[1];
+	long double	trample5	= (intptr_t)trample3 + (intptr_t)a2;
+	char		trample6	= trample4 + ((char*)&a2)[1];
+	long double	trample7	= (intptr_t)trample5 + (intptr_t)trample1;
+	char		trample8	= trample6 + trample2;
+	void*		result;
+
+	dummyVar	= dummy_func(trample1, trample2, trample3, trample4,
+		trample5, trample6, trample7, trample8);
+
+	result	= (void*)((intptr_t)a1 + (intptr_t)a2);
+
+	printf("0x%08x 0x%08x: 0x%08x\n",
+               (unsigned int)(intptr_t) a1,
+               (unsigned int)(intptr_t) a2,
+               (unsigned int)(intptr_t) result);
+
+	CHECK((unsigned int)(uintptr_t) a1 == 0x01234567);
+	CHECK((unsigned int)(uintptr_t) a2 == 0x89abcdef);
+	CHECK((unsigned int)(uintptr_t) result == 0x8acf1356);
+
+	result	= cls_pointer_fn2(result, a1);
+
+	return result;
+}
+
+static void
+cls_pointer_gn(ffi_cif* cif __UNUSED__, void* resp, 
+	       void** args, void* userdata __UNUSED__)
+{
+	void*	a1	= *(void**)(args[0]);
+	void*	a2	= *(void**)(args[1]);
+
+	long double	trample1	= (intptr_t)a1 + (intptr_t)a2;
+	char		trample2	= ((char*)&a1)[0] + ((char*)&a2)[0];
+	long double	trample3	= (intptr_t)trample1 + (intptr_t)a1;
+	char		trample4	= trample2 + ((char*)&a1)[1];
+	long double	trample5	= (intptr_t)trample3 + (intptr_t)a2;
+	char		trample6	= trample4 + ((char*)&a2)[1];
+	long double	trample7	= (intptr_t)trample5 + (intptr_t)trample1;
+	char		trample8	= trample6 + trample2;
+
+	dummyVar	= dummy_func(trample1, trample2, trample3, trample4,
+		trample5, trample6, trample7, trample8);
+
+	*(void**)resp = cls_pointer_fn1(a1, a2);
+}
+
+int main (void)
+{
+	ffi_cif	cif;
+        void *code;
+	ffi_closure*	pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void*			args[3];
+	/*	ffi_type		cls_pointer_type; */
+	ffi_type*		arg_types[3];
+
+/*	cls_pointer_type.size = sizeof(void*);
+	cls_pointer_type.alignment = 0;
+	cls_pointer_type.type = FFI_TYPE_POINTER;
+	cls_pointer_type.elements = NULL;*/
+
+	void*	arg1	= (void*)0x01234567;
+	void*	arg2	= (void*)0x89abcdef;
+	ffi_arg	res		= 0;
+
+	arg_types[0] = &ffi_type_pointer;
+	arg_types[1] = &ffi_type_pointer;
+	arg_types[2] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_pointer,
+		arg_types) == FFI_OK);
+
+	args[0] = &arg1;
+	args[1] = &arg2;
+	args[2] = NULL;
+
+	printf("\n");
+	ffi_call(&cif, FFI_FN(cls_pointer_fn1), &res, args);
+
+	printf("res: 0x%08x\n", (unsigned int) res);
+	/* { dg-output "\n0x01234567 0x89abcdef: 0x8acf1356" } */
+	/* { dg-output "\n0x8acf1356 0x01234567: 0x8bf258bd" } */
+	/* { dg-output "\nres: 0x8bf258bd" } */
+	CHECK(res == 0x8bf258bd);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
+
+	res = (ffi_arg)(uintptr_t)((void*(*)(void*, void*))(code))(arg1, arg2);
+
+	printf("res: 0x%08x\n", (unsigned int) res);
+	/* { dg-output "\n0x01234567 0x89abcdef: 0x8acf1356" } */
+	/* { dg-output "\n0x8acf1356 0x01234567: 0x8bf258bd" } */
+	/* { dg-output "\nres: 0x8bf258bd" } */
+	CHECK(res == 0x8bf258bd);
+
+	exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_args.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_args.c b/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_args.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_args.c	
@@ -0,0 +1,70 @@
+/* Area:	closure_call
+   Purpose:	Check closures called with many args of mixed types
+   Limitations:	none.
+   PR:		none.
+   Originator:	<david.schneider@picle.org> */
+
+/* { dg-do run } */
+#include "ffitest.h"
+#include <float.h>
+#include <math.h>
+
+#define NARGS 16
+
+static void cls_ret_double_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+{
+  int i;
+  double r = 0;
+  double t;
+  for(i = 0; i < NARGS; i++)
+    {
+    if(i == 4 || i == 9 || i == 11 || i == 13 || i == 15)
+      {
+      t = *(long int *)args[i];
+      CHECK(t == i+1);
+      }
+    else
+      {
+      t = *(double *)args[i];
+      CHECK(fabs(t - ((i+1) * 0.1)) < FLT_EPSILON);
+      }
+    r += t;
+    }
+  *(double *)resp = r;
+}
+typedef double (*cls_ret_double)(double, double, double, double, long int,
+double, double, double, double, long int, double, long int, double, long int,
+double, long int);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type * cl_arg_types[NARGS];
+  double res;
+  int i;
+  double expected = 64.9;
+
+  for(i = 0; i < NARGS; i++)
+    {
+    if(i == 4 || i == 9 || i == 11 || i == 13 || i == 15)
+      cl_arg_types[i] = &ffi_type_slong;
+    else
+      cl_arg_types[i] = &ffi_type_double;
+    }
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, NARGS,
+		     &ffi_type_double, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_double_fn, NULL, code) == FFI_OK);
+
+  res = (((cls_ret_double)code))(0.1, 0.2, 0.3, 0.4, 5, 0.6, 0.7, 0.8, 0.9, 10,
+                                 1.1, 12, 1.3, 14, 1.5, 16);
+  if (fabs(res - expected) < FLT_EPSILON)
+    exit(0);
+  else
+    abort();
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble.c	
@@ -0,0 +1,111 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of long double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  unsigned char a;
+  long double b;
+  unsigned char c;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(struct cls_struct_align a1,
+			    struct cls_struct_align a2)
+{
+  struct cls_struct_align result;
+
+  result.a = a1.a + a2.a;
+  result.b = a1.b + a2.b;
+  result.c = a1.c + a2.c;
+
+  printf("%d %g %d %d %g %d: %d %g %d\n", a1.a, (double)a1.b, a1.c, a2.a, (double)a2.b, a2.c, result.a, (double)result.b, result.c);
+
+  CHECK(a1.a == 12);
+  CHECK(a1.b == 4951);
+  CHECK(a1.c == 127);
+
+  CHECK(a2.a == 1);
+  CHECK(a2.b == 9320);
+  CHECK(a2.c == 13);
+
+  CHECK(result.a == 13);
+  CHECK(result.b == 14271);
+  CHECK(result.c == 140);
+
+  return  result;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+
+  struct cls_struct_align a1, a2;
+
+  a1 = *(struct cls_struct_align*)(args[0]);
+  a2 = *(struct cls_struct_align*)(args[1]);
+
+  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[5];
+  ffi_type* cls_struct_fields[4];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[5];
+
+  struct cls_struct_align g_dbl = { 12, 4951, 127 };
+  struct cls_struct_align f_dbl = { 1, 9320, 13 };
+  struct cls_struct_align res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_longdouble;
+  cls_struct_fields[2] = &ffi_type_uchar;
+  cls_struct_fields[3] = NULL;
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &g_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+  /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+  /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
+  printf("res: %d %g %d\n", res_dbl.a, (double)res_dbl.b, res_dbl.c);
+  /* { dg-output "\nres: 13 14271 140" } */
+  CHECK(res_dbl.a == 13);
+  CHECK(res_dbl.b == 14271);
+  CHECK(res_dbl.c == 140);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshortchar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshortchar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshortchar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_sshortchar.c	
@@ -0,0 +1,94 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple signed short/char values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<andreast@gcc.gnu.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static signed short test_func_fn(signed char a1, signed short a2,
+			  signed char a3, signed short a4)
+{
+  signed short result;
+
+  result = a1 + a2 + a3 + a4;
+
+  printf("%d %d %d %d: %d\n", a1, a2, a3, a4, result);
+
+  CHECK(a1 == 1);
+  CHECK(a2 == 32765);
+  CHECK(a3 == 127);
+  CHECK(a4 == -128);
+  CHECK(result == 32765);
+
+  return result;
+
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  signed char a1, a3;
+  signed short a2, a4;
+
+  a1 = *(signed char *)avals[0];
+  a2 = *(signed short *)avals[1];
+  a3 = *(signed char *)avals[2];
+  a4 = *(signed short *)avals[3];
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);
+
+}
+
+typedef signed short (*test_type)(signed char, signed short,
+				  signed char, signed short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[5];
+  ffi_type * cl_arg_types[5];
+  ffi_arg res_call;
+  signed char a, c;
+  signed short b, d, res_closure;
+
+  a = 1;
+  b = 32765;
+  c = 127;
+  d = -128;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = &c;
+  args_dbl[3] = &d;
+  args_dbl[4] = NULL;
+
+  cl_arg_types[0] = &ffi_type_schar;
+  cl_arg_types[1] = &ffi_type_sshort;
+  cl_arg_types[2] = &ffi_type_schar;
+  cl_arg_types[3] = &ffi_type_sshort;
+  cl_arg_types[4] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_sshort, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "1 32765 127 -128: 32765" } */
+  printf("res: %d\n", (signed short)res_call);
+  /* { dg-output "\nres: 32765" } */
+  CHECK(res_call == 32765);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(1, 32765, 127, -128);
+  /* { dg-output "\n1 32765 127 -128: 32765" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 32765" } */
+  CHECK(res_closure == 32765);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushortchar.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushortchar.c b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushortchar.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_multi_ushortchar.c	
@@ -0,0 +1,94 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check passing of multiple unsigned short/char values.
+   Limitations:	none.
+   PR:		PR13221.
+   Originator:	<andreast@gcc.gnu.org> 20031129  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static unsigned short test_func_fn(unsigned char a1, unsigned short a2,
+			    unsigned char a3, unsigned short a4)
+{
+  unsigned short result;
+
+  result = a1 + a2 + a3 + a4;
+
+  printf("%d %d %d %d: %d\n", a1, a2, a3, a4, result);
+
+  CHECK(a1 == 1);
+  CHECK(a2 == 2);
+  CHECK(a3 == 127);
+  CHECK(a4 == 128);
+  CHECK(result == 258);
+
+  return result;
+
+}
+
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
+{
+  unsigned char a1, a3;
+  unsigned short a2, a4;
+
+  a1 = *(unsigned char *)avals[0];
+  a2 = *(unsigned short *)avals[1];
+  a3 = *(unsigned char *)avals[2];
+  a4 = *(unsigned short *)avals[3];
+
+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);
+
+}
+
+typedef unsigned short (*test_type)(unsigned char, unsigned short,
+				   unsigned char, unsigned short);
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void * args_dbl[5];
+  ffi_type * cl_arg_types[5];
+  ffi_arg res_call;
+  unsigned char a, c;
+  unsigned short b, d, res_closure;
+
+  a = 1;
+  b = 2;
+  c = 127;
+  d = 128;
+
+  args_dbl[0] = &a;
+  args_dbl[1] = &b;
+  args_dbl[2] = &c;
+  args_dbl[3] = &d;
+  args_dbl[4] = NULL;
+
+  cl_arg_types[0] = &ffi_type_uchar;
+  cl_arg_types[1] = &ffi_type_ushort;
+  cl_arg_types[2] = &ffi_type_uchar;
+  cl_arg_types[3] = &ffi_type_ushort;
+  cl_arg_types[4] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_ushort, cl_arg_types) == FFI_OK);
+
+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
+  /* { dg-output "1 2 127 128: 258" } */
+  printf("res: %d\n", (unsigned short)res_call);
+  /* { dg-output "\nres: 258" } */
+  CHECK(res_call == 258);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_func_gn, NULL, code)  == FFI_OK);
+
+  res_closure = (*((test_type)code))(1, 2, 127, 128);
+  /* { dg-output "\n1 2 127 128: 258" } */
+  printf("res: %d\n", res_closure);
+  /* { dg-output "\nres: 258" } */
+  CHECK(res_closure == 258);
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/unwindtest_ffi_call.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/unwindtest_ffi_call.cc b/libffi-3.4.6/testsuite/libffi.closures/unwindtest_ffi_call.cc
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/unwindtest_ffi_call.cc	
@@ -0,0 +1,55 @@
+/* Area:	ffi_call, unwind info
+   Purpose:	Check if the unwind information is passed correctly.
+   Limitations:	none.
+   PR:		none.
+   Originator:	Andreas Tobler <andreast@gcc.gnu.org> 20061213  */
+
+/* { dg-do run { xfail moxie*-*-* } } */
+
+#include "ffitest.h"
+
+static int checking(int a __UNUSED__, short b __UNUSED__,
+		    signed char c __UNUSED__)
+{
+  throw 9;
+}
+
+extern "C"
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_arg rint;
+
+  signed int si;
+  signed short ss;
+  signed char sc;
+
+  args[0] = &ffi_type_sint;
+  values[0] = &si;
+  args[1] = &ffi_type_sshort;
+  values[1] = &ss;
+  args[2] = &ffi_type_schar;
+  values[2] = &sc;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
+		     &ffi_type_sint, args) == FFI_OK);
+
+  si = -6;
+  ss = -12;
+  sc = -1;
+  {
+    try
+      {
+	ffi_call(&cif, FFI_FN(checking), &rint, values);
+      } catch (int exception_code)
+      {
+	CHECK(exception_code == 9);
+      }
+    printf("part one OK\n");
+    /* { dg-output "part one OK" } */
+  }
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/single_entry_structs1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs1.c b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs1.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs1.c	
@@ -0,0 +1,86 @@
+/* Area:       ffi_call, closure_call
+   Purpose:    Single argument structs have a different ABI in emscripten.
+   Limitations:        none.
+   PR:         none.
+   Originator: <hood@mit.edu>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  int a;
+} A;
+
+static struct A A_fn(int b0, struct A b1)
+{
+  b1.a += b0;
+  return b1;
+}
+
+static void
+A_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  int b0;
+  struct A b1;
+
+  b0 = *(int*)(args[0]);
+  b1 = *(struct A*)(args[1]);
+
+  *(A*)resp = A_fn(b0, b1);
+}
+
+int main (void)
+{
+  printf("123\n");
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[2];
+  ffi_type cls_struct_type;
+  ffi_type* dbl_arg_types[3];
+
+  int e_dbl = 12125;
+  struct A f_dbl = { 31625 };
+
+  struct A res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = NULL;
+
+  dbl_arg_types[0] = &ffi_type_sint;
+  dbl_arg_types[1] = &cls_struct_type;
+  dbl_arg_types[2] = NULL;
+
+  res_dbl = A_fn(e_dbl, f_dbl);
+  printf("0 res: %d\n", res_dbl.a);
+  /* { dg-output "0 res: 43750" } */
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+                    dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+
+  ffi_call(&cif, FFI_FN(A_fn), &res_dbl, args_dbl);
+  printf("1 res: %d\n", res_dbl.a);
+  /* { dg-output "\n1 res: 43750" } */
+  CHECK( res_dbl.a == (e_dbl + f_dbl.a));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, A_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((A(*)(int, A))(code))(e_dbl, f_dbl);
+  printf("2 res: %d\n", res_dbl.a);
+  /* { dg-output "\n2 res: 43750" } */
+  CHECK( res_dbl.a == (e_dbl + f_dbl.a));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/single_entry_structs2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs2.c b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs2.c	
@@ -0,0 +1,102 @@
+/* Area:       ffi_call, closure_call
+   Purpose:    Single argument structs have a different ABI in emscripten.
+   Limitations:        none.
+   PR:         none.
+   Originator: <hood@mit.edu>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  int a, b;
+} A;
+
+typedef struct B {
+  struct A y;
+} B;
+
+static struct B B_fn(int b0, struct B b1)
+{
+  b1.y.a += b0;
+  b1.y.b -= b0;
+  return b1;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  int b0;
+  struct B b1;
+
+  b0 = *(int*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[2];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  int e_dbl = 12125;
+  struct B f_dbl = { { 31625, 16723 } };
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = &ffi_type_sint;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = NULL;
+
+
+  dbl_arg_types[0] = &ffi_type_sint;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  res_dbl = B_fn(e_dbl, f_dbl);
+  printf("0 res: %d %d\n", res_dbl.y.a, res_dbl.y.b);
+  /* { dg-output "0 res: 43750 4598" } */
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+                    dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  printf("1 res: %d %d\n", res_dbl.y.a, res_dbl.y.b);
+  /* { dg-output "\n1 res: 43750 4598" } */
+  CHECK( res_dbl.y.a == (f_dbl.y.a + e_dbl));
+  CHECK( res_dbl.y.b == (f_dbl.y.b - e_dbl));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(int, B))(code))(e_dbl, f_dbl);
+  printf("2 res: %d %d\n", res_dbl.y.a, res_dbl.y.b);
+  /* { dg-output "\n2 res: 43750 4598" } */
+  CHECK( res_dbl.y.a == (f_dbl.y.a + e_dbl));
+  CHECK( res_dbl.y.b == (f_dbl.y.b - e_dbl));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/single_entry_structs3.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs3.c b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs3.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/single_entry_structs3.c	
@@ -0,0 +1,101 @@
+/* Area:       ffi_call, closure_call
+   Purpose:    Single argument structs have a different ABI in emscripten.
+   Limitations:        none.
+   PR:         none.
+   Originator: <hood@mit.edu>  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  int a;
+} A;
+
+typedef struct B {
+  struct A y;
+} B;
+
+static struct B B_fn(int b0, struct B b1)
+{
+  b1.y.a += b0;
+  return b1;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  int b0;
+  struct B b1;
+
+  b0 = *(int*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  printf("123\n");
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[2];
+  ffi_type* cls_struct_fields1[2];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  int e_dbl = 12125;
+  struct B f_dbl = { { 31625 } };
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_sint;
+  cls_struct_fields[1] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = NULL;
+
+
+  dbl_arg_types[0] = &ffi_type_sint;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  res_dbl = B_fn(e_dbl, f_dbl);
+  printf("0 res: %d\n", res_dbl.y.a);
+  /* { dg-output "0 res: 43750" } */
+
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+                    dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  printf("1 res: %d\n", res_dbl.y.a);
+  /* { dg-output "\n1 res: 43750" } */
+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(int, B))(code))(e_dbl, f_dbl);
+  printf("2 res: %d\n", res_dbl.y.a);
+  /* { dg-output "\n2 res: 43750" } */
+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));
+
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split.c	
@@ -0,0 +1,147 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure alignment of long double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<hos@tamanegi.org> 20031203	 */
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-options -mlong-double-128 { target powerpc64*-*-linux-gnu* } } */
+
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  long double a;
+  long double b;
+  long double c;
+  long double d;
+  long double e;
+  long double f;
+  long double g;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(
+	cls_struct_align	a1,
+	cls_struct_align	a2)
+{
+	struct cls_struct_align r;
+
+	r.a = a1.a + a2.a;
+	r.b = a1.b + a2.b;
+	r.c = a1.c + a2.c;
+	r.d = a1.d + a2.d;
+	r.e = a1.e + a2.e;
+	r.f = a1.f + a2.f;
+	r.g = a1.g + a2.g;
+
+	printf("%Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg %Lg: "
+		"%Lg %Lg %Lg %Lg %Lg %Lg %Lg\n",
+		a1.a, a1.b, a1.c, a1.d, a1.e, a1.f, a1.g,
+		a2.a, a2.b, a2.c, a2.d, a2.e, a2.f, a2.g,
+		r.a, r.b, r.c, r.d, r.e, r.f, r.g);
+
+	CHECK(a1.a == 1);
+	CHECK(a1.b == 2);
+	CHECK(a1.c == 3);
+	CHECK(a1.d == 4);
+	CHECK(a1.e == 5);
+	CHECK(a1.f == 6);
+	CHECK(a1.g == 7);
+
+	CHECK(a2.a == 8);
+	CHECK(a2.b == 9);
+	CHECK(a2.c == 10);
+	CHECK(a2.d == 11);
+	CHECK(a2.e == 12);
+	CHECK(a2.f == 13);
+	CHECK(a2.g == 14);
+
+	CHECK(r.a == 9);
+	CHECK(r.b == 11);
+	CHECK(r.c == 13);
+	CHECK(r.d == 15);
+	CHECK(r.e == 17);
+	CHECK(r.f == 19);
+	CHECK(r.g == 21);
+	return r;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
+{
+	struct cls_struct_align a1, a2;
+
+	a1 = *(struct cls_struct_align*)(args[0]);
+	a2 = *(struct cls_struct_align*)(args[1]);
+
+	*(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[3];
+	ffi_type* cls_struct_fields[8];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[3];
+
+	struct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };
+	struct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };
+	struct cls_struct_align res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_longdouble;
+	cls_struct_fields[1] = &ffi_type_longdouble;
+	cls_struct_fields[2] = &ffi_type_longdouble;
+	cls_struct_fields[3] = &ffi_type_longdouble;
+	cls_struct_fields[4] = &ffi_type_longdouble;
+	cls_struct_fields[5] = &ffi_type_longdouble;
+	cls_struct_fields[6] = &ffi_type_longdouble;
+	cls_struct_fields[7] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &g_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+	/* { dg-output "1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
+	printf("res: %Lg %Lg %Lg %Lg %Lg %Lg %Lg\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
+	CHECK(res_dbl.a == 9);
+	CHECK(res_dbl.b == 11);
+	CHECK(res_dbl.c == 13);
+	CHECK(res_dbl.d == 15);
+	CHECK(res_dbl.e == 17);
+	CHECK(res_dbl.f == 19);
+	CHECK(res_dbl.g == 21);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+	/* { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
+	printf("res: %Lg %Lg %Lg %Lg %Lg %Lg %Lg\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
+	CHECK(res_dbl.a == 9);
+	CHECK(res_dbl.b == 11);
+	CHECK(res_dbl.c == 13);
+	CHECK(res_dbl.d == 15);
+	CHECK(res_dbl.e == 17);
+	CHECK(res_dbl.f == 19);
+	CHECK(res_dbl.g == 21);
+  exit(0);
+}
Index: libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split2.c b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split2.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_align_longdouble_split2.c	
@@ -0,0 +1,152 @@
+/*	Area:			ffi_call, closure_call
+	Purpose:		Check structure alignment of long double.
+	Limitations:	none.
+	PR:				none.
+	Originator:		Blake Chaffin	6/18/2007
+*/
+
+/* { dg-do run { xfail strongarm*-*-* } } */
+/* { dg-options -mlong-double-128 { target powerpc64*-*-linux-gnu* } } */
+
+#include "ffitest.h"
+
+typedef struct cls_struct_align {
+  long double a;
+  long double b;
+  long double c;
+  long double d;
+  long double e;
+  double f;
+  long double g;
+} cls_struct_align;
+
+static cls_struct_align cls_struct_align_fn(
+	cls_struct_align	a1,
+	cls_struct_align	a2)
+{
+	struct cls_struct_align r;
+
+	r.a = a1.a + a2.a;
+	r.b = a1.b + a2.b;
+	r.c = a1.c + a2.c;
+	r.d = a1.d + a2.d;
+	r.e = a1.e + a2.e;
+	r.f = a1.f + a2.f;
+	r.g = a1.g + a2.g;
+
+	printf("%Lg %Lg %Lg %Lg %Lg %g %Lg %Lg %Lg %Lg %Lg %Lg %g %Lg: "
+		"%Lg %Lg %Lg %Lg %Lg %g %Lg\n",
+		a1.a, a1.b, a1.c, a1.d, a1.e, a1.f, a1.g,
+		a2.a, a2.b, a2.c, a2.d, a2.e, a2.f, a2.g,
+		r.a, r.b, r.c, r.d, r.e, r.f, r.g);
+
+	CHECK(a1.a == 1);
+	CHECK(a1.b == 2);
+	CHECK(a1.c == 3);
+	CHECK(a1.d == 4);
+	CHECK(a1.e == 5);
+	CHECK(a1.f == 6);
+	CHECK(a1.g == 7);
+
+	CHECK(a2.a == 8);
+	CHECK(a2.b == 9);
+	CHECK(a2.c == 10);
+	CHECK(a2.d == 11);
+	CHECK(a2.e == 12);
+	CHECK(a2.f == 13);
+	CHECK(a2.g == 14);
+
+	CHECK(r.a == 9);
+	CHECK(r.b == 11);
+	CHECK(r.c == 13);
+	CHECK(r.d == 15);
+	CHECK(r.e == 17);
+	CHECK(r.f == 19);
+	CHECK(r.g == 21);
+
+	return r;
+}
+
+static void
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args, 
+		    void* userdata __UNUSED__)
+{
+	struct cls_struct_align a1, a2;
+
+	a1 = *(struct cls_struct_align*)(args[0]);
+	a2 = *(struct cls_struct_align*)(args[1]);
+
+	*(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args_dbl[3];
+	ffi_type* cls_struct_fields[8];
+	ffi_type cls_struct_type;
+	ffi_type* dbl_arg_types[3];
+
+	struct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };
+	struct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };
+	struct cls_struct_align res_dbl;
+
+	cls_struct_type.size = 0;
+	cls_struct_type.alignment = 0;
+	cls_struct_type.type = FFI_TYPE_STRUCT;
+	cls_struct_type.elements = cls_struct_fields;
+
+	cls_struct_fields[0] = &ffi_type_longdouble;
+	cls_struct_fields[1] = &ffi_type_longdouble;
+	cls_struct_fields[2] = &ffi_type_longdouble;
+	cls_struct_fields[3] = &ffi_type_longdouble;
+	cls_struct_fields[4] = &ffi_type_longdouble;
+	cls_struct_fields[5] = &ffi_type_double;
+	cls_struct_fields[6] = &ffi_type_longdouble;
+	cls_struct_fields[7] = NULL;
+
+	dbl_arg_types[0] = &cls_struct_type;
+	dbl_arg_types[1] = &cls_struct_type;
+	dbl_arg_types[2] = NULL;
+
+	CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
+		dbl_arg_types) == FFI_OK);
+
+	args_dbl[0] = &g_dbl;
+	args_dbl[1] = &f_dbl;
+	args_dbl[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
+	/* { dg-output "1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
+	printf("res: %Lg %Lg %Lg %Lg %Lg %g %Lg\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
+	CHECK(res_dbl.a == 9);
+	CHECK(res_dbl.b == 11);
+	CHECK(res_dbl.c == 13);
+	CHECK(res_dbl.d == 15);
+	CHECK(res_dbl.e == 17);
+	CHECK(res_dbl.f == 19);
+	CHECK(res_dbl.g == 21);
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
+
+	res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_dbl, f_dbl);
+	/* { dg-output "\n1 2 3 4 5 6 7 8 9 10 11 12 13 14: 9 11 13 15 17 19 21" } */
+	printf("res: %Lg %Lg %Lg %Lg %Lg %g %Lg\n", res_dbl.a, res_dbl.b,
+		res_dbl.c, res_dbl.d, res_dbl.e, res_dbl.f, res_dbl.g);
+	/* { dg-output "\nres: 9 11 13 15 17 19 21" } */
+	CHECK(res_dbl.a == 9);
+	CHECK(res_dbl.b == 11);
+	CHECK(res_dbl.c == 13);
+	CHECK(res_dbl.d == 15);
+	CHECK(res_dbl.e == 17);
+	CHECK(res_dbl.f == 19);
+	CHECK(res_dbl.g == 21);
+  exit(0);
+}
+
+
+
Index: libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_float_double.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_float_double.c b/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_float_double.c
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/testsuite/libffi.closures/cls_many_mixed_float_double.c	
@@ -0,0 +1,55 @@
+/* Area:	closure_call
+   Purpose:	Check register allocation for closure calls with many float and double arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	<david.schneider@picle.org> */
+
+/* { dg-do run } */
+#include "ffitest.h"
+#include <float.h>
+#include <math.h>
+
+#define NARGS 16
+
+static void cls_mixed_float_double_fn(ffi_cif* cif , void* ret, void** args,
+			      void* userdata __UNUSED__)
+{
+    double r = 0;
+    unsigned int i;
+    double t;
+    for(i=0; i < cif->nargs; i++)
+    {
+        if(cif->arg_types[i] == &ffi_type_double) {
+				t = *(((double**)(args))[i]);
+        } else {
+				t = *(((float**)(args))[i]);
+        }
+        r += t;
+    }
+    *((double*)ret) = r;
+}
+typedef double (*cls_mixed)(double, float, double, double, double, double, double, float, float, double, float, float);
+
+int main (void)
+{
+    ffi_cif cif;
+    ffi_closure *closure;
+	void* code;
+    ffi_type *argtypes[12] = {&ffi_type_double, &ffi_type_float, &ffi_type_double,
+                          &ffi_type_double, &ffi_type_double, &ffi_type_double,
+                          &ffi_type_double, &ffi_type_float, &ffi_type_float,
+                          &ffi_type_double, &ffi_type_float, &ffi_type_float};
+
+
+    closure = ffi_closure_alloc(sizeof(ffi_closure), (void**)&code);
+    if(closure ==NULL)
+		abort();
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 12, &ffi_type_double, argtypes) == FFI_OK);
+	CHECK(ffi_prep_closure_loc(closure, &cif, cls_mixed_float_double_fn, NULL,  code) == FFI_OK);
+    double ret = ((cls_mixed)code)(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2);
+    ffi_closure_free(closure);
+	if(fabs(ret - 7.8) < FLT_EPSILON)
+		exit(0);
+	else
+		abort();
+}
Index: libffi-3.4.6/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/.gitignore b/libffi-3.4.6/.gitignore
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/.gitignore	
@@ -0,0 +1,46 @@
+.libs
+.deps
+*.o
+*.lo
+*.wasm
+*.js
+*.test
+*.log
+.dirstamp
+*.la
+Makefile
+!testsuite/libffi.bhaible/Makefile
+Makefile.in
+aclocal.m4
+compile
+!.ci/compile
+configure
+depcomp
+doc/libffi.info
+*~
+fficonfig.h.in
+fficonfig.h
+include/ffi.h
+include/ffitarget.h
+install-sh
+libffi.pc
+libtool
+ltmain.sh
+m4/libtool.m4
+m4/lt*.m4
+mdate-sh
+missing
+stamp-h1
+libffi*gz
+autom4te.cache
+libffi.xcodeproj/xcuserdata
+libffi.xcodeproj/project.xcworkspace
+build_*/
+darwin_*/
+src/arm/trampoline.S
+**/texinfo.tex
+target/
+__pycache__
+.docker_home
+emsdk
+test-results
Index: libffi-3.4.6/autogen.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/autogen.sh b/libffi-3.4.6/autogen.sh
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/autogen.sh	
@@ -0,0 +1,2 @@
+#!/bin/sh
+exec autoreconf -v -i
Index: libffi-3.4.6/config.sub
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/config.sub b/libffi-3.4.6/config.sub
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/config.sub	
@@ -0,0 +1,1892 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright 1992-2022 Free Software Foundation, Inc.
+
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2022-01-03'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+
+
+# Please send patches to <config-patches@gnu.org>.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
+
+Canonicalize a configuration name.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright 1992-2022 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo "$1"
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Split fields of configuration type
+# shellcheck disable=SC2162
+saved_IFS=$IFS
+IFS="-" read field1 field2 field3 field4 <<EOF
+$1
+EOF
+IFS=$saved_IFS
+
+# Separate into logical components for further validation
+case $1 in
+	*-*-*-*-*)
+		echo Invalid configuration \`"$1"\': more than four components >&2
+		exit 1
+		;;
+	*-*-*-*)
+		basic_machine=$field1-$field2
+		basic_os=$field3-$field4
+		;;
+	*-*-*)
+		# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two
+		# parts
+		maybe_os=$field2-$field3
+		case $maybe_os in
+			nto-qnx* | linux-* | uclinux-uclibc* \
+			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
+			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
+			| storm-chaos* | os2-emx* | rtmk-nova*)
+				basic_machine=$field1
+				basic_os=$maybe_os
+				;;
+			android-linux)
+				basic_machine=$field1-unknown
+				basic_os=linux-android
+				;;
+			*)
+				basic_machine=$field1-$field2
+				basic_os=$field3
+				;;
+		esac
+		;;
+	*-*)
+		# A lone config we happen to match not fitting any pattern
+		case $field1-$field2 in
+			decstation-3100)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			*-*)
+				# Second component is usually, but not always the OS
+				case $field2 in
+					# Prevent following clause from handling this valid os
+					sun*os*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+					zephyr*)
+						basic_machine=$field1-unknown
+						basic_os=$field2
+						;;
+					# Manufacturers
+					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
+					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
+					| unicom* | ibm* | next | hp | isi* | apollo | altos* \
+					| convergent* | ncr* | news | 32* | 3600* | 3100* \
+					| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \
+					| ultra | tti* | harris | dolphin | highlevel | gould \
+					| cbm | ns | masscomp | apple | axis | knuth | cray \
+					| microblaze* | sim | cisco \
+					| oki | wec | wrs | winbond)
+						basic_machine=$field1-$field2
+						basic_os=
+						;;
+					*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+				esac
+			;;
+		esac
+		;;
+	*)
+		# Convert single-component short-hands not valid as part of
+		# multi-component configurations.
+		case $field1 in
+			386bsd)
+				basic_machine=i386-pc
+				basic_os=bsd
+				;;
+			a29khif)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			adobe68k)
+				basic_machine=m68010-adobe
+				basic_os=scout
+				;;
+			alliant)
+				basic_machine=fx80-alliant
+				basic_os=
+				;;
+			altos | altos3068)
+				basic_machine=m68k-altos
+				basic_os=
+				;;
+			am29k)
+				basic_machine=a29k-none
+				basic_os=bsd
+				;;
+			amdahl)
+				basic_machine=580-amdahl
+				basic_os=sysv
+				;;
+			amiga)
+				basic_machine=m68k-unknown
+				basic_os=
+				;;
+			amigaos | amigados)
+				basic_machine=m68k-unknown
+				basic_os=amigaos
+				;;
+			amigaunix | amix)
+				basic_machine=m68k-unknown
+				basic_os=sysv4
+				;;
+			apollo68)
+				basic_machine=m68k-apollo
+				basic_os=sysv
+				;;
+			apollo68bsd)
+				basic_machine=m68k-apollo
+				basic_os=bsd
+				;;
+			aros)
+				basic_machine=i386-pc
+				basic_os=aros
+				;;
+			aux)
+				basic_machine=m68k-apple
+				basic_os=aux
+				;;
+			balance)
+				basic_machine=ns32k-sequent
+				basic_os=dynix
+				;;
+			blackfin)
+				basic_machine=bfin-unknown
+				basic_os=linux
+				;;
+			cegcc)
+				basic_machine=arm-unknown
+				basic_os=cegcc
+				;;
+			convex-c1)
+				basic_machine=c1-convex
+				basic_os=bsd
+				;;
+			convex-c2)
+				basic_machine=c2-convex
+				basic_os=bsd
+				;;
+			convex-c32)
+				basic_machine=c32-convex
+				basic_os=bsd
+				;;
+			convex-c34)
+				basic_machine=c34-convex
+				basic_os=bsd
+				;;
+			convex-c38)
+				basic_machine=c38-convex
+				basic_os=bsd
+				;;
+			cray)
+				basic_machine=j90-cray
+				basic_os=unicos
+				;;
+			crds | unos)
+				basic_machine=m68k-crds
+				basic_os=
+				;;
+			da30)
+				basic_machine=m68k-da30
+				basic_os=
+				;;
+			decstation | pmax | pmin | dec3100 | decstatn)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			delta88)
+				basic_machine=m88k-motorola
+				basic_os=sysv3
+				;;
+			dicos)
+				basic_machine=i686-pc
+				basic_os=dicos
+				;;
+			djgpp)
+				basic_machine=i586-pc
+				basic_os=msdosdjgpp
+				;;
+			ebmon29k)
+				basic_machine=a29k-amd
+				basic_os=ebmon
+				;;
+			es1800 | OSE68k | ose68k | ose | OSE)
+				basic_machine=m68k-ericsson
+				basic_os=ose
+				;;
+			gmicro)
+				basic_machine=tron-gmicro
+				basic_os=sysv
+				;;
+			go32)
+				basic_machine=i386-pc
+				basic_os=go32
+				;;
+			h8300hms)
+				basic_machine=h8300-hitachi
+				basic_os=hms
+				;;
+			h8300xray)
+				basic_machine=h8300-hitachi
+				basic_os=xray
+				;;
+			h8500hms)
+				basic_machine=h8500-hitachi
+				basic_os=hms
+				;;
+			harris)
+				basic_machine=m88k-harris
+				basic_os=sysv3
+				;;
+			hp300 | hp300hpux)
+				basic_machine=m68k-hp
+				basic_os=hpux
+				;;
+			hp300bsd)
+				basic_machine=m68k-hp
+				basic_os=bsd
+				;;
+			hppaosf)
+				basic_machine=hppa1.1-hp
+				basic_os=osf
+				;;
+			hppro)
+				basic_machine=hppa1.1-hp
+				basic_os=proelf
+				;;
+			i386mach)
+				basic_machine=i386-mach
+				basic_os=mach
+				;;
+			isi68 | isi)
+				basic_machine=m68k-isi
+				basic_os=sysv
+				;;
+			m68knommu)
+				basic_machine=m68k-unknown
+				basic_os=linux
+				;;
+			magnum | m3230)
+				basic_machine=mips-mips
+				basic_os=sysv
+				;;
+			merlin)
+				basic_machine=ns32k-utek
+				basic_os=sysv
+				;;
+			mingw64)
+				basic_machine=x86_64-pc
+				basic_os=mingw64
+				;;
+			mingw32)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			mingw32ce)
+				basic_machine=arm-unknown
+				basic_os=mingw32ce
+				;;
+			monitor)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			morphos)
+				basic_machine=powerpc-unknown
+				basic_os=morphos
+				;;
+			moxiebox)
+				basic_machine=moxie-unknown
+				basic_os=moxiebox
+				;;
+			msdos)
+				basic_machine=i386-pc
+				basic_os=msdos
+				;;
+			msys)
+				basic_machine=i686-pc
+				basic_os=msys
+				;;
+			mvs)
+				basic_machine=i370-ibm
+				basic_os=mvs
+				;;
+			nacl)
+				basic_machine=le32-unknown
+				basic_os=nacl
+				;;
+			ncr3000)
+				basic_machine=i486-ncr
+				basic_os=sysv4
+				;;
+			netbsd386)
+				basic_machine=i386-pc
+				basic_os=netbsd
+				;;
+			netwinder)
+				basic_machine=armv4l-rebel
+				basic_os=linux
+				;;
+			news | news700 | news800 | news900)
+				basic_machine=m68k-sony
+				basic_os=newsos
+				;;
+			news1000)
+				basic_machine=m68030-sony
+				basic_os=newsos
+				;;
+			necv70)
+				basic_machine=v70-nec
+				basic_os=sysv
+				;;
+			nh3000)
+				basic_machine=m68k-harris
+				basic_os=cxux
+				;;
+			nh[45]000)
+				basic_machine=m88k-harris
+				basic_os=cxux
+				;;
+			nindy960)
+				basic_machine=i960-intel
+				basic_os=nindy
+				;;
+			mon960)
+				basic_machine=i960-intel
+				basic_os=mon960
+				;;
+			nonstopux)
+				basic_machine=mips-compaq
+				basic_os=nonstopux
+				;;
+			os400)
+				basic_machine=powerpc-ibm
+				basic_os=os400
+				;;
+			OSE68000 | ose68000)
+				basic_machine=m68000-ericsson
+				basic_os=ose
+				;;
+			os68k)
+				basic_machine=m68k-none
+				basic_os=os68k
+				;;
+			paragon)
+				basic_machine=i860-intel
+				basic_os=osf
+				;;
+			parisc)
+				basic_machine=hppa-unknown
+				basic_os=linux
+				;;
+			psp)
+				basic_machine=mipsallegrexel-sony
+				basic_os=psp
+				;;
+			pw32)
+				basic_machine=i586-unknown
+				basic_os=pw32
+				;;
+			rdos | rdos64)
+				basic_machine=x86_64-pc
+				basic_os=rdos
+				;;
+			rdos32)
+				basic_machine=i386-pc
+				basic_os=rdos
+				;;
+			rom68k)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			sa29200)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			sei)
+				basic_machine=mips-sei
+				basic_os=seiux
+				;;
+			sequent)
+				basic_machine=i386-sequent
+				basic_os=
+				;;
+			sps7)
+				basic_machine=m68k-bull
+				basic_os=sysv2
+				;;
+			st2000)
+				basic_machine=m68k-tandem
+				basic_os=
+				;;
+			stratus)
+				basic_machine=i860-stratus
+				basic_os=sysv4
+				;;
+			sun2)
+				basic_machine=m68000-sun
+				basic_os=
+				;;
+			sun2os3)
+				basic_machine=m68000-sun
+				basic_os=sunos3
+				;;
+			sun2os4)
+				basic_machine=m68000-sun
+				basic_os=sunos4
+				;;
+			sun3)
+				basic_machine=m68k-sun
+				basic_os=
+				;;
+			sun3os3)
+				basic_machine=m68k-sun
+				basic_os=sunos3
+				;;
+			sun3os4)
+				basic_machine=m68k-sun
+				basic_os=sunos4
+				;;
+			sun4)
+				basic_machine=sparc-sun
+				basic_os=
+				;;
+			sun4os3)
+				basic_machine=sparc-sun
+				basic_os=sunos3
+				;;
+			sun4os4)
+				basic_machine=sparc-sun
+				basic_os=sunos4
+				;;
+			sun4sol2)
+				basic_machine=sparc-sun
+				basic_os=solaris2
+				;;
+			sun386 | sun386i | roadrunner)
+				basic_machine=i386-sun
+				basic_os=
+				;;
+			sv1)
+				basic_machine=sv1-cray
+				basic_os=unicos
+				;;
+			symmetry)
+				basic_machine=i386-sequent
+				basic_os=dynix
+				;;
+			t3e)
+				basic_machine=alphaev5-cray
+				basic_os=unicos
+				;;
+			t90)
+				basic_machine=t90-cray
+				basic_os=unicos
+				;;
+			toad1)
+				basic_machine=pdp10-xkl
+				basic_os=tops20
+				;;
+			tpf)
+				basic_machine=s390x-ibm
+				basic_os=tpf
+				;;
+			udi29k)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			ultra3)
+				basic_machine=a29k-nyu
+				basic_os=sym1
+				;;
+			v810 | necv810)
+				basic_machine=v810-nec
+				basic_os=none
+				;;
+			vaxv)
+				basic_machine=vax-dec
+				basic_os=sysv
+				;;
+			vms)
+				basic_machine=vax-dec
+				basic_os=vms
+				;;
+			vsta)
+				basic_machine=i386-pc
+				basic_os=vsta
+				;;
+			vxworks960)
+				basic_machine=i960-wrs
+				basic_os=vxworks
+				;;
+			vxworks68)
+				basic_machine=m68k-wrs
+				basic_os=vxworks
+				;;
+			vxworks29k)
+				basic_machine=a29k-wrs
+				basic_os=vxworks
+				;;
+			xbox)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			ymp)
+				basic_machine=ymp-cray
+				basic_os=unicos
+				;;
+			*)
+				basic_machine=$1
+				basic_os=
+				;;
+		esac
+		;;
+esac
+
+# Decode 1-component or ad-hoc basic machines
+case $basic_machine in
+	# Here we handle the default manufacturer of certain CPU types.  It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		cpu=hppa1.1
+		vendor=winbond
+		;;
+	op50n)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	op60c)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	ibm*)
+		cpu=i370
+		vendor=ibm
+		;;
+	orion105)
+		cpu=clipper
+		vendor=highlevel
+		;;
+	mac | mpw | mac-mpw)
+		cpu=m68k
+		vendor=apple
+		;;
+	pmac | pmac-mpw)
+		cpu=powerpc
+		vendor=apple
+		;;
+
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		cpu=m68000
+		vendor=att
+		;;
+	3b*)
+		cpu=we32k
+		vendor=att
+		;;
+	bluegene*)
+		cpu=powerpc
+		vendor=ibm
+		basic_os=cnk
+		;;
+	decsystem10* | dec10*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops10
+		;;
+	decsystem20* | dec20*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		cpu=m68k
+		vendor=motorola
+		;;
+	dpx2*)
+		cpu=m68k
+		vendor=bull
+		basic_os=sysv3
+		;;
+	encore | umax | mmax)
+		cpu=ns32k
+		vendor=encore
+		;;
+	elxsi)
+		cpu=elxsi
+		vendor=elxsi
+		basic_os=${basic_os:-bsd}
+		;;
+	fx2800)
+		cpu=i860
+		vendor=alliant
+		;;
+	genix)
+		cpu=ns32k
+		vendor=ns
+		;;
+	h3050r* | hiux*)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		cpu=m68000
+		vendor=hp
+		;;
+	hp9k3[2-9][0-9])
+		cpu=m68k
+		vendor=hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	i*86v32)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv32
+		;;
+	i*86v4*)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv4
+		;;
+	i*86v)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv
+		;;
+	i*86sol2)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=solaris2
+		;;
+	j90 | j90-cray)
+		cpu=j90
+		vendor=cray
+		basic_os=${basic_os:-unicos}
+		;;
+	iris | iris4d)
+		cpu=mips
+		vendor=sgi
+		case $basic_os in
+		    irix*)
+			;;
+		    *)
+			basic_os=irix4
+			;;
+		esac
+		;;
+	miniframe)
+		cpu=m68000
+		vendor=convergent
+		;;
+	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		cpu=m68k
+		vendor=atari
+		basic_os=mint
+		;;
+	news-3600 | risc-news)
+		cpu=mips
+		vendor=sony
+		basic_os=newsos
+		;;
+	next | m*-next)
+		cpu=m68k
+		vendor=next
+		case $basic_os in
+		    openstep*)
+		        ;;
+		    nextstep*)
+			;;
+		    ns2*)
+		      basic_os=nextstep2
+			;;
+		    *)
+		      basic_os=nextstep3
+			;;
+		esac
+		;;
+	np1)
+		cpu=np1
+		vendor=gould
+		;;
+	op50n-* | op60c-*)
+		cpu=hppa1.1
+		vendor=oki
+		basic_os=proelf
+		;;
+	pa-hitachi)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	pbd)
+		cpu=sparc
+		vendor=tti
+		;;
+	pbb)
+		cpu=m68k
+		vendor=tti
+		;;
+	pc532)
+		cpu=ns32k
+		vendor=pc532
+		;;
+	pn)
+		cpu=pn
+		vendor=gould
+		;;
+	power)
+		cpu=power
+		vendor=ibm
+		;;
+	ps2)
+		cpu=i386
+		vendor=ibm
+		;;
+	rm[46]00)
+		cpu=mips
+		vendor=siemens
+		;;
+	rtpc | rtpc-*)
+		cpu=romp
+		vendor=ibm
+		;;
+	sde)
+		cpu=mipsisa32
+		vendor=sde
+		basic_os=${basic_os:-elf}
+		;;
+	simso-wrs)
+		cpu=sparclite
+		vendor=wrs
+		basic_os=vxworks
+		;;
+	tower | tower-32)
+		cpu=m68k
+		vendor=ncr
+		;;
+	vpp*|vx|vx-*)
+		cpu=f301
+		vendor=fujitsu
+		;;
+	w65)
+		cpu=w65
+		vendor=wdc
+		;;
+	w89k-*)
+		cpu=hppa1.1
+		vendor=winbond
+		basic_os=proelf
+		;;
+	none)
+		cpu=none
+		vendor=none
+		;;
+	leon|leon[3-9])
+		cpu=sparc
+		vendor=$basic_machine
+		;;
+	leon-*|leon[3-9]-*)
+		cpu=sparc
+		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+		;;
+
+	*-*)
+		# shellcheck disable=SC2162
+		saved_IFS=$IFS
+		IFS="-" read cpu vendor <<EOF
+$basic_machine
+EOF
+		IFS=$saved_IFS
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+		cpu=$basic_machine
+		vendor=pc
+		;;
+	# These rules are duplicated from below for sake of the special case above;
+	# i.e. things that normalized to x86 arches should also default to "pc"
+	pc98)
+		cpu=i386
+		vendor=pc
+		;;
+	x64 | amd64)
+		cpu=x86_64
+		vendor=pc
+		;;
+	# Recognize the basic CPU types without company name.
+	*)
+		cpu=$basic_machine
+		vendor=unknown
+		;;
+esac
+
+unset -v basic_machine
+
+# Decode basic machines in the full and proper CPU-Company form.
+case $cpu-$vendor in
+	# Here we handle the default manufacturer of certain CPU types in canonical form. It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	craynv-unknown)
+		vendor=cray
+		basic_os=${basic_os:-unicosmp}
+		;;
+	c90-unknown | c90-cray)
+		vendor=cray
+		basic_os=${Basic_os:-unicos}
+		;;
+	fx80-unknown)
+		vendor=alliant
+		;;
+	romp-unknown)
+		vendor=ibm
+		;;
+	mmix-unknown)
+		vendor=knuth
+		;;
+	microblaze-unknown | microblazeel-unknown)
+		vendor=xilinx
+		;;
+	rs6000-unknown)
+		vendor=ibm
+		;;
+	vax-unknown)
+		vendor=dec
+		;;
+	pdp11-unknown)
+		vendor=dec
+		;;
+	we32k-unknown)
+		vendor=att
+		;;
+	cydra-unknown)
+		vendor=cydrome
+		;;
+	i370-ibm*)
+		vendor=ibm
+		;;
+	orion-unknown)
+		vendor=highlevel
+		;;
+	xps-unknown | xps100-unknown)
+		cpu=xps100
+		vendor=honeywell
+		;;
+
+	# Here we normalize CPU types with a missing or matching vendor
+	armh-unknown | armh-alt)
+		cpu=armv7l
+		vendor=alt
+		basic_os=${basic_os:-linux-gnueabihf}
+		;;
+	dpx20-unknown | dpx20-bull)
+		cpu=rs6000
+		vendor=bull
+		basic_os=${basic_os:-bosx}
+		;;
+
+	# Here we normalize CPU types irrespective of the vendor
+	amd64-*)
+		cpu=x86_64
+		;;
+	blackfin-*)
+		cpu=bfin
+		basic_os=linux
+		;;
+	c54x-*)
+		cpu=tic54x
+		;;
+	c55x-*)
+		cpu=tic55x
+		;;
+	c6x-*)
+		cpu=tic6x
+		;;
+	e500v[12]-*)
+		cpu=powerpc
+		basic_os=${basic_os}"spe"
+		;;
+	mips3*-*)
+		cpu=mips64
+		;;
+	ms1-*)
+		cpu=mt
+		;;
+	m68knommu-*)
+		cpu=m68k
+		basic_os=linux
+		;;
+	m9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)
+		cpu=s12z
+		;;
+	openrisc-*)
+		cpu=or32
+		;;
+	parisc-*)
+		cpu=hppa
+		basic_os=linux
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		cpu=i586
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)
+		cpu=i686
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		cpu=i686
+		;;
+	pentium4-*)
+		cpu=i786
+		;;
+	pc98-*)
+		cpu=i386
+		;;
+	ppc-* | ppcbe-*)
+		cpu=powerpc
+		;;
+	ppcle-* | powerpclittle-*)
+		cpu=powerpcle
+		;;
+	ppc64-*)
+		cpu=powerpc64
+		;;
+	ppc64le-* | powerpc64little-*)
+		cpu=powerpc64le
+		;;
+	sb1-*)
+		cpu=mipsisa64sb1
+		;;
+	sb1el-*)
+		cpu=mipsisa64sb1el
+		;;
+	sh5e[lb]-*)
+		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
+		;;
+	spur-*)
+		cpu=spur
+		;;
+	strongarm-* | thumb-*)
+		cpu=arm
+		;;
+	tx39-*)
+		cpu=mipstx39
+		;;
+	tx39el-*)
+		cpu=mipstx39el
+		;;
+	x64-*)
+		cpu=x86_64
+		;;
+	xscale-* | xscalee[bl]-*)
+		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+		;;
+	arm64-* | arm64_32-* | aarch64le-*)
+		cpu=aarch64
+		;;
+
+	# Recognize the canonical CPU Types that limit and/or modify the
+	# company names they are paired with.
+	cr16-*)
+		basic_os=${basic_os:-elf}
+		;;
+	crisv32-* | etraxfs*-*)
+		cpu=crisv32
+		vendor=axis
+		;;
+	cris-* | etrax*-*)
+		cpu=cris
+		vendor=axis
+		;;
+	crx-*)
+		basic_os=${basic_os:-elf}
+		;;
+	neo-tandem)
+		cpu=neo
+		vendor=tandem
+		;;
+	nse-tandem)
+		cpu=nse
+		vendor=tandem
+		;;
+	nsr-tandem)
+		cpu=nsr
+		vendor=tandem
+		;;
+	nsv-tandem)
+		cpu=nsv
+		vendor=tandem
+		;;
+	nsx-tandem)
+		cpu=nsx
+		vendor=tandem
+		;;
+	mipsallegrexel-sony)
+		cpu=mipsallegrexel
+		vendor=sony
+		;;
+	tile*-*)
+		basic_os=${basic_os:-linux-gnu}
+		;;
+
+	*)
+		# Recognize the canonical CPU types that are allowed with any
+		# company name.
+		case $cpu in
+			1750a | 580 \
+			| a29k \
+			| aarch64 | aarch64_be \
+			| abacus \
+			| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \
+			| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \
+			| alphapca5[67] | alpha64pca5[67] \
+			| am33_2.0 \
+			| amdgcn \
+			| arc | arceb | arc32 | arc64 \
+			| arm | arm[lb]e | arme[lb] | armv* \
+			| avr | avr32 \
+			| asmjs \
+			| ba \
+			| be32 | be64 \
+			| bfin | bpf | bs2000 \
+			| c[123]* | c30 | [cjt]90 | c4x \
+			| c8051 | clipper | craynv | csky | cydra \
+			| d10v | d30v | dlx | dsp16xx \
+			| e2k | elxsi | epiphany \
+			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
+			| h8300 | h8500 \
+			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+			| hexagon \
+			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
+			| ip2k | iq2000 \
+			| k1om \
+			| le32 | le64 \
+			| lm32 \
+			| loongarch32 | loongarch64 | loongarchx32 \
+			| m32c | m32r | m32rle \
+			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
+			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
+			| m88110 | m88k | maxq | mb | mcore | mep | metag \
+			| microblaze | microblazeel \
+			| mips | mipsbe | mipseb | mipsel | mipsle \
+			| mips16 \
+			| mips64 | mips64eb | mips64el \
+			| mips64octeon | mips64octeonel \
+			| mips64orion | mips64orionel \
+			| mips64r5900 | mips64r5900el \
+			| mips64vr | mips64vrel \
+			| mips64vr4100 | mips64vr4100el \
+			| mips64vr4300 | mips64vr4300el \
+			| mips64vr5000 | mips64vr5000el \
+			| mips64vr5900 | mips64vr5900el \
+			| mipsisa32 | mipsisa32el \
+			| mipsisa32r2 | mipsisa32r2el \
+			| mipsisa32r3 | mipsisa32r3el \
+			| mipsisa32r5 | mipsisa32r5el \
+			| mipsisa32r6 | mipsisa32r6el \
+			| mipsisa64 | mipsisa64el \
+			| mipsisa64r2 | mipsisa64r2el \
+			| mipsisa64r3 | mipsisa64r3el \
+			| mipsisa64r5 | mipsisa64r5el \
+			| mipsisa64r6 | mipsisa64r6el \
+			| mipsisa64sb1 | mipsisa64sb1el \
+			| mipsisa64sr71k | mipsisa64sr71kel \
+			| mipsr5900 | mipsr5900el \
+			| mipstx39 | mipstx39el \
+			| mmix \
+			| mn10200 | mn10300 \
+			| moxie \
+			| mt \
+			| msp430 \
+			| nds32 | nds32le | nds32be \
+			| nfp \
+			| nios | nios2 | nios2eb | nios2el \
+			| none | np1 | ns16k | ns32k | nvptx \
+			| open8 \
+			| or1k* \
+			| or32 \
+			| orion \
+			| picochip \
+			| pdp10 | pdp11 | pj | pjl | pn | power \
+			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
+			| pru \
+			| pyramid \
+			| riscv | riscv32 | riscv32be | riscv64 | riscv64be \
+			| rl78 | romp | rs6000 | rx \
+			| s390 | s390x \
+			| score \
+			| sh | shl \
+			| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \
+			| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \
+			| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \
+			| sparclite \
+			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
+			| spu \
+			| tahoe \
+			| thumbv7* \
+			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tron \
+			| ubicom32 \
+			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
+			| vax \
+			| visium \
+			| w65 \
+			| wasm32 | wasm64 \
+			| we32k \
+			| x86 | x86_64 | xc16x | xgate | xps100 \
+			| xstormy16 | xtensa* \
+			| ymp \
+			| z8k | z80)
+				;;
+
+			*)
+				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
+				exit 1
+				;;
+		esac
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $vendor in
+	digital*)
+		vendor=dec
+		;;
+	commodore*)
+		vendor=cbm
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if test x$basic_os != x
+then
+
+# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
+# set os.
+case $basic_os in
+	gnu/linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
+		;;
+	os2-emx)
+		kernel=os2
+		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
+		;;
+	nto-qnx*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
+		;;
+	*-*)
+		# shellcheck disable=SC2162
+		saved_IFS=$IFS
+		IFS="-" read kernel os <<EOF
+$basic_os
+EOF
+		IFS=$saved_IFS
+		;;
+	# Default OS when just kernel was specified
+	nto*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
+		;;
+	linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
+		;;
+	*)
+		kernel=
+		os=$basic_os
+		;;
+esac
+
+# Now, normalize the OS (knowing we just have one component, it's not a kernel,
+# etc.)
+case $os in
+	# First match some system type aliases that might get confused
+	# with valid system types.
+	# solaris* is a basic system type, with this one exception.
+	auroraux)
+		os=auroraux
+		;;
+	bluegene*)
+		os=cnk
+		;;
+	solaris1 | solaris1.*)
+		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
+		;;
+	solaris)
+		os=solaris2
+		;;
+	unixware*)
+		os=sysv4.2uw
+		;;
+	# es1800 is here to avoid being matched by es* (a different OS)
+	es1800*)
+		os=ose
+		;;
+	# Some version numbers need modification
+	chorusos*)
+		os=chorusos
+		;;
+	isc)
+		os=isc2.2
+		;;
+	sco6)
+		os=sco5v6
+		;;
+	sco5)
+		os=sco3.2v5
+		;;
+	sco4)
+		os=sco3.2v4
+		;;
+	sco3.2.[4-9]*)
+		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
+		;;
+	sco*v* | scout)
+		# Don't match below
+		;;
+	sco*)
+		os=sco3.2v2
+		;;
+	psos*)
+		os=psos
+		;;
+	qnx*)
+		os=qnx
+		;;
+	hiux*)
+		os=hiuxwe2
+		;;
+	lynx*178)
+		os=lynxos178
+		;;
+	lynx*5)
+		os=lynxos5
+		;;
+	lynxos*)
+		# don't get caught up in next wildcard
+		;;
+	lynx*)
+		os=lynxos
+		;;
+	mac[0-9]*)
+		os=`echo "$os" | sed -e 's|mac|macos|'`
+		;;
+	opened*)
+		os=openedition
+		;;
+	os400*)
+		os=os400
+		;;
+	sunos5*)
+		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		;;
+	sunos6*)
+		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		;;
+	wince*)
+		os=wince
+		;;
+	utek*)
+		os=bsd
+		;;
+	dynix*)
+		os=bsd
+		;;
+	acis*)
+		os=aos
+		;;
+	atheos*)
+		os=atheos
+		;;
+	syllable*)
+		os=syllable
+		;;
+	386bsd)
+		os=bsd
+		;;
+	ctix* | uts*)
+		os=sysv
+		;;
+	nova*)
+		os=rtmk-nova
+		;;
+	ns2)
+		os=nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	sinix5.*)
+		os=`echo "$os" | sed -e 's|sinix|sysv|'`
+		;;
+	sinix*)
+		os=sysv4
+		;;
+	tpf*)
+		os=tpf
+		;;
+	triton*)
+		os=sysv3
+		;;
+	oss*)
+		os=sysv3
+		;;
+	svr4*)
+		os=sysv4
+		;;
+	svr3)
+		os=sysv3
+		;;
+	sysvr4)
+		os=sysv4
+		;;
+	ose*)
+		os=ose
+		;;
+	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
+		os=mint
+		;;
+	dicos*)
+		os=dicos
+		;;
+	pikeos*)
+		# Until real need of OS specific support for
+		# particular features comes up, bare metal
+		# configurations are quite functional.
+		case $cpu in
+		    arm*)
+			os=eabi
+			;;
+		    *)
+			os=elf
+			;;
+		esac
+		;;
+	*)
+		# No normalization, but not necessarily accepted, that comes below.
+		;;
+esac
+
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+kernel=
+case $cpu-$vendor in
+	score-*)
+		os=elf
+		;;
+	spu-*)
+		os=elf
+		;;
+	*-acorn)
+		os=riscix1.2
+		;;
+	arm*-rebel)
+		kernel=linux
+		os=gnu
+		;;
+	arm*-semi)
+		os=aout
+		;;
+	c4x-* | tic4x-*)
+		os=coff
+		;;
+	c8051-*)
+		os=elf
+		;;
+	clipper-intergraph)
+		os=clix
+		;;
+	hexagon-*)
+		os=elf
+		;;
+	tic54x-*)
+		os=coff
+		;;
+	tic55x-*)
+		os=coff
+		;;
+	tic6x-*)
+		os=coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=tops20
+		;;
+	pdp11-*)
+		os=none
+		;;
+	*-dec | vax-*)
+		os=ultrix4.2
+		;;
+	m68*-apollo)
+		os=domain
+		;;
+	i386-sun)
+		os=sunos4.0.2
+		;;
+	m68000-sun)
+		os=sunos3
+		;;
+	m68*-cisco)
+		os=aout
+		;;
+	mep-*)
+		os=elf
+		;;
+	mips*-cisco)
+		os=elf
+		;;
+	mips*-*)
+		os=elf
+		;;
+	or32-*)
+		os=coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=sysv3
+		;;
+	sparc-* | *-sun)
+		os=sunos4.1.1
+		;;
+	pru-*)
+		os=elf
+		;;
+	*-be)
+		os=beos
+		;;
+	*-ibm)
+		os=aix
+		;;
+	*-knuth)
+		os=mmixware
+		;;
+	*-wec)
+		os=proelf
+		;;
+	*-winbond)
+		os=proelf
+		;;
+	*-oki)
+		os=proelf
+		;;
+	*-hp)
+		os=hpux
+		;;
+	*-hitachi)
+		os=hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=sysv
+		;;
+	*-cbm)
+		os=amigaos
+		;;
+	*-dg)
+		os=dgux
+		;;
+	*-dolphin)
+		os=sysv3
+		;;
+	m68k-ccur)
+		os=rtu
+		;;
+	m88k-omron*)
+		os=luna
+		;;
+	*-next)
+		os=nextstep
+		;;
+	*-sequent)
+		os=ptx
+		;;
+	*-crds)
+		os=unos
+		;;
+	*-ns)
+		os=genix
+		;;
+	i370-*)
+		os=mvs
+		;;
+	*-gould)
+		os=sysv
+		;;
+	*-highlevel)
+		os=bsd
+		;;
+	*-encore)
+		os=bsd
+		;;
+	*-sgi)
+		os=irix
+		;;
+	*-siemens)
+		os=sysv4
+		;;
+	*-masscomp)
+		os=rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=uxpv
+		;;
+	*-rom68k)
+		os=coff
+		;;
+	*-*bug)
+		os=coff
+		;;
+	*-apple)
+		os=macos
+		;;
+	*-atari*)
+		os=mint
+		;;
+	*-wrs)
+		os=vxworks
+		;;
+	*)
+		os=none
+		;;
+esac
+
+fi
+
+# Now, validate our (potentially fixed-up) OS.
+case $os in
+	# Sometimes we do "kernel-libc", so those need to count as OSes.
+	musl* | newlib* | relibc* | uclibc*)
+		;;
+	# Likewise for "kernel-abi"
+	eabi* | gnueabi*)
+		;;
+	# VxWorks passes extra cpu info in the 4th filed.
+	simlinux | simwindows | spe)
+		;;
+	# Now accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST end in a * to match a version number.
+	gnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \
+	     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \
+	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
+	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
+	     | hiux* | abug | nacl* | netware* | windows* \
+	     | os9* | macos* | osx* | ios* | watchos* | tvos* \
+	     | mpw* | magic* | mmixware* | mon960* | lnews* \
+	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
+	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
+	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
+	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
+	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
+	     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \
+	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
+	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
+	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
+	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
+	     | chorusrdb* | cegcc* | glidix* | serenity* \
+	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
+	     | midipix* | mingw32* | mingw64* | mint* \
+	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
+	     | interix* | uwin* | mks* | rhapsody* | darwin* \
+	     | openstep* | oskit* | conix* | pw32* | nonstopux* \
+	     | storm-chaos* | tops10* | tenex* | tops20* | its* \
+	     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \
+	     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \
+	     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \
+	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
+	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
+	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
+	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
+	     | fiwix* )
+		;;
+	# This one is extra strict with allowed versions
+	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		;;
+	none)
+		;;
+	*)
+		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# As a final step for OS-related things, validate the OS-kernel combination
+# (given a valid OS), if there is a kernel.
+case $kernel-$os in
+	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
+		   | linux-musl* | linux-relibc* | linux-uclibc* )
+		;;
+	uclinux-uclibc* )
+		;;
+	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* )
+		# These are just libc implementations, not actual OSes, and thus
+		# require a kernel.
+		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	kfreebsd*-gnu* | kopensolaris*-gnu*)
+		;;
+	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
+		;;
+	nto-qnx*)
+		;;
+	os2-emx)
+		;;
+	ios*-simulator | tvos*-simulator | watchos*-simulator)
+		;;
+	*-eabi* | *-gnueabi*)
+		;;
+	-*)
+		# Blank kernel with real OS is always fine.
+		;;
+	*-*)
+		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
+		exit 1
+		;;
+esac
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+case $vendor in
+	unknown)
+		case $cpu-$os in
+			*-riscix*)
+				vendor=acorn
+				;;
+			*-sunos*)
+				vendor=sun
+				;;
+			*-cnk* | *-aix*)
+				vendor=ibm
+				;;
+			*-beos*)
+				vendor=be
+				;;
+			*-hpux*)
+				vendor=hp
+				;;
+			*-mpeix*)
+				vendor=hp
+				;;
+			*-hiux*)
+				vendor=hitachi
+				;;
+			*-unos*)
+				vendor=crds
+				;;
+			*-dgux*)
+				vendor=dg
+				;;
+			*-luna*)
+				vendor=omron
+				;;
+			*-genix*)
+				vendor=ns
+				;;
+			*-clix*)
+				vendor=intergraph
+				;;
+			*-mvs* | *-opened*)
+				vendor=ibm
+				;;
+			*-os400*)
+				vendor=ibm
+				;;
+			s390-* | s390x-*)
+				vendor=ibm
+				;;
+			*-ptx*)
+				vendor=sequent
+				;;
+			*-tpf*)
+				vendor=ibm
+				;;
+			*-vxsim* | *-vxworks* | *-windiss*)
+				vendor=wrs
+				;;
+			*-aux*)
+				vendor=apple
+				;;
+			*-hms*)
+				vendor=hitachi
+				;;
+			*-mpw* | *-macos*)
+				vendor=apple
+				;;
+			*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)
+				vendor=atari
+				;;
+			*-vos*)
+				vendor=stratus
+				;;
+		esac
+		;;
+esac
+
+echo "$cpu-$vendor-${kernel:+$kernel-}$os"
+exit
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
Index: libffi-3.4.6/msvc_build/aarch64/aarch64_include/ffi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvc_build/aarch64/aarch64_include/ffi.h b/libffi-3.4.6/msvc_build/aarch64/aarch64_include/ffi.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvc_build/aarch64/aarch64_include/ffi.h	
@@ -0,0 +1,511 @@
+/* -----------------------------------------------------------------*-C-*-
+   libffi 3.3-rc0 - Copyright (c) 2011, 2014 Anthony Green
+                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------
+   Most of the API is documented in doc/libffi.texi.
+
+   The raw API is designed to bypass some of the argument packing and
+   unpacking on architectures for which it can be avoided.  Routines
+   are provided to emulate the raw API if the underlying platform
+   doesn't allow faster implementation.
+
+   More details on the raw API can be found in:
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00138.html
+
+   and
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00174.html
+   -------------------------------------------------------------------- */
+
+#ifndef LIBFFI_H
+#define LIBFFI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Specify which architecture libffi is configured for. */
+#ifndef AARCH64
+#define AARCH64
+#endif
+
+/* ---- System configuration information --------------------------------- */
+
+#include <ffitarget.h>
+
+#ifndef LIBFFI_ASM
+
+#if defined(_MSC_VER) && !defined(__clang__)
+#define __attribute__(X)
+#endif
+
+#include <stddef.h>
+#include <limits.h>
+
+/* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).
+   But we can find it either under the correct ANSI name, or under GNU
+   C's internal name.  */
+
+#define FFI_64_BIT_MAX 9223372036854775807
+
+#ifdef LONG_LONG_MAX
+# define FFI_LONG_LONG_MAX LONG_LONG_MAX
+#else
+# ifdef LLONG_MAX
+#  define FFI_LONG_LONG_MAX LLONG_MAX
+#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */
+#   undef FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif /* _AIX52 or newer */
+# else
+#  ifdef __GNUC__
+#   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__
+#  endif
+#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */
+#   ifndef __PPC64__
+#    if defined (__IBMC__) || defined (__IBMCPP__)
+#     define FFI_LONG_LONG_MAX LONGLONG_MAX
+#    endif
+#   endif /* __PPC64__ */
+#   undef  FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif
+# endif
+#endif
+
+/* The closure code assumes that this works on pointers, i.e. a size_t
+   can hold a pointer.  */
+
+typedef struct _ffi_type
+{
+  size_t size;
+  unsigned short alignment;
+  unsigned short type;
+  struct _ffi_type **elements;
+} ffi_type;
+
+/* Need minimal decorations for DLLs to work on Windows.  GCC has
+   autoimport and autoexport.  Always mark externally visible symbols
+   as dllimport for MSVC clients, even if it means an extra indirection
+   when using the static version of the library.
+   Besides, as a workaround, they can define FFI_BUILDING if they
+   *know* they are going to link with the static library.  */
+#if defined _MSC_VER
+# if defined FFI_BUILDING_DLL /* Building libffi.DLL with msvcc.sh */
+#  define FFI_API __declspec(dllexport)
+# elif !defined FFI_BUILDING  /* Importing libffi.DLL */
+#  define FFI_API __declspec(dllimport)
+# else                        /* Building/linking static library */
+#  define FFI_API
+# endif
+#else
+# define FFI_API
+#endif
+
+/* The externally visible type declarations also need the MSVC DLL
+   decorations, or they will not be exported from the object file.  */
+#if defined LIBFFI_HIDE_BASIC_TYPES
+# define FFI_EXTERN FFI_API
+#else
+# define FFI_EXTERN extern FFI_API
+#endif
+
+#ifndef LIBFFI_HIDE_BASIC_TYPES
+#if SCHAR_MAX == 127
+# define ffi_type_uchar                ffi_type_uint8
+# define ffi_type_schar                ffi_type_sint8
+#else
+ #error "char size not supported"
+#endif
+
+#if SHRT_MAX == 32767
+# define ffi_type_ushort       ffi_type_uint16
+# define ffi_type_sshort       ffi_type_sint16
+#elif SHRT_MAX == 2147483647
+# define ffi_type_ushort       ffi_type_uint32
+# define ffi_type_sshort       ffi_type_sint32
+#else
+ #error "short size not supported"
+#endif
+
+#if INT_MAX == 32767
+# define ffi_type_uint         ffi_type_uint16
+# define ffi_type_sint         ffi_type_sint16
+#elif INT_MAX == 2147483647
+# define ffi_type_uint         ffi_type_uint32
+# define ffi_type_sint         ffi_type_sint32
+#elif INT_MAX == 9223372036854775807
+# define ffi_type_uint         ffi_type_uint64
+# define ffi_type_sint         ffi_type_sint64
+#else
+ #error "int size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX
+ #error "no 64-bit data type supported"
+# endif
+#elif LONG_MAX != FFI_64_BIT_MAX
+ #error "long size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# define ffi_type_ulong        ffi_type_uint32
+# define ffi_type_slong        ffi_type_sint32
+#elif LONG_MAX == FFI_64_BIT_MAX
+# define ffi_type_ulong        ffi_type_uint64
+# define ffi_type_slong        ffi_type_sint64
+#else
+ #error "long size not supported"
+#endif
+
+/* These are defined in types.c.  */
+FFI_EXTERN ffi_type ffi_type_void;
+FFI_EXTERN ffi_type ffi_type_uint8;
+FFI_EXTERN ffi_type ffi_type_sint8;
+FFI_EXTERN ffi_type ffi_type_uint16;
+FFI_EXTERN ffi_type ffi_type_sint16;
+FFI_EXTERN ffi_type ffi_type_uint32;
+FFI_EXTERN ffi_type ffi_type_sint32;
+FFI_EXTERN ffi_type ffi_type_uint64;
+FFI_EXTERN ffi_type ffi_type_sint64;
+FFI_EXTERN ffi_type ffi_type_float;
+FFI_EXTERN ffi_type ffi_type_double;
+FFI_EXTERN ffi_type ffi_type_pointer;
+
+#ifndef _M_ARM64
+FFI_EXTERN ffi_type ffi_type_longdouble;
+#else
+#define ffi_type_longdouble ffi_type_double
+#endif
+
+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
+FFI_EXTERN ffi_type ffi_type_complex_float;
+FFI_EXTERN ffi_type ffi_type_complex_double;
+#if 1
+FFI_EXTERN ffi_type ffi_type_complex_longdouble;
+#else
+#define ffi_type_complex_longdouble ffi_type_complex_double
+#endif
+#endif
+#endif /* LIBFFI_HIDE_BASIC_TYPES */
+
+typedef enum {
+  FFI_OK = 0,
+  FFI_BAD_TYPEDEF,
+  FFI_BAD_ABI
+} ffi_status;
+
+typedef struct {
+  ffi_abi abi;
+  unsigned nargs;
+  ffi_type **arg_types;
+  ffi_type *rtype;
+  unsigned bytes;
+  unsigned flags;
+#ifdef FFI_EXTRA_CIF_FIELDS
+  FFI_EXTRA_CIF_FIELDS;
+#endif
+} ffi_cif;
+
+/* ---- Definitions for the raw API -------------------------------------- */
+
+#ifndef FFI_SIZEOF_ARG
+# if LONG_MAX == 2147483647
+#  define FFI_SIZEOF_ARG        4
+# elif LONG_MAX == FFI_64_BIT_MAX
+#  define FFI_SIZEOF_ARG        8
+# endif
+#endif
+
+#ifndef FFI_SIZEOF_JAVA_RAW
+#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG
+#endif
+
+typedef union {
+  ffi_sarg  sint;
+  ffi_arg   uint;
+  float	    flt;
+  char      data[FFI_SIZEOF_ARG];
+  void*     ptr;
+} ffi_raw;
+
+#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8
+/* This is a special case for mips64/n32 ABI (and perhaps others) where
+   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */
+typedef union {
+  signed int	sint;
+  unsigned int	uint;
+  float		flt;
+  char		data[FFI_SIZEOF_JAVA_RAW];
+  void*		ptr;
+} ffi_java_raw;
+#else
+typedef ffi_raw ffi_java_raw;
+#endif
+
+
+FFI_API 
+void ffi_raw_call (ffi_cif *cif,
+		   void (*fn)(void),
+		   void *rvalue,
+		   ffi_raw *avalue);
+
+FFI_API void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
+FFI_API void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
+FFI_API size_t ffi_raw_size (ffi_cif *cif);
+
+/* This is analogous to the raw API, except it uses Java parameter
+   packing, even on 64-bit machines.  I.e. on 64-bit machines longs
+   and doubles are followed by an empty 64-bit word.  */
+
+FFI_API
+void ffi_java_raw_call (ffi_cif *cif,
+			void (*fn)(void),
+			void *rvalue,
+			ffi_java_raw *avalue);
+
+FFI_API
+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);
+FFI_API
+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);
+FFI_API
+size_t ffi_java_raw_size (ffi_cif *cif);
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#if FFI_CLOSURES
+
+#ifdef _MSC_VER
+__declspec(align(8))
+#endif
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+  void      *user_data;
+} ffi_closure
+#ifdef __GNUC__
+    __attribute__((aligned (8)))
+#endif
+    ;
+
+#ifndef __GNUC__
+# ifdef __sgi
+#  pragma pack 0
+# endif
+#endif
+
+FFI_API void *ffi_closure_alloc (size_t size, void **code);
+FFI_API void ffi_closure_free (void *);
+
+FFI_API ffi_status
+ffi_prep_closure (ffi_closure*,
+		  ffi_cif *,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+#if defined(__GNUC__) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 405)
+  __attribute__((deprecated ("use ffi_prep_closure_loc instead")))
+#elif defined(__GNUC__) && __GNUC__ >= 3
+  __attribute__((deprecated))
+#endif
+  ;
+
+FFI_API ffi_status
+ffi_prep_closure_loc (ffi_closure*,
+		      ffi_cif *,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void*codeloc);
+
+#ifdef __sgi
+# pragma pack 8
+#endif
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout 
+     as a regular closure.  We use this to install an intermediate 
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_raw*,void*);
+  void      *user_data;
+
+} ffi_raw_closure;
+
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout 
+     as a regular closure.  We use this to install an intermediate 
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
+  void      *user_data;
+
+} ffi_java_raw_closure;
+
+FFI_API ffi_status
+ffi_prep_raw_closure (ffi_raw_closure*,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+		      void *user_data);
+
+FFI_API ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure*,
+			  ffi_cif *cif,
+			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+			  void *user_data,
+			  void *codeloc);
+
+FFI_API ffi_status
+ffi_prep_java_raw_closure (ffi_java_raw_closure*,
+		           ffi_cif *cif,
+		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+		           void *user_data);
+
+FFI_API ffi_status
+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
+			       ffi_cif *cif,
+			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+			       void *user_data,
+			       void *codeloc);
+
+#endif /* FFI_CLOSURES */
+
+#ifdef FFI_GO_CLOSURES
+
+typedef struct {
+  void      *tramp;
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+} ffi_go_closure;
+
+FFI_API ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
+				void (*fun)(ffi_cif*,void*,void**,void*));
+
+FFI_API void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+		  void **avalue, void *closure);
+
+#endif /* FFI_GO_CLOSURES */
+
+/* ---- Public interface definition -------------------------------------- */
+
+FFI_API 
+ffi_status ffi_prep_cif(ffi_cif *cif,
+			ffi_abi abi,
+			unsigned int nargs,
+			ffi_type *rtype,
+			ffi_type **atypes);
+
+FFI_API
+ffi_status ffi_prep_cif_var(ffi_cif *cif,
+			    ffi_abi abi,
+			    unsigned int nfixedargs,
+			    unsigned int ntotalargs,
+			    ffi_type *rtype,
+			    ffi_type **atypes);
+
+FFI_API
+void ffi_call(ffi_cif *cif,
+	      void (*fn)(void),
+	      void *rvalue,
+	      void **avalue);
+
+FFI_API
+ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
+				   size_t *offsets);
+
+/* Useful for eliminating compiler warnings.  */
+#define FFI_FN(f) ((void (*)(void))f)
+
+/* ---- Definitions shared with assembly code ---------------------------- */
+
+#endif
+
+/* If these change, update src/mips/ffitarget.h. */
+#define FFI_TYPE_VOID       0    
+#define FFI_TYPE_INT        1
+#define FFI_TYPE_FLOAT      2    
+#define FFI_TYPE_DOUBLE     3
+#ifndef _M_ARM64
+#define FFI_TYPE_LONGDOUBLE 4
+#else
+#define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE
+#endif
+#define FFI_TYPE_UINT8      5   
+#define FFI_TYPE_SINT8      6
+#define FFI_TYPE_UINT16     7 
+#define FFI_TYPE_SINT16     8
+#define FFI_TYPE_UINT32     9
+#define FFI_TYPE_SINT32     10
+#define FFI_TYPE_UINT64     11
+#define FFI_TYPE_SINT64     12
+#define FFI_TYPE_STRUCT     13
+#define FFI_TYPE_POINTER    14
+#define FFI_TYPE_COMPLEX    15
+/* This should always refer to the last type code (for sanity checks).  */
+#define FFI_TYPE_LAST   FFI_TYPE_COMPLEX
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.sln
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.sln b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.sln
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.sln	
@@ -0,0 +1,33 @@
+
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 15
+VisualStudioVersion = 15.0.28302.56
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ffi_staticLib_arm64", "Ffi_staticLib.vcxproj", "{115502C0-BE05-4767-BF19-5C87D805FAD6}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|ARM64 = Debug|ARM64
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|ARM64 = Release|ARM64
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Debug|ARM64.Build.0 = Debug|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Debug|x64.ActiveCfg = Debug|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Debug|x86.ActiveCfg = Debug|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Release|ARM64.ActiveCfg = Release|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Release|ARM64.Build.0 = Release|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Release|x64.ActiveCfg = Release|ARM64
+		{115502C0-BE05-4767-BF19-5C87D805FAD6}.Release|x86.ActiveCfg = Release|ARM64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {241C54C7-20DD-4897-9376-E6B6D1B43BD5}
+	EndGlobalSection
+EndGlobal
Index: libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj	
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <VCProjectVersion>15.0</VCProjectVersion>
+    <ProjectGuid>{115502C0-BE05-4767-BF19-5C87D805FAD6}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FfistaticLib</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
+    <ProjectName>Ffi_staticLib_arm64</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v141</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v141</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>FFI_BUILDING_DLL;_DEBUG;_LIB;USE_DL_PREFIX;ARM64;_M_ARM64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalIncludeDirectories>..\..\include;.\aarch64_include;..\..\src\aarch64;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+      <BrowseInformation>true</BrowseInformation>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>FFI_BUILDING_DLL;USE_DL_PREFIX;ARM64;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalIncludeDirectories>..\..\include;.\aarch64_include;..\..\src\aarch64;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <OmitFramePointers>true</OmitFramePointers>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
+      <AdditionalUsingDirectories>..\..\src;..\..\src\aarch64;%(AdditionalUsingDirectories)</AdditionalUsingDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <ProjectReference>
+      <LinkLibraryDependencies>true</LinkLibraryDependencies>
+    </ProjectReference>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include=".\aarch64_include\ffi.h" />
+    <ClInclude Include=".\aarch64_include\fficonfig.h" />
+    <ClInclude Include="..\..\src\aarch64\ffitarget.h" />
+    <ClInclude Include="..\include\ffi_cfi.h" />
+    <ClInclude Include="..\include\ffi_common.h" />
+    <ClInclude Include="..\..\src\aarch64\internal.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\closures.c" />
+    <ClCompile Include="..\..\src\dlmalloc.c" />
+    <ClCompile Include="..\..\src\aarch64\ffi.c" />
+    <ClCompile Include="..\..\src\prep_cif.c" />
+    <ClCompile Include="..\..\src\types.c" />
+  </ItemGroup>
+  <!--ItemGroup>
+    <Object Include="..\..\..\..\Downloads\libffi-master-win64\src\aarch64\win64_armasm.obj" />
+  </ItemGroup-->
+  <ItemGroup>
+    <CustomBuild Include="..\..\src\aarch64\win64_armasm.S">
+      <!--ExcludedFromBuild Condition="'$(Platform)'!='ARM64'">true</ExcludedFromBuild -->
+      <Command>
+        cl /FA /EP /nologo /I"..\..\include" /I".\aarch64_include" /I"..\..\src\aarch64" "%(FullPath)" &gt; $(IntDir)win64_armasm.i
+        armasm64 $(IntDir)win64_armasm.i /I"src\" /I"..\..\include" /I"..\..\src\aarch64" -o "$(IntDir)win64_armasm.obj"
+      </Command>
+      <Outputs>win64_armasm.obj;%(Outputs)</Outputs>
+    </CustomBuild>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
Index: libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.user
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.user b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.user
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.user	
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup />
+</Project>
\ No newline at end of file
Index: libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.filters
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.filters b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.filters
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/msvc_build/aarch64/Ffi_staticLib.vcxproj.filters	
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\include\ffi.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\ffi_cfi.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\ffi_common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\fficonfig.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\ffitarget.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\internal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\closures.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dlmalloc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ffi.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\prep_cif.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\types.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <CustomBuild Include="src\win64_armasm.S" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
Index: libffi-3.4.6/stamp-h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/stamp-h.in b/libffi-3.4.6/stamp-h.in
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/stamp-h.in	
@@ -0,0 +1,1 @@
+timestamp
Index: libffi-3.4.6/Makefile.am
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/Makefile.am b/libffi-3.4.6/Makefile.am
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/Makefile.am	
@@ -0,0 +1,157 @@
+## Process this with automake to create Makefile.in
+
+AUTOMAKE_OPTIONS = foreign subdir-objects
+
+ACLOCAL_AMFLAGS = -I m4
+
+SUBDIRS = include testsuite man
+if BUILD_DOCS
+## This hack is needed because it doesn't seem possible to make a
+## conditional info_TEXINFOS in Automake.  At least Automake 1.14
+## either gives errors -- if this attempted in the most
+## straightforward way -- or simply unconditionally tries to build the
+## info file.
+SUBDIRS += doc
+endif
+
+EXTRA_DIST = LICENSE ChangeLog.old					\
+	m4/libtool.m4 m4/lt~obsolete.m4					\
+	 m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4			\
+	 m4/ltversion.m4 src/debug.c msvcc.sh				\
+	generate-darwin-source-and-headers.py				\
+	libffi.xcodeproj/project.pbxproj				\
+        src/powerpc/t-aix                                               \
+	libtool-ldflags libtool-version configure.host README.md        \
+	libffi.map.in LICENSE-BUILDTOOLS msvc_build make_sunver.pl
+
+# local.exp is generated by configure
+DISTCLEANFILES = local.exp
+
+# Subdir rules rely on $(FLAGS_TO_PASS)
+FLAGS_TO_PASS = $(AM_MAKEFLAGS)
+
+MAKEOVERRIDES=
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = libffi.pc
+
+toolexeclib_LTLIBRARIES = libffi.la
+noinst_LTLIBRARIES = libffi_convenience.la
+
+libffi_la_SOURCES = src/prep_cif.c src/types.c \
+		src/raw_api.c src/java_raw_api.c src/closures.c \
+		src/tramp.c
+
+if FFI_DEBUG
+libffi_la_SOURCES += src/debug.c
+endif
+
+noinst_HEADERS = src/aarch64/ffitarget.h src/aarch64/internal.h		\
+	src/alpha/ffitarget.h src/alpha/internal.h			\
+	src/arc/ffitarget.h src/arm/ffitarget.h src/arm/internal.h	\
+	src/avr32/ffitarget.h src/bfin/ffitarget.h			\
+	src/cris/ffitarget.h src/csky/ffitarget.h src/frv/ffitarget.h	\
+	src/ia64/ffitarget.h src/ia64/ia64_flags.h			\
+	src/m32r/ffitarget.h src/m68k/ffitarget.h			\
+	src/m88k/ffitarget.h src/metag/ffitarget.h			\
+	src/microblaze/ffitarget.h src/mips/ffitarget.h			\
+	src/moxie/ffitarget.h src/nios2/ffitarget.h			\
+	src/or1k/ffitarget.h src/pa/ffitarget.h				\
+	src/powerpc/ffitarget.h src/powerpc/asm.h			\
+	src/powerpc/ffi_powerpc.h src/riscv/ffitarget.h			\
+	src/s390/ffitarget.h src/s390/internal.h src/sh/ffitarget.h	\
+	src/sh64/ffitarget.h src/sparc/ffitarget.h			\
+	src/sparc/internal.h src/tile/ffitarget.h src/vax/ffitarget.h	\
+	src/wasm32/ffitarget.h \
+	src/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h	\
+	src/x86/asmnames.h src/xtensa/ffitarget.h src/dlmalloc.c	\
+	src/kvx/ffitarget.h src/kvx/asm.h				\
+	src/loongarch64/ffitarget.h
+
+EXTRA_libffi_la_SOURCES = src/aarch64/ffi.c src/aarch64/sysv.S		\
+	src/aarch64/win64_armasm.S src/alpha/ffi.c src/alpha/osf.S	\
+	src/arc/ffi.c src/arc/arcompact.S src/arm/ffi.c			\
+	src/arm/sysv.S src/arm/ffi.c src/arm/sysv_msvc_arm32.S		\
+	src/avr32/ffi.c src/avr32/sysv.S src/bfin/ffi.c			\
+	src/bfin/sysv.S src/cris/ffi.c src/cris/sysv.S src/frv/ffi.c	\
+	src/csky/ffi.c src/csky/sysv.S src/frv/eabi.S src/ia64/ffi.c	\
+	src/ia64/unix.S src/m32r/ffi.c src/m32r/sysv.S src/m68k/ffi.c	\
+	src/m68k/sysv.S src/m88k/ffi.c src/m88k/obsd.S			\
+	src/metag/ffi.c src/metag/sysv.S src/microblaze/ffi.c		\
+	src/microblaze/sysv.S src/mips/ffi.c src/mips/o32.S		\
+	src/mips/n32.S src/moxie/ffi.c src/moxie/eabi.S			\
+	src/nios2/ffi.c src/nios2/sysv.S src/or1k/ffi.c			\
+	src/or1k/sysv.S src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S	\
+	src/pa/hpux64.S src/powerpc/ffi.c src/powerpc/ffi_sysv.c	\
+	src/powerpc/ffi_linux64.c src/powerpc/sysv.S			\
+	src/powerpc/linux64.S src/powerpc/linux64_closure.S		\
+	src/powerpc/ppc_closure.S src/powerpc/aix.S			\
+	src/powerpc/darwin.S src/powerpc/aix_closure.S			\
+	src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c		\
+	src/riscv/ffi.c src/riscv/sysv.S src/s390/ffi.c			\
+	src/s390/sysv.S src/sh/ffi.c src/sh/sysv.S src/sh64/ffi.c	\
+	src/sh64/sysv.S src/sparc/ffi.c src/sparc/ffi64.c		\
+	src/sparc/v8.S src/sparc/v9.S src/tile/ffi.c src/tile/tile.S	\
+	src/vax/ffi.c src/vax/elfbsd.S src/x86/ffi.c src/x86/sysv.S	\
+	src/wasm32/ffi.c \
+	src/x86/ffiw64.c src/x86/win64.S src/x86/ffi64.c		\
+	src/x86/unix64.S src/x86/sysv_intel.S src/x86/win64_intel.S	\
+	src/xtensa/ffi.c src/xtensa/sysv.S src/kvx/ffi.c		\
+	src/kvx/sysv.S src/loongarch64/ffi.c src/loongarch64/sysv.S
+
+TARGET_OBJ = @TARGET_OBJ@
+libffi_la_LIBADD = $(TARGET_OBJ)
+
+libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)
+EXTRA_libffi_convenience_la_SOURCES = $(EXTRA_libffi_la_SOURCES)
+libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)
+libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)
+nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/libtool-ldflags $(LDFLAGS))
+
+AM_CFLAGS =
+if FFI_DEBUG
+# Build debug. Define FFI_DEBUG on the commandline so that, when building with
+# MSVC, it can link against the debug CRT.
+AM_CFLAGS += -DFFI_DEBUG
+endif
+
+if LIBFFI_BUILD_VERSIONED_SHLIB
+if LIBFFI_BUILD_VERSIONED_SHLIB_GNU
+libffi_version_script = -Wl,--version-script,libffi.map
+libffi_version_dep = libffi.map
+endif
+if LIBFFI_BUILD_VERSIONED_SHLIB_SUN
+libffi_version_script = -Wl,-M,libffi.map-sun
+libffi_version_dep = libffi.map-sun
+libffi.map-sun : libffi.map $(top_srcdir)/make_sunver.pl \
+		 $(libffi_la_OBJECTS) $(libffi_la_LIBADD)
+	perl $(top_srcdir)/make_sunver.pl libffi.map \
+	 `echo $(libffi_la_OBJECTS) $(libffi_la_LIBADD) | \
+	    sed 's,\([^/        ]*\)\.l\([ao]\),.libs/\1.\2,g'` \
+	 > $@ || (rm -f $@ ; exit 1)
+endif
+else
+libffi_version_script =
+libffi_version_dep =
+endif
+libffi_version_info = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
+
+libffi.map: $(top_srcdir)/libffi.map.in
+	$(COMPILE) -D$(TARGET) -DGENERATE_LIBFFI_MAP \
+	 -E -x assembler-with-cpp -o $@ $(top_srcdir)/libffi.map.in
+
+libffi_la_LDFLAGS = -no-undefined $(libffi_version_info) $(libffi_version_script) $(LTLDFLAGS) $(AM_LTLDFLAGS)
+libffi_la_DEPENDENCIES = $(libffi_la_LIBADD) $(libffi_version_dep)
+
+AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src
+AM_CCASFLAGS = $(AM_CPPFLAGS)
+
+dist-hook:
+	d=`(cd $(distdir); pwd)`; (cd doc; make pdf; cp *.pdf $$d/doc)
+	if [ -d $(top_srcdir)/.git ] ; then (cd $(top_srcdir); git log --no-decorate) ; else echo 'See git log for history.' ; fi > $(distdir)/ChangeLog
+	s=`awk '/was released on/{ print NR; exit}' $(top_srcdir)/README.md`; tail -n +$$(($$s-1)) $(top_srcdir)/README.md > $(distdir)/README.md
+
+# target overrides
+-include $(tmake_file)
Index: libffi-3.4.6/acinclude.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/acinclude.m4 b/libffi-3.4.6/acinclude.m4
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/acinclude.m4	
@@ -0,0 +1,377 @@
+# mmap(2) blacklisting.  Some platforms provide the mmap library routine
+# but don't support all of the features we need from it.
+AC_DEFUN([AC_FUNC_MMAP_BLACKLIST],
+[
+AC_CHECK_HEADER([sys/mman.h],
+		[libffi_header_sys_mman_h=yes], [libffi_header_sys_mman_h=no])
+AC_CHECK_FUNC([mmap], [libffi_func_mmap=yes], [libffi_func_mmap=no])
+if test "$libffi_header_sys_mman_h" != yes \
+ || test "$libffi_func_mmap" != yes; then
+   ac_cv_func_mmap_file=no
+   ac_cv_func_mmap_dev_zero=no
+   ac_cv_func_mmap_anon=no
+else
+   AC_CACHE_CHECK([whether read-only mmap of a plain file works],
+  ac_cv_func_mmap_file,
+  [# Add a system to this blacklist if
+   # mmap(0, stat_size, PROT_READ, MAP_PRIVATE, fd, 0) doesn't return a
+   # memory area containing the same data that you'd get if you applied
+   # read() to the same fd.  The only system known to have a problem here
+   # is VMS, where text files have record structure.
+   case "$host_os" in
+     vms* | ultrix*)
+	ac_cv_func_mmap_file=no ;;
+     *)
+	ac_cv_func_mmap_file=yes;;
+   esac])
+   AC_CACHE_CHECK([whether mmap from /dev/zero works],
+  ac_cv_func_mmap_dev_zero,
+  [# Add a system to this blacklist if it has mmap() but /dev/zero
+   # does not exist, or if mmapping /dev/zero does not give anonymous
+   # zeroed pages with both the following properties:
+   # 1. If you map N consecutive pages in with one call, and then
+   #    unmap any subset of those pages, the pages that were not
+   #    explicitly unmapped remain accessible.
+   # 2. If you map two adjacent blocks of memory and then unmap them
+   #    both at once, they must both go away.
+   # Systems known to be in this category are Windows (all variants),
+   # VMS, and Darwin.
+   case "$host_os" in
+     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)
+	ac_cv_func_mmap_dev_zero=no ;;
+     *)
+	ac_cv_func_mmap_dev_zero=yes;;
+   esac])
+
+   # Unlike /dev/zero, the MAP_ANON(YMOUS) defines can be probed for.
+   AC_CACHE_CHECK([for MAP_ANON(YMOUS)], ac_cv_decl_map_anon,
+    [AC_COMPILE_IFELSE(
+[AC_LANG_PROGRAM([[#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+]],
+[[int n = MAP_ANONYMOUS;]])],
+    ac_cv_decl_map_anon=yes,
+    ac_cv_decl_map_anon=no)])
+
+   if test $ac_cv_decl_map_anon = no; then
+     ac_cv_func_mmap_anon=no
+   else
+     AC_CACHE_CHECK([whether mmap with MAP_ANON(YMOUS) works],
+     ac_cv_func_mmap_anon,
+  [# Add a system to this blacklist if it has mmap() and MAP_ANON or
+   # MAP_ANONYMOUS, but using mmap(..., MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
+   # doesn't give anonymous zeroed pages with the same properties listed
+   # above for use of /dev/zero.
+   # Systems known to be in this category are Windows, VMS, and SCO Unix.
+   case "$host_os" in
+     vms* | cygwin* | pe | mingw* | sco* | udk* )
+	ac_cv_func_mmap_anon=no ;;
+     *)
+	ac_cv_func_mmap_anon=yes;;
+   esac])
+   fi
+fi
+
+if test $ac_cv_func_mmap_file = yes; then
+  AC_DEFINE(HAVE_MMAP_FILE, 1,
+	    [Define if read-only mmap of a plain file works.])
+fi
+if test $ac_cv_func_mmap_dev_zero = yes; then
+  AC_DEFINE(HAVE_MMAP_DEV_ZERO, 1,
+	    [Define if mmap of /dev/zero works.])
+fi
+if test $ac_cv_func_mmap_anon = yes; then
+  AC_DEFINE(HAVE_MMAP_ANON, 1,
+	    [Define if mmap with MAP_ANON(YMOUS) works.])
+fi
+])
+
+dnl ----------------------------------------------------------------------
+dnl This whole bit snagged from libstdc++-v3, via libatomic.
+
+dnl
+dnl LIBFFI_ENABLE
+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING)
+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, permit a|b|c)
+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, SHELL-CODE-HANDLER)
+dnl
+dnl See docs/html/17_intro/configury.html#enable for documentation.
+dnl
+m4_define([LIBFFI_ENABLE],[dnl
+m4_define([_g_switch],[--enable-$1])dnl
+m4_define([_g_help],[AS_HELP_STRING([_g_switch$3],[$4 @<:@default=$2@:>@])])dnl
+ AC_ARG_ENABLE($1,_g_help,
+  m4_bmatch([$5],
+   [^permit ],
+     [[
+      case "$enableval" in
+       m4_bpatsubst([$5],[permit ])) ;;
+       *) AC_MSG_ERROR(Unknown argument to enable/disable $1) ;;
+          dnl Idea for future:  generate a URL pointing to
+          dnl "onlinedocs/configopts.html#whatever"
+      esac
+     ]],
+   [^$],
+     [[
+      case "$enableval" in
+       yes|no) ;;
+       *) AC_MSG_ERROR(Argument to enable/disable $1 must be yes or no) ;;
+      esac
+     ]],
+   [[$5]]),
+  [enable_]m4_bpatsubst([$1],-,_)[=][$2])
+m4_undefine([_g_switch])dnl
+m4_undefine([_g_help])dnl
+])
+
+dnl
+dnl If GNU ld is in use, check to see if tricky linker opts can be used.  If
+dnl the native linker is in use, all variables will be defined to something
+dnl safe (like an empty string).
+dnl
+dnl Defines:
+dnl  SECTION_LDFLAGS='-Wl,--gc-sections' if possible
+dnl  OPT_LDFLAGS='-Wl,-O1' if possible
+dnl  LD (as a side effect of testing)
+dnl Sets:
+dnl  with_gnu_ld
+dnl  libat_ld_is_gold (possibly)
+dnl  libat_gnu_ld_version (possibly)
+dnl
+dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will
+dnl set libat_gnu_ld_version to 12345.  Zeros cause problems.
+dnl
+AC_DEFUN([LIBFFI_CHECK_LINKER_FEATURES], [
+  # If we're not using GNU ld, then there's no point in even trying these
+  # tests.  Check for that first.  We should have already tested for gld
+  # by now (in libtool), but require it now just to be safe...
+  test -z "$SECTION_LDFLAGS" && SECTION_LDFLAGS=''
+  test -z "$OPT_LDFLAGS" && OPT_LDFLAGS=''
+  AC_REQUIRE([LT_PATH_LD])
+  AC_REQUIRE([AC_PROG_AWK])
+
+  # The name set by libtool depends on the version of libtool.  Shame on us
+  # for depending on an impl detail, but c'est la vie.  Older versions used
+  # ac_cv_prog_gnu_ld, but now it's lt_cv_prog_gnu_ld, and is copied back on
+  # top of with_gnu_ld (which is also set by --with-gnu-ld, so that actually
+  # makes sense).  We'll test with_gnu_ld everywhere else, so if that isn't
+  # set (hence we're using an older libtool), then set it.
+  if test x${with_gnu_ld+set} != xset; then
+    if test x${ac_cv_prog_gnu_ld+set} != xset; then
+      # We got through "ac_require(ac_prog_ld)" and still not set?  Huh?
+      with_gnu_ld=no
+    else
+      with_gnu_ld=$ac_cv_prog_gnu_ld
+    fi
+  fi
+
+  # Start by getting the version number.  I think the libtool test already
+  # does some of this, but throws away the result.
+  libat_ld_is_gold=no
+  if $LD --version 2>/dev/null | grep 'GNU gold'> /dev/null 2>&1; then
+    libat_ld_is_gold=yes
+  fi
+  libat_ld_is_lld=no
+  if $LD --version 2>/dev/null | grep 'LLD '> /dev/null 2>&1; then
+    libat_ld_is_lld=yes
+  fi
+  changequote(,)
+  ldver=`$LD --version 2>/dev/null |
+         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \([0-9.][0-9.]*\).*/\1/; q'`
+  changequote([,])
+  libat_gnu_ld_version=`echo $ldver | \
+         $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`
+
+  # Set --gc-sections.
+  if test "$with_gnu_ld" = "notbroken"; then
+    # GNU ld it is!  Joy and bunny rabbits!
+
+    # All these tests are for C++; save the language and the compiler flags.
+    # Need to do this so that g++ won't try to link in libstdc++
+    ac_test_CFLAGS="${CFLAGS+set}"
+    ac_save_CFLAGS="$CFLAGS"
+    CFLAGS='-x c++  -Wl,--gc-sections'
+
+    # Check for -Wl,--gc-sections
+    # XXX This test is broken at the moment, as symbols required for linking
+    # are now in libsupc++ (not built yet).  In addition, this test has
+    # cored on solaris in the past.  In addition, --gc-sections doesn't
+    # really work at the moment (keeps on discarding used sections, first
+    # .eh_frame and now some of the glibc sections for iconv).
+    # Bzzzzt.  Thanks for playing, maybe next time.
+    AC_MSG_CHECKING([for ld that supports -Wl,--gc-sections])
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
+     int main(void)
+     {
+       try { throw 1; }
+       catch (...) { };
+       return 0;
+     }
+    ]])],[ac_sectionLDflags=yes],[ac_sectionLDflags=no],[ac_sectionLDflags=yes])
+    if test "$ac_test_CFLAGS" = set; then
+      CFLAGS="$ac_save_CFLAGS"
+    else
+      # this is the suspicious part
+      CFLAGS=''
+    fi
+    if test "$ac_sectionLDflags" = "yes"; then
+      SECTION_LDFLAGS="-Wl,--gc-sections $SECTION_LDFLAGS"
+    fi
+    AC_MSG_RESULT($ac_sectionLDflags)
+  fi
+
+  # Set linker optimization flags.
+  if test x"$with_gnu_ld" = x"yes"; then
+    OPT_LDFLAGS="-Wl,-O1 $OPT_LDFLAGS"
+  fi
+
+  AC_SUBST(SECTION_LDFLAGS)
+  AC_SUBST(OPT_LDFLAGS)
+])
+
+
+dnl
+dnl Add version tags to symbols in shared library (or not), additionally
+dnl marking other symbols as private/local (or not).
+dnl
+dnl --enable-symvers=style adds a version script to the linker call when
+dnl       creating the shared library.  The choice of version script is
+dnl       controlled by 'style'.
+dnl --disable-symvers does not.
+dnl  +  Usage:  LIBFFI_ENABLE_SYMVERS[(DEFAULT)]
+dnl       Where DEFAULT is either 'yes' or 'no'.  Passing `yes' tries to
+dnl       choose a default style based on linker characteristics.  Passing
+dnl       'no' disables versioning.
+dnl
+AC_DEFUN([LIBFFI_ENABLE_SYMVERS], [
+
+LIBFFI_ENABLE(symvers,yes,[=STYLE],
+  [enables symbol versioning of the shared library],
+  [permit yes|no|gnu*|sun])
+
+# If we never went through the LIBFFI_CHECK_LINKER_FEATURES macro, then we
+# don't know enough about $LD to do tricks...
+AC_REQUIRE([LIBFFI_CHECK_LINKER_FEATURES])
+
+# Turn a 'yes' into a suitable default.
+if test x$enable_symvers = xyes ; then
+  # FIXME  The following test is too strict, in theory.
+  if test $enable_shared = no || test "x$LD" = x; then
+    enable_symvers=no
+  else
+    if test $with_gnu_ld = yes ; then
+      enable_symvers=gnu
+    else
+      case ${target_os} in
+        # Sun symbol versioning exists since Solaris 2.5.
+        solaris2.[[5-9]]* | solaris2.1[[0-9]]*)
+          enable_symvers=sun ;;
+        *)
+          enable_symvers=no ;;
+      esac
+    fi
+  fi
+fi
+
+# Check if 'sun' was requested on non-Solaris 2 platforms.
+if test x$enable_symvers = xsun ; then
+  case ${target_os} in
+    solaris2*)
+      # All fine.
+      ;;
+    *)
+      # Unlikely to work.
+      AC_MSG_WARN([=== You have requested Sun symbol versioning, but])
+      AC_MSG_WARN([=== you are not targetting Solaris 2.])
+      AC_MSG_WARN([=== Symbol versioning will be disabled.])
+      enable_symvers=no
+      ;;
+  esac
+fi
+
+# Check to see if libgcc_s exists, indicating that shared libgcc is possible.
+if test $enable_symvers != no; then
+  AC_MSG_CHECKING([for shared libgcc])
+  ac_save_CFLAGS="$CFLAGS"
+  CFLAGS=' -lgcc_s'
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[return 0;]])],[libat_shared_libgcc=yes],[libat_shared_libgcc=no])
+  CFLAGS="$ac_save_CFLAGS"
+  if test $libat_shared_libgcc = no; then
+    cat > conftest.c <<EOF
+int main (void) { return 0; }
+EOF
+changequote(,)dnl
+    libat_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \
+			     -shared -shared-libgcc -o conftest.so \
+			     conftest.c -v 2>&1 >/dev/null \
+			     | sed -n 's/^.* -lgcc_s\([^ ]*\) .*$/\1/p'`
+changequote([,])dnl
+    rm -f conftest.c conftest.so
+    if test x${libat_libgcc_s_suffix+set} = xset; then
+      CFLAGS=" -lgcc_s$libat_libgcc_s_suffix"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[return 0;]])],[libat_shared_libgcc=yes],[])
+      CFLAGS="$ac_save_CFLAGS"
+    fi
+  fi
+  AC_MSG_RESULT($libat_shared_libgcc)
+fi
+
+# For GNU ld, we need at least this version.  The format is described in
+# LIBFFI_CHECK_LINKER_FEATURES above.
+libat_min_gnu_ld_version=21400
+# XXXXXXXXXXX libat_gnu_ld_version=21390
+
+# Check to see if unspecified "yes" value can win, given results above.
+# Change "yes" into either "no" or a style name.
+if test $enable_symvers != no && test $libat_shared_libgcc = yes; then
+  if test $with_gnu_ld = yes; then
+    if test $libat_gnu_ld_version -ge $libat_min_gnu_ld_version ; then
+      enable_symvers=gnu
+    elif test $libat_ld_is_gold = yes ; then
+      enable_symvers=gnu
+    elif test $libat_ld_is_lld = yes ; then
+      enable_symvers=gnu
+    else
+      # The right tools, the right setup, but too old.  Fallbacks?
+      AC_MSG_WARN(=== Linker version $libat_gnu_ld_version is too old for)
+      AC_MSG_WARN(=== full symbol versioning support in this release of GCC.)
+      AC_MSG_WARN(=== You would need to upgrade your binutils to version)
+      AC_MSG_WARN(=== $libat_min_gnu_ld_version or later and rebuild GCC.)
+      if test $libat_gnu_ld_version -ge 21200 ; then
+        # Globbing fix is present, proper block support is not.
+        dnl AC_MSG_WARN([=== Dude, you are soooo close.  Maybe we can fake it.])
+        dnl enable_symvers=???
+        AC_MSG_WARN([=== Symbol versioning will be disabled.])
+        enable_symvers=no
+      else
+        # 2.11 or older.
+        AC_MSG_WARN([=== Symbol versioning will be disabled.])
+        enable_symvers=no
+      fi
+    fi
+  elif test $enable_symvers = sun; then
+    : All interesting versions of Sun ld support sun style symbol versioning.
+  else
+    # just fail for now
+    AC_MSG_WARN([=== You have requested some kind of symbol versioning, but])
+    AC_MSG_WARN([=== either you are not using a supported linker, or you are])
+    AC_MSG_WARN([=== not building a shared libgcc_s (which is required).])
+    AC_MSG_WARN([=== Symbol versioning will be disabled.])
+    enable_symvers=no
+  fi
+fi
+if test $enable_symvers = gnu; then
+  AC_DEFINE(LIBFFI_GNU_SYMBOL_VERSIONING, 1,
+	    [Define to 1 if GNU symbol versioning is used for libatomic.])
+fi
+
+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)
+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB_GNU, test $enable_symvers = gnu)
+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB_SUN, test $enable_symvers = sun)
+AC_MSG_NOTICE(versioning on shared library symbols is $enable_symvers)
+])
Index: libffi-3.4.6/config.guess
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/config.guess b/libffi-3.4.6/config.guess
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/config.guess	
@@ -0,0 +1,1754 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright 1992-2022 Free Software Foundation, Inc.
+
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2022-01-09'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
+#
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
+
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright 1992-2022 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+# Just in case it came from the environment.
+GUESS=
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    # prevent multiple calls if $tmp is already set
+    test "$tmp" && return 0
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039,SC3028
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD=$driver
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if test -f /.attbin/uname ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+case $UNAME_SYSTEM in
+Linux|GNU|GNU/*)
+	LIBC=unknown
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#elif defined(__GLIBC__)
+	LIBC=gnu
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
+	#endif
+	EOF
+	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	eval "$cc_set_libc"
+
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
+	fi
+	;;
+esac
+
+# Note: order is significant - the case branches are not exclusive.
+
+case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    echo unknown)`
+	case $UNAME_MACHINE_ARCH in
+	    aarch64eb) machine=aarch64_be-unknown ;;
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
+	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently (or will in the future) and ABI.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		os=netbsdelf
+		;;
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep -q __ELF__
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+		os=netbsd
+		;;
+	esac
+	# Determine ABI tags.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case $UNAME_VERSION in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	GUESS=$machine-${os}${release}${abi-}
+	;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
+	;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
+	;;
+    *:SecBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
+	;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
+	;;
+    *:MidnightBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
+	;;
+    *:ekkoBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
+	;;
+    *:SolidBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
+	;;
+    *:OS108:*:*)
+	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
+	;;
+    macppc:MirBSD:*:*)
+	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
+	;;
+    *:MirBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
+	;;
+    *:Sortix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-sortix
+	;;
+    *:Twizzler:*:*)
+	GUESS=$UNAME_MACHINE-unknown-twizzler
+	;;
+    *:Redox:*:*)
+	GUESS=$UNAME_MACHINE-unknown-redox
+	;;
+    mips:OSF1:*.*)
+	GUESS=mips-dec-osf1
+	;;
+    alpha:OSF1:*:*)
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	trap '' 0
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case $ALPHA_CPU_TYPE in
+	    "EV4 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE=alpha ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE=alphaev5 ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE=alphaev56 ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE=alphapca56 ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE=alphapca57 ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE=alphaev6 ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE=alphaev67 ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE=alphaev69 ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE=alphaev7 ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE=alphaev79 ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
+	;;
+    Amiga*:UNIX_System_V:4.0:*)
+	GUESS=m68k-unknown-sysv4
+	;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	GUESS=$UNAME_MACHINE-unknown-amigaos
+	;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	GUESS=$UNAME_MACHINE-unknown-morphos
+	;;
+    *:OS/390:*:*)
+	GUESS=i370-ibm-openedition
+	;;
+    *:z/VM:*:*)
+	GUESS=s390-ibm-zvmoe
+	;;
+    *:OS400:*:*)
+	GUESS=powerpc-ibm-os400
+	;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	GUESS=arm-acorn-riscix$UNAME_RELEASE
+	;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	GUESS=arm-unknown-riscos
+	;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	GUESS=hppa1.1-hitachi-hiuxmpp
+	;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	case `(/bin/universe) 2>/dev/null` in
+	    att) GUESS=pyramid-pyramid-sysv3 ;;
+	    *)   GUESS=pyramid-pyramid-bsd   ;;
+	esac
+	;;
+    NILE*:*:*:dcosx)
+	GUESS=pyramid-pyramid-svr4
+	;;
+    DRS?6000:unix:4.0:6*)
+	GUESS=sparc-icl-nx6
+	;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) GUESS=sparc-icl-nx7 ;;
+	esac
+	;;
+    s390x:SunOS:*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
+	;;
+    sun4H:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-hal-solaris2$SUN_REL
+	;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris2$SUN_REL
+	;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	GUESS=i386-pc-auroraux$UNAME_RELEASE
+	;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	set_cc_for_build
+	SUN_ARCH=i386
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH=x86_64
+	    fi
+	fi
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
+	;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris3$SUN_REL
+	;;
+    sun4*:SunOS:*:*)
+	case `/usr/bin/arch -k` in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
+	GUESS=sparc-sun-sunos$SUN_REL
+	;;
+    sun3*:SunOS:*:*)
+	GUESS=m68k-sun-sunos$UNAME_RELEASE
+	;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+	case `/bin/arch` in
+	    sun3)
+		GUESS=m68k-sun-sunos$UNAME_RELEASE
+		;;
+	    sun4)
+		GUESS=sparc-sun-sunos$UNAME_RELEASE
+		;;
+	esac
+	;;
+    aushp:SunOS:*:*)
+	GUESS=sparc-auspex-sunos$UNAME_RELEASE
+	;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+	GUESS=m68k-milan-mint$UNAME_RELEASE
+	;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+	GUESS=m68k-hades-mint$UNAME_RELEASE
+	;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+	GUESS=m68k-unknown-mint$UNAME_RELEASE
+	;;
+    m68k:machten:*:*)
+	GUESS=m68k-apple-machten$UNAME_RELEASE
+	;;
+    powerpc:machten:*:*)
+	GUESS=powerpc-apple-machten$UNAME_RELEASE
+	;;
+    RISC*:Mach:*:*)
+	GUESS=mips-dec-mach_bsd4.3
+	;;
+    RISC*:ULTRIX:*:*)
+	GUESS=mips-dec-ultrix$UNAME_RELEASE
+	;;
+    VAX*:ULTRIX*:*:*)
+	GUESS=vax-dec-ultrix$UNAME_RELEASE
+	;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	GUESS=clipper-intergraph-clix$UNAME_RELEASE
+	;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	GUESS=mips-mips-riscos$UNAME_RELEASE
+	;;
+    Motorola:PowerMAX_OS:*:*)
+	GUESS=powerpc-motorola-powermax
+	;;
+    Motorola:*:4.3:PL8-*)
+	GUESS=powerpc-harris-powermax
+	;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	GUESS=powerpc-harris-powermax
+	;;
+    Night_Hawk:Power_UNIX:*:*)
+	GUESS=powerpc-harris-powerunix
+	;;
+    m88k:CX/UX:7*:*)
+	GUESS=m88k-harris-cxux7
+	;;
+    m88k:*:4*:R4*)
+	GUESS=m88k-motorola-sysv4
+	;;
+    m88k:*:3*:R3*)
+	GUESS=m88k-motorola-sysv3
+	;;
+    AViiON:dgux:*:*)
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
+	then
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
+	    then
+		GUESS=m88k-dg-dgux$UNAME_RELEASE
+	    else
+		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
+	    fi
+	else
+	    GUESS=i586-dg-dgux$UNAME_RELEASE
+	fi
+	;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	GUESS=m88k-dolphin-sysv3
+	;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	GUESS=m88k-motorola-sysv3
+	;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	GUESS=m88k-tektronix-sysv3
+	;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	GUESS=m68k-tektronix-bsd
+	;;
+    *:IRIX*:*:*)
+	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
+	GUESS=mips-sgi-irix$IRIX_REL
+	;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
+	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	GUESS=i386-ibm-aix
+	;;
+    ia64:AIX:*:*)
+	if test -x /usr/bin/oslevel ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+	fi
+	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
+	;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		then
+			GUESS=$SYSTEM_NAME
+		else
+			GUESS=rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		GUESS=rs6000-ibm-aix3.2.4
+	else
+		GUESS=rs6000-ibm-aix3.2
+	fi
+	;;
+    *:AIX:*:[4567])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+	else
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+	fi
+	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
+	;;
+    *:AIX:*:*)
+	GUESS=rs6000-ibm-aix
+	;;
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+	GUESS=romp-ibm-bsd4.4
+	;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
+	;;                                  # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	GUESS=rs6000-bull-bosx
+	;;
+    DPX/2?00:B.O.S.:*:*)
+	GUESS=m68k-bull-sysv3
+	;;
+    9000/[34]??:4.3bsd:1.*:*)
+	GUESS=m68k-hp-bsd
+	;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	GUESS=m68k-hp-bsd4.4
+	;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	case $UNAME_MACHINE in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if test -x /usr/bin/getconf; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case $sc_cpu_version in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case $sc_kernel_bits in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+			esac ;;
+		    esac
+		fi
+		if test "$HP_ARCH" = ""; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
+EOF
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if test "$HP_ARCH" = hppa2.0w
+	then
+	    set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
+	    then
+		HP_ARCH=hppa2.0w
+	    else
+		HP_ARCH=hppa64
+	    fi
+	fi
+	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
+	;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	GUESS=ia64-hp-hpux$HPUX_REV
+	;;
+    3050*:HI-UX:*:*)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	GUESS=unknown-hitachi-hiuxwe2
+	;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+	GUESS=hppa1.1-hp-bsd
+	;;
+    9000/8??:4.3bsd:*:*)
+	GUESS=hppa1.0-hp-bsd
+	;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	GUESS=hppa1.0-hp-mpeix
+	;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+	GUESS=hppa1.1-hp-osf
+	;;
+    hp8??:OSF1:*:*)
+	GUESS=hppa1.0-hp-osf
+	;;
+    i*86:OSF1:*:*)
+	if test -x /usr/sbin/sysversion ; then
+	    GUESS=$UNAME_MACHINE-unknown-osf1mk
+	else
+	    GUESS=$UNAME_MACHINE-unknown-osf1
+	fi
+	;;
+    parisc*:Lites*:*:*)
+	GUESS=hppa1.1-hp-lites
+	;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	GUESS=c1-convex-bsd
+	;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	GUESS=c34-convex-bsd
+	;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	GUESS=c38-convex-bsd
+	;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	GUESS=c4-convex-bsd
+	;;
+    CRAY*Y-MP:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=ymp-cray-unicos$CRAY_REL
+	;;
+    CRAY*[A-Z]90:*:*:*)
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=t90-cray-unicos$CRAY_REL
+	;;
+    CRAY*T3E:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=alphaev5-cray-unicosmk$CRAY_REL
+	;;
+    CRAY*SV1:*:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=sv1-cray-unicos$CRAY_REL
+	;;
+    *:UNICOS/mp:*:*)
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=craynv-cray-unicosmp$CRAY_REL
+	;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
+    5000:UNIX_System_V:4.*:*)
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
+	;;
+    sparc*:BSD/OS:*:*)
+	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
+	;;
+    *:BSD/OS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
+	;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
+	else
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
+	fi
+	;;
+    *:FreeBSD:*:*)
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case $UNAME_PROCESSOR in
+	    amd64)
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
+	esac
+	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
+	;;
+    i*:CYGWIN*:*)
+	GUESS=$UNAME_MACHINE-pc-cygwin
+	;;
+    *:MINGW64*:*)
+	GUESS=$UNAME_MACHINE-pc-mingw64
+	;;
+    *:MINGW*:*)
+	GUESS=$UNAME_MACHINE-pc-mingw32
+	;;
+    *:MSYS*:*)
+	GUESS=$UNAME_MACHINE-pc-msys
+	;;
+    i*:PW*:*)
+	GUESS=$UNAME_MACHINE-pc-pw32
+	;;
+    *:SerenityOS:*:*)
+        GUESS=$UNAME_MACHINE-pc-serenity
+        ;;
+    *:Interix*:*)
+	case $UNAME_MACHINE in
+	    x86)
+		GUESS=i586-pc-interix$UNAME_RELEASE
+		;;
+	    authenticamd | genuineintel | EM64T)
+		GUESS=x86_64-unknown-interix$UNAME_RELEASE
+		;;
+	    IA64)
+		GUESS=ia64-unknown-interix$UNAME_RELEASE
+		;;
+	esac ;;
+    i*:UWIN*:*)
+	GUESS=$UNAME_MACHINE-pc-uwin
+	;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	GUESS=x86_64-pc-cygwin
+	;;
+    prep*:SunOS:5.*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=powerpcle-unknown-solaris2$SUN_REL
+	;;
+    *:GNU:*:*)
+	# the GNU system
+	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
+	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
+	;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
+	;;
+    *:Minix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-minix
+	;;
+    aarch64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arm*:Linux:*:*)
+	set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
+	    else
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
+	    fi
+	fi
+	;;
+    avr32*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    cris:Linux:*:*)
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
+    crisv32:Linux:*:*)
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
+    e2k:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    frv:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    hexagon:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    i*86:Linux:*:*)
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
+	;;
+    ia64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    k1om:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    m32r*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    m68*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	MIPS_ENDIAN=el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	MIPS_ENDIAN=
+	#else
+	MIPS_ENDIAN=
+	#endif
+	#endif
+EOF
+	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
+	eval "$cc_set_vars"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+	;;
+    mips64el:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    openrisc*:Linux:*:*)
+	GUESS=or1k-unknown-linux-$LIBC
+	;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    padre:Linux:*:*)
+	GUESS=sparc-unknown-linux-$LIBC
+	;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	GUESS=hppa64-unknown-linux-$LIBC
+	;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
+	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
+	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
+	esac
+	;;
+    ppc64:Linux:*:*)
+	GUESS=powerpc64-unknown-linux-$LIBC
+	;;
+    ppc:Linux:*:*)
+	GUESS=powerpc-unknown-linux-$LIBC
+	;;
+    ppc64le:Linux:*:*)
+	GUESS=powerpc64le-unknown-linux-$LIBC
+	;;
+    ppcle:Linux:*:*)
+	GUESS=powerpcle-unknown-linux-$LIBC
+	;;
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
+	;;
+    sh64*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    sh*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    tile*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    vax:Linux:*:*)
+	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
+	;;
+    x86_64:Linux:*:*)
+	set_cc_for_build
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_X32 >/dev/null
+	    then
+		LIBCABI=${LIBC}x32
+	    fi
+	fi
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBCABI
+	;;
+    xtensa*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	GUESS=i386-sequent-sysv4
+	;;
+    i*86:UNIX_SV:4.2MP:2.*)
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+	# Use sysv4.2uw... so that sysv4* matches it.
+	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
+	;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	GUESS=$UNAME_MACHINE-pc-os2-emx
+	;;
+    i*86:XTS-300:*:STOP)
+	GUESS=$UNAME_MACHINE-unknown-stop
+	;;
+    i*86:atheos:*:*)
+	GUESS=$UNAME_MACHINE-unknown-atheos
+	;;
+    i*86:syllable:*:*)
+	GUESS=$UNAME_MACHINE-pc-syllable
+	;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	GUESS=i386-unknown-lynxos$UNAME_RELEASE
+	;;
+    i*86:*DOS:*:*)
+	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
+	;;
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
+	else
+		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
+	fi
+	;;
+    i*86:*:5:[678]*)
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
+	else
+		GUESS=$UNAME_MACHINE-pc-sysv32
+	fi
+	;;
+    pc:*:*:*)
+	# Left here for compatibility:
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configure will decide that
+	# this is a cross-build.
+	GUESS=i586-pc-msdosdjgpp
+	;;
+    Intel:Mach:3*:*)
+	GUESS=i386-pc-mach3
+	;;
+    paragon:*:*:*)
+	GUESS=i860-intel-osf1
+	;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
+	fi
+	;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	GUESS=m68010-convergent-sysv
+	;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	GUESS=m68k-convergent-sysv
+	;;
+    M680?0:D-NIX:5.3:*)
+	GUESS=m68k-diab-dnix
+	;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
+	;;
+    mc68030:UNIX_System_V:4.*:*)
+	GUESS=m68k-atari-sysv4
+	;;
+    TSUNAMI:LynxOS:2.*:*)
+	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
+	;;
+    rs6000:LynxOS:2.*:*)
+	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
+	;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
+	;;
+    SM[BE]S:UNIX_SV:*:*)
+	GUESS=mips-dde-sysv$UNAME_RELEASE
+	;;
+    RM*:ReliantUNIX-*:*:*)
+	GUESS=mips-sni-sysv4
+	;;
+    RM*:SINIX-*:*:*)
+	GUESS=mips-sni-sysv4
+	;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		GUESS=$UNAME_MACHINE-sni-sysv4
+	else
+		GUESS=ns32k-sni-sysv
+	fi
+	;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	GUESS=i586-unisys-sysv4
+	;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	GUESS=hppa1.1-stratus-sysv4
+	;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	GUESS=i860-stratus-sysv4
+	;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	GUESS=$UNAME_MACHINE-stratus-vos
+	;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	GUESS=hppa1.1-stratus-vos
+	;;
+    mc68*:A/UX:*:*)
+	GUESS=m68k-apple-aux$UNAME_RELEASE
+	;;
+    news*:NEWS-OS:6*:*)
+	GUESS=mips-sony-newsos6
+	;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if test -d /usr/nec; then
+		GUESS=mips-nec-sysv$UNAME_RELEASE
+	else
+		GUESS=mips-unknown-sysv$UNAME_RELEASE
+	fi
+	;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	GUESS=powerpc-be-beos
+	;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	GUESS=powerpc-apple-beos
+	;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	GUESS=i586-pc-beos
+	;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	GUESS=i586-pc-haiku
+	;;
+    x86_64:Haiku:*:*)
+	GUESS=x86_64-unknown-haiku
+	;;
+    SX-4:SUPER-UX:*:*)
+	GUESS=sx4-nec-superux$UNAME_RELEASE
+	;;
+    SX-5:SUPER-UX:*:*)
+	GUESS=sx5-nec-superux$UNAME_RELEASE
+	;;
+    SX-6:SUPER-UX:*:*)
+	GUESS=sx6-nec-superux$UNAME_RELEASE
+	;;
+    SX-7:SUPER-UX:*:*)
+	GUESS=sx7-nec-superux$UNAME_RELEASE
+	;;
+    SX-8:SUPER-UX:*:*)
+	GUESS=sx8-nec-superux$UNAME_RELEASE
+	;;
+    SX-8R:SUPER-UX:*:*)
+	GUESS=sx8r-nec-superux$UNAME_RELEASE
+	;;
+    SX-ACE:SUPER-UX:*:*)
+	GUESS=sxace-nec-superux$UNAME_RELEASE
+	;;
+    Power*:Rhapsody:*:*)
+	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
+	;;
+    *:Rhapsody:*:*)
+	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
+	;;
+    arm64:Darwin:*:*)
+	GUESS=aarch64-apple-darwin$UNAME_RELEASE
+	;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
+	fi
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
+	fi
+	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
+	;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = x86; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
+	;;
+    *:QNX:*:4*)
+	GUESS=i386-pc-qnx
+	;;
+    NEO-*:NONSTOP_KERNEL:*:*)
+	GUESS=neo-tandem-nsk$UNAME_RELEASE
+	;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	GUESS=nse-tandem-nsk$UNAME_RELEASE
+	;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsr-tandem-nsk$UNAME_RELEASE
+	;;
+    NSV-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsv-tandem-nsk$UNAME_RELEASE
+	;;
+    NSX-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsx-tandem-nsk$UNAME_RELEASE
+	;;
+    *:NonStop-UX:*:*)
+	GUESS=mips-compaq-nonstopux
+	;;
+    BS2000:POSIX*:*:*)
+	GUESS=bs2000-siemens-sysv
+	;;
+    DS/*:UNIX_System_V:*:*)
+	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
+	;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "${cputype-}" = 386; then
+	    UNAME_MACHINE=i386
+	elif test "x${cputype-}" != x; then
+	    UNAME_MACHINE=$cputype
+	fi
+	GUESS=$UNAME_MACHINE-unknown-plan9
+	;;
+    *:TOPS-10:*:*)
+	GUESS=pdp10-unknown-tops10
+	;;
+    *:TENEX:*:*)
+	GUESS=pdp10-unknown-tenex
+	;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	GUESS=pdp10-dec-tops20
+	;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	GUESS=pdp10-xkl-tops20
+	;;
+    *:TOPS-20:*:*)
+	GUESS=pdp10-unknown-tops20
+	;;
+    *:ITS:*:*)
+	GUESS=pdp10-unknown-its
+	;;
+    SEI:*:*:SEIUX)
+	GUESS=mips-sei-seiux$UNAME_RELEASE
+	;;
+    *:DragonFly:*:*)
+	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
+	;;
+    *:*VMS:*:*)
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case $UNAME_MACHINE in
+	    A*) GUESS=alpha-dec-vms ;;
+	    I*) GUESS=ia64-dec-vms ;;
+	    V*) GUESS=vax-dec-vms ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	GUESS=i386-pc-xenix
+	;;
+    i*86:skyos:*:*)
+	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
+	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
+	;;
+    i*86:rdos:*:*)
+	GUESS=$UNAME_MACHINE-pc-rdos
+	;;
+    i*86:Fiwix:*:*)
+	GUESS=$UNAME_MACHINE-pc-fiwix
+	;;
+    *:AROS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-aros
+	;;
+    x86_64:VMkernel:*:*)
+	GUESS=$UNAME_MACHINE-unknown-esx
+	;;
+    amd64:Isilon\ OneFS:*:*)
+	GUESS=x86_64-unknown-onefs
+	;;
+    *:Unleashed:*:*)
+	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
+	;;
+esac
+
+# Do we have a guess based on uname results?
+if test "x$GUESS" != x; then
+    echo "$GUESS"
+    exit
+fi
+
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
+#ifdef _SEQUENT_
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+  "4"
+#else
+  ""
+#endif
+  ); exit (0);
+#endif
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+  struct utsname un;
+
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
+
+echo "$0: unable to guess system type" >&2
+
+case $UNAME_MACHINE:$UNAME_SYSTEM in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
+
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
+
+cat >&2 <<EOF
+
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
+
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+and
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+EOF
+
+our_year=`echo $timestamp | sed 's,-.*,,'`
+thisyear=`date +%Y`
+# shellcheck disable=SC2003
+script_age=`expr "$thisyear" - "$our_year"`
+if test "$script_age" -lt 3 ; then
+   cat >&2 <<EOF
+
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
+EOF
+fi
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
Index: libffi-3.4.6/configure.ac
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/configure.ac b/libffi-3.4.6/configure.ac
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/configure.ac	
@@ -0,0 +1,451 @@
+dnl Process this with autoconf to create configure
+
+AC_PREREQ([2.71])
+
+AC_INIT([libffi],[3.4.6],[http://github.com/libffi/libffi/issues])
+AC_CONFIG_HEADERS([fficonfig.h])
+
+AC_CANONICAL_TARGET
+target_alias=${target_alias-$host_alias}
+
+case "${host}" in
+  frv*-elf)
+    LDFLAGS=`echo $LDFLAGS | sed "s/\-B[^ ]*libgloss\/frv\///"`\ -B`pwd`/../libgloss/frv/
+    ;;
+esac
+
+AX_ENABLE_BUILDDIR
+
+AM_INIT_AUTOMAKE
+
+# The same as in boehm-gc and libstdc++. Have to borrow it from there.
+# We must force CC to /not/ be precious variables; otherwise
+# the wrong, non-multilib-adjusted value will be used in multilibs.
+# As a side effect, we have to subst CFLAGS ourselves.
+# Also save and restore CFLAGS, since AC_PROG_CC will come up with
+# defaults of its own if none are provided.
+
+m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])
+m4_define([_AC_ARG_VAR_PRECIOUS],[])
+save_CFLAGS=$CFLAGS
+AC_PROG_CC
+AC_PROG_CXX
+CFLAGS=$save_CFLAGS
+m4_undefine([_AC_ARG_VAR_PRECIOUS])
+m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])
+
+AC_SUBST(CFLAGS)
+
+AM_PROG_AS
+AM_PROG_CC_C_O
+AC_PROG_EGREP
+LT_INIT
+AC_CONFIG_MACRO_DIR([m4])
+
+AC_CHECK_TOOL(READELF, readelf)
+
+# Test for 64-bit build.
+AC_CHECK_SIZEOF([size_t])
+
+AX_COMPILER_VENDOR
+AX_CC_MAXOPT
+# The AX_CFLAGS_WARN_ALL macro doesn't currently work for sunpro
+# compiler.
+if test "$ax_cv_c_compiler_vendor" != "sun"; then
+  AX_CFLAGS_WARN_ALL
+fi
+
+if test "x$GCC" = "xyes"; then
+  CFLAGS="$CFLAGS -fexceptions"
+fi
+
+cat > local.exp <<EOF
+set CC_FOR_TARGET "$CC"
+set CXX_FOR_TARGET "$CXX"
+set compiler_vendor "$ax_cv_c_compiler_vendor"
+EOF
+
+AM_MAINTAINER_MODE
+
+AC_CHECK_HEADERS(sys/memfd.h)
+AC_CHECK_FUNCS([memfd_create])
+
+dnl The -no-testsuite modules omit the test subdir.
+AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)
+
+TARGETDIR="unknown"
+HAVE_LONG_DOUBLE_VARIANT=0
+
+. ${srcdir}/configure.host
+
+if test -n "${UNSUPPORTED}"; then
+  AC_MSG_ERROR(["libffi has not been ported to $host."])
+fi
+
+AC_SUBST(AM_RUNTESTFLAGS)
+AC_SUBST(AM_LTLDFLAGS)
+
+m4_warn([obsolete],
+[The preprocessor macro `STDC_HEADERS' is obsolete.
+  Except in unusual embedded environments, you can safely include all
+  ISO C90 headers unconditionally.])dnl
+# Autoupdate added the next two lines to ensure that your configure
+# script's behavior did not change.  They are probably safe to remove.
+AC_CHECK_INCLUDES_DEFAULT
+AC_PROG_EGREP
+
+AC_CHECK_FUNCS(memcpy)
+AC_CHECK_HEADERS(alloca.h)
+
+AC_CHECK_SIZEOF(double)
+AC_CHECK_SIZEOF(long double)
+
+# Also AC_SUBST this variable for ffi.h.
+if test -z "$HAVE_LONG_DOUBLE"; then
+  HAVE_LONG_DOUBLE=0
+  if test $ac_cv_sizeof_long_double != 0; then
+    if test $HAVE_LONG_DOUBLE_VARIANT != 0; then
+      AC_DEFINE(HAVE_LONG_DOUBLE_VARIANT, 1, [Define if you support more than one size of the long double type])
+      HAVE_LONG_DOUBLE=1
+    else
+      if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then
+        HAVE_LONG_DOUBLE=1
+        AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if you have the long double type and it is bigger than a double])
+      fi
+    fi
+  fi
+fi
+AC_SUBST(HAVE_LONG_DOUBLE)
+AC_SUBST(HAVE_LONG_DOUBLE_VARIANT)
+
+AC_C_BIGENDIAN
+
+GCC_AS_CFI_PSEUDO_OP
+
+case "$TARGET" in
+  SPARC)
+    AC_CACHE_CHECK([assembler and linker support unaligned pc related relocs],
+	libffi_cv_as_sparc_ua_pcrel, [
+	save_CFLAGS="$CFLAGS"
+	save_LDFLAGS="$LDFLAGS"
+	CFLAGS="$CFLAGS -fpic"
+	LDFLAGS="$LDFLAGS -shared"
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[asm (".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text");]], [[]])],[libffi_cv_as_sparc_ua_pcrel=yes],[libffi_cv_as_sparc_ua_pcrel=no])
+	CFLAGS="$save_CFLAGS"
+	LDFLAGS="$save_LDFLAGS"])
+    if test "x$libffi_cv_as_sparc_ua_pcrel" = xyes; then
+	AC_DEFINE(HAVE_AS_SPARC_UA_PCREL, 1,
+		  [Define if your assembler and linker support unaligned PC relative relocs.])
+    fi
+
+    AC_CACHE_CHECK([assembler .register pseudo-op support],
+       libffi_cv_as_register_pseudo_op, [
+       libffi_cv_as_register_pseudo_op=unknown
+       # Check if we have .register
+       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[asm (".register %g2, #scratch");]])],[libffi_cv_as_register_pseudo_op=yes],[libffi_cv_as_register_pseudo_op=no])
+    ])
+    if test "x$libffi_cv_as_register_pseudo_op" = xyes; then
+       AC_DEFINE(HAVE_AS_REGISTER_PSEUDO_OP, 1,
+	       [Define if your assembler supports .register.])
+    fi
+    ;;
+
+  X86*)
+    AC_CACHE_CHECK([assembler supports pc related relocs],
+	libffi_cv_as_x86_pcrel, [
+	libffi_cv_as_x86_pcrel=no
+	echo '.text; foo: nop; .data; .long foo-.; .text' > conftest.s
+	if $CC $CFLAGS -c conftest.s > /dev/null 2>&1; then
+	    libffi_cv_as_x86_pcrel=yes
+	fi
+	])
+    if test "x$libffi_cv_as_x86_pcrel" = xyes; then
+	AC_DEFINE(HAVE_AS_X86_PCREL, 1,
+		  [Define if your assembler supports PC relative relocs.])
+    fi
+    ;;
+
+  S390)
+    AC_CACHE_CHECK([compiler uses zarch features],
+	libffi_cv_as_s390_zarch, [
+	libffi_cv_as_s390_zarch=no
+	echo 'void foo(void) { bar(); bar(); }' > conftest.c
+	if $CC $CFLAGS -S conftest.c > /dev/null 2>&1; then
+	    if grep -q brasl conftest.s; then
+	        libffi_cv_as_s390_zarch=yes
+	    fi
+	fi
+	])
+    if test "x$libffi_cv_as_s390_zarch" = xyes; then
+	AC_DEFINE(HAVE_AS_S390_ZARCH, 1,
+		  [Define if the compiler uses zarch features.])
+    fi
+    ;;
+esac
+
+AC_CACHE_CHECK([whether compiler supports pointer authentication],
+   libffi_cv_as_ptrauth, [
+   libffi_cv_as_ptrauth=unknown
+   AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[
+#ifdef __clang__
+# if __has_feature(ptrauth_calls)
+#  define HAVE_PTRAUTH 1
+# endif
+#endif
+
+#ifndef HAVE_PTRAUTH
+# error Pointer authentication not supported
+#endif
+		   ]])],[libffi_cv_as_ptrauth=yes],[libffi_cv_as_ptrauth=no])
+])
+if test "x$libffi_cv_as_ptrauth" = xyes; then
+    AC_DEFINE(HAVE_PTRAUTH, 1,
+	      [Define if your compiler supports pointer authentication.])
+fi
+
+# On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC;
+# if EMUTRAMP is active too ffi could try mapping without PROT_EXEC,
+# but the kernel needs to recognize the trampoline generated by ffi.
+# Otherwise fallback to double mmap trick.
+AC_ARG_ENABLE(pax_emutramp,
+  [  --enable-pax_emutramp       enable pax emulated trampolines (experimental)],
+  if test "$enable_pax_emutramp" = "yes"; then
+    AC_MSG_WARN([EMUTRAMP is experimental only.  Use --enable-pax_emutramp=experimental to enforce.])
+  elif test "$enable_pax_emutramp" = "experimental"; then
+    AC_DEFINE(FFI_MMAP_EXEC_EMUTRAMP_PAX, 1,
+      [Define this if you want to enable pax emulated trampolines (experimental)])
+  fi)
+
+LT_SYS_SYMBOL_USCORE
+if test "x$sys_symbol_underscore" = xyes; then
+    AC_DEFINE(SYMBOL_UNDERSCORE, 1, [Define if symbols are underscored.])
+fi
+
+FFI_EXEC_TRAMPOLINE_TABLE=0
+case "$target" in
+     *arm*-apple-* | aarch64-apple-*)
+       FFI_EXEC_TRAMPOLINE_TABLE=1
+       AC_DEFINE(FFI_EXEC_TRAMPOLINE_TABLE, 1,
+                 [Cannot use PROT_EXEC on this target, so, we revert to
+                   alternative means])
+     ;;
+     *-apple-* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris* | *-linux-android*)
+       AC_DEFINE(FFI_MMAP_EXEC_WRIT, 1,
+                 [Cannot use malloc on this target, so, we revert to
+                   alternative means])
+     ;;
+esac
+AM_CONDITIONAL(FFI_EXEC_TRAMPOLINE_TABLE, test x$FFI_EXEC_TRAMPOLINE_TABLE = x1)
+AC_SUBST(FFI_EXEC_TRAMPOLINE_TABLE)
+
+if test x$TARGET = xX86_64; then
+    AC_CACHE_CHECK([toolchain supports unwind section type],
+	libffi_cv_as_x86_64_unwind_section_type, [
+        cat  > conftest1.s << EOF
+.text
+.globl foo
+foo:
+jmp bar
+.section .eh_frame,"a",@unwind
+bar:
+EOF
+
+        cat > conftest2.c  << EOF
+extern void foo();
+int main(){foo();}
+EOF
+
+	libffi_cv_as_x86_64_unwind_section_type=no
+	# we ensure that we can compile _and_ link an assembly file containing an @unwind section
+	# since the compiler can support it and not the linker (ie old binutils)
+	if $CC -Wa,--fatal-warnings $CFLAGS -c conftest1.s > /dev/null 2>&1 && \
+           $CC conftest2.c conftest1.o > /dev/null 2>&1 ; then
+	    libffi_cv_as_x86_64_unwind_section_type=yes
+	fi
+	])
+    if test "x$libffi_cv_as_x86_64_unwind_section_type" = xyes; then
+	AC_DEFINE(HAVE_AS_X86_64_UNWIND_SECTION_TYPE, 1,
+		  [Define if your assembler supports unwind section type.])
+    fi
+fi
+
+if test "x$GCC" = "xyes"; then
+  AX_CHECK_COMPILE_FLAG(-fno-lto, libffi_cv_no_lto=-fno-lto)
+
+  AC_CACHE_CHECK([whether .eh_frame section should be read-only],
+      libffi_cv_ro_eh_frame, [
+  	libffi_cv_ro_eh_frame=yes
+  	echo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c
+  	if $CC $CFLAGS -c -fpic -fexceptions $libffi_cv_no_lto -o conftest.o conftest.c > /dev/null 2>&1; then
+	    if $READELF -WS conftest.o 2>/dev/null | grep -q -n 'eh_frame .* WA'; then
+	        libffi_cv_ro_eh_frame=no
+	    fi
+  	fi
+  	rm -f conftest.*
+      ])
+  if test "x$libffi_cv_ro_eh_frame" = xyes; then
+      AC_DEFINE(HAVE_RO_EH_FRAME, 1,
+  	      [Define if .eh_frame sections should be read-only.])
+      AC_DEFINE(EH_FRAME_FLAGS, "a",
+  	      [Define to the flags needed for the .section .eh_frame directive.  ])
+  else
+      AC_DEFINE(EH_FRAME_FLAGS, "aw",
+  	      [Define to the flags needed for the .section .eh_frame directive.  ])
+  fi
+
+  AC_CACHE_CHECK([for __attribute__((visibility("hidden")))],
+      libffi_cv_hidden_visibility_attribute, [
+  	echo 'int __attribute__ ((visibility ("hidden"))) foo (void) { return 1  ; }' > conftest.c
+  	libffi_cv_hidden_visibility_attribute=no
+  	if AC_TRY_COMMAND(${CC-cc} -Werror -S conftest.c -o conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  	    if $EGREP '(\.hidden|\.private_extern).*foo|foo.*,hidden' conftest.s >/dev/null; then
+  		libffi_cv_hidden_visibility_attribute=yes
+  	    fi
+  	fi
+  	rm -f conftest.*
+      ])
+  if test $libffi_cv_hidden_visibility_attribute = yes; then
+      AC_DEFINE(HAVE_HIDDEN_VISIBILITY_ATTRIBUTE, 1,
+  	      [Define if __attribute__((visibility("hidden"))) is supported.])
+  fi
+fi
+
+AC_ARG_ENABLE(docs,
+              AS_HELP_STRING([--disable-docs],[Disable building of docs (default: no)]),
+              [enable_docs=no],
+              [enable_docs=yes])
+AM_CONDITIONAL(BUILD_DOCS, [test x$enable_docs = xyes])
+
+AH_BOTTOM([
+#ifdef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+#ifdef LIBFFI_ASM
+#ifdef __APPLE__
+#define FFI_HIDDEN(name) .private_extern name
+#else
+#define FFI_HIDDEN(name) .hidden name
+#endif
+#else
+#define FFI_HIDDEN __attribute__ ((visibility ("hidden")))
+#endif
+#else
+#ifdef LIBFFI_ASM
+#define FFI_HIDDEN(name)
+#else
+#define FFI_HIDDEN
+#endif
+#endif
+])
+
+AC_SUBST(TARGET)
+AC_SUBST(TARGETDIR)
+
+changequote(<,>)
+TARGET_OBJ=
+for i in $SOURCES; do
+  TARGET_OBJ="${TARGET_OBJ} src/${TARGETDIR}/"`echo $i | sed 's/[cS]$/lo/'`
+done
+changequote([,])
+AC_SUBST(TARGET_OBJ)
+
+AC_SUBST(SHELL)
+
+AC_ARG_ENABLE(debug,
+[  --enable-debug          debugging mode],
+  if test "$enable_debug" = "yes"; then
+    AC_DEFINE(FFI_DEBUG, 1, [Define this if you want extra debugging.])
+  fi)
+AM_CONDITIONAL(FFI_DEBUG, test "$enable_debug" = "yes")
+
+AC_ARG_ENABLE(structs,
+[  --disable-structs       omit code for struct support],
+  if test "$enable_structs" = "no"; then
+    AC_DEFINE(FFI_NO_STRUCTS, 1, [Define this if you do not want support for aggregate types.])
+  fi)
+AM_CONDITIONAL(FFI_DEBUG, test "$enable_debug" = "yes")
+
+AC_ARG_ENABLE(raw-api,
+[  --disable-raw-api       make the raw api unavailable],
+  if test "$enable_raw_api" = "no"; then
+    AC_DEFINE(FFI_NO_RAW_API, 1, [Define this if you do not want support for the raw API.])
+  fi)
+
+AC_ARG_ENABLE(exec-static-tramp,
+[  --disable-exec-static-tramp  disable use of static exec trampolines (enabled by default)])
+
+if test "$enable_exec_static_tramp" != no; then
+case "$target" in
+     *-cygwin* | *-msys*)
+       # Only define static trampolines if we are using the cygwin runtime.
+       # Will this need to be changed for mingw?
+       if test "x$GCC" = "xyes"; then
+         AC_DEFINE(FFI_EXEC_STATIC_TRAMP, 1,
+                   [Define this if you want statically defined trampolines])
+       fi
+     ;;
+     *arm*-*-linux-* | aarch64*-*-linux-* | i*86-*-linux-* | x86_64-*-linux-* | loongarch*-*-linux-*)
+       AC_DEFINE(FFI_EXEC_STATIC_TRAMP, 1,
+                 [Define this if you want statically defined trampolines])
+     ;;
+esac
+fi
+
+AC_ARG_ENABLE(purify-safety,
+[  --enable-purify-safety  purify-safe mode],
+  if test "$enable_purify_safety" = "yes"; then
+    AC_DEFINE(USING_PURIFY, 1, [Define this if you are using Purify and want to suppress spurious messages.])
+  fi)
+
+AC_ARG_ENABLE(multi-os-directory,
+[  --disable-multi-os-directory
+                          disable use of gcc --print-multi-os-directory to change the library installation directory])
+
+# These variables are only ever used when we cross-build to X86_WIN32.
+# And we only support this with GCC, so...
+if test "x$GCC" = "xyes"; then
+  if test -n "$with_cross_host" &&
+     test x"$with_cross_host" != x"no"; then
+    toolexecdir='${exec_prefix}'/'$(target_alias)'
+    toolexeclibdir='${toolexecdir}'/lib
+  else
+    toolexecdir='${libdir}'/gcc-lib/'$(target_alias)'
+    toolexeclibdir='${libdir}'
+  fi
+  if test x"$enable_multi_os_directory" != x"no"; then
+    multi_os_directory=`$CC $CFLAGS -print-multi-os-directory`
+    case $multi_os_directory in
+      .) ;; # Avoid trailing /.
+      ../*) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;
+    esac
+  fi
+  AC_SUBST(toolexecdir)
+else
+  toolexeclibdir='${libdir}'
+fi
+AC_SUBST(toolexeclibdir)
+
+# Conditionalize the makefile for this target machine.
+tmake_file_=
+for f in ${tmake_file}; do
+  if test -f ${srcdir}/src/$TARGETDIR/$f; then
+     tmake_file_="${tmake_file_} \$(srcdir)/src/$TARGETDIR/$f"
+  fi
+done
+tmake_file="${tmake_file_}"
+AC_SUBST(tmake_file)
+
+# Check linker support.
+LIBFFI_ENABLE_SYMVERS
+
+AC_CONFIG_COMMANDS(include, [test -d include || mkdir include])
+AC_CONFIG_COMMANDS(src, [
+test -d src || mkdir src
+test -d src/$TARGETDIR || mkdir src/$TARGETDIR
+], [TARGETDIR="$TARGETDIR"])
+
+AC_CONFIG_FILES(include/Makefile include/ffi.h Makefile testsuite/Makefile man/Makefile doc/Makefile libffi.pc)
+
+AC_OUTPUT
+
+# Copy this file instead of using AC_CONFIG_LINK in order to support
+# compiling with MSVC, which won't understand cygwin style symlinks.
+cp ${srcdir}/src/$TARGETDIR/ffitarget.h include/ffitarget.h
Index: libffi-3.4.6/libffi.pc.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/libffi.pc.in b/libffi-3.4.6/libffi.pc.in
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/libffi.pc.in	
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+toolexeclibdir=@toolexeclibdir@
+includedir=@includedir@
+
+Name: @PACKAGE_NAME@
+Description: Library supporting Foreign Function Interfaces
+Version: @PACKAGE_VERSION@
+Libs: -L${toolexeclibdir} -lffi
+Cflags: -I${includedir}
Index: libffi-3.4.6/.appveyor.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/.appveyor.yml b/libffi-3.4.6/.appveyor.yml
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/.appveyor.yml	
@@ -0,0 +1,84 @@
+shallow_clone: true
+
+# We're currently only testing libffi built with Microsoft's
+# tools.
+# This matrix should be expanded to include at least:
+#  32- and 64-bit gcc/cygwin
+#  32- and 64-bit gcc/mingw
+#  32- and 64-bit clang/mingw
+#  and perhaps more.
+
+image: Visual Studio 2017
+platform:
+  - x64
+  - x86
+  - arm
+  - arm64
+
+configuration:
+  - Debug
+  - Release
+
+environment:
+  global:
+    CYG_ROOT: C:/cygwin64
+    CYG_CACHE: C:/cygwin64/var/cache/setup
+    CYG_MIRROR: http://mirrors.kernel.org/sourceware/cygwin/
+    VSVER: 15
+  matrix:
+    - SHARED_ARG: "--enable-shared --disable-static"
+    - SHARED_ARG: "--enable-static --disable-shared"
+
+install:
+  - ps: >-
+      If ($env:Platform -Match "x86") {
+          $env:VCVARS_PLATFORM="x86"
+          $env:BUILD="i686-pc-cygwin"
+          $env:HOST="i686-pc-cygwin"
+          $env:MSVCC="/cygdrive/c/projects/libffi/msvcc.sh"
+          $env:SRC_ARCHITECTURE="x86"
+        } ElseIf ($env:Platform -Match "arm64") {
+          $env:VCVARS_PLATFORM="x86_arm64"
+          $env:BUILD="i686-pc-cygwin"
+          $env:HOST="aarch64-w64-cygwin"
+          $env:MSVCC="/cygdrive/c/projects/libffi/msvcc.sh -marm64"
+          $env:SRC_ARCHITECTURE="aarch64"
+        } ElseIf ($env:Platform -Match "arm") {
+          $env:VCVARS_PLATFORM="x86_arm"
+          $env:BUILD="i686-pc-cygwin"
+          $env:HOST="arm-w32-cygwin"
+          $env:MSVCC="/cygdrive/c/projects/libffi/msvcc.sh -marm"
+          $env:SRC_ARCHITECTURE="arm"
+        } Else {
+          $env:VCVARS_PLATFORM="amd64"
+          $env:BUILD="x86_64-w64-cygwin"
+          $env:HOST="x86_64-w64-cygwin"
+          $env:MSVCC="/cygdrive/c/projects/libffi/msvcc.sh -m64"
+          $env:SRC_ARCHITECTURE="x86"
+      }
+      If ($env:Configuration -Match "Debug") {
+          $env:DEBUG_ARG="--enable-debug"
+        } Else {
+          $env:DEBUG_ARG="--disable-debug"
+      }
+  - 'appveyor DownloadFile https://cygwin.com/setup-x86_64.exe -FileName setup.exe'
+  - 'setup.exe -qgnNdO -R "%CYG_ROOT%" -s "%CYG_MIRROR%" -l "%CYG_CACHE%" -P dejagnu -P autoconf -P automake -P libtool'
+  - '%CYG_ROOT%/bin/bash -lc "cygcheck -dc cygwin"'
+  - echo call VsDevCmd to set VS150COMNTOOLS
+  - call "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\Tools\VsDevCmd.bat"
+  - ps: $env:VSCOMNTOOLS=(Get-Content ("env:VS" + "$env:VSVER" + "0COMNTOOLS"))
+  - echo "Using Visual Studio %VSVER%.0 at %VSCOMNTOOLS%"
+  - call "%VSCOMNTOOLS%..\..\vc\Auxiliary\Build\vcvarsall.bat" %VCVARS_PLATFORM%
+
+build_script:
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; ./autogen.sh)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; ./configure CC='%MSVCC%' CXX='%MSVCC%' LD='link' CPP='cl -nologo -EP' CXXCPP='cl -nologo -EP' CPPFLAGS='-DFFI_BUILDING_DLL' AR='/cygdrive/c/projects/libffi/.travis/ar-lib lib' NM='dumpbin -symbols' STRIP=':' --build=$BUILD --host=$HOST $DEBUG_ARG $SHARED_ARG)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; cp src/%SRC_ARCHITECTURE%/ffitarget.h include)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; make)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; cp $HOST/.libs/libffi.lib $HOST/testsuite/libffi-8.lib || true)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; cp `find . -name 'libffi-?.dll'` $HOST/testsuite/ || true)"
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; TERM=none make check RUNTESTFLAGS='-v -v -v -v --target '$HOST  DEJAGNU=$PWD/.appveyor/site.exp SITEDIR=$PWD/.appveyor)"
+
+
+on_finish:
+  - c:\cygwin64\bin\sh -lc "(cd $OLDPWD; cat `find ./ -name libffi.log`)"
Index: libffi-3.4.6/ChangeLog.old
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/ChangeLog.old b/libffi-3.4.6/ChangeLog.old
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/ChangeLog.old	
@@ -0,0 +1,7407 @@
+Libffi change logs used to be maintained in separate ChangeLog files.
+These days we generate them directly from the git commit messages.
+The old ChangeLog files are saved here in order to maintain the historical
+record.
+
+=============================================================================
+From the old ChangeLog.libffi-3.1 file...
+
+2014-03-16  Josh Triplett  <josh@joshtriplett.org>
+
+	* ChangeLog: Archive to ChangeLog.libffi-3.1 and delete.  Future
+	changelogs will come from git, with autogenerated snapshots shipped in
+	distributed tarballs.
+
+2014-03-16  Josh Triplett  <josh@joshtriplett.org>
+
+	Add support for stdcall, thiscall, and fastcall on non-Windows
+	x86-32.
+
+	Linux supports the stdcall calling convention, either via
+	functions explicitly declared with the stdcall attribute, or via
+	code compiled with -mrtd which effectively makes stdcall the
+	default.
+
+	This introduces FFI_STDCALL, FFI_THISCALL, and FFI_FASTCALL on
+	non-Windows x86-32 platforms, as non-default calling conventions.
+
+	* Makefile.am: Compile in src/x86/win32.S on non-Windows x86-32.
+	* src/x86/ffitarget.h: Add FFI_STDCALL, FFI_THISCALL, and
+	FFI_FASTCALL on non-Windows x86-32.  Increase trampoline size to
+	accomodate these calling conventions, and unify some ifdeffery.
+	* src/x86/ffi.c: Add support for FFI_STDCALL, FFI_THISCALL, and
+	FFI_FASTCALL on non-Windows x86-32 platforms; update ifdeffery.
+	* src/x86/win32.S: Support compiling on non-Windows x86-32
+	platforms.  On those platforms, avoid redefining the SYSV symbols
+	already provided by src/x86/sysv.S.
+	* testsuite/libffi.call/closure_stdcall.c: Run on non-Windows.
+	#define __stdcall if needed.
+	* testsuite/libffi.call/closure_thiscall.c: Run on non-Windows.
+	#define __fastcall if needed.
+	* testsuite/libffi.call/fastthis1_win32.c: Run on non-Windows.
+	* testsuite/libffi.call/fastthis2_win32.c: Ditto.
+	* testsuite/libffi.call/fastthis3_win32.c: Ditto.
+	* testsuite/libffi.call/many2_win32.c: Ditto.
+	* testsuite/libffi.call/many_win32.c: Ditto.
+	* testsuite/libffi.call/strlen2_win32.c: Ditto.
+	* testsuite/libffi.call/strlen_win32.c: Ditto.
+	* testsuite/libffi.call/struct1_win32.c: Ditto.
+	* testsuite/libffi.call/struct2_win32.c: Ditto.
+
+2014-03-16  Josh Triplett  <josh@joshtriplett.org>
+
+	* prep_cif.c: Remove unnecessary ifdef for X86_WIN32.
+	ffi_prep_cif_core had a special case for X86_WIN32, checking for
+	FFI_THISCALL in addition to the FFI_FIRST_ABI-to-FFI_LAST_ABI
+	range before returning FFI_BAD_ABI.  However, on X86_WIN32,
+	FFI_THISCALL already falls in that range, making the special case
+	unnecessary.  Remove it.
+
+2014-03-16  Josh Triplett  <josh@joshtriplett.org>
+
+	* testsuite/libffi.call/closure_stdcall.c,
+	testsuite/libffi.call/closure_thiscall.c: Remove fragile stack
+	pointer checks.  These files included inline assembly to save the
+	stack pointer before and after the call, and compare the values.
+	However, compilers can and do leave the stack in different states
+	for these two pieces of inline assembly, such as by saving a
+	temporary value on the stack across the call; observed with gcc
+	-Os, and verified as spurious through careful inspection of
+	disassembly.
+
+2014-03-16  Josh Triplett  <josh@joshtriplett.org>
+
+	* testsuite/libffi.call/many.c: Avoid spurious failure due to
+	excess floating-point precision.
+	* testsuite/libffi.call/many_win32.c: Ditto.
+
+2014-03-16  Josh Triplett <josh@joshtriplett.org>
+
+	* libtool-ldflags: Re-add.
+
+2014-03-16  Josh Triplett <josh@joshtriplett.org>
+
+	* Makefile.in, aclocal.m4, compile, config.guess, config.sub,
+	configure, depcomp, include/Makefile.in, install-sh,
+	libtool-ldflags, ltmain.sh, m4/libtool.m4, m4/ltoptions.m4,
+	m4/ltsugar.m4, m4/ltversion.m4, m4/lt~obsolete.m4,
+	man/Makefile.in, mdate-sh, missing, testsuite/Makefile.in: Delete
+	autogenerated files from version control.
+	* .gitignore: Add autogenerated files.
+	* autogen.sh: New script to generate the autogenerated files.
+	* README: Document requirement to run autogen.sh when building
+	directly from version control.
+	* .travis.yml: Run autogen.sh
+
+2014-03-14  Anthony Green <green@moxielogic.com>
+
+	* configure, Makefile.in: Rebuilt.
+
+2014-03-10  Mike Hommey <mh+mozilla@glandium.org>
+
+	* configure.ac: Allow building for mipsel with Android NDK r8.
+	* Makefile.am (AM_MAKEFLAGS): Replace double quotes with single
+	quotes.
+
+2014-03-10  Landry Breuil <landry@openbsd.org>
+
+	* configure.ac: Ensure the linker supports @unwind sections in libffi.
+
+2014-03-01  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (EXTRA_DIST): Replace old scripts with
+	generate-darwin-source-and-headers.py.
+	* Makefile.in: Rebuilt.
+
+2014-02-28  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (AM_CFLAGS): Reintroduce missing -DFFI_DEBUG for
+	--enable-debug builds.
+	* Makefile.in: Rebuilt.
+
+2014-02-28  Makoto Kato  <m_kato@ga2.so-net.ne.jp>
+
+	* src/closures.c: Fix build failure when using clang for Android.
+
+2014-02-28  Marcin Wojdyr  <wojdyr@gmail.com>
+
+	* libffi.pc.in (toolexeclibdir): use -L${toolexeclibdir} instead
+	of -L${libdir}.
+
+2014-02-28  Paulo Pizarro  <paulo.pizarro@gmail.com>
+
+	* src/bfin/sysv.S: Calling functions in shared libraries requires
+	considering the GOT.
+
+2014-02-28  Josh Triplett  <josh@joshtriplett.org>
+
+	* src/x86/ffi64.c (classify_argument): Handle case where
+	FFI_TYPE_LONGDOUBLE == FFI_TYPE_DOUBLE.
+
+2014-02-28  Anthony Green  <green@moxielogic.com>
+
+	* ltmain.sh: Generate with libtool-2.4.2.418.
+	* m4/libtool.m4, m4/ltoptions.m4, m4/ltversion.m4: Ditto.
+	* configure: Rebuilt.
+
+2014-02-28  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* configure.ac (AC_ARG_ENABLE struct): Fix typo in help
+	message.
+	(AC_ARG_ENABLE raw_api): Ditto.
+	* configure, fficonfig.h.in: Rebuilt.
+
+2014-02-28  Will Newton  <will.newton@linaro.org>
+
+	* src/arm/sysv.S: Initialize IP register with FP.
+
+2014-02-28  Yufeng Zhang  <yufeng.zhang@arm.com>
+
+	* src/aarch64/sysv.S (ffi_closure_SYSV): Use x29 as the
+	main CFA reg; update cfi_rel_offset.
+
+2014-02-15  Marcus Comstedt  <marcus@mc.pp.se>
+
+	* src/powerpc/ffi_linux64.c, src/powerpc/linux64_closure.S: Remove
+	assumption on contents of r11 in closure.
+
+2014-02-09  Heiher  <r@hev.cc>
+
+	* src/mips/n32.S: Fix call floating point va function.
+
+2014-01-21  Zachary Waldowski  <zach@waldowski.me>
+
+	* src/aarch64/ffi.c: Fix missing semicolons on assertions under
+	debug mode.
+
+2013-12-30  Zachary Waldowski  <zach@waldowski.me>
+
+	* .gitignore: Exclude darwin_* generated source and build_* trees.
+	* src/aarch64/ffi.c, src/arm/ffi.c, src/x86/ffi.c: Inhibit Clang
+	previous prototype warnings.
+	* src/arm/ffi.c: Prevent NULL dereference, fix short type warning
+	* src/dlmalloc.c: Fix warnings from set_segment_flags return type,
+	and the native use of size_t for malloc on platforms
+	* src/arm/sysv.S: Use unified syntax. Clang clean-ups for
+	ARM_FUNC_START.
+	* generate-osx-source-and-headers.py: Remove.
+	* build-ios.sh: Remove.
+	* libffi.xcodeproj/project.pbxproj: Rebuild targets. Include
+	x86_64+aarch64 pieces in library.  Export headers properly.
+	* src/x86/ffi64.c: More Clang warning clean-ups.
+	* src/closures.c (open_temp_exec_file_dir): Use size_t.
+	* src/prep_cif.c (ffi_prep_cif_core): Cast ALIGN result.
+	* src/aarch64/sysv.S: Use CNAME for global symbols.  Only use
+	.size for ELF targets.
+	* src/aarch64/ffi.c: Clean up for double == long double.  Clean up
+	from Clang warnings.  Use Clang cache invalidation builtin.  Use
+	size_t in place of unsigned in many places.  Accommodate for
+	differences in Apple AArch64 ABI.
+
+2013-12-02  Daniel Rodríguez Troitiño  <drodrigueztroitino@yahoo.es>
+
+	* generate-darwin-source-and-headers.py: Clean up, modernize,
+	merged version of previous scripts.
+
+2013-11-21  Anthony Green  <green@moxielogic.com>
+
+	* configure, Makefile.in, include/Makefile.in, include/ffi.h.in,
+	man/Makefile.in, testsuite/Makefile.in, fficonfig.h.in: Rebuilt.
+
+2013-11-21  Alan Modra  <amodra@gmail.com>
+
+	* Makefile.am (EXTRA_DIST): Add new src/powerpc files.
+	(nodist_libffi_la_SOURCES <POWERPC, POWERPC_FREEBSD>): Likewise.
+	* configure.ac (HAVE_LONG_DOUBLE_VARIANT): Define for powerpc.
+	* include/ffi.h.in (ffi_prep_types): Declare.
+	* src/prep_cif.c (ffi_prep_cif_core): Call ffi_prep_types.
+	* src/types.c (FFI_NONCONST_TYPEDEF): Define and use for
+	HAVE_LONG_DOUBLE_VARIANT.
+	* src/powerpc/ffi_powerpc.h: New file.
+	* src/powerpc/ffi.c: Split into..
+	* src/powerpc/ffi_sysv.c: ..new file, and..
+	* src/powerpc/ffi_linux64.c: ..new file, rewriting parts.
+	* src/powerpc/ffitarget.h (enum ffi_abi): Rewrite powerpc ABI
+	selection as bits controlling features.
+	* src/powerpc/linux64.S: For consistency, use POWERPC64 rather
+	than __powerpc64__.
+	* src/powerpc/linux64_closure.S: Likewise.
+	* src/powerpc/ppc_closure.S: Likewise.  Move .note.FNU-stack
+	inside guard.
+	* src/powerpc/sysv.S: Likewise.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* Makefile.in: Regenerate.
+
+2013-11-20  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep_core): Use
+	NUM_FPR_ARG_REGISTERS64 and NUM_GPR_ARG_REGISTERS64 not their
+	32-bit versions for 64-bit code.
+	* src/powerpc/linux64_closure.S: Don't use the return value area
+	as a parameter save area on ELFv2.
+
+2013-11-18  Iain Sandoe  <iain@codesourcery.com>
+
+	* src/powerpc/darwin.S (EH): Correct use of pcrel FDE encoding.
+	* src/powerpc/darwin_closure.S (EH): Likewise. Modernise picbase
+	labels.
+
+2013-11-18  Anthony Green  <green@moxielogic.com>
+
+	* src/arm/ffi.c (ffi_call): Hoist declaration of temp to top of
+	function.
+	* src/arm/ffi.c (ffi_closure_inner): Moderize function declaration
+	to appease compiler.
+	Thanks for Gregory P. Smith <greg@krypto.org>.
+
+2013-11-18  Anthony Green  <green@moxielogic.com>
+
+	* README (tested): Mention PowerPC ELFv2.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ppc_closure.S: Move errant #endif to where it belongs.
+	Don't bl .Luint128.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep_core): Use #if _CALL_ELF
+	test to select parameter save sizing for ELFv2 vs. ELFv1.
+	* src/powerpc/ffitarget.h (FFI_V2_TYPE_FLOAT_HOMOG,
+	FFI_V2_TYPE_DOUBLE_HOMOG, FFI_V2_TYPE_SMALL_STRUCT): Define.
+	(FFI_TRAMPOLINE_SIZE): Define variant for ELFv2.
+	* src/powerpc/ffi.c (FLAG_ARG_NEEDS_PSAVE): Define.
+	(discover_homogeneous_aggregate): New function.
+	(ffi_prep_args64): Adjust start of param save area for ELFv2.
+	Handle homogenous floating point struct parms.
+	(ffi_prep_cif_machdep_core): Adjust space calculation for ELFv2.
+	Handle ELFv2 return values.  Set FLAG_ARG_NEEDS_PSAVE.  Handle
+	homogenous floating point structs.
+	(ffi_call): Increase size of smst_buffer for ELFv2.  Handle ELFv2.
+	(flush_icache): Compile for ELFv2.
+	(ffi_prep_closure_loc): Set up ELFv2 trampoline.
+	(ffi_closure_helper_LINUX64): Don't return all structs directly
+	to caller.  Handle homogenous floating point structs.  Handle
+	ELFv2 struct return values.
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Set up r2 for
+	ELFv2.  Adjust toc save location.  Call function pointer using
+	r12.  Handle FLAG_RETURNS_SMST.  Don't predict branches.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Set up r2
+	for ELFv2.  Define ELFv2 versions of STACKFRAME, PARMSAVE, and
+	RETVAL.  Handle possibly missing parameter save area.  Handle
+	ELFv2 return values.
+	(.note.GNU-stack): Move inside outer #ifdef.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep): Revert 2013-02-08
+	change.  Do not consume an int arg when returning a small struct
+	for FFI_SYSV ABI.
+	(ffi_call): Only use bounce buffer when FLAG_RETURNS_SMST.
+	Properly copy bounce buffer to destination.
+	* src/powerpc/sysv.S: Revert 2013-02-08 change.
+	* src/powerpc/ppc_closure.S: Remove stray '+'.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_args64): Align struct parameters
+	according to __STRUCT_PARM_ALIGN__.
+	(ffi_prep_cif_machdep_core): Likewise.
+	(ffi_closure_helper_LINUX64): Likewise.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Tweak restore of r28.
+	(.note.GNU-stack): Move inside outer #ifdef.
+	* src/powerpc/linux64_closure.S (STACKFRAME, PARMSAVE,
+	RETVAL): Define and use throughout.
+	(ffi_closure_LINUX64): Save fprs before buying stack.
+	(.note.GNU-stack): Move inside outer #ifdef.
+
+2013-11-16  Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffitarget.h (FFI_TARGET_SPECIFIC_VARIADIC): Define.
+	(FFI_EXTRA_CIF_FIELDS): Define.
+	* src/powerpc/ffi.c (ffi_prep_args64): Save fprs as per the
+	ABI, not to both fpr and param save area.
+	(ffi_prep_cif_machdep_core): Renamed from ffi_prep_cif_machdep.
+	Keep initial flags.  Formatting.  Remove dead FFI_LINUX_SOFT_FLOAT
+	code.
+	(ffi_prep_cif_machdep, ffi_prep_cif_machdep_var): New functions.
+	(ffi_closure_helper_LINUX64): Pass floating point as per ABI,
+	not to both fpr and parameter save areas.
+
+	* libffi/testsuite/libffi.call/cls_double_va.c (main): Correct
+	function cast and don't call ffi_prep_cif.
+	* libffi/testsuite/libffi.call/cls_longdouble_va.c (main): Likewise.
+
+2013-11-15  Andrew Haley  <aph@redhat.com>
+
+	* doc/libffi.texi (Closure Example): Fix the sample code.
+	* doc/libffi.info, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+2013-11-15  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/va_struct1.c (main): Fix broken test.
+	* testsuite/libffi.call/cls_uint_va.c (cls_ret_T_fn): Likewise
+	* testsuite/libffi.call/cls_struct_va1.c (test_fn): Likewise.
+	* testsuite/libffi.call/va_1.c (main): Likewise.
+
+2013-11-14  David Schneider  <david.schneider@bivab.de>
+
+	* src/arm/ffi.c: Fix register allocation for mixed float and
+	doubles.
+	* testsuite/libffi.call/cls_many_mixed_float_double.c: Testcase
+	for many mixed float and double arguments.
+
+2013-11-13  Alan Modra  <amodra@gmail.com>
+
+	* doc/libffi.texi (Simple Example): Correct example code.
+	* doc/libffi.info, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+2013-11-13  Anthony Green  <green@moxielogic.com>
+
+	* include/ffi_common.h: Respect HAVE_ALLOCA_H for GNU compiler
+	based build. (Thanks to tmr111116 on github)
+
+2013-11-09  Anthony Green  <green@moxielogic.com>
+
+	* m4/libtool.m4: Refresh.
+	* configure, Makefile.in: Rebuilt.
+	* README: Add more notes about next release.
+
+2013-11-09  Shigeharu TAKENO  <shige@iee.niit.ac.jp>
+
+	* m4/ax_gcc_archflag.m4 (ax_gcc_arch): Don't recognize
+	UltraSPARC-IIi as ultrasparc3.
+
+2013-11-06  Mark Kettenis  <kettenis@gnu.org>
+
+	* src/x86/freebsd.S (ffi_call_SYSV): Align the stack pointer to
+        16-bytes.
+
+2013-11-06  Konstantin Belousov <kib@freebsd.org>
+
+	* src/x86/freebsd.S (ffi_closure_raw_SYSV): Mark the assembler
+	source as not requiring executable stack.
+
+2013-11-02  Anthony Green  <green@moxielogic.com>
+
+	* doc/libffi.texi (The Basics): Clarify return value buffer size
+	requirements.  Also, NULL result buffer pointers are no longer
+	supported.
+	* doc/libffi.info: Rebuilt.
+
+2013-11-02  Mischa Jonker  <mjonker@synopsys.com>
+
+	* Makefile.am (nodist_libffi_la_SOURCES): Fix build error.
+	* Makefile.in: Rebuilt.
+
+2013-11-02  David Schneider  <david.schneider@bivab.de>
+
+	* src/arm/ffi.c: more robust argument handling for closures on arm hardfloat
+	* testsuite/libffi.call/many_mixed.c: New file.
+	* testsuite/libffi.call/cls_many_mixed_args.c: More tests.
+
+2013-11-02  Vitaly Budovski
+
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Don't align stack for win32.
+
+2013-10-23  Mark H Weaver  <mhw@netris.org>
+
+	* src/mips/ffi.c: Fix handling of uint32_t arguments on the
+	MIPS N32 ABI.
+
+2013-10-13  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* README: Add Nios II to table of supported platforms.
+	* Makefile.am (EXTRA_DIST): Add nios2 files.
+	(nodist_libffi_la_SOURCES): Likewise.
+	* Makefile.in: Regenerated.
+	* configure.ac (nios2*-linux*): New host.
+	(NIOS2): Add AM_CONDITIONAL.
+	* configure: Regenerated.
+	* src/nios2/ffi.c: New.
+	* src/nios2/ffitarget.h: New.
+	* src/nios2/sysv.S: New.
+	* src/prep_cif.c (initialize_aggregate): Handle extra structure
+	alignment via FFI_AGGREGATE_ALIGNMENT.
+	(ffi_prep_cif_core): Conditionalize structure return for NIOS2.
+
+2013-10-10  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* testsuite/libffi.call/cls_many_mixed_args.c (cls_ret_double_fn):
+	Fix uninitialized variable.
+
+2013-10-11  Marcus Shawcroft  <marcus.shawcroft@arm.com>
+
+	* testsuite/libffi.call/many.c (many): Replace * with +.
+
+2013-10-08  Ondřej Bílka  <neleai@seznam.cz>
+
+	* src/aarch64/ffi.c, src/aarch64/sysv.S, src/arm/ffi.c,
+	src/arm/gentramp.sh, src/bfin/sysv.S, src/closures.c,
+	src/dlmalloc.c, src/ia64/ffi.c, src/microblaze/ffi.c,
+	src/microblaze/sysv.S, src/powerpc/darwin_closure.S,
+	src/powerpc/ffi.c, src/powerpc/ffi_darwin.c, src/sh/ffi.c,
+	src/tile/tile.S, testsuite/libffi.call/nested_struct11.c: Fix
+	spelling errors.
+
+2013-10-08  Anthony Green  <green@moxielogic.com>
+
+	* aclocal.m4, compile, config.guess, config.sub, depcomp,
+	install-sh, mdate-sh, missing, texinfo.tex: Update from upstream.
+	* configure.ac: Update version to 3.0.14-rc0.
+	* Makefile.in, configure, Makefile.in, include/Makefile.in,
+	man/Makefile.in, testsuite/Makefile.in: Rebuilt.
+	* README: Mention M88K and VAX.
+
+2013-07-15  Miod Vallat  <miod@openbsd.org>
+
+	* Makefile.am,
+	configure.ac,
+	src/m88k/ffi.c,
+	src/m88k/ffitarget.h,
+	src/m88k/obsd.S,
+	src/vax/elfbsd.S,
+	src/vax/ffi.c,
+	src/vax/ffitarget.h: Add m88k and vax support.
+
+2013-06-24 Alan Modra  <amodra@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Move var declaration
+	before statements.
+	(ffi_prep_args64): Support little-endian.
+	(ffi_closure_helper_SYSV, ffi_closure_helper_LINUX64): Likewise.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Likewise.
+	* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Likewise.
+
+2013-06-12  Mischa Jonker  <mjonker@synopsys.com>
+
+	 * configure.ac: Add support for ARC.
+	 * Makefile.am: Likewise.
+	 * README: Add ARC details.
+	 * src/arc/arcompact.S: New.
+	 * src/arc/ffi.c: Likewise.
+	 * src/arc/ffitarget.h: Likewise.
+
+2013-03-28  David Schneider  <david.schneider@bivab.de>
+
+	 * src/arm/ffi.c: Fix support for ARM hard-float calling convention.
+	 * src/arm/sysv.S: call different methods for SYSV and VFP ABIs.
+	 * testsuite/libffi.call/cls_many_mixed_args.c: testcase for a closure with
+	 mixed arguments, many doubles.
+	 * testsuite/libffi.call/many_double.c: testcase for calling a function using
+	 more than 8 doubles.
+	 * testcase/libffi.call/many.c: use absolute value to check result against an
+	 epsilon
+
+2013-03-17  Anthony Green  <green@moxielogic.com>
+
+	* README: Update for 3.0.13.
+	* configure.ac: Ditto.
+	* configure: Rebuilt.
+	* doc/*: Update version.
+
+2013-03-17  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	* src/closures.c (is_emutramp_enabled
+	[!FFI_MMAP_EXEC_EMUTRAMP_PAX]): Move default definition outside
+	enclosing #if scope.
+
+2013-03-17  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Only modify toolexecdir in certain cases.
+	* configure: Rebuilt.
+
+2013-03-16  Gilles Talis  <gilles.talis@gmail.com>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Don't use
+	fparg_count,etc on __NO_FPRS__ targets.
+
+2013-03-16  Alan Hourihane  <alanh@fairlite.co.uk>
+
+	* src/m68k/sysv.S (epilogue): Don't use extb instruction on
+	m680000 machines.
+
+2013-03-16  Alex Gaynor <alex.gaynor@gmail.com>
+
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Always align stack.
+
+2013-03-13  Markos Chandras <markos.chandras@imgtec.com>
+
+	* configure.ac: Add support for Imagination Technologies Meta.
+	* Makefile.am: Likewise.
+	* README: Add Imagination Technologies Meta details.
+	* src/metag/ffi.c: New.
+	* src/metag/ffitarget.h: Likewise.
+	* src/metag/sysv.S: Likewise.
+
+2013-02-24  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* doc/libffi.texi (Structures): Fix missing category argument of
+	@deftp.
+
+2013-02-11  Anthony Green <green@moxielogic.com>
+
+	* configure.ac: Update release number to 3.0.12.
+	* configure: Rebuilt.
+	* README: Update release info.
+
+2013-02-10  Anthony Green <green@moxielogic.com>
+
+	* README: Add Moxie.
+	* src/moxie/ffi.c: Created.
+	* src/moxie/eabi.S: Created.
+	* src/moxie/ffitarget.h: Created.
+	* Makefile.am (nodist_libffi_la_SOURCES): Add Moxie.
+	* Makefile.in: Rebuilt.
+	* configure.ac: Add Moxie.
+	* configure: Rebuilt.
+	* testsuite/libffi.call/huge_struct.c: Disable format string
+	warnings for moxie*-*-elf tests.
+
+2013-02-10  Anthony Green <green@moxielogic.com>
+
+	* Makefile.am (LTLDFLAGS): Fix reference.
+	* Makefile.in: Rebuilt.
+
+2013-02-10  Anthony Green <green@moxielogic.com>
+
+	* README: Update supported platforms.  Update test results link.
+
+2013-02-09  Anthony Green <green@moxielogic.com>
+
+	* testsuite/libffi.call/negint.c: Remove forced -O2.
+	* testsuite/libffi.call/many2.c (foo): Remove GCCism.
+	* testsuite/libffi.call/ffitest.h: Add default PRIuPTR definition.
+
+	* src/sparc/v8.S (ffi_closure_v8): Import ancient ulonglong
+	closure return type fix developed by Martin v. Löwis for cpython
+	fork.
+
+2013-02-08  Andreas Tobler  <andreast@fgznet.ch>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep): Fix small struct
+	support.
+	* src/powerpc/sysv.S: Ditto.
+
+2013-02-08  Anthony Green <green@moxielogic.com>
+
+	* testsuite/libffi.call/cls_longdouble.c: Remove xfail for
+	arm*-*-*.
+
+2013-02-08  Anthony Green <green@moxielogic.com>
+
+	* src/sparc/ffi.c (ffi_prep_closure_loc): Fix cache flushing for GCC.
+
+2013-02-08  Matthias Klose  <doko@ubuntu.com>
+
+	* man/ffi_prep_cif.3: Clean up for debian linter.
+
+2013-02-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Account for FP args pushed
+	on the stack.
+
+2013-02-08  Anthony Green <green@moxielogic.com>
+
+	* Makefile.am (EXTRA_DIST): Add missing files.
+	* testsuite/Makefile.am (EXTRA_DIST): Ditto.
+	* Makefile.in: Rebuilt.
+
+2013-02-08  Anthony Green <green@moxielogic.com>
+
+	* configure.ac: Move sparc asm config checks to within functions
+	for compatibility with sun tools.
+	* configure: Rebuilt.
+	* src/sparc/ffi.c (ffi_prep_closure_loc): Flush cache on v9
+	systems.
+	* src/sparc/v8.S (ffi_flush_icache): Implement a sparc v9 cache
+	flusher.
+
+2013-02-08  Nathan Rossi <nathan.rossi@xilinx.com>
+
+	* src/microblaze/ffi.c (ffi_closure_call_SYSV): Fix handling of
+	small big-endian structures.
+	(ffi_prep_args): Ditto.
+
+2013-02-07  Anthony Green <green@moxielogic.com>
+
+	* src/sparc/v8.S (ffi_call_v8): Fix typo from last patch
+	(effectively hiding ffi_call_v8).
+
+2013-02-07  Anthony Green <green@moxielogic.com>
+
+	* configure.ac: Update bug reporting address.
+	* configure.in: Rebuild.
+
+	* src/sparc/v8.S (ffi_flush_icache): Out-of-line cache flusher for
+	Sun compiler.
+	* src/sparc/ffi.c (ffi_call): Remove warning.
+	Call ffi_flush_icache for non-GCC builds.
+	(ffi_prep_closure_loc): Use ffi_flush_icache.
+
+	* Makefile.am (EXTRA_DIST): Add libtool-ldflags.
+	* Makefile.in: Rebuilt.
+	* libtool-ldflags: New file.
+
+2013-02-07  Daniel Schepler <dschepler@gmail.com>
+
+	* configure.ac: Correctly identify x32 systems as 64-bit.
+	* m4/libtool.m4: Remove libtool expr error.
+	* aclocal.m4, configure: Rebuilt.
+
+2013-02-07  Anthony Green <green@moxielogic.com>
+
+	* configure.ac: Fix GCC usage test.
+	* configure: Rebuilt.
+	* README: Mention LLVM/GCC x86_64 issue.
+	* testsuite/Makefile.in: Rebuilt.
+
+2013-02-07  Anthony Green <green@moxielogic.com>
+
+	* testsuite/libffi.call/cls_double_va.c (main): Replace // style
+	comments with /* */ for xlc compiler.
+	* testsuite/libffi.call/stret_large.c (main): Ditto.
+	* testsuite/libffi.call/stret_large2.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct1.c (main): Ditto.
+	* testsuite/libffi.call/huge_struct.c (main): Ditto.
+	* testsuite/libffi.call/float_va.c (main): Ditto.
+	* testsuite/libffi.call/cls_struct_va1.c (main): Ditto.
+	* testsuite/libffi.call/cls_pointer_stack.c (main): Ditto.
+	* testsuite/libffi.call/cls_pointer.c (main): Ditto.
+	* testsuite/libffi.call/cls_longdouble_va.c (main): Ditto.
+
+2013-02-06  Anthony Green <green@moxielogic.com>
+
+	* man/ffi_prep_cif.3: Clean up for debian lintian checker.
+
+2013-02-06  Anthony Green <green@moxielogic.com>
+
+	* Makefile.am (pkgconfigdir): Add missing pkgconfig install bits.
+	* Makefile.in: Rebuild.
+
+2013-02-02  Mark H Weaver <mhw@netris.org>
+
+	* src/x86/ffi64.c (ffi_call): Sign-extend integer arguments passed
+	via general purpose registers.
+
+2013-01-21  Nathan Rossi <nathan.rossi@xilinx.com>
+
+	* README: Add MicroBlaze details.
+	* Makefile.am: Add MicroBlaze support.
+	* configure.ac: Likewise.
+	* src/microblaze/ffi.c: New.
+	* src/microblaze/ffitarget.h: Likewise.
+	* src/microblaze/sysv.S: Likewise.
+
+2013-01-21  Nathan Rossi <nathan.rossi@xilinx.com>
+	* testsuite/libffi.call/return_uc.c: Fixed issue.
+
+2013-01-21  Chris Zankel   <chris@zankel.net>
+
+	* README: Add Xtensa support.
+	* Makefile.am: Likewise.
+	* configure.ac: Likewise.
+	* Makefile.in Regenerate.
+	* configure: Likewise.
+	* src/prep_cif.c: Handle Xtensa.
+	* src/xtensa: New directory.
+	* src/xtensa/ffi.c: New file.
+	* src/xtensa/ffitarget.h: Ditto.
+	* src/xtensa/sysv.S: Ditto.
+
+2013-01-11  Anthony Green  <green@moxielogic.com>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Replace // style
+	comments with /* */ for xlc compiler.
+	* src/powerpc/aix.S (ffi_call_AIX): Ditto.
+	* testsuite/libffi.call/ffitest.h (allocate_mmap): Delete
+	deprecated inline function.
+	* testsuite/libffi.special/ffitestcxx.h: Ditto.
+	* README: Add update for AIX support.
+
+2013-01-11  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Robustify pc relative reloc check.
+	* m4/ax_cc_maxopt.m4: Don't -malign-double.  This is an ABI
+	changing option for 32-bit x86.
+	* aclocal.m4, configure: Rebuilt.
+	* README: Update supported target list.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* README (tested): Add Compiler column to table.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* src/x86/ffi64.c (struct register_args): Make sse array and array
+	of unions for sunpro compiler compatibility.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Test target platform size_t size.  Handle both 32
+	and 64-bit builds for x86_64-* and i?86-* targets (allowing for
+	CFLAG option to change default settings).
+	* configure, aclocal.m4: Rebuilt.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* testsuite/libffi.special/special.exp: Only run exception
+	handling tests when using GNU compiler.
+
+	* m4/ax_compiler_vendor.m4: New file.
+	* configure.ac: Test for compiler vendor and don't use
+	AX_CFLAGS_WARN_ALL with the sun compiler.
+	* aclocal.m4, configure: Rebuilt.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* include/ffi_common.h: Don't use GCCisms to define types when
+	building with the SUNPRO compiler.
+
+2013-01-10  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Put local.exp in the right place.
+	* configure: Rebuilt.
+
+	* src/x86/ffi.c: Update comment about regparm function attributes.
+	* src/x86/sysv.S (ffi_closure_SYSV): The SUNPRO compiler requires
+	that all function arguments be passed on the stack (no regparm
+	support).
+
+2013-01-08  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Generate local.exp.  This sets CC_FOR_TARGET
+	when we are using the vendor compiler.
+	* testsuite/Makefile.am (EXTRA_DEJAGNU_SITE_CONFIG): Point to
+	../local.exp.
+	* configure, testsuite/Makefile.in: Rebuilt.
+
+	* testsuite/libffi.call/call.exp: Run tests with different
+	options, depending on whether or not we are using gcc or the
+	vendor compiler.
+	* testsuite/lib/libffi.exp (libffi-init): Set using_gcc based on
+	whether or not we are building/testing with gcc.
+
+2013-01-08  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Switch x86 solaris target to X86 by default.
+	* configure: Rebuilt.
+
+2013-01-08  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Fix test for read-only eh_frame.
+	* configure: Rebuilt.
+
+2013-01-08  Anthony Green  <green@moxielogic.com>
+
+	* src/x86/sysv.S, src/x86/unix64.S: Only emit DWARF unwind info
+	when building with the GNU toolchain.
+	* testsuite/libffi.call/ffitest.h (CHECK): Fix for Solaris vendor
+	compiler.
+
+2013-01-07  Thorsten Glaser <tg@mirbsd.org>
+
+	* testsuite/libffi.call/cls_uchar_va.c,
+	testsuite/libffi.call/cls_ushort_va.c,
+	testsuite/libffi.call/va_1.c: Testsuite fixes.
+
+2013-01-07  Thorsten Glaser <tg@mirbsd.org>
+
+	* src/m68k/ffi.c (CIF_FLAGS_SINT8, CIF_FLAGS_SINT16): Define.
+	(ffi_prep_cif_machdep): Fix 8-bit and 16-bit signed calls.
+	* src/m68k/sysv.S (ffi_call_SYSV, ffi_closure_SYSV): Ditto.
+
+2013-01-04  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (AM_CFLAGS): Don't automatically add -fexceptions
+	and -Wall.  This is set in the configure script after testing for
+	GCC.
+	* Makefile.in: Rebuilt.
+
+2013-01-02  rofl0r <https://github.com/rofl0r>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep): Fix build error on ppc
+	when long double == double.
+
+2013-01-02  Reini Urban  <rurban@x-ray.at>
+
+	* Makefile.am (libffi_la_LDFLAGS): Add -no-undefined to LDFLAGS
+	(required for shared libs on cygwin/mingw).
+	* Makefile.in: Rebuilt.
+
+2012-10-31  Alan Modra  <amodra@gmail.co>
+
+	* src/powerpc/linux64_closure.S: Add new ABI support.
+	* src/powerpc/linux64.S: Likewise.
+
+2012-10-30  Magnus Granberg  <zorry@gentoo.org>
+	    Pavel Labushev  <pavel.labushev@runbox.ru>
+
+	* configure.ac: New options pax_emutramp
+	* configure, fficonfig.h.in: Regenerated
+	* src/closures.c: New function emutramp_enabled_check() and
+	checks.
+
+2012-10-30  Frederick Cheung  <frederick.cheung@gmail.com>
+
+	* configure.ac: Enable FFI_MAP_EXEC_WRIT for Darwin 12 (mountain
+	lion) and future version.
+	* configure: Rebuild.
+
+2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>
+            Marcus Shawcroft  <marcus.shawcroft at arm.com>
+
+        * README: Add details of aarch64 port.
+        * src/aarch64/ffi.c: New.
+        * src/aarch64/ffitarget.h: Likewise.
+        * src/aarch64/sysv.S: Likewise.
+	* Makefile.am: Support aarch64.
+	* configure.ac: Support aarch64.
+	* Makefile.in, configure: Rebuilt.
+
+2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>
+            Marcus Shawcroft  <marcus.shawcroft at arm.com>
+
+        * testsuite/lib/libffi.exp: Add support for aarch64.
+        * testsuite/libffi.call/cls_struct_va1.c: New.
+        * testsuite/libffi.call/cls_uchar_va.c: Likewise.
+        * testsuite/libffi.call/cls_uint_va.c: Likewise.
+        * testsuite/libffi.call/cls_ulong_va.c: Likewise.
+        * testsuite/libffi.call/cls_ushort_va.c: Likewise.
+        * testsuite/libffi.call/nested_struct11.c: Likewise.
+        * testsuite/libffi.call/uninitialized.c: Likewise.
+        * testsuite/libffi.call/va_1.c: Likewise.
+        * testsuite/libffi.call/va_struct1.c: Likewise.
+        * testsuite/libffi.call/va_struct2.c: Likewise.
+        * testsuite/libffi.call/va_struct3.c: Likewise.
+
+2012-10-12  Walter Lee  <walt@tilera.com>
+
+        * Makefile.am: Add TILE-Gx/TILEPro support.
+        * configure.ac: Likewise.
+        * Makefile.in: Regenerate.
+        * configure: Likewise.
+        * src/prep_cif.c (ffi_prep_cif_core): Handle TILE-Gx/TILEPro.
+        * src/tile: New directory.
+        * src/tile/ffi.c: New file.
+        * src/tile/ffitarget.h: Ditto.
+        * src/tile/tile.S: Ditto.
+
+2012-10-12  Matthias Klose  <doko@ubuntu.com>
+
+	* generate-osx-source-and-headers.py: Normalize whitespace.
+
+2012-09-14  David Edelsohn  <dje.gcc@gmail.com>
+
+	* configure: Regenerated.
+
+2012-08-26  Andrew Pinski  <apinski@cavium.com>
+
+	PR libffi/53014
+	* src/mips/ffi.c (ffi_prep_closure_loc): Allow n32 with soft-float and n64 with
+	soft-float.
+
+2012-08-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	* src/s390/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,
+	just return FFI_BAD_ABI when things are wrong.
+
+2012-07-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libffi/53982
+	PR libffi/53973
+	* src/x86/ffitarget.h: Check __ILP32__ instead of __LP64__ for x32.
+	(FFI_SIZEOF_JAVA_RAW): Defined to 4 for x32.
+
+2012-05-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure: Regenerated.
+
+2012-05-05  Nicolas Lelong
+
+	* libffi.xcodeproj/project.pbxproj: Fixes.
+	* README: Update for iOS builds.
+
+2012-04-23  Alexandre Keunecke I. de Mendonca <alexandre.keunecke@gmail.com>
+
+	* configure.ac: Add Blackfin/sysv support
+	* Makefile.am: Add Blackfin/sysv support
+	* src/bfin/ffi.c:  Add Blackfin/sysv support
+	* src/bfin/ffitarget.h: Add Blackfin/sysv support
+
+2012-04-11  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (EXTRA_DIST): Add new script.
+	* Makefile.in: Rebuilt.
+
+2012-04-11  Zachary Waldowski  <zwaldowski@gmail.com>
+
+	* generate-ios-source-and-headers.py,
+	libffi.xcodeproj/project.pbxproj: Support a Mac static library via
+	Xcode. Set iOS compatibility to 4.0.  Move iOS trampoline
+	generation into an Xcode "run script" phase.  Include both as
+	Xcode build scripts. Don't always regenerate config files.
+
+2012-04-10  Anthony Green  <green@moxielogic.com>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Add missing semicolon.
+
+2012-04-06  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (EXTRA_DIST): Add new iOS/xcode files.
+	* Makefile.in: Rebuilt.
+
+2012-04-06  Mike Lewis  <mikelikespie@gmail.com>
+
+	* generate-ios-source-and-headers.py: New file.
+	* libffi.xcodeproj/project.pbxproj: New file.
+	* README: Update instructions on building iOS binary.
+	* build-ios.sh: Delete.
+
+2012-04-06  Anthony Green  <green@moxielogic.com>
+
+	* src/x86/ffi64.c (UINT128): Define differently for Intel and GNU
+	compilers, then use it.
+
+2012-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* m4/libtool.m4 (_LT_ENABLE_LOCK): Support x32.
+
+2012-04-06  Anthony Green  <green@moxielogic.com>
+
+	* testsuite/Makefile.am (EXTRA_DIST): Add missing test cases.
+	* testsuite/Makefile.in: Rebuilt.
+
+2012-04-05  Zachary Waldowski  <zwaldowski@gmail.com>
+
+	* include/ffi.h.in: Add missing trampoline table fields.
+	* src/arm/sysv.S: Fix ENTRY definition, and wrap symbol references
+	in CNAME.
+	* src/x86/ffi.c: Wrap Windows specific code in ifdefs.
+
+2012-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Declare double_tmp.
+	Silence casting pointer to integer of different size warning.
+	Delete goto to previously deleted label.
+	(ffi_call): Silence possibly undefined warning.
+	(ffi_closure_helper_SYSV): Declare variable type.
+
+2012-04-02  Peter Rosin  <peda@lysator.liu.se>
+
+	* src/x86/win32.S (ffi_call_win32): Sign/zero extend the return
+	value in the Intel version as is already done for the AT&T version.
+	(ffi_closure_SYSV): Likewise.
+	(ffi_closure_raw_SYSV): Likewise.
+	(ffi_closure_STDCALL): Likewise.
+
+2012-03-29  Peter Rosin  <peda@lysator.liu.se>
+
+	* src/x86/win32.S (ffi_closure_raw_THISCALL): Unify the frame
+	generation, fix the ENDP label and remove the surplus third arg
+	from the 'lea' insn.
+
+2012-03-29  Peter Rosin  <peda@lysator.liu.se>
+
+	* src/x86/win32.S (ffi_closure_raw_SYSV): Make the 'stubraw' label
+	visible outside the PROC, so that ffi_closure_raw_THISCALL can see
+	it.  Also instruct the assembler to add a frame to the function.
+
+2012-03-23  Peter Rosin  <peda@lysator.liu.se>
+
+	* Makefile.am (AM_CPPFLAGS): Add -DFFI_BUILDING.
+	* Makefile.in: Rebuilt.
+	* include/ffi.h.in [MSVC]: Add __declspec(dllimport) decorations
+	to all data exports, when compiling libffi clients using MSVC.
+
+2012-03-29  Peter Rosin  <peda@lysator.liu.se>
+
+	* src/x86/ffitarget.h (ffi_abi): Add new ABI FFI_MS_CDECL and
+	make it the default for MSVC.
+	(FFI_TYPE_MS_STRUCT): New structure return convention.
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Tweak the structure
+	return convention for FFI_MS_CDECL to be FFI_TYPE_MS_STRUCT
+	instead of an ordinary FFI_TYPE_STRUCT.
+	(ffi_prep_args): Treat FFI_TYPE_MS_STRUCT as FFI_TYPE_STRUCT.
+	(ffi_call): Likewise.
+	(ffi_prep_incoming_args_SYSV): Likewise.
+	(ffi_raw_call): Likewise.
+	(ffi_prep_closure_loc): Treat FFI_MS_CDECL as FFI_SYSV.
+	* src/x86/win32.S (ffi_closure_SYSV): For FFI_TYPE_MS_STRUCT,
+	return a pointer to the result structure in eax and don't pop
+	that pointer from the stack, the caller takes care of it.
+	(ffi_call_win32): Treat FFI_TYPE_MS_STRUCT as FFI_TYPE_STRUCT.
+	(ffi_closure_raw_SYSV): Likewise.
+
+2012-03-22  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/closure_stdcall.c [MSVC]: Add inline
+	assembly version with Intel syntax.
+	* testsuite/libffi.call/closure_thiscall.c [MSVC]: Likewise.
+
+2012-03-23  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/ffitest.h: Provide abstration of
+	__attribute__((fastcall)) in the form of a __FASTCALL__
+	define.  Define it to __fastcall for MSVC.
+	* testsuite/libffi.call/fastthis1_win32.c: Use the above.
+	* testsuite/libffi.call/fastthis2_win32.c: Likewise.
+	* testsuite/libffi.call/fastthis3_win32.c: Likewise.
+	* testsuite/libffi.call/strlen2_win32.c: Likewise.
+	* testsuite/libffi.call/struct1_win32.c: Likewise.
+	* testsuite/libffi.call/struct2_win32.c: Likewise.
+
+2012-03-22  Peter Rosin  <peda@lysator.liu.se>
+
+	* src/x86/win32.S [MSVC] (ffi_closure_THISCALL): Remove the manual
+	frame on function entry, MASM adds one automatically.
+
+2012-03-22  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/ffitest.h [MSVC]: Add kludge for missing
+	bits in the MSVC headers.
+
+2012-03-22  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/cls_12byte.c: Adjust to the C89 style
+	with no declarations after statements.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_18byte.c: Likewise.
+	* testsuite/libffi.call/cls_19byte.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte1.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_5_1_byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+	* testsuite/libffi.call/cls_64byte.c: Likewise.
+	* testsuite/libffi.call/cls_6_1_byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7_1_byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_9byte1.c: Likewise.
+	* testsuite/libffi.call/cls_9byte2.c: Likewise.
+	* testsuite/libffi.call/cls_align_double.c: Likewise.
+	* testsuite/libffi.call/cls_align_float.c: Likewise.
+	* testsuite/libffi.call/cls_align_longdouble.c: Likewise.
+	* testsuite/libffi.call/cls_align_longdouble_split.c: Likewise.
+	* testsuite/libffi.call/cls_align_longdouble_split2.c: Likewise.
+	* testsuite/libffi.call/cls_align_pointer.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint64.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint64.c: Likewise.
+	* testsuite/libffi.call/cls_dbls_struct.c: Likewise.
+	* testsuite/libffi.call/cls_pointer_stack.c: Likewise.
+	* testsuite/libffi.call/err_bad_typedef.c: Likewise.
+	* testsuite/libffi.call/huge_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct1.c: Likewise.
+	* testsuite/libffi.call/nested_struct10.c: Likewise.
+	* testsuite/libffi.call/nested_struct2.c: Likewise.
+	* testsuite/libffi.call/nested_struct3.c: Likewise.
+	* testsuite/libffi.call/nested_struct4.c: Likewise.
+	* testsuite/libffi.call/nested_struct5.c: Likewise.
+	* testsuite/libffi.call/nested_struct6.c: Likewise.
+	* testsuite/libffi.call/nested_struct7.c: Likewise.
+	* testsuite/libffi.call/nested_struct8.c: Likewise.
+	* testsuite/libffi.call/nested_struct9.c: Likewise.
+	* testsuite/libffi.call/stret_large.c: Likewise.
+	* testsuite/libffi.call/stret_large2.c: Likewise.
+	* testsuite/libffi.call/stret_medium.c: Likewise.
+	* testsuite/libffi.call/stret_medium2.c: Likewise.
+	* testsuite/libffi.call/struct1.c: Likewise.
+	* testsuite/libffi.call/struct1_win32.c: Likewise.
+	* testsuite/libffi.call/struct2.c: Likewise.
+	* testsuite/libffi.call/struct2_win32.c: Likewise.
+	* testsuite/libffi.call/struct3.c: Likewise.
+	* testsuite/libffi.call/struct4.c: Likewise.
+	* testsuite/libffi.call/struct5.c: Likewise.
+	* testsuite/libffi.call/struct6.c: Likewise.
+	* testsuite/libffi.call/struct7.c: Likewise.
+	* testsuite/libffi.call/struct8.c: Likewise.
+	* testsuite/libffi.call/struct9.c: Likewise.
+	* testsuite/libffi.call/testclosure.c: Likewise.
+
+2012-03-21  Peter Rosin	 <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/float_va.c (float_va_fn): Use %f when
+	printing doubles (%lf is for long doubles).
+	(main): Likewise.
+
+2012-03-21  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/lib/target-libpath.exp [*-*-cygwin*, *-*-mingw*]
+	(set_ld_library_path_env_vars): Add the library search dir to PATH
+	(and save PATH for later).
+	(restore_ld_library_path_env_vars): Restore PATH.
+
+2012-03-21  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/lib/target-libpath.exp [*-*-cygwin*, *-*-mingw*]
+	(set_ld_library_path_env_vars): Add the library search dir to PATH
+	(and save PATH for later).
+	(restore_ld_library_path_env_vars): Restore PATH.
+
+2012-03-20  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/strlen2_win32.c (main): Remove bug.
+	* src/x86/win32.S [MSVC] (ffi_closure_SYSV): Make the 'stub' label
+	visible outside the PROC, so that ffi_closure_THISCALL can see it.
+
+2012-03-20  Peter Rosin  <peda@lysator.liu.se>
+
+	* testsuite/libffi.call/strlen2_win32.c (main): Remove bug.
+	* src/x86/win32.S [MSVC] (ffi_closure_SYSV): Make the 'stub' label
+	visible outside the PROC, so that ffi_closure_THISCALL can see it.
+
+2012-03-19  Alan Hourihane  <alanh@fairlite.co.uk>
+
+	* src/m68k/ffi.c: Add MINT support.
+	* src/m68k/sysv.S: Ditto.
+
+2012-03-06  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	* src/arm/ffi.c (ffi_call): Add __ARM_EABI__ guard around call to
+	ffi_call_VFP().
+	(ffi_prep_closure_loc): Add __ARM_EABI__ guard around use of
+	ffi_closure_VFP.
+	* src/arm/sysv.S: Add __ARM_EABI__ guard around VFP code.
+
+2012-03-19  chennam  <csit@axway.com>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_closure_loc): Fix AIX closure
+	support.
+
+2012-03-13  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,
+	just return FFI_BAD_ABI when things are wrong.
+	* src/sh64/ffi.c (ffi_prep_closure_loc): Ditto.
+
+2012-03-09  David Edelsohn  <dje.gcc@gmail.com>
+
+	* src/powerpc/aix_closure.S (ffi_closure_ASM): Adjust for Darwin64
+	change to return value of ffi_closure_helper_DARWIN and load type
+	from return type.
+
+2012-03-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* src/x86/ffi64.c (ffi_call): Cast the return value to unsigned
+	long.
+	(ffi_prep_closure_loc): Cast to 64bit address in trampoline.
+	(ffi_closure_unix64_inner): Cast return pointer to unsigned long
+	first.
+
+	* src/x86/ffitarget.h (FFI_SIZEOF_ARG): Defined to 8 for x32.
+	(ffi_arg): Set to unsigned long long for x32.
+	(ffi_sarg): Set to long long for x32.
+
+2012-03-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* src/prep_cif.c (ffi_prep_cif_core): Properly check bad ABI.
+
+2012-03-03  Andoni Morales Alastruey  <ylatuya@gmail.com>
+
+	* configure.ac: Add -no-undefined for both 32- and 64-bit x86
+	windows-like hosts.
+	* configure: Rebuilt.
+
+2012-02-27  Mikael Pettersson  <mikpe@it.uu.se>
+
+	PR libffi/52223
+	* Makefile.am (FLAGS_TO_PASS): Define.
+	* Makefile.in: Regenerate.
+
+2012-02-23  Anthony Green  <green@moxielogic.com>
+
+	* src/*/ffitarget.h: Ensure that users never include ffitarget.h
+	directly.
+
+2012-02-23  Kai Tietz  <ktietz@redhat.com>
+
+	PR libffi/52221
+	* src/x86/ffi.c (ffi_closure_raw_THISCALL): New
+	prototype.
+	(ffi_prep_raw_closure_loc): Use ffi_closure_raw_THISCALL for
+	thiscall-convention.
+	(ffi_raw_call): Use ffi_prep_args_raw.
+	* src/x86/win32.S (ffi_closure_raw_THISCALL): Add
+	implementation for stub.
+
+2012-02-10  Kai Tietz  <ktietz@redhat.com>
+
+	* configure.ac (AM_LTLDFLAGS): Add -no-undefine for x64
+	windows target.
+	* configure: Regenerated.
+
+2012-02-08  Kai Tietz  <ktietz@redhat.com>
+
+	* src/prep_cif.c (ffi_prep_cif): Allow for X86_WIN32
+	also FFI_THISCALL.
+	* src/x86/ffi.c (ffi_closure_THISCALL): Add prototype.
+	(FFI_INIT_TRAMPOLINE_THISCALL): New trampoline code.
+	(ffi_prep_closure_loc): Add FFI_THISCALL support.
+	* src/x86/ffitarget.h (FFI_TRAMPOLINE_SIZE): Adjust size.
+	* src/x86/win32.S (ffi_closure_THISCALL): New closure code
+	for thiscall-calling convention.
+	* testsuite/libffi.call/closure_thiscall.c: New test.
+
+2012-01-28  Kai Tietz  <ktietz@redhat.com>
+
+	* src/libffi/src/x86/ffi.c (ffi_call_win32): Add new
+	argument to prototype for specify calling-convention.
+	(ffi_call): Add support for stdcall/thiscall convention.
+	(ffi_prep_args): Likewise.
+	(ffi_raw_call): Likewise.
+	* src/x86/ffitarget.h (ffi_abi): Add FFI_THISCALL and
+	FFI_FASTCALL.
+	* src/x86/win32.S (_ffi_call_win32): Add support for
+	fastcall/thiscall calling-convention calls.
+	* testsuite/libffi.call/fastthis1_win32.c: New test.
+	* testsuite/libffi.call/fastthis2_win32.c: New test.
+	* testsuite/libffi.call/fastthis3_win32.c: New test.
+	* testsuite/libffi.call/strlen2_win32.c: New test.
+	* testsuite/libffi.call/many2_win32.c: New test.
+	* testsuite/libffi.call/struct1_win32.c: New test.
+	* testsuite/libffi.call/struct2_win32.c: New test.
+
+2012-01-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	* src/alpha/ffi.c (ffi_prep_closure_loc): Check for bad ABI.
+
+2012-01-23  Anthony Green  <green@moxielogic.com>
+	    Chris Young  <cdyoung@ntlworld.com>
+
+	* configure.ac: Add Amiga support.
+	* configure: Rebuilt.
+
+2012-01-23  Dmitry Nadezhin  <dmitry.nadezhin@gmail.com>
+
+	* include/ffi_common.h (LIKELY, UNLIKELY): Fix definitions.
+
+2012-01-23  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* src/m68k/sysv.S (ffi_call_SYSV): Properly test for plain
+	mc68000.  Test for __HAVE_68881__ in addition to __MC68881__.
+
+2012-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/48496
+	* src/ia64/ffi.c (ffi_call): Fix up aliasing violations.
+
+2012-01-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (i?86-*-*): Set TARGET to X86_64.
+	* configure: Regenerate.
+
+2011-12-07  Andrew Pinski  <apinski@cavium.com>
+
+	PR libffi/50051
+	* src/mips/n32.S: Add ".set mips4".
+
+2011-11-21  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
+2011-11-12  David Gilbert <david.gilbert@linaro.org>
+
+	* doc/libffi.texi, include/ffi.h.in, include/ffi_common.h,
+	man/Makefile.am, man/ffi.3, man/ffi_prep_cif.3,
+	man/ffi_prep_cif_var.3, src/arm/ffi.c, src/arm/ffitarget.h,
+	src/cris/ffi.c, src/prep_cif.c,
+	testsuite/libffi.call/cls_double_va.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/float_va.c: Many changes to support variadic
+	function calls.
+
+2011-11-12  Kyle Moffett <Kyle.D.Moffett@boeing.com>
+
+	* src/powerpc/ffi.c, src/powerpc/ffitarget.h,
+	src/powerpc/ppc_closure.S, src/powerpc/sysv.S: Many changes for
+	softfloat powerpc variants.
+
+2011-11-12  Petr Salinger <Petr.Salinger@seznam.cz>
+
+	* configure.ac (FFI_EXEC_TRAMPOLINE_TABLE): Fix kfreebsd support.
+	* configure: Rebuilt.
+
+2011-11-12  Timothy Wall  <twall@users.sf.net>
+
+	* src/arm/ffi.c (ffi_prep_args, ffi_prep_incoming_args_SYSV): Max
+	alignment of 4 for wince on ARM.
+
+2011-11-12  Kyle Moffett <Kyle.D.Moffett@boeing.com>
+	    Anthony Green <green@moxielogic.com>
+
+	* src/ppc/sysv.S, src/ppc/ffi.c: Remove use of ppc string
+	instructions (not available on some cores, like the PPC440).
+
+2011-11-12  Kimura Wataru  <kimuraw@i.nifty.jp>
+
+	* m4/ax_enable_builddir: Change from string comparison to numeric
+	comparison for wc output.
+	* configure.ac: Enable FFI_MMAP_EXEC_WRIT for darwin11 aka Mac OS
+	X 10.7.
+	* configure: Rebuilt.
+
+2011-11-12  Anthony Green  <green@moxielogic.com>
+
+	* Makefile.am (AM_CCASFLAGS): Add -g option to build assembly
+	files with debug info.
+	* Makefile.in: Rebuilt.
+
+2011-11-12  Jasper Lievisse Adriaanse <jasper@openbsd.org>
+
+	* README: Update list of supported OpenBSD systems.
+
+2011-11-12  Anthony Green  <green@moxielogic.com>
+
+	* libtool-version: Update.
+	* Makefile.am (nodist_libffi_la_SOURCES): Add src/debug.c if
+	FFI_DEBUG.
+	(libffi_la_SOURCES): Remove src/debug.c
+	(EXTRA_DIST): Add src/debug.c
+	* Makefile.in: Rebuilt.
+	* README: Update for 3.0.11.
+
+2011-11-10  Richard Henderson  <rth@redhat.com>
+
+	* configure.ac (GCC_AS_CFI_PSEUDO_OP): Use it instead of inline check.
+	* configure, aclocal.m4: Rebuild.
+
+2011-09-04  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR libffi/49594
+	* src/powerpc/darwin_closure.S (stubs): Make the stub binding
+	helper reference track the architecture pointer size.
+
+2011-08-25  Andrew Haley  <aph@redhat.com>
+
+	* src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Remove hard-coded assembly
+	instructions.
+	* src/arm/sysv.S (ffi_arm_trampoline): Put them here instead.
+
+2011-07-11  Andrew Haley  <aph@redhat.com>
+
+        * src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Clear icache.
+
+2011-06-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/cls_double_va.c: Move PR number to comment.
+	* testsuite/libffi.call/cls_longdouble_va.c: Likewise.
+
+2011-06-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libffi/46660
+	* testsuite/libffi.call/cls_double_va.c: xfail dg-output on
+	mips-sgi-irix6*.
+	* testsuite/libffi.call/cls_longdouble_va.c: Likewise.
+
+2011-06-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/huge_struct.c (test_large_fn): Use PRIu8,
+	PRId8 instead of %hhu, %hhd.
+	* testsuite/libffi.call/ffitest.h [__alpha__ && __osf__] (PRId8,
+	PRIu8): Define.
+	[__sgi__] (PRId8, PRIu8): Define.
+
+2011-04-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* src/alpha/osf.S (UA_SI, FDE_ENCODING, FDE_ENCODE, FDE_ARANGE):
+	Define.
+	Use them to handle ELF vs. ECOFF differences.
+	[__osf__] (_GLOBAL__F_ffi_call_osf): Define.
+
+2011-03-30  Timothy Wall  <twall@users.sf.net>
+
+	* src/powerpc/darwin.S: Fix unknown FDE encoding.
+	* src/powerpc/darwin_closure.S: ditto.
+
+2011-02-25  Anthony Green  <green@moxielogic.com>
+
+	* src/powerpc/ffi.c (ffi_prep_closure_loc): Allow for more
+	32-bit ABIs.
+
+2011-02-15  Anthony Green  <green@moxielogic.com>
+
+	* m4/ax_cc_maxopt.m4: Don't -malign-double or use -ffast-math.
+	* configure: Rebuilt.
+
+2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure: Regenerate.
+
+2011-02-13  Anthony Green  <green@moxielogic.com>
+
+	* include/ffi_common.h (UNLIKELY, LIKELY): Define.
+	* src/x86/ffi64.c (UNLIKELY, LIKELY): Remove definition.
+	* src/prep_cif.c (UNLIKELY, LIKELY): Remove definition.
+
+	* src/prep_cif.c (initialize_aggregate): Convert assertion into
+	FFI_BAD_TYPEDEF return.  Initialize arg size and alignment to 0.
+
+	* src/pa/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,
+	just return FFI_BAD_ABI when things are wrong.
+	* src/arm/ffi.c (ffi_prep_closure_loc): Ditto.
+	* src/powerpc/ffi.c (ffi_prep_closure_loc): Ditto.
+	* src/mips/ffi.c (ffi_prep_closure_loc): Ditto.
+	* src/ia64/ffi.c (ffi_prep_closure_loc): Ditto.
+	* src/avr32/ffi.c (ffi_prep_closure_loc): Ditto.
+
+2011-02-11  Anthony Green  <green@moxielogic.com>
+
+	* src/sparc/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,
+	just return FFI_BAD_ABI when things are wrong.
+
+2012-02-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* src/sparc/v9.S (STACKFRAME): Bump to 176.
+
+2011-02-09  Stuart Shelton  <srcshelton@gmail.com>
+
+	http://bugs.gentoo.org/show_bug.cgi?id=286911
+	* src/mips/ffitarget.h: Clean up error messages.
+	* src/java_raw_api.c (ffi_java_translate_args): Cast raw arg to
+	ffi_raw*.
+	* include/ffi.h.in: Add pragma for SGI compiler.
+
+2011-02-09  Anthony Green  <green@moxielogic.com>
+
+	* configure.ac: Add powerpc64-*-darwin* support.
+
+2011-02-09  Anthony Green <green@moxielogic.com>
+
+	* README: Mention Interix.
+
+2011-02-09  Jonathan Callen  <abcd@gentoo.org>
+
+	* configure.ac: Add Interix to win32/cygwin/mingw case.
+	* configure: Ditto.
+	* src/closures.c: Treat Interix like Cygwin, instead of as a
+	generic win32.
+
+2011-02-09  Anthony Green <green@moxielogic.com>
+
+	* testsuite/libffi.call/err_bad_typedef.c: Remove xfail.
+	* testsuite/libffi.call/err_bad_abi.c: Remove xfail.
+	* src/x86/ffi64.c (UNLIKELY, LIKELY): Define.
+	(ffi_prep_closure_loc): Check for bad ABI.
+	* src/prep_cif.c (UNLIKELY, LIKELY): Define.
+	(initialize_aggregate): Check for bad types.
+
+2011-02-09  Landon Fuller <landonf@plausible.coop>
+
+	* Makefile.am (EXTRA_DIST): Add build-ios.sh, src/arm/gentramp.sh,
+	src/arm/trampoline.S.
+	(nodist_libffi_la_SOURCES): Add src/arc/trampoline.S.
+	* configure.ac (FFI_EXEC_TRAMPOLINE_TABLE): Define.
+	* src/arm/ffi.c (ffi_trampoline_table)
+	(ffi_closure_trampoline_table_page, ffi_trampoline_table_entry)
+	(FFI_TRAMPOLINE_CODELOC_CONFIG, FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET)
+	(FFI_TRAMPOLINE_COUNT, ffi_trampoline_lock, ffi_trampoline_tables)
+	(ffi_trampoline_table_alloc, ffi_closure_alloc, ffi_closure_free):
+	Define for FFI_EXEC_TRAMPOLINE_TABLE case (iOS).
+	(ffi_prep_closure_loc): Handl FFI_EXEC_TRAMPOLINE_TABLE case
+	separately.
+	* src/arm/sysv.S: Handle Apple iOS host.
+	* src/closures.c: Handle FFI_EXEC_TRAMPOLINE_TABLE case.
+	* build-ios.sh: New file.
+	* fficonfig.h.in, configure, Makefile.in: Rebuilt.
+	* README: Mention ARM iOS.
+
+2011-02-08  Oren Held  <orenhe@il.ibm.com>
+
+	* src/dlmalloc.c (_STRUCT_MALLINFO): Define in order to avoid
+	redefinition of mallinfo on HP-UX.
+
+2011-02-08  Ginn Chen  <ginn.chen@oracle.com>
+
+	* src/sparc/ffi.c (ffi_call): Make compatible with Solaris Studio
+	aggregate return ABI.  Flush cache.
+	(ffi_prep_closure_loc): Flush cache.
+
+2011-02-11  Anthony Green  <green@moxielogic.com>
+
+	From Tom Honermann <tom.honermann@oracle.com>:
+	* src/powerpc/aix.S (ffi_call_AIX): Support for xlc toolchain on
+	AIX.  Declare .ffi_prep_args.  Insert nops after branch
+	instructions so that the AIX linker can insert TOC reload
+	instructions.
+	* src/powerpc/aix_closure.S: Declare .ffi_closure_helper_DARWIN.
+
+2011-02-08  Ed  <ed@kdtc.net>
+
+	* src/powerpc/asm.h: Fix grammar nit in comment.
+
+2011-02-08  Uli Link  <ul.mcamafia@linkitup.de>
+
+	* include/ffi.h.in (FFI_64_BIT_MAX): Define and use.
+
+2011-02-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libffi/46661
+	* testsuite/libffi.call/cls_pointer.c (main): Cast void * to
+	uintptr_t first.
+	* testsuite/libffi.call/cls_pointer_stack.c (main): Likewise.
+
+2011-02-08  Rafael Avila de Espindola  <respindola@mozilla.com>
+
+	* configure.ac: Fix x86 test for pc related relocs.
+	* configure: Rebuilt.
+
+2011-02-07  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* libffi/src/m68k/ffi.c: Add RTEMS support for cache flushing.
+	Handle case when CPU variant does not have long double support.
+	* libffi/src/m68k/sysv.S: Add support for mc68000, Coldfire,
+	and cores with soft floating point.
+
+2011-02-07  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* configure.ac: Add mips*-*-rtems* support.
+	* configure: Regenerate.
+	* src/mips/ffitarget.h: Ensure needed constants are available
+	for targets which do not have sgidefs.h.
+
+2011-01-26  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	PR target/40125
+	* configure.ac (AM_LTLDFLAGS): Add -bindir option for windows DLLs.
+	* configure: Regenerate.
+
+2010-12-18  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR libffi/29152
+	PR libffi/42378
+	* src/powerpc/darwin_closure.S: Provide Darwin64 implementation,
+	update comments.
+	* src/powerpc/ffitarget.h (POWERPC_DARWIN64): New,
+	(FFI_TRAMPOLINE_SIZE): Update for Darwin64.
+	* src/powerpc/darwin.S: Provide Darwin64 implementation,
+	update comments.
+	* src/powerpc/ffi_darwin.c: Likewise.
+
+2010-12-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (libffi_cv_as_ascii_pseudo_op): Use double
+	backslashes.
+	(libffi_cv_as_string_pseudo_op): Likewise.
+	* configure: Regenerate.
+
+2010-12-03  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	* src/arm/sysv.S (ffi_closure_SYSV): Add UNWIND to .pad directive.
+	(ffi_closure_VFP): Same.
+	(ffi_call_VFP): Move down to before ffi_closure_VFP. Add '.fpu vfp'
+	directive.
+
+2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/ffitest.h [__sgi] (PRId64, PRIu64): Define.
+	(PRIuPTR): Define.
+
+2010-11-29  Richard Henderson  <rth@redhat.com>
+	    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* src/x86/sysv.S (FDE_ENCODING, FDE_ENCODE): Define.
+	(.eh_frame): Use FDE_ENCODING.
+	(.LASFDE1, .LASFDE2, LASFDE3): Simplify with FDE_ENCODE.
+
+2010-11-22  Jacek Caban <jacek@codeweavers.com>
+
+	* configure.ac: Check for symbol underscores on mingw-w64.
+	* configure: Rebuilt.
+	* src/x86/win64.S: Correctly access extern symbols in respect to
+	underscores.
+
+2010-11-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/lib/libffi-dg.exp: Rename ...
+	* testsuite/lib/libffi.exp: ... to this.
+	* libffi/testsuite/libffi.call/call.exp: Don't load libffi-dg.exp.
+	* libffi/testsuite/libffi.special/special.exp: Likewise.
+
+2010-10-28  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	* src/arm/ffi.c (ffi_prep_args): Add VFP register argument handling
+	code, new parameter, and return value. Update comments.
+	(ffi_prep_cif_machdep): Add case for VFP struct return values. Add
+	call to layout_vfp_args().
+	(ffi_call_SYSV): Update declaration.
+	(ffi_call_VFP): New declaration.
+	(ffi_call): Add VFP struct return conditions. Call ffi_call_VFP()
+	when ABI is FFI_VFP.
+	(ffi_closure_VFP): New declaration.
+	(ffi_closure_SYSV_inner): Add new vfp_args parameter, update call to
+	ffi_prep_incoming_args_SYSV().
+	(ffi_prep_incoming_args_SYSV): Update parameters. Add VFP argument
+	case handling.
+	(ffi_prep_closure_loc): Pass ffi_closure_VFP to trampoline
+	construction under VFP hard-float.
+	(rec_vfp_type_p): New function.
+	(vfp_type_p): Same.
+	(place_vfp_arg): Same.
+	(layout_vfp_args): Same.
+	* src/arm/ffitarget.h (ffi_abi): Add FFI_VFP. Define FFI_DEFAULT_ABI
+	based on __ARM_PCS_VFP.
+	(FFI_EXTRA_CIF_FIELDS): Define for adding VFP hard-float specific
+	fields.
+	(FFI_TYPE_STRUCT_VFP_FLOAT): Define internally used type code.
+	(FFI_TYPE_STRUCT_VFP_DOUBLE): Same.
+	* src/arm/sysv.S (ffi_call_SYSV): Change call of ffi_prep_args() to
+	direct call. Move function pointer load upwards.
+	(ffi_call_VFP): New function.
+	(ffi_closure_VFP): Same.
+
+	* testsuite/lib/libffi-dg.exp (check-flags): New function.
+	(dg-skip-if): New function.
+	* testsuite/libffi.call/cls_double_va.c: Skip if target is arm*-*-*
+	and compiler options include -mfloat-abi=hard.
+	* testsuite/libffi.call/cls_longdouble_va.c: Same.
+
+2010-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libffi/45677
+	* src/x86/ffi64.c (ffi_prep_cif_machdep): Ensure cif->bytes is
+	a multiple of 8.
+	* testsuite/libffi.call/many2.c: New test.
+
+2010-08-20  Mark Wielaard  <mjw@redhat.com>
+
+	* src/closures.c (open_temp_exec_file_mnt): Check if getmntent_r
+	returns NULL.
+
+2010-08-09  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure.ac: Add target powerpc64-*-freebsd*.
+	* configure: Regenerate.
+	* testsuite/libffi.call/cls_align_longdouble_split.c: Pass
+	-mlong-double-128 only to linux targets.
+	* testsuite/libffi.call/cls_align_longdouble_split2.c: Likewise.
+	* testsuite/libffi.call/cls_longdouble.c: Likewise.
+	* testsuite/libffi.call/huge_struct.c: Likewise.
+
+2010-08-05  Dan Witte  <dwitte@mozilla.com>
+
+        * Makefile.am: Pass FFI_DEBUG define to msvcc.sh for linking to the
+        debug CRT when --enable-debug is given.
+        * configure.ac: Define it.
+        * msvcc.sh: Translate -g and -DFFI_DEBUG appropriately.
+
+2010-08-04  Dan Witte  <dwitte@mozilla.com>
+
+	* src/x86/ffitarget.h: Add X86_ANY define for all x86/x86_64
+	platforms.
+	* src/x86/ffi.c: Remove redundant ifdef checks.
+	* src/prep_cif.c: Push stack space computation into src/x86/ffi.c
+	for X86_ANY so return value space doesn't get added twice.
+
+2010-08-03  Neil Rashbrooke <neil@parkwaycc.co.uk>
+
+	* msvcc.sh: Don't pass -safeseh to ml64 because behavior is buggy.
+
+2010-07-22  Dan Witte  <dwitte@mozilla.com>
+
+	* src/*/ffitarget.h: Make FFI_LAST_ABI one past the last valid ABI.
+	* src/prep_cif.c: Fix ABI assertion.
+        * src/cris/ffi.c: Ditto.
+
+2010-07-10  Evan Phoenix  <evan@fallingsnow.net>
+
+	* src/closures.c (selinux_enabled_check): Fix strncmp usage bug.
+
+2010-07-07  Dan Horák <dan@danny.cz>
+
+	* include/ffi.h.in: Protect #define with #ifndef.
+	* src/powerpc/ffitarget.h: Ditto.
+	* src/s390/ffitarget.h: Ditto.
+	* src/sparc/ffitarget.h: Ditto.
+
+2010-07-07   Neil Roberts <neil@linux.intel.com>
+
+	* src/x86/sysv.S (ffi_call_SYSV): Align the stack pointer to
+	16-bytes.
+
+2010-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* Makefile.am (AM_MAKEFLAGS): Pass also mandir to submakes.
+	* Makefile.in: Regenerated.
+
+2010-05-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (libffi_cv_as_x86_pcrel): Check for illegal in as
+	output, too.
+	(libffi_cv_as_ascii_pseudo_op): Check for .ascii.
+	(libffi_cv_as_string_pseudo_op): Check for .string.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* src/x86/sysv.S (.eh_frame): Use .ascii, .string or error.
+
+2010-05-11  Dan Witte  <dwitte@mozilla.com>
+
+	* doc/libffi.tex: Document previous change.
+
+2010-05-11  Makoto Kato <m_kato@ga2.so-net.ne.jp>
+
+	* src/x86/ffi.c (ffi_call): Don't copy structs passed by value.
+
+2010-05-05  Michael Kohler <michaelkohler@live.com>
+
+	* src/dlmalloc.c (dlfree): Fix spelling.
+	* src/ia64/ffi.c (ffi_prep_cif_machdep): Ditto.
+	* configure.ac: Ditto.
+	* configure: Rebuilt.
+
+2010-04-13  Dan Witte  <dwitte@mozilla.com>
+
+	* msvcc.sh: Build with -W3 instead of -Wall.
+	* src/powerpc/ffi_darwin.c: Remove build warnings.
+	* src/x86/ffi.c: Ditto.
+	* src/x86/ffitarget.h: Ditto.
+
+2010-04-12  Dan Witte  <dwitte@mozilla.com>
+	    Walter Meinl <wuno@lsvw.de>
+
+	* configure.ac: Add OS/2 support.
+	* configure: Rebuilt.
+	* src/closures.c: Ditto.
+	* src/dlmalloc.c: Ditto.
+	* src/x86/win32.S: Ditto.
+
+2010-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libffi.call/err_bad_abi.c: Remove unused args variable.
+
+2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in: Regenerate.
+	* aclocal.m4: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* man/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2010-03-30  Dan Witte  <dwitte@mozilla.com>
+
+	* msvcc.sh: Disable build warnings.
+	* README (tested): Clarify windows build procedure.
+
+2010-03-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (libffi_cv_as_x86_64_unwind_section_type): New test.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* libffi/src/x86/unix64.S (.eh_frame)
+	[HAVE_AS_X86_64_UNWIND_SECTION_TYPE]: Use @unwind section type.
+
+2010-03-14  Matthias Klose  <doko@ubuntu.com>
+
+	* src/x86/ffi64.c: Fix typo in comment.
+	* src/x86/ffi.c: Use /* ... */ comment style.
+
+2010-02-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* doc/libffi.texi (The Closure API): Fix typo.
+	* doc/libffi.info: Remove.
+
+2010-02-15  Matthias Klose  <doko@ubuntu.com>
+
+	* src/arm/sysv.S (__ARM_ARCH__): Define for processor
+	__ARM_ARCH_7EM__.
+
+2010-01-15  Anthony Green  <green@redhat.com>
+
+	* README: Add notes on building with Microsoft Visual C++.
+
+2010-01-15  Daniel Witte  <dwitte@mozilla.com>
+
+	* msvcc.sh: New file.
+
+	* src/x86/win32.S: Port assembly routines to MSVC and #ifdef.
+	* src/x86/ffi.c: Tweak function declaration and remove excess
+	parens.
+	* include/ffi.h.in: Add __declspec(align(8)) to typedef struct
+	ffi_closure.
+
+	* src/x86/ffi.c: Merge ffi_call_SYSV and ffi_call_STDCALL into new
+	function ffi_call_win32 on X86_WIN32.
+	* src/x86/win32.S (ffi_call_SYSV): Rename to ffi_call_win32.
+	(ffi_call_STDCALL): Remove.
+
+	* src/prep_cif.c (ffi_prep_cif): Move stack space allocation code
+	to ffi_prep_cif_machdep for x86.
+	* src/x86/ffi.c (ffi_prep_cif_machdep): To here.
+
+2010-01-15  Oliver Kiddle  <okiddle@yahoo.co.uk>
+
+	* src/x86/ffitarget.h (ffi_abi): Check for __i386 and __amd64 for
+	Sun Studio compiler compatibility.
+
+2010-01-12  Conrad Irwin <conrad.irwin@gmail.com>
+
+	* doc/libffi.texi: Add closure example.
+
+2010-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libffi/40701
+	* testsuite/libffi.call/ffitest.h [__alpha__ && __osf__] (PRIdLL,
+	PRIuLL, PRId64, PRIu64, PRIuPTR): Define.
+	* testsuite/libffi.call/cls_align_sint64.c: Add -Wno-format on
+	alpha*-dec-osf*.
+	* testsuite/libffi.call/cls_align_uint64.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/return_ll1.c: Likewise.
+	* testsuite/libffi.call/stret_medium2.c: Likewise.
+	* testsuite/libffi.special/ffitestcxx.h (allocate_mmap): Cast
+	MAP_FAILED to char *.
+
+2010-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* src/mips/n32.S: Use .abicalls and .eh_frame with __GNUC__.
+
+2009-12-31  Anthony Green  <green@redhat.com>
+
+	* README: Update for libffi 3.0.9.
+
+2009-12-27  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac (HAVE_LONG_DOUBLE): Define for mips when
+	appropriate.
+	* configure: Rebuilt.
+
+2009-12-26  Anthony Green  <green@redhat.com>
+
+	* testsuite/libffi.call/cls_longdouble_va.c: Mark as xfail for
+	avr32*-*-*.
+	* testsuite/libffi.call/cls_double_va.c: Ditto.
+
+2009-12-26  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* testsuite/libffi.call/ffitest.h: Conditionally include stdint.h
+	and inttypes.h.
+	* testsuite/libffi.special/unwindtest.cc: Ditto.
+
+2009-12-26  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Add amd64-*-openbsd*.
+	* configure: Rebuilt.
+	* testsuite/lib/libffi-dg.exp (libffi_target_compile): Link
+	openbsd programs with -lpthread.
+
+2009-12-26  Anthony Green  <green@redhat.com>
+
+	* testsuite/libffi.call/cls_double_va.c,
+	testsuite/libffi.call/cls_longdouble.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_pointer.c,
+	testsuite/libffi.call/cls_pointer_stack.c: Remove xfail for
+	mips*-*-* and arm*-*-*.
+	* testsuite/libffi.call/cls_align_longdouble_split.c,
+	testsuite/libffi.call/cls_align_longdouble_split2.c,
+	testsuite/libffi.call/stret_medium2.c,
+	testsuite/libffi.call/stret_medium.c,
+	testsuite/libffi.call/stret_large.c,
+	testsuite/libffi.call/stret_large2.c: Remove xfail for arm*-*-*.
+
+2009-12-31  Kay Tietz  <ktietz70@googlemail.com>
+
+	* testsuite/libffi.call/ffitest.h,
+	testsuite/libffi.special/ffitestcxx.h (PRIdLL, PRuLL): Fix
+	definitions.
+
+2009-12-31  Carlo Bramini  <carlo.bramix@libero.it>
+
+	* configure.ac (AM_LTLDFLAGS): Define for windows hosts.
+	* Makefile.am (libffi_la_LDFLAGS): Add AM_LTLDFLAGS.
+	* configure: Rebuilt.
+	* Makefile.in: Rebuilt.
+
+2009-12-31  Anthony Green  <green@redhat.com>
+	    Blake Chaffin.
+
+	* testsuite/libffi.call/huge_struct.c: New test case from Blake
+	Chaffin @ Apple.
+
+2009-12-28  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Copy abi and nargs to
+	local variables.
+	(aix_adjust_aggregate_sizes): New function.
+	(ffi_prep_cif_machdep): Call it.
+
+2009-12-26  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Define FFI_MMAP_EXEC_WRIT for the given targets.
+	* configure: Regenerate.
+	* fficonfig.h.in: Likewise.
+	* src/closures.c: Remove the FFI_MMAP_EXEC_WRIT definition for
+	Solaris/x86.
+
+2009-12-26  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Advance intarg_count
+	when a float arguments is passed in memory.
+	(ffi_closure_helper_SYSV): Mark general registers as used up when
+	a 64bit or soft-float long double argument is passed in memory.
+
+2009-12-25  Matthias Klose  <doko@ubuntu.com>
+
+	* man/ffi_call.3: Fix #include in examples.
+	* doc/libffi.texi: Add dircategory.
+
+2009-12-25  Frank Everdij <f.p.x.everdij@tudelft.nl>
+
+	* include/ffi.h.in: Placed '__GNUC__' ifdef around
+	'__attribute__((aligned(8)))' in ffi_closure, fixes compile for
+	IRIX MIPSPro c99.
+	* include/ffi_common.h: Added '__sgi' define to non
+	'__attribute__((__mode__()))' integer typedefs.
+	* src/mips/ffi.c (ffi_call, ffi_closure_mips_inner_O32,
+	ffi_closure_mips_inner_N32): Added 'defined(_MIPSEB)' to BE check.
+	(ffi_closure_mips_inner_O32, ffi_closure_mips_inner_N32): Added
+	FFI_LONGDOUBLE support and alignment(N32 only).
+	* src/mips/ffitarget.h: Corrected '#include <sgidefs.h>' for IRIX and
+	fixed non '__attribute__((__mode__()))' integer typedefs.
+	* src/mips/n32.S: Put '#ifdef linux' around '.abicalls' and '.eh_frame'
+	since they are Linux/GNU Assembler specific.
+
+2009-12-25  Bradley Smith  <brad@brad-smith.co.uk>
+
+	* configure.ac, Makefile.am, src/avr32/ffi.c,
+	src/avr32/ffitarget.h,
+	src/avr32/sysv.S: Add AVR32 port.
+	* configure, Makefile.in: Rebuilt.
+
+2009-12-21  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Make i?86 build on FreeBSD and OpenBSD.
+	* configure: Regenerate.
+
+2009-12-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* testsuite/libffi.call/ffitest.h: Define PRIuPTR on PA HP-UX.
+
+2009-12-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* src/pa/ffi.c (ffi_closure_inner_pa32): Handle FFI_TYPE_LONGDOUBLE
+	type on HP-UX.
+
+2012-02-13  Kai Tietz  <ktietz@redhat.com>
+
+	PR libffi/52221
+	* src/x86/ffi.c (ffi_prep_raw_closure_loc): Add thiscall
+	support for X86_WIN32.
+	(FFI_INIT_TRAMPOLINE_THISCALL): Fix displacement.
+
+2009-12-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* src/sparc/ffi.c (ffi_closure_sparc_inner_v9): Properly align 'long
+	double' arguments.
+
+2009-12-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* testsuite/libffi.call/ffitest.h: Define PRIuPTR on Solaris < 10.
+
+2009-12-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libffi/40700
+	* src/closures.c [X86_64 && __sun__ && __svr4__]
+	(FFI_MMAP_EXEC_WRIT): Define.
+
+2009-12-08  David Daney  <ddaney@caviumnetworks.com>
+
+	* testsuite/libffi.call/stret_medium.c: Remove xfail for mips*-*-*
+	* testsuite/libffi.call/cls_align_longdouble_split2.c: Same.
+	* testsuite/libffi.call/stret_large.c: Same.
+	* testsuite/libffi.call/cls_align_longdouble_split.c: Same.
+	* testsuite/libffi.call/stret_large2.c: Same.
+	* testsuite/libffi.call/stret_medium2.c: Same.
+
+2009-12-07  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/aix_closure.S (libffi_closure_ASM): Fix tablejump
+	typo.
+
+2009-12-05  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/aix.S: Update AIX32 code to be consistent with AIX64
+	code.
+	* src/powerpc/aix_closure.S: Same.
+
+2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* man/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2009-12-04  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/aix_closure.S: Reorganize 64-bit code to match
+	linux64_closure.S.
+
+2009-12-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR libffi/41908
+	* src/x86/ffi64.c (classify_argument): Update from
+	gcc/config/i386/i386.c.
+	(ffi_closure_unix64_inner): Do not use the address of two consecutive
+	SSE registers directly.
+	* testsuite/libffi.call/cls_dbls_struct.c (main): Remove xfail
+	for x86_64 linux targets.
+
+2009-12-04  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/ffi_darwin.c (ffi_closure_helper_DARWIN): Increment
+	pfr for long double split between fpr13 and stack.
+
+2009-12-03  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Increment next_arg and
+	fparg_count twice for long double.
+
+2009-12-03  David Edelsohn  <edelsohn@gnu.org>
+
+	PR libffi/42243
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Remove extra parentheses.
+
+2009-12-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* testsuite/libffi.call/cls_longdouble_va.c (main): Fix format string.
+	Remove xfails for x86 linux targets.
+
+2009-12-02  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Fix typo in INT64
+	case.
+
+2009-12-01  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/aix.S (ffi_call_AIX): Convert to more standard
+	register usage.  Call ffi_prep_args directly.  Add long double
+	return value support.
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Double arg increment
+	applies to FFI_TYPE_DOUBLE.  Correct fpr_base increment typo.
+	Separate FFI_TYPE_SINT32 and FFI_TYPE_UINT32 cases.
+	(ffi_prep_cif_machdep): Only 16 byte stack alignment in 64 bit
+	mode.
+	(ffi_closure_helper_DARWIN): Remove nf and ng counters.  Move temp
+	into case.
+	* src/powerpc/aix_closure.S: Maintain 16 byte stack alignment.
+	Allocate result area between params and FPRs.
+
+2009-11-30  David Edelsohn  <edelsohn@gnu.org>
+
+	PR target/35484
+	* src/powerpc/ffitarget.h (POWERPC64): Define for PPC64 Linux and
+	AIX64.
+	* src/powerpc/aix.S: Implement AIX64 version.
+	* src/powerpc/aix_closure.S: Implement AIX64 version.
+	(ffi_closure_ASM): Use extsb, lha and displament addresses.
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Implement AIX64
+	support.
+	(ffi_prep_cif_machdep): Same.
+	(ffi_call): Same.
+	(ffi_closure_helper_DARWIN): Same.
+
+2009-11-02  Andreas Tobler  <a.tobler@schweiz.org>
+
+	PR libffi/41908
+	* testsuite/libffi.call/testclosure.c: New test.
+
+2009-09-28  Kai Tietz  <kai.tietz@onevision.com>
+
+	* src/x86/win64.S (_ffi_call_win64 stack): Remove for gnu
+	assembly version use of ___chkstk.
+
+2009-09-23  Matthias Klose  <doko@ubuntu.com>
+
+	PR libffi/40242, PR libffi/41443
+	* src/arm/sysv.S (__ARM_ARCH__): Define for processors
+	__ARM_ARCH_6T2__, __ARM_ARCH_6M__, __ARM_ARCH_7__,
+	__ARM_ARCH_7A__, __ARM_ARCH_7R__, __ARM_ARCH_7M__.
+	Change the conditionals to __SOFTFP__ || __ARM_EABI__
+	for -mfloat-abi=softfp to work.
+
+2009-09-17  Loren J. Rittle  <ljrittle@acm.org>
+
+	PR testsuite/32843 (strikes again)
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Add X86_FREEBSD to
+	enable proper extension on char and short.
+
+2009-09-15  David Daney  <ddaney@caviumnetworks.com>
+
+	* src/java_raw_api.c (ffi_java_raw_to_rvalue): Remove special
+	handling for FFI_TYPE_POINTER.
+	* src/mips/ffitarget.h (FFI_TYPE_STRUCT_D_SOFT,
+	FFI_TYPE_STRUCT_F_SOFT, FFI_TYPE_STRUCT_DD_SOFT,
+	FFI_TYPE_STRUCT_FF_SOFT, FFI_TYPE_STRUCT_FD_SOFT,
+	FFI_TYPE_STRUCT_DF_SOFT, FFI_TYPE_STRUCT_SOFT): New defines.
+	(FFI_N32_SOFT_FLOAT, FFI_N64_SOFT_FLOAT): New ffi_abi enumerations.
+	(enum ffi_abi): Set FFI_DEFAULT_ABI for soft-float.
+	* src/mips/n32.S (ffi_call_N32): Add handling for soft-float
+	structure and pointer returns.
+	(ffi_closure_N32): Add handling for pointer returns.
+	* src/mips/ffi.c (ffi_prep_args, calc_n32_struct_flags,
+	calc_n32_return_struct_flags): Handle soft-float.
+	(ffi_prep_cif_machdep):  Handle soft-float, fix pointer handling.
+	(ffi_call_N32): Declare proper argument types.
+	(ffi_call, copy_struct_N32, ffi_closure_mips_inner_N32): Handle
+	soft-float.
+
+2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure.ac (AC_PREREQ): Bump to 2.64.
+
+2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.am (install-html, install-pdf): Remove.
+	* Makefile.in: Regenerate.
+
+	* Makefile.in: Regenerate.
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* man/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2011-08-22  Jasper Lievisse Adriaanse <jasper@openbsd.org>
+
+	* configure.ac: Add OpenBSD/hppa and OpenBSD/powerpc support.
+	* configure: Rebuilt.
+
+2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force.
+
+2009-07-24  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	PR libffi/40807
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Also use sign/zero-extending
+	return types for X86_WIN32.
+	* src/x86/win32.S (_ffi_call_SYSV): Handle omitted return types.
+	(_ffi_call_STDCALL, _ffi_closure_SYSV, _ffi_closure_raw_SYSV,
+	_ffi_closure_STDCALL): Likewise.
+
+	* src/closures.c (is_selinux_enabled): Define to const 0 for Cygwin.
+	(dlmmap, dlmunmap): Also use these functions on Cygwin.
+
+2009-07-11  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	PR testsuite/40699
+	PR testsuite/40707
+	PR testsuite/40709
+	* testsuite/lib/libffi-dg.exp: Revert 2009-07-02, 2009-07-01 and
+	2009-06-30 commits.
+
+2009-07-01  Richard Sandiford  <r.sandiford@uk.ibm.com>
+
+	* testsuite/lib/libffi-dg.exp (libffi-init): Set ld_library_path
+	to "" before adding paths.  (This reinstates an assignment that
+	was removed by my 2009-06-30 commit, but changes the initial
+	value from "." to "".)
+
+2009-07-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR testsuite/40601
+	* testsuite/lib/libffi-dg.exp (libffi-init): Properly set
+	gccdir.  Adjust ld_library_path for gcc only if gccdir isn't
+	empty.
+
+2009-06-30  Richard Sandiford  <r.sandiford@uk.ibm.com>
+
+	* testsuite/lib/libffi-dg.exp (libffi-init): Don't add "."
+	to ld_library_path.  Use add_path.  Add just find_libgcc_s
+	to ld_library_path, not every libgcc multilib directory.
+
+2009-06-16  Wim Lewis  <wiml@hhhh.org>
+
+	* src/powerpc/ffi.c: Avoid clobbering cr3 and cr4, which are
+	supposed to be callee-saved.
+	* src/powerpc/sysv.S (small_struct_return_value): Fix overrun of
+	return buffer for odd-size structs.
+
+2009-06-16  Andreas Tobler  <a.tobler@schweiz.org>
+
+	PR libffi/40444
+	* testsuite/lib/libffi-dg.exp (libffi_target_compile): Add
+	allow_stack_execute for Darwin.
+
+2009-06-16  Andrew Haley  <aph@redhat.com>
+
+	* configure.ac (TARGETDIR): Add missing blank lines.
+	* configure: Regenerate.
+
+2009-06-16  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/return_ll1.c,
+	testsuite/libffi.call/stret_medium2.c: Fix printf format
+	specifiers.
+	* testsuite/libffi.call/ffitest.h,
+	testsuite/libffi.special/ffitestcxx.h (PRIdLL, PRIuLL): Define.
+
+2009-06-15  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/err_bad_typedef.c: xfail everywhere.
+	* testsuite/libffi.call/err_bad_abi.c: Likewise.
+
+2009-06-12  Andrew Haley  <aph@redhat.com>
+
+	* Makefile.am: Remove info_TEXINFOS.
+
+2009-06-12  Andrew Haley  <aph@redhat.com>
+
+	* ChangeLog.libffi: testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/return_ll1.c,
+	testsuite/libffi.call/stret_medium2.c: Fix printf format
+	specifiers.
+	testsuite/libffi.special/unwindtest.cc: include stdint.h.
+
+2009-06-11  Timothy Wall  <twall@users.sf.net>
+
+	* Makefile.am,
+	configure.ac,
+	include/ffi.h.in,
+	include/ffi_common.h,
+	src/closures.c,
+	src/dlmalloc.c,
+	src/x86/ffi.c,
+	src/x86/ffitarget.h,
+	src/x86/win64.S (new),
+	README: Added win64 support (mingw or MSVC)
+	* Makefile.in,
+	include/Makefile.in,
+	man/Makefile.in,
+	testsuite/Makefile.in,
+	configure,
+	aclocal.m4: Regenerated
+	* ltcf-c.sh: properly escape cygwin/w32 path
+	* man/ffi_call.3: Clarify size requirements for return value.
+	* src/x86/ffi64.c: Fix filename in comment.
+	* src/x86/win32.S: Remove unused extern.
+
+	* testsuite/libffi.call/closure_fn0.c,
+	testsuite/libffi.call/closure_fn1.c,
+	testsuite/libffi.call/closure_fn2.c,
+	testsuite/libffi.call/closure_fn3.c,
+	testsuite/libffi.call/closure_fn4.c,
+	testsuite/libffi.call/closure_fn5.c,
+	testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/closure_stdcall.c,
+	testsuite/libffi.call/cls_12byte.c,
+	testsuite/libffi.call/cls_16byte.c,
+	testsuite/libffi.call/cls_18byte.c,
+	testsuite/libffi.call/cls_19byte.c,
+	testsuite/libffi.call/cls_1_1byte.c,
+	testsuite/libffi.call/cls_20byte.c,
+	testsuite/libffi.call/cls_20byte1.c,
+	testsuite/libffi.call/cls_24byte.c,
+	testsuite/libffi.call/cls_2byte.c,
+	testsuite/libffi.call/cls_3_1byte.c,
+	testsuite/libffi.call/cls_3byte1.c,
+ 	testsuite/libffi.call/cls_3byte2.c,
+ 	testsuite/libffi.call/cls_4_1byte.c,
+ 	testsuite/libffi.call/cls_4byte.c,
+ 	testsuite/libffi.call/cls_5_1_byte.c,
+ 	testsuite/libffi.call/cls_5byte.c,
+ 	testsuite/libffi.call/cls_64byte.c,
+ 	testsuite/libffi.call/cls_6_1_byte.c,
+ 	testsuite/libffi.call/cls_6byte.c,
+ 	testsuite/libffi.call/cls_7_1_byte.c,
+ 	testsuite/libffi.call/cls_7byte.c,
+ 	testsuite/libffi.call/cls_8byte.c,
+ 	testsuite/libffi.call/cls_9byte1.c,
+ 	testsuite/libffi.call/cls_9byte2.c,
+ 	testsuite/libffi.call/cls_align_double.c,
+ 	testsuite/libffi.call/cls_align_float.c,
+ 	testsuite/libffi.call/cls_align_longdouble.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split2.c,
+ 	testsuite/libffi.call/cls_align_pointer.c,
+ 	testsuite/libffi.call/cls_align_sint16.c,
+ 	testsuite/libffi.call/cls_align_sint32.c,
+ 	testsuite/libffi.call/cls_align_sint64.c,
+ 	testsuite/libffi.call/cls_align_uint16.c,
+ 	testsuite/libffi.call/cls_align_uint32.c,
+ 	testsuite/libffi.call/cls_align_uint64.c,
+ 	testsuite/libffi.call/cls_dbls_struct.c,
+ 	testsuite/libffi.call/cls_double.c,
+ 	testsuite/libffi.call/cls_double_va.c,
+ 	testsuite/libffi.call/cls_float.c,
+ 	testsuite/libffi.call/cls_longdouble.c,
+ 	testsuite/libffi.call/cls_longdouble_va.c,
+ 	testsuite/libffi.call/cls_multi_schar.c,
+ 	testsuite/libffi.call/cls_multi_sshort.c,
+ 	testsuite/libffi.call/cls_multi_sshortchar.c,
+ 	testsuite/libffi.call/cls_multi_uchar.c,
+ 	testsuite/libffi.call/cls_multi_ushort.c,
+ 	testsuite/libffi.call/cls_multi_ushortchar.c,
+ 	testsuite/libffi.call/cls_pointer.c,
+ 	testsuite/libffi.call/cls_pointer_stack.c,
+ 	testsuite/libffi.call/cls_schar.c,
+ 	testsuite/libffi.call/cls_sint.c,
+ 	testsuite/libffi.call/cls_sshort.c,
+ 	testsuite/libffi.call/cls_uchar.c,
+ 	testsuite/libffi.call/cls_uint.c,
+ 	testsuite/libffi.call/cls_ulonglong.c,
+ 	testsuite/libffi.call/cls_ushort.c,
+ 	testsuite/libffi.call/err_bad_abi.c,
+ 	testsuite/libffi.call/err_bad_typedef.c,
+ 	testsuite/libffi.call/float2.c,
+ 	testsuite/libffi.call/huge_struct.c,
+ 	testsuite/libffi.call/nested_struct.c,
+ 	testsuite/libffi.call/nested_struct1.c,
+ 	testsuite/libffi.call/nested_struct10.c,
+ 	testsuite/libffi.call/nested_struct2.c,
+ 	testsuite/libffi.call/nested_struct3.c,
+ 	testsuite/libffi.call/nested_struct4.c,
+ 	testsuite/libffi.call/nested_struct5.c,
+ 	testsuite/libffi.call/nested_struct6.c,
+ 	testsuite/libffi.call/nested_struct7.c,
+ 	testsuite/libffi.call/nested_struct8.c,
+ 	testsuite/libffi.call/nested_struct9.c,
+ 	testsuite/libffi.call/problem1.c,
+ 	testsuite/libffi.call/return_ldl.c,
+ 	testsuite/libffi.call/return_ll1.c,
+ 	testsuite/libffi.call/stret_large.c,
+ 	testsuite/libffi.call/stret_large2.c,
+ 	testsuite/libffi.call/stret_medium.c,
+ 	testsuite/libffi.call/stret_medium2.c,
+	testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead
+	of checking for MMAP.  Use intptr_t instead of long casts.
+
+2009-06-11  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* testsuite/libffi.call/cls_longdouble_va.c: Add xfail sh*-*-linux-*.
+	* testsuite/libffi.call/err_bad_abi.c: Add xfail sh*-*-*.
+	* testsuite/libffi.call/err_bad_typedef.c: Likewise.
+
+2009-06-09  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/freebsd.S: Add missing file.
+
+2009-06-08  Andrew Haley  <aph@redhat.com>
+
+	Import from libffi 3.0.8:
+
+	* doc/libffi.texi: New file.
+	* doc/libffi.info: Likewise.
+	* doc/stamp-vti: Likewise.
+	* man/Makefile.am: New file.
+	* man/ffi_call.3: New file.
+
+	* Makefile.am (EXTRA_DIST): Add src/x86/darwin64.S,
+	src/dlmalloc.c.
+	(nodist_libffi_la_SOURCES): Add X86_FREEBSD.
+
+	* configure.ac: Bump version to 3.0.8.
+	parisc*-*-linux*: Add.
+	i386-*-freebsd* | i386-*-openbsd*: Add.
+	powerpc-*-beos*: Add.
+	AM_CONDITIONAL X86_FREEBSD: Add.
+	AC_CONFIG_FILES: Add man/Makefile.
+
+	* include/ffi.h.in (FFI_FN): Change void (*)() to void (*)(void).
+
+2009-06-08  Andrew Haley  <aph@redhat.com>
+
+	* README: Import from libffi 3.0.8.
+
+2009-06-08  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/err_bad_abi.c: Add xfails.
+	* testsuite/libffi.call/cls_longdouble_va.c: Add xfails.
+	* testsuite/libffi.call/cls_dbls_struct.c: Add xfail x86_64-*-linux-*.
+	* testsuite/libffi.call/err_bad_typedef.c: Add xfails.
+
+	* testsuite/libffi.call/stret_medium2.c: Add __UNUSED__ to args.
+	* testsuite/libffi.call/stret_medium.c: Likewise.
+	* testsuite/libffi.call/stret_large2.c: Likewise.
+	* testsuite/libffi.call/stret_large.c:  Likewise.
+
+2008-12-26  Timothy Wall  <twall@users.sf.net>
+
+	* testsuite/libffi.call/cls_longdouble.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_align_longdouble.c,
+	testsuite/libffi.call/cls_align_longdouble_split.c,
+	testsuite/libffi.call/cls_align_longdouble_split2.c: mark expected
+	failures on x86_64 cygwin/mingw.
+
+2008-12-22  Timothy Wall  <twall@users.sf.net>
+
+	* testsuite/libffi.call/closure_fn0.c,
+	testsuite/libffi.call/closure_fn1.c,
+	testsuite/libffi.call/closure_fn2.c,
+	testsuite/libffi.call/closure_fn3.c,
+	testsuite/libffi.call/closure_fn4.c,
+	testsuite/libffi.call/closure_fn5.c,
+	testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/closure_loc_fn0.c,
+	testsuite/libffi.call/closure_stdcall.c,
+	testsuite/libffi.call/cls_align_pointer.c,
+	testsuite/libffi.call/cls_pointer.c,
+	testsuite/libffi.call/cls_pointer_stack.c: use portable cast from
+	pointer to integer (intptr_t).
+	* testsuite/libffi.call/cls_longdouble.c: disable for win64.
+
+2008-07-24  Anthony Green  <green@redhat.com>
+
+	* testsuite/libffi.call/cls_dbls_struct.c,
+	testsuite/libffi.call/cls_double_va.c,
+	testsuite/libffi.call/cls_longdouble.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_pointer.c,
+	testsuite/libffi.call/cls_pointer_stack.c,
+	testsuite/libffi.call/err_bad_abi.c: Clean up failures from
+	compiler warnings.
+
+2008-03-04  Anthony Green  <green@redhat.com>
+	    Blake Chaffin
+	    hos@tamanegi.org
+
+	* testsuite/libffi.call/cls_align_longdouble_split2.c
+	  testsuite/libffi.call/cls_align_longdouble_split.c
+	  testsuite/libffi.call/cls_dbls_struct.c
+	  testsuite/libffi.call/cls_double_va.c
+	  testsuite/libffi.call/cls_longdouble.c
+	  testsuite/libffi.call/cls_longdouble_va.c
+	  testsuite/libffi.call/cls_pointer.c
+	  testsuite/libffi.call/cls_pointer_stack.c
+	  testsuite/libffi.call/err_bad_abi.c
+	  testsuite/libffi.call/err_bad_typedef.c
+	  testsuite/libffi.call/stret_large2.c
+	  testsuite/libffi.call/stret_large.c
+	  testsuite/libffi.call/stret_medium2.c
+	  testsuite/libffi.call/stret_medium.c: New tests from Apple.
+
+2009-06-05  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/ffitarget.h, src/x86/ffi.c: Merge stdcall changes from
+	libffi.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/ffitarget.h, src/x86/win32.S, src/x86/ffi.c: Back out
+	stdcall changes.
+
+2008-02-26  Anthony Green  <green@redhat.com>
+	    Thomas Heller  <theller@ctypes.org>
+
+	* src/x86/ffi.c (ffi_closure_SYSV_inner): Change C++ comment to C
+	comment.
+
+2008-02-03  Timothy Wall  <twall@users.sf.net>
+
+	* src/x86/ffi.c (FFI_INIT_TRAMPOLINE_STDCALL): Calculate jump return
+	  offset based on code pointer, not data pointer.
+
+2008-01-31  Timothy Wall <twall@users.sf.net>
+
+	* testsuite/libffi.call/closure_stdcall.c: Add test for stdcall
+	closures.
+	* src/x86/ffitarget.h: Increase size of trampoline for stdcall
+	closures.
+	* src/x86/win32.S: Add assembly for stdcall closure.
+	* src/x86/ffi.c: Initialize stdcall closure trampoline.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* include/ffi.h.in: Change void (*)() to void (*)(void).
+	* src/x86/ffi.c: Likewise.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/powerpc/ppc_closure.S: Insert licence header.
+	* src/powerpc/linux64_closure.S: Likewise.
+	* src/m68k/sysv.S: Likewise.
+
+	* src/sh64/ffi.c: Change void (*)() to void (*)(void).
+	* src/powerpc/ffi.c: Likewise.
+	* src/powerpc/ffi_darwin.c: Likewise.
+	* src/m32r/ffi.c: Likewise.
+	* src/sh64/ffi.c: Likewise.
+	* src/x86/ffi64.c: Likewise.
+	* src/alpha/ffi.c: Likewise.
+	* src/alpha/osf.S: Likewise.
+	* src/frv/ffi.c: Likewise.
+	* src/s390/ffi.c: Likewise.
+	* src/pa/ffi.c: Likewise.
+	* src/pa/hpux32.S: Likewise.
+	* src/ia64/unix.S: Likewise.
+	* src/ia64/ffi.c: Likewise.
+	* src/sparc/ffi.c: Likewise.
+	* src/mips/ffi.c: Likewise.
+	* src/sh/ffi.c: Likewise.
+
+2008-02-15  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/ffi.c (USE__BUILTIN___CLEAR_CACHE):
+	Define (conditionally), and use it to include cachectl.h.
+	(ffi_prep_closure_loc): Fix cache flushing.
+	* src/mips/ffitarget.h (_ABIN32, _ABI64, _ABIO32): Define.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	include/ffi.h.in,
+	src/arm/ffitarget.h,
+	src/arm/ffi.c,
+	src/arm/sysv.S,
+	src/powerpc/ffitarget.h,
+	src/closures.c,
+	src/sh64/ffitarget.h,
+	src/sh64/ffi.c,
+	src/sh64/sysv.S,
+	src/types.c,
+	src/x86/ffi64.c,
+	src/x86/ffitarget.h,
+	src/x86/win32.S,
+	src/x86/darwin.S,
+	src/x86/ffi.c,
+	src/x86/sysv.S,
+	src/x86/unix64.S,
+	src/alpha/ffitarget.h,
+	src/alpha/ffi.c,
+	src/alpha/osf.S,
+	src/m68k/ffitarget.h,
+	src/frv/ffitarget.h,
+	src/frv/ffi.c,
+	src/s390/ffitarget.h,
+	src/s390/sysv.S,
+	src/cris/ffitarget.h,
+	src/pa/linux.S,
+	src/pa/ffitarget.h,
+	src/pa/ffi.c,
+	src/raw_api.c,
+	src/ia64/ffitarget.h,
+	src/ia64/unix.S,
+	src/ia64/ffi.c,
+	src/ia64/ia64_flags.h,
+	src/java_raw_api.c,
+	src/debug.c,
+	src/sparc/v9.S,
+	src/sparc/ffitarget.h,
+	src/sparc/ffi.c,
+	src/sparc/v8.S,
+	src/mips/ffitarget.h,
+	src/mips/n32.S,
+	src/mips/o32.S,
+	src/mips/ffi.c,
+	src/prep_cif.c,
+	src/sh/ffitarget.h,
+	src/sh/ffi.c,
+	src/sh/sysv.S: Update license text.
+
+2009-05-22  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	* src/x86/win32.S (_ffi_closure_STDCALL):  New function.
+	(.eh_frame):  Add FDE for it.
+
+2009-05-22  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	* configure.ac:  Also check if assembler supports pc-relative
+	relocs on X86_WIN32 targets.
+	* configure:  Regenerate.
+	* src/x86/win32.S (ffi_prep_args):  Declare extern, not global.
+	(_ffi_call_SYSV):  Add missing function type symbol .def and
+	add EH markup labels.
+	(_ffi_call_STDCALL):  Likewise.
+	(_ffi_closure_SYSV):  Likewise.
+	(_ffi_closure_raw_SYSV):  Likewise.
+	(.eh_frame):  Add hand-crafted EH data.
+
+2009-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/lib/libffi-dg.exp: Change copyright header to refer to
+	version 3 of the GNU General Public License and to point readers
+	at the COPYING3 file and the FSF's license web page.
+	* testsuite/libffi.call/call.exp: Likewise.
+	* testsuite/libffi.special/special.exp: Likewise.
+
+2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure: Regenerate.
+
+2008-12-18  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR libffi/26048
+	* configure.ac (HAVE_AS_X86_PCREL): New test.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* src/x86/sysv.S [!FFI_NO_RAW_API]: Precalculate
+	RAW_CLOSURE_CIF_OFFSET, RAW_CLOSURE_FUN_OFFSET,
+	RAW_CLOSURE_USER_DATA_OFFSET for the Solaris 10/x86 assembler.
+	(.eh_frame): Only use SYMBOL-. iff HAVE_AS_X86_PCREL.
+	* src/x86/unix64.S (.Lstore_table): Move to .text section.
+	(.Lload_table): Likewise.
+	(.eh_frame): Only use SYMBOL-. iff HAVE_AS_X86_PCREL.
+
+2008-12-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure: Regenerate.
+
+2008-11-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* src/sparc/ffi.c (ffi_prep_cif_machdep): Add support for
+	signed/unsigned int8/16 return values.
+	* src/sparc/v8.S (ffi_call_v8): Likewise.
+	(ffi_closure_v8): Likewise.
+
+2008-09-26  Peter O'Gorman  <pogma@thewrittenword.com>
+	    Steve Ellcey  <sje@cup.hp.com>
+
+	* configure: Regenerate for new libtool.
+	* Makefile.in: Ditto.
+	* include/Makefile.in: Ditto.
+	* aclocal.m4: Ditto.
+
+2008-08-25  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* src/powerpc/ffitarget.h (ffi_abi): Add FFI_LINUX and
+	FFI_LINUX_SOFT_FLOAT to the POWERPC_FREEBSD enum.
+	Add note about flag bits used for FFI_SYSV_TYPE_SMALL_STRUCT.
+	Adjust copyright notice.
+	* src/powerpc/ffi.c: Add two new flags to indicate if we have one
+	register or two register to use for FFI_SYSV structs.
+	(ffi_prep_cif_machdep): Pass the right register flag introduced above.
+	(ffi_closure_helper_SYSV): Fix the return type for
+	FFI_SYSV_TYPE_SMALL_STRUCT. Comment.
+	Adjust copyright notice.
+
+2008-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_prep_closure_loc): Turn INSN into an unsigned
+	int.
+
+2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* configure: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2008-06-07  Joseph Myers  <joseph@codesourcery.com>
+
+	* configure.ac (parisc*-*-linux*, powerpc-*-sysv*,
+	powerpc-*-beos*): Remove.
+	* configure: Regenerate.
+
+2008-05-09  Julian Brown  <julian@codesourcery.com>
+
+	* Makefile.am (LTLDFLAGS): New.
+	(libffi_la_LDFLAGS): Use above.
+	* Makefile.in: Regenerate.
+
+2008-04-18  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/35457
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+
+2008-03-26  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/sysv.S: Add .note.GNU-stack on Linux.
+	* src/sh64/sysv.S: Likewise.
+
+2008-03-26  Daniel Jacobowitz  <dan@debian.org>
+
+	* src/arm/sysv.S: Fix ARM comment marker.
+
+2008-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/alpha/osf.S: Add .note.GNU-stack on Linux.
+	* src/s390/sysv.S: Likewise.
+	* src/powerpc/ppc_closure.S: Likewise.
+	* src/powerpc/sysv.S: Likewise.
+	* src/x86/unix64.S: Likewise.
+	* src/x86/sysv.S: Likewise.
+	* src/sparc/v8.S: Likewise.
+	* src/sparc/v9.S: Likewise.
+	* src/m68k/sysv.S: Likewise.
+	* src/arm/sysv.S: Likewise.
+
+2008-03-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* aclocal.m4: Regenerate.
+	* configure: Likewise.
+	* Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2008-02-12  Bjoern Koenig  <bkoenig@alpha-tierchen.de>
+	    Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Add amd64-*-freebsd* target.
+	* configure: Regenerate.
+
+2008-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libffi/34612
+	* src/x86/sysv.S (ffi_closure_SYSV): Pop 4 byte from stack when
+	returning struct.
+
+	* testsuite/libffi.call/call.exp: Add "-O2 -fomit-frame-pointer"
+	tests.
+
+2008-01-24  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure: Regenerate.
+
+2008-01-06  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Fix thinko.
+
+2008-01-05  Andreas Tobler  <a.tobler@schweiz.org>
+
+	PR testsuite/32843
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Add code for
+	signed/unsigned int8/16 for X86_DARWIN.
+	Updated copyright info.
+	Handle one and two byte structs with special cif->flags.
+	* src/x86/ffitarget.h: Add special types for one and two byte structs.
+	Updated copyright info.
+	* src/x86/darwin.S (ffi_call_SYSV): Rewrite to use a jump table like
+	sysv.S
+	Remove code to pop args from the stack after call.
+	Special-case signed/unsigned for int8/16, one and two byte structs.
+	(ffi_closure_raw_SYSV): Handle FFI_TYPE_UINT8,
+	FFI_TYPE_SINT8, FFI_TYPE_UINT16, FFI_TYPE_SINT16, FFI_TYPE_UINT32,
+	FFI_TYPE_SINT32.
+	Updated copyright info.
+
+2007-12-08  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/n32.S (ffi_call_N32):  Replace dadd with ADDU, dsub with
+	SUBU, add with ADDU and use smaller code sequences.
+
+2007-12-07  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/ffi.c (ffi_prep_cif_machdep): Handle long double return
+	type.
+
+2007-12-06  David Daney  <ddaney@avtrex.com>
+
+	* include/ffi.h.in (FFI_SIZEOF_JAVA_RAW): Define if not	already
+	defined.
+	(ffi_java_raw): New typedef.
+	(ffi_java_raw_call, ffi_java_ptrarray_to_raw,
+	ffi_java_raw_to_ptrarray): Change parameter types from ffi_raw to
+	ffi_java_raw.
+	(ffi_java_raw_closure) : Same.
+	(ffi_prep_java_raw_closure, ffi_prep_java_raw_closure_loc): Change
+	parameter types.
+	* src/java_raw_api.c (ffi_java_raw_size):  Replace FFI_SIZEOF_ARG with
+	FFI_SIZEOF_JAVA_RAW.
+	(ffi_java_raw_to_ptrarray): Change type of raw to ffi_java_raw.
+	Replace FFI_SIZEOF_ARG with FFI_SIZEOF_JAVA_RAW. Use
+	sizeof(ffi_java_raw) for alignment calculations.
+	(ffi_java_ptrarray_to_raw): Same.
+	(ffi_java_rvalue_to_raw): Add special handling for FFI_TYPE_POINTER
+	if FFI_SIZEOF_JAVA_RAW == 4.
+	(ffi_java_raw_to_rvalue): Same.
+	(ffi_java_raw_call): Change type of raw to ffi_java_raw.
+	(ffi_java_translate_args): Same.
+	(ffi_prep_java_raw_closure_loc, ffi_prep_java_raw_closure): Change
+	parameter types.
+	* src/mips/ffitarget.h (FFI_SIZEOF_JAVA_RAW): Define for N32 ABI.
+
+2007-12-06  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/n32.S (ffi_closure_N32): Use 64-bit add instruction on
+	pointer values.
+
+2007-12-01  Andreas Tobler  <a.tobler@schweiz.org>
+
+	PR libffi/31937
+	* src/powerpc/ffitarget.h: Introduce new ABI FFI_LINUX_SOFT_FLOAT.
+	Add local FFI_TYPE_UINT128 to handle soft-float long-double-128.
+	* src/powerpc/ffi.c: Distinguish between __NO_FPRS__ and not and
+	set the NUM_FPR_ARG_REGISTERS according to.
+	Add support for potential soft-float support under hard-float
+	architecture.
+	(ffi_prep_args_SYSV): Set NUM_FPR_ARG_REGISTERS to 0 in case of
+	FFI_LINUX_SOFT_FLOAT, handle float, doubles and long-doubles according
+	to the FFI_LINUX_SOFT_FLOAT ABI.
+	(ffi_prep_cif_machdep): Likewise.
+	(ffi_closure_helper_SYSV): Likewise.
+	* src/powerpc/ppc_closure.S: Make sure not to store float/double
+	on archs where __NO_FPRS__ is true.
+	Add FFI_TYPE_UINT128 support.
+	* src/powerpc/sysv.S: Add support for soft-float long-double-128.
+	Adjust copyright notice.
+
+2007-11-25  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* src/closures.c: Move defintion of MAYBE_UNUSED from here to ...
+	* include/ffi_common.h: ... here.
+	Update copyright.
+
+2007-11-17  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* src/powerpc/sysv.S: Load correct cr to compare if we have long double.
+	* src/powerpc/linux64.S: Likewise.
+	* src/powerpc/ffi.c: Add a comment to show which part goes into cr6.
+	* testsuite/libffi.call/return_ldl.c: New test.
+
+2007-09-04    <aph@redhat.com>
+
+	* src/arm/sysv.S (UNWIND): New.
+	(Whole file): Conditionally compile unwinder directives.
+	* src/arm/sysv.S: Add unwinder directives.
+
+	* src/arm/ffi.c (ffi_prep_args): Align structs by at least 4 bytes.
+	Only treat r0 as a struct address if we're actually returning a
+	struct by address.
+	Only copy the bytes that are actually within a struct.
+	(ffi_prep_cif_machdep): A Composite Type not larger than 4 bytes
+	is returned in r0, not passed by address.
+	(ffi_call): Allocate a word-sized temporary for the case where
+	a composite is returned in r0.
+	(ffi_prep_incoming_args_SYSV): Align as necessary.
+
+2007-08-05  Steven Newbury  <s_j_newbury@yahoo.co.uk>
+
+	* src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Use __clear_cache instead of
+	directly using the sys_cacheflush syscall.
+
+2007-07-27  Andrew Haley  <aph@redhat.com>
+
+	* src/arm/sysv.S (ffi_closure_SYSV): Add soft-float.
+
+2007-09-03  Maciej W. Rozycki  <macro@linux-mips.org>
+
+	* Makefile.am: Unify MIPS_IRIX and MIPS_LINUX into MIPS.
+	* configure.ac: Likewise.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+	* configure: Likewise.
+
+2007-08-24  David Daney  <ddaney@avtrex.com>
+
+	* testsuite/libffi.call/return_sl.c: New test.
+
+2007-08-10  David Daney  <ddaney@avtrex.com>
+
+	* testsuite/libffi.call/cls_multi_ushort.c,
+	testsuite/libffi.call/cls_align_uint16.c,
+	testsuite/libffi.call/nested_struct1.c,
+	testsuite/libffi.call/nested_struct3.c,
+	testsuite/libffi.call/cls_7_1_byte.c,
+	testsuite/libffi.call/nested_struct5.c,
+	testsuite/libffi.call/cls_double.c,
+	testsuite/libffi.call/nested_struct7.c,
+	testsuite/libffi.call/cls_sint.c,
+	testsuite/libffi.call/nested_struct9.c,
+	testsuite/libffi.call/cls_20byte1.c,
+	testsuite/libffi.call/cls_multi_sshortchar.c,
+	testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_3byte2.c,
+	testsuite/libffi.call/cls_multi_schar.c,
+	testsuite/libffi.call/cls_multi_uchar.c,
+	testsuite/libffi.call/cls_19byte.c,
+	testsuite/libffi.call/cls_9byte1.c,
+	testsuite/libffi.call/cls_align_float.c,
+	testsuite/libffi.call/closure_fn1.c,
+	testsuite/libffi.call/problem1.c,
+	testsuite/libffi.call/closure_fn3.c,
+	testsuite/libffi.call/cls_sshort.c,
+	testsuite/libffi.call/closure_fn5.c,
+	testsuite/libffi.call/cls_align_double.c,
+	testsuite/libffi.call/nested_struct.c,
+	testsuite/libffi.call/cls_2byte.c,
+	testsuite/libffi.call/nested_struct10.c,
+	testsuite/libffi.call/cls_4byte.c,
+	testsuite/libffi.call/cls_6byte.c,
+	testsuite/libffi.call/cls_8byte.c,
+	testsuite/libffi.call/cls_multi_sshort.c,
+	testsuite/libffi.call/cls_align_sint16.c,
+	testsuite/libffi.call/cls_align_uint32.c,
+	testsuite/libffi.call/cls_20byte.c,
+	testsuite/libffi.call/cls_float.c,
+	testsuite/libffi.call/nested_struct2.c,
+	testsuite/libffi.call/cls_5_1_byte.c,
+	testsuite/libffi.call/nested_struct4.c,
+	testsuite/libffi.call/cls_24byte.c,
+	testsuite/libffi.call/nested_struct6.c,
+	testsuite/libffi.call/cls_64byte.c,
+	testsuite/libffi.call/nested_struct8.c,
+	testsuite/libffi.call/cls_uint.c,
+	testsuite/libffi.call/cls_multi_ushortchar.c,
+	testsuite/libffi.call/cls_schar.c,
+	testsuite/libffi.call/cls_uchar.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/cls_align_longdouble.c,
+	testsuite/libffi.call/cls_1_1byte.c,
+	testsuite/libffi.call/cls_12byte.c,
+	testsuite/libffi.call/cls_3_1byte.c,
+	testsuite/libffi.call/cls_3byte1.c,
+	testsuite/libffi.call/cls_4_1byte.c,
+	testsuite/libffi.call/cls_6_1_byte.c,
+	testsuite/libffi.call/cls_16byte.c,
+	testsuite/libffi.call/cls_18byte.c,
+	testsuite/libffi.call/closure_fn0.c,
+	testsuite/libffi.call/cls_9byte2.c,
+	testsuite/libffi.call/closure_fn2.c,
+	testsuite/libffi.call/closure_fn4.c,
+	testsuite/libffi.call/cls_ushort.c,
+	testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/cls_5byte.c,
+	testsuite/libffi.call/cls_align_pointer.c,
+	testsuite/libffi.call/cls_7byte.c,
+	testsuite/libffi.call/cls_align_sint32.c,
+	testsuite/libffi.special/unwindtest_ffi_call.cc,
+	testsuite/libffi.special/unwindtest.cc: Remove xfail for mips64*-*-*.
+
+2007-08-10  David Daney  <ddaney@avtrex.com>
+
+	PR libffi/28313
+	* configure.ac: Don't treat mips64 as a special case.
+	* Makefile.am (nodist_libffi_la_SOURCES): Add n32.S.
+	* configure: Regenerate
+	* Makefile.in: Ditto.
+	* fficonfig.h.in: Ditto.
+	* src/mips/ffitarget.h (REG_L, REG_S, SUBU, ADDU, SRL, LI): Indent.
+	(LA, EH_FRAME_ALIGN, FDE_ADDR_BYTES): New preprocessor macros.
+	(FFI_DEFAULT_ABI): Set for n64 case.
+	(FFI_CLOSURES, FFI_TRAMPOLINE_SIZE): Define for n32 and n64 cases.
+	* src/mips/n32.S (ffi_call_N32): Add debug macros and labels for FDE.
+	(ffi_closure_N32): New function.
+	(.eh_frame): New section
+	* src/mips/o32.S: Clean up comments.
+	(ffi_closure_O32): Pass ffi_closure parameter in $12.
+	* src/mips/ffi.c: Use FFI_MIPS_N32 instead of
+	_MIPS_SIM == _ABIN32 throughout.
+	(FFI_MIPS_STOP_HERE): New, use in place of
+	ffi_stop_here.
+	(ffi_prep_args): Use unsigned long to hold pointer values.  Rewrite
+	to support n32/n64 ABIs.
+	(calc_n32_struct_flags): Rewrite.
+	(calc_n32_return_struct_flags): Remove unused variable.  Reverse
+	position of flag bits.
+	(ffi_prep_cif_machdep): Rewrite n32 portion.
+	(ffi_call): Enable for n64.  Add special handling for small structure
+	return values.
+	(ffi_prep_closure_loc): Add n32 and n64 support.
+	(ffi_closure_mips_inner_O32): Add cast to silence warning.
+	(copy_struct_N32, ffi_closure_mips_inner_N32): New functions.
+
+2007-08-08  David Daney  <ddaney@avtrex.com>
+
+	* testsuite/libffi.call/ffitest.h (ffi_type_mylong): Remove definition.
+	* testsuite/libffi.call/cls_align_uint16.c (main): Use correct type
+	specifiers.
+	* testsuite/libffi.call/nested_struct1.c (main): Ditto.
+	* testsuite/libffi.call/cls_sint.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct9.c (main): Ditto.
+	* testsuite/libffi.call/cls_20byte1.c (main): Ditto.
+	* testsuite/libffi.call/cls_9byte1.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn1.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn3.c (main): Ditto.
+	* testsuite/libffi.call/return_dbl2.c (main): Ditto.
+	* testsuite/libffi.call/cls_sshort.c (main): Ditto.
+	* testsuite/libffi.call/return_fl3.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn5.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct10.c (main): Ditto.
+	* testsuite/libffi.call/return_ll1.c (main): Ditto.
+	* testsuite/libffi.call/cls_8byte.c (main): Ditto.
+	* testsuite/libffi.call/cls_align_uint32.c (main): Ditto.
+	* testsuite/libffi.call/cls_align_sint16.c (main): Ditto.
+	* testsuite/libffi.call/cls_20byte.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct2.c (main): Ditto.
+	* testsuite/libffi.call/cls_24byte.c (main): Ditto.
+	* testsuite/libffi.call/nested_struct6.c (main): Ditto.
+	* testsuite/libffi.call/cls_uint.c (main): Ditto.
+	* testsuite/libffi.call/cls_12byte.c (main): Ditto.
+	* testsuite/libffi.call/cls_16byte.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn0.c (main): Ditto.
+	* testsuite/libffi.call/cls_9byte2.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn2.c (main): Ditto.
+	* testsuite/libffi.call/return_dbl1.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn4.c (main): Ditto.
+	* testsuite/libffi.call/closure_fn6.c (main): Ditto.
+	* testsuite/libffi.call/cls_align_sint32.c (main): Ditto.
+
+2007-08-07  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/sysv.S (ffi_closure_raw_SYSV): Fix typo in previous
+	checkin.
+
+2007-08-06  Andrew Haley  <aph@redhat.com>
+
+	PR testsuite/32843
+	* src/x86/sysv.S (ffi_closure_raw_SYSV): Handle FFI_TYPE_UINT8,
+	FFI_TYPE_SINT8, FFI_TYPE_UINT16, FFI_TYPE_SINT16, FFI_TYPE_UINT32,
+	FFI_TYPE_SINT32.
+
+2007-08-02  David Daney  <ddaney@avtrex.com>
+
+	* testsuite/libffi.call/return_ul.c (main): Define return type as
+	ffi_arg.  Use proper printf conversion specifier.
+
+2007-07-30  Andrew Haley  <aph@redhat.com>
+
+	PR testsuite/32843
+	* src/x86/ffi.c (ffi_prep_cif_machdep): in x86 case, add code for
+	signed/unsigned int8/16.
+	* src/x86/sysv.S (ffi_call_SYSV): Rewrite to:
+	Use a jump table.
+	Remove code to pop args from the stack after call.
+	Special-case signed/unsigned int8/16.
+	* testsuite/libffi.call/return_sc.c (main): Revert.
+
+2007-07-26  Richard Guenther  <rguenther@suse.de>
+
+	PR testsuite/32843
+	* testsuite/libffi.call/return_sc.c (main): Verify call
+	result as signed char, not ffi_arg.
+
+2007-07-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.ac (i?86-*-solaris2.1[0-9]): Set TARGET to X86_64.
+	* configure: Regenerate.
+
+2007-07-11  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/ffi.c: Don't include sys/cachectl.h.
+	(ffi_prep_closure_loc): Use __builtin___clear_cache() instead of
+	cacheflush().
+
+2007-05-18  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* src/arm/ffi.c (ffi_prep_closure_loc): Renamed and ajusted
+	from (ffi_prep_closure): ... this.
+	(FFI_INIT_TRAMPOLINE): Adjust.
+
+2005-12-31  Phil Blundell  <pb@reciva.com>
+
+	* src/arm/ffi.c (ffi_prep_incoming_args_SYSV,
+	ffi_closure_SYSV_inner, ffi_prep_closure): New, add closure support.
+	* src/arm/sysv.S(ffi_closure_SYSV): Likewise.
+	* src/arm/ffitarget.h (FFI_TRAMPOLINE_SIZE): Likewise.
+	(FFI_CLOSURES): Enable closure support.
+
+2007-07-03  Andrew Haley  <aph@hedges.billgatliff.com>
+
+	* testsuite/libffi.call/cls_multi_ushort.c,
+	testsuite/libffi.call/cls_align_uint16.c,
+	testsuite/libffi.call/nested_struct1.c,
+	testsuite/libffi.call/nested_struct3.c,
+	testsuite/libffi.call/cls_7_1_byte.c,
+	testsuite/libffi.call/cls_double.c,
+	testsuite/libffi.call/nested_struct5.c,
+	testsuite/libffi.call/nested_struct7.c,
+	testsuite/libffi.call/cls_sint.c,
+	testsuite/libffi.call/nested_struct9.c,
+	testsuite/libffi.call/cls_20byte1.c,
+	testsuite/libffi.call/cls_multi_sshortchar.c,
+	testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_3byte2.c,
+	testsuite/libffi.call/cls_multi_schar.c,
+	testsuite/libffi.call/cls_multi_uchar.c,
+	testsuite/libffi.call/cls_19byte.c,
+	testsuite/libffi.call/cls_9byte1.c,
+	testsuite/libffi.call/cls_align_float.c,
+	testsuite/libffi.call/closure_fn1.c,
+	testsuite/libffi.call/problem1.c,
+	testsuite/libffi.call/closure_fn3.c,
+	testsuite/libffi.call/cls_sshort.c,
+	testsuite/libffi.call/closure_fn5.c,
+	testsuite/libffi.call/cls_align_double.c,
+	testsuite/libffi.call/cls_2byte.c,
+	testsuite/libffi.call/nested_struct.c,
+	testsuite/libffi.call/nested_struct10.c,
+	testsuite/libffi.call/cls_4byte.c,
+	testsuite/libffi.call/cls_6byte.c,
+	testsuite/libffi.call/cls_8byte.c,
+	testsuite/libffi.call/cls_multi_sshort.c,
+	testsuite/libffi.call/cls_align_uint32.c,
+	testsuite/libffi.call/cls_align_sint16.c,
+	testsuite/libffi.call/cls_float.c,
+	testsuite/libffi.call/cls_20byte.c,
+	testsuite/libffi.call/cls_5_1_byte.c,
+	testsuite/libffi.call/nested_struct2.c,
+	testsuite/libffi.call/cls_24byte.c,
+	testsuite/libffi.call/nested_struct4.c,
+	testsuite/libffi.call/nested_struct6.c,
+	testsuite/libffi.call/cls_64byte.c,
+	testsuite/libffi.call/nested_struct8.c,
+	testsuite/libffi.call/cls_uint.c,
+	testsuite/libffi.call/cls_multi_ushortchar.c,
+	testsuite/libffi.call/cls_schar.c,
+	testsuite/libffi.call/cls_uchar.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/cls_align_longdouble.c,
+	testsuite/libffi.call/cls_1_1byte.c,
+	testsuite/libffi.call/cls_12byte.c,
+	testsuite/libffi.call/cls_3_1byte.c,
+	testsuite/libffi.call/cls_3byte1.c,
+	testsuite/libffi.call/cls_4_1byte.c,
+	testsuite/libffi.call/cls_6_1_byte.c,
+	testsuite/libffi.call/cls_16byte.c,
+	testsuite/libffi.call/cls_18byte.c,
+	testsuite/libffi.call/closure_fn0.c,
+	testsuite/libffi.call/cls_9byte2.c,
+	testsuite/libffi.call/closure_fn2.c,
+	testsuite/libffi.call/closure_fn4.c,
+	testsuite/libffi.call/cls_ushort.c,
+	testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/cls_5byte.c,
+	testsuite/libffi.call/cls_align_pointer.c,
+	testsuite/libffi.call/cls_7byte.c,
+	testsuite/libffi.call/cls_align_sint32.c,
+	testsuite/libffi.special/unwindtest_ffi_call.cc,
+	testsuite/libffi.special/unwindtest.cc: Enable for ARM.
+
+2007-07-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* aclocal.m4: Regenerated.
+
+2007-06-02  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure: Regenerate.
+
+2007-05-23  Steve Ellcey  <sje@cup.hp.com>
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+	* aclocal.m4: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2007-05-10  Roman Zippel <zippel@linux-m68k.org>
+
+	* src/m68k/ffi.c (ffi_prep_incoming_args_SYSV,
+	ffi_closure_SYSV_inner,ffi_prep_closure): New, add closure support.
+	* src/m68k/sysv.S(ffi_closure_SYSV,ffi_closure_struct_SYSV): Likewise.
+	* src/m68k/ffitarget.h (FFI_TRAMPOLINE_SIZE): Likewise.
+	(FFI_CLOSURES): Enable closure support.
+
+2007-05-10  Roman Zippel <zippel@linux-m68k.org>
+
+	* configure.ac (HAVE_AS_CFI_PSEUDO_OP): New test.
+	* configure: Regenerate.
+	* fficonfig.h.in: Regenerate.
+	* src/m68k/sysv.S (CFI_STARTPROC,CFI_ENDPROC,
+	CFI_OFFSET,CFI_DEF_CFA): New macros.
+	(ffi_call_SYSV): Add callframe annotation.
+
+2007-05-10  Roman Zippel <zippel@linux-m68k.org>
+
+	* src/m68k/ffi.c (ffi_prep_args,ffi_prep_cif_machdep): Fix
+	numerous test suite failures.
+	* src/m68k/sysv.S (ffi_call_SYSV): Likewise.
+
+2007-04-11  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.am (EXTRA_DIST): Bring up to date.
+	* Makefile.in: Regenerate.
+	* src/frv/eabi.S: Remove RCS keyword.
+
+2007-04-06  Richard Henderson  <rth@redhat.com>
+
+	* configure.ac: Tidy target case.
+	(HAVE_LONG_DOUBLE): Allow the target to override.
+	* configure: Regenerate.
+	* include/ffi.h.in: Don't define ffi_type_foo if
+	LIBFFI_HIDE_BASIC_TYPES is defined.
+	(ffi_type_longdouble): If not HAVE_LONG_DOUBLE, define
+	to ffi_type_double.
+	* types.c (LIBFFI_HIDE_BASIC_TYPES): Define.
+	(FFI_TYPEDEF, ffi_type_void): Mark the data const.
+	(ffi_type_longdouble): Special case for Alpha.  Don't define
+	if long double == double.
+
+	* src/alpha/ffi.c (FFI_TYPE_LONGDOUBLE): Assert unique value.
+	(ffi_prep_cif_machdep): Handle it as the 128-bit type.
+	(ffi_call, ffi_closure_osf_inner): Likewise.
+	(ffi_closure_osf_inner): Likewise.  Mark hidden.
+	(ffi_call_osf, ffi_closure_osf): Mark hidden.
+	* src/alpha/ffitarget.h (FFI_LAST_ABI): Tidy definition.
+	* src/alpha/osf.S (ffi_call_osf, ffi_closure_osf): Mark hidden.
+	(load_table): Handle 128-bit long double.
+
+	* testsuite/libffi.call/float4.c: Add -mieee for alpha.
+
+2007-04-06  Tom Tromey  <tromey@redhat.com>
+
+	PR libffi/31491:
+	* README: Fixed bug in example.
+
+2007-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/closures.c: Include sys/statfs.h.
+	(_GNU_SOURCE): Define on Linux.
+	(FFI_MMAP_EXEC_SELINUX): Define.
+	(selinux_enabled): New variable.
+	(selinux_enabled_check): New function.
+	(is_selinux_enabled): Define.
+	(dlmmap): Use it.
+
+2007-03-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* testsuite/libffi.call/return_fl2.c (return_fl): Mark as static.
+	Use 'volatile float sum' to create sum of floats to avoid false
+	negative due to excess precision on ix86 targets.
+	(main): Ditto.
+
+2007-03-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* src/powerpc/ffi.c (flush_icache): Fix left-over from previous
+	patch.
+	(ffi_prep_closure_loc): Remove unneeded casts.  Add needed ones.
+
+2007-03-07  Alexandre Oliva  <aoliva@redhat.com>
+
+	* include/ffi.h.in (ffi_closure_alloc, ffi_closure_free): New.
+	(ffi_prep_closure_loc): New.
+	(ffi_prep_raw_closure_loc): New.
+	(ffi_prep_java_raw_closure_loc): New.
+	* src/closures.c: New file.
+	* src/dlmalloc.c [FFI_MMAP_EXEC_WRIT] (struct malloc_segment):
+	Replace sflags with exec_offset.
+	[FFI_MMAP_EXEC_WRIT] (mmap_exec_offset, add_segment_exec_offset,
+	sub_segment_exec_offset): New macros.
+	(get_segment_flags, set_segment_flags, check_segment_merge): New
+	macros.
+	(is_mmapped_segment, is_extern_segment): Use get_segment_flags.
+	(add_segment, sys_alloc, create_mspace, create_mspace_with_base,
+	destroy_mspace): Use new macros.
+	(sys_alloc): Silence warning.
+	* Makefile.am (libffi_la_SOURCES): Add src/closures.c.
+	* Makefile.in: Rebuilt.
+	* src/prep_cif [FFI_CLOSURES] (ffi_prep_closure): Implement in
+	terms of ffi_prep_closure_loc.
+	* src/raw_api.c (ffi_prep_raw_closure_loc): Renamed and adjusted
+	from...
+	(ffi_prep_raw_closure): ... this.  Re-implement in terms of the
+	renamed version.
+	* src/java_raw_api (ffi_prep_java_raw_closure_loc): Renamed and
+	adjusted from...
+	(ffi_prep_java_raw_closure): ... this.  Re-implement in terms of
+	the renamed version.
+	* src/alpha/ffi.c (ffi_prep_closure_loc): Renamed from
+	(ffi_prep_closure): ... this.
+	* src/pa/ffi.c: Likewise.
+	* src/cris/ffi.c: Likewise.  Adjust.
+	* src/frv/ffi.c: Likewise.
+	* src/ia64/ffi.c: Likewise.
+	* src/mips/ffi.c: Likewise.
+	* src/powerpc/ffi_darwin.c: Likewise.
+	* src/s390/ffi.c: Likewise.
+	* src/sh/ffi.c: Likewise.
+	* src/sh64/ffi.c: Likewise.
+	* src/sparc/ffi.c: Likewise.
+	* src/x86/ffi64.c: Likewise.
+	* src/x86/ffi.c: Likewise.
+	(FFI_INIT_TRAMPOLINE): Adjust.
+	(ffi_prep_raw_closure_loc): Renamed and adjusted from...
+	(ffi_prep_raw_closure): ... this.
+	* src/powerpc/ffi.c (ffi_prep_closure_loc): Renamed from
+	(ffi_prep_closure): ... this.
+	(flush_icache): Adjust.
+
+2007-03-07  Alexandre Oliva  <aoliva@redhat.com>
+
+	* src/dlmalloc.c: New file, imported version 2.8.3 of Doug
+	Lea's malloc.
+
+2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>
+
+	* Makefile.am: Add dummy install-pdf target.
+	* Makefile.in: Regenerate
+
+2007-02-13  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* src/s390/ffi.c (ffi_prep_args, ffi_prep_cif_machdep,
+	ffi_closure_helper_SYSV): Add long double handling.
+
+2007-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Move restore of r2
+	immediately after bctrl instruction.
+
+2007-01-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.am (all-recursive, install-recursive,
+	mostlyclean-recursive, clean-recursive, distclean-recursive,
+	maintainer-clean-recursive): Add missing targets.
+	* Makefile.in: Rebuilt.
+
+2006-12-14  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Add TARGET for x86_64-*-darwin*.
+	* Makefile.am (nodist_libffi_la_SOURCES): Add rules for 64-bit sources
+	for X86_DARWIN.
+	* src/x86/ffitarget.h: Set trampoline size for x86_64-*-darwin*.
+	* src/x86/darwin64.S: New file for x86_64-*-darwin* support.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+	* testsuite/libffi.special/unwindtest_ffi_call.cc: New test case for
+	ffi_call only.
+
+2006-12-13  Andreas Tobler <a.tobler@schweiz.org>
+
+	* aclocal.m4: Regenerate with aclocal -I .. as written in the
+	Makefile.am.
+
+2006-10-31  Geoffrey Keating  <geoffk@apple.com>
+
+	* src/powerpc/ffi_darwin.c (darwin_adjust_aggregate_sizes): New.
+	(ffi_prep_cif_machdep): Call darwin_adjust_aggregate_sizes for
+	Darwin.
+	* testsuite/libffi.call/nested_struct4.c: Remove Darwin XFAIL.
+	* testsuite/libffi.call/nested_struct6.c: Remove Darwin XFAIL.
+
+2006-10-10  Paolo Bonzini  <bonzini@gnu.org>
+	    Sandro Tolaini  <tolaini@libero.it>
+
+	* configure.ac [i*86-*-darwin*]: Set X86_DARWIN symbol and
+	conditional.
+	* configure: Regenerated.
+	* Makefile.am (nodist_libffi_la_SOURCES) [X86_DARWIN]: New case.
+	(EXTRA_DIST): Add src/x86/darwin.S.
+	* Makefile.in: Regenerated.
+	* include/Makefile.in: Regenerated.
+	* testsuite/Makefile.in: Regenerated.
+
+	* src/x86/ffi.c (ffi_prep_cif_machdep) [X86_DARWIN]: Treat like
+	X86_WIN32, and additionally align stack to 16 bytes.
+	* src/x86/darwin.S: New, based on sysv.S.
+	* src/prep_cif.c (ffi_prep_cif) [X86_DARWIN]: Align > 8-byte structs.
+
+2006-09-12  David Daney  <ddaney@avtrex.com>
+
+	PR libffi/23935
+	* include/Makefile.am: Install both ffi.h and ffitarget.h in
+	$(libdir)/gcc/$(target_alias)/$(gcc_version)/include.
+	* aclocal.m4: Regenerated for automake 1.9.6.
+	* Makefile.in: Regenerated.
+	* include/Makefile.in: Regenerated.
+	* testsuite/Makefile.in: Regenerated.
+
+2006-08-17  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* include/ffi_common.h (struct): Revert accidental commit.
+
+2006-08-15  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* include/ffi_common.h: Remove lint directives.
+	* include/ffi.h.in: Likewise.
+
+2006-07-25  Torsten Schoenfeld  <kaffeetisch@gmx.de>
+
+	* include/ffi.h.in (ffi_type_ulong, ffi_type_slong): Define correctly
+	for 32-bit architectures.
+	* testsuite/libffi.call/return_ul.c: New test case.
+
+2006-07-19  David Daney  <ddaney@avtrex.com>
+
+	* testsuite/libffi.call/closure_fn6.c: Remove xfail for mips,
+	xfail remains for mips64.
+
+2006-05-23  Carlos O'Donell  <carlos@codesourcery.com>
+
+	* Makefile.am: Add install-html target. Add install-html to .PHONY
+	* Makefile.in: Regenerate.
+	* aclocal.m4: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2006-05-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa/ffi.c (ffi_prep_args_pa32): Load floating point arguments from
+	stack slot.
+
+2006-04-22  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* README: Remove notice about 'Crazy Comments'.
+	* src/debug.c: Remove lint directives. Cleanup white spaces.
+	* src/java_raw_api.c: Likewise.
+	* src/prep_cif.c: Likewise.
+	* src/raw_api.c: Likewise.
+	* src/ffitest.c: Delete. No longer needed, all test cases migrated
+	to the testsuite.
+	* src/arm/ffi.c: Remove lint directives.
+	* src/m32r/ffi.c: Likewise.
+	* src/pa/ffi.c: Likewise.
+	* src/powerpc/ffi.c: Likewise.
+	* src/powerpc/ffi_darwin.c: Likewise.
+	* src/sh/ffi.c: Likewise.
+	* src/sh64/ffi.c: Likewise.
+	* src/x86/ffi.c: Likewise.
+	* testsuite/libffi.call/float2.c: Likewise.
+	* testsuite/libffi.call/promotion.c: Likewise.
+	* testsuite/libffi.call/struct1.c: Likewise.
+
+2006-04-13  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/pa/hpux32.S: Correct unwind offset calculation for
+	ffi_closure_pa32.
+	* src/pa/linux.S: Likewise.
+
+2006-04-12  James E Wilson  <wilson@specifix.com>
+
+	PR libgcj/26483
+	* src/ia64/ffi.c (stf_spill, ldf_fill): Rewrite as macros.
+	(hfa_type_load): Call stf_spill.
+	(hfa_type_store): Call ldf_fill.
+	(ffi_call): Adjust calls to above routines.  Add local temps for
+	macro result.
+
+2006-04-10  Matthias Klose  <doko@debian.org>
+
+	* testsuite/lib/libffi-dg.exp (libffi-init): Recognize multilib
+	directory names containing underscores.
+
+2006-04-07  James E Wilson  <wilson@specifix.com>
+
+	* testsuite/libffi.call/float4.c: New testcase.
+
+2006-04-05  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+	    Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* Makefile.am: Add PA_HPUX port.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+	* configure.ac: Add PA_HPUX rules.
+	* configure: Regenerate.
+	* src/pa/ffitarget.h: Rename linux target to PA_LINUX.
+	Add PA_HPUX and PA64_HPUX.
+	Rename FFI_LINUX ABI to FFI_PA32 ABI.
+	(FFI_TRAMPOLINE_SIZE): Define for 32-bit HP-UX targets.
+	(FFI_TYPE_SMALL_STRUCT2): Define.
+	(FFI_TYPE_SMALL_STRUCT4): Likewise.
+	(FFI_TYPE_SMALL_STRUCT8): Likewise.
+	(FFI_TYPE_SMALL_STRUCT3): Redefine.
+	(FFI_TYPE_SMALL_STRUCT5): Likewise.
+	(FFI_TYPE_SMALL_STRUCT6): Likewise.
+	(FFI_TYPE_SMALL_STRUCT7): Likewise.
+	* src/pa/ffi.c (ROUND_DOWN): Delete.
+	(fldw, fstw, fldd, fstd): Use '__asm__'.
+	(ffi_struct_type): Add support for FFI_TYPE_SMALL_STRUCT2,
+	FFI_TYPE_SMALL_STRUCT4 and FFI_TYPE_SMALL_STRUCT8.
+	(ffi_prep_args_LINUX): Rename to ffi_prep_args_pa32. Update comment.
+	Simplify incrementing of stack slot variable. Change type of local
+	'n' to unsigned int.
+	(ffi_size_stack_LINUX): Rename to ffi_size_stack_pa32. Handle long
+	double on PA_HPUX.
+	(ffi_prep_cif_machdep): Likewise.
+	(ffi_call): Likewise.
+	(ffi_closure_inner_LINUX): Rename to ffi_closure_inner_pa32. Change
+	return type to ffi_status. Simplify incrementing of stack slot
+	variable. Only copy floating point argument registers when PA_LINUX
+	is true. Reformat debug statement.
+	Add support for FFI_TYPE_SMALL_STRUCT2, FFI_TYPE_SMALL_STRUCT4 and
+	FFI_TYPE_SMALL_STRUCT8.
+	(ffi_closure_LINUX): Rename to ffi_closure_pa32. Add 'extern' to
+	declaration.
+	(ffi_prep_closure): Make linux trampoline conditional on PA_LINUX.
+	Add nops to cache flush.  Add trampoline for PA_HPUX.
+	* src/pa/hpux32.S: New file.
+	* src/pa/linux.S (ffi_call_LINUX): Rename to ffi_call_pa32. Rename
+	ffi_prep_args_LINUX to ffi_prep_args_pa32.
+	Localize labels. Add support for 2, 4 and 8-byte small structs. Handle
+	unaligned destinations in 3, 5, 6 and 7-byte small structs. Order
+	argument type checks so that common argument types appear first.
+	(ffi_closure_LINUX): Rename to ffi_closure_pa32. Rename
+	ffi_closure_inner_LINUX to ffi_closure_inner_pa32.
+
+2006-03-24  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/powerpc/ffitarget.h (enum ffi_abi): Add FFI_LINUX.  Default
+	for 32-bit using IBM extended double format.  Fix FFI_LAST_ABI.
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Handle linux variant of
+	FFI_TYPE_LONGDOUBLE.
+	(ffi_prep_args64): Assert using IBM extended double.
+	(ffi_prep_cif_machdep): Don't munge FFI_TYPE_LONGDOUBLE type.
+	Handle FFI_LINUX FFI_TYPE_LONGDOUBLE return and args.
+	(ffi_call): Handle FFI_LINUX.
+	(ffi_closure_helper_SYSV): Non FFI_LINUX long double return needs
+	gpr3 return pointer as for struct return.  Handle FFI_LINUX
+	FFI_TYPE_LONGDOUBLE return and args.  Don't increment "nf"
+	unnecessarily.
+	* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Load both f1 and f2
+	for FFI_TYPE_LONGDOUBLE.  Move epilogue insns into case table.
+	Don't use r6 as pointer to results, instead use sp offset.  Don't
+	make a special call to load lr with case table address, instead
+	use offset from previous call.
+	* src/powerpc/sysv.S (ffi_call_SYSV): Save long double return.
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Simplify long double
+	return.
+
+2006-03-15  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh64/ffi.c (ffi_prep_cif_machdep): Handle float arguments
+	passed with FP registers correctly.
+	(ffi_closure_helper_SYSV): Likewise.
+	* src/sh64/sysv.S: Likewise.
+
+2006-03-01  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.special/unwindtest.cc (closure_test_fn): Mark cif,
+	args and userdata unused.
+	(closure_test_fn1): Mark cif and userdata unused.
+	(main): Remove unused res.
+
+2006-02-28  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/call.exp: Adjust FSF address. Add test runs for
+	-O2, -O3, -Os and the warning flags -W -Wall.
+	* testsuite/libffi.special/special.exp: Likewise.
+	* testsuite/libffi.call/ffitest.h: Add an __UNUSED__ macro to mark
+	unused parameter unused for gcc or else do nothing.
+	* testsuite/libffi.special/ffitestcxx.h: Likewise.
+	* testsuite/libffi.call/cls_12byte.c (cls_struct_12byte_gn): Mark cif
+	and userdata unused.
+	* testsuite/libffi.call/cls_16byte.c (cls_struct_16byte_gn): Likewise.
+	* testsuite/libffi.call/cls_18byte.c (cls_struct_18byte_gn): Likewise.
+	* testsuite/libffi.call/cls_19byte.c (cls_struct_19byte_gn): Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c (cls_struct_1_1byte_gn): Likewise.
+	* testsuite/libffi.call/cls_20byte.c (cls_struct_20byte_gn): Likewise.
+	* testsuite/libffi.call/cls_20byte1.c (cls_struct_20byte_gn): Likewise.
+	* testsuite/libffi.call/cls_24byte.c (cls_struct_24byte_gn): Likewise.
+	* testsuite/libffi.call/cls_2byte.c (cls_struct_2byte_gn): Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c (cls_struct_3_1byte_gn): Likewise.
+	* testsuite/libffi.call/cls_3byte1.c (cls_struct_3byte_gn): Likewise.
+	* testsuite/libffi.call/cls_3byte2.c (cls_struct_3byte_gn1): Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c (cls_struct_4_1byte_gn): Likewise.
+	* testsuite/libffi.call/cls_4byte.c (cls_struct_4byte_gn): Likewise.
+	* testsuite/libffi.call/cls_5_1_byte.c (cls_struct_5byte_gn): Likewise.
+	* testsuite/libffi.call/cls_5byte.c (cls_struct_5byte_gn): Likewise.
+	* testsuite/libffi.call/cls_64byte.c (cls_struct_64byte_gn): Likewise.
+	* testsuite/libffi.call/cls_6_1_byte.c (cls_struct_6byte_gn): Likewise.
+	* testsuite/libffi.call/cls_6byte.c (cls_struct_6byte_gn): Likewise.
+	* testsuite/libffi.call/cls_7_1_byte.c (cls_struct_7byte_gn): Likewise.
+	* testsuite/libffi.call/cls_7byte.c (cls_struct_7byte_gn): Likewise.
+	* testsuite/libffi.call/cls_8byte.c (cls_struct_8byte_gn): Likewise.
+	* testsuite/libffi.call/cls_9byte1.c (cls_struct_9byte_gn): Likewise.
+	* testsuite/libffi.call/cls_9byte2.c (cls_struct_9byte_gn): Likewise.
+	* testsuite/libffi.call/cls_align_double.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_float.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_longdouble.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_pointer.c (cls_struct_align_fn): Cast
+	void* to avoid compiler warning.
+	(main): Likewise.
+	(cls_struct_align_gn): Mark cif and userdata unused.
+	* testsuite/libffi.call/cls_align_sint16.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_sint32.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_sint64.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_uint16.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_align_uint32.c (cls_struct_align_gn):
+	Likewise.
+	* testsuite/libffi.call/cls_double.c (cls_ret_double_fn): Likewise.
+	* testsuite/libffi.call/cls_float.c (cls_ret_float_fn): Likewise.
+	* testsuite/libffi.call/cls_multi_schar.c (test_func_gn): Mark cif and
+	data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_multi_sshort.c (test_func_gn): Mark cif and
+	data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_multi_sshortchar.c (test_func_gn): Mark cif
+	and data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_multi_uchar.c (test_func_gn): Mark cif and
+	data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_multi_ushort.c (test_func_gn): Mark cif and
+	data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_multi_ushortchar.c (test_func_gn): Mark cif
+	and data unused.
+	(main): Cast res_call to silence gcc.
+	* testsuite/libffi.call/cls_schar.c (cls_ret_schar_fn): Mark cif and
+	userdata unused.
+	(cls_ret_schar_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/cls_sint.c (cls_ret_sint_fn): Mark cif and
+	userdata unused.
+	(cls_ret_sint_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/cls_sshort.c (cls_ret_sshort_fn): Mark cif and
+	userdata unused.
+	(cls_ret_sshort_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/cls_uchar.c (cls_ret_uchar_fn):  Mark cif and
+	userdata unused.
+	(cls_ret_uchar_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/cls_uint.c (cls_ret_uint_fn): Mark cif and
+	userdata unused.
+	(cls_ret_uint_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/cls_ulonglong.c (cls_ret_ulonglong_fn): Mark cif
+	and userdata unused.
+	* testsuite/libffi.call/cls_ushort.c (cls_ret_ushort_fn): Mark cif and
+	userdata unused.
+	(cls_ret_ushort_fn): Cast printf parameter to silence gcc.
+	* testsuite/libffi.call/float.c (floating): Remove unused parameter e.
+	* testsuite/libffi.call/float1.c (main): Remove unused variable i.
+	Cleanup white spaces.
+	* testsuite/libffi.call/negint.c (checking): Remove unused variable i.
+	* testsuite/libffi.call/nested_struct.c (cls_struct_combined_gn): Mark
+	cif and userdata unused.
+	* testsuite/libffi.call/nested_struct1.c (cls_struct_combined_gn):
+	Likewise.
+	* testsuite/libffi.call/nested_struct10.c (B_gn): Likewise.
+	* testsuite/libffi.call/nested_struct2.c (B_fn): Adjust printf
+	formatters to silence gcc.
+	(B_gn): Mark cif and userdata unused.
+	* testsuite/libffi.call/nested_struct3.c (B_gn): Mark cif and userdata
+	unused.
+	* testsuite/libffi.call/nested_struct4.c: Mention related PR.
+	(B_gn): Mark cif and userdata unused.
+	* testsuite/libffi.call/nested_struct5.c (B_gn): Mark cif and userdata
+	unused.
+	* testsuite/libffi.call/nested_struct6.c: Mention related PR.
+	(B_gn): Mark cif and userdata unused.
+	* testsuite/libffi.call/nested_struct7.c (B_gn): Mark cif and userdata
+	unused.
+	* testsuite/libffi.call/nested_struct8.c (B_gn): Likewise.
+	* testsuite/libffi.call/nested_struct9.c (B_gn): Likewise.
+	* testsuite/libffi.call/problem1.c (stub): Likewise.
+	* testsuite/libffi.call/pyobjc-tc.c (main): Cast the result to silence
+	gcc.
+	* testsuite/libffi.call/return_fl2.c (return_fl): Add the note mentioned
+	in the last commit for this test case in the test case itself.
+	* testsuite/libffi.call/closure_fn0.c (closure_test_fn0): Mark cif as
+	unused.
+	* testsuite/libffi.call/closure_fn1.c (closure_test_fn1): Likewise.
+	* testsuite/libffi.call/closure_fn2.c (closure_test_fn2): Likewise.
+	* testsuite/libffi.call/closure_fn3.c (closure_test_fn3): Likewise.
+	* testsuite/libffi.call/closure_fn4.c (closure_test_fn0): Likewise.
+	* testsuite/libffi.call/closure_fn5.c (closure_test_fn5): Likewise.
+	* testsuite/libffi.call/closure_fn6.c (closure_test_fn0): Likewise.
+
+2006-02-22  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/sysv.S: Fix register numbers in the FDE for
+	ffi_closure_SYSV.
+
+2006-02-20  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/return_fl2.c (return_fl): Remove static
+	declaration to avoid a false negative on ix86. See PR323.
+
+2006-02-18  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_closure_helper_SYSV): Remove unused variable
+	and cast integer to void * if needed.  Update the pointer to
+	the FP register saved area correctly.
+
+2006-02-17  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/nested_struct6.c: XFAIL this test until PR25630
+	is fixed.
+	* testsuite/libffi.call/nested_struct4.c: Likewise.
+
+2006-02-16  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/return_dbl.c: New test case.
+	* testsuite/libffi.call/return_dbl1.c: Likewise.
+	* testsuite/libffi.call/return_dbl2.c: Likewise.
+	* testsuite/libffi.call/return_fl.c: Likewise.
+	* testsuite/libffi.call/return_fl1.c: Likewise.
+	* testsuite/libffi.call/return_fl2.c: Likewise.
+	* testsuite/libffi.call/return_fl3.c: Likewise.
+	* testsuite/libffi.call/closure_fn6.c: Likewise.
+
+	* testsuite/libffi.call/nested_struct2.c: Remove ffi_type_mylong
+	definition.
+	* testsuite/libffi.call/ffitest.h: Add ffi_type_mylong definition
+	here to be used by other test cases too.
+
+	* testsuite/libffi.call/nested_struct10.c: New test case.
+	* testsuite/libffi.call/nested_struct9.c: Likewise.
+	* testsuite/libffi.call/nested_struct8.c: Likewise.
+	* testsuite/libffi.call/nested_struct7.c: Likewise.
+	* testsuite/libffi.call/nested_struct6.c: Likewise.
+	* testsuite/libffi.call/nested_struct5.c: Likewise.
+	* testsuite/libffi.call/nested_struct4.c: Likewise.
+
+2006-01-21  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* configure.ac: Enable libffi for sparc64-*-freebsd*.
+	* configure: Rebuilt.
+
+2006-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/powerpc/sysv.S (smst_two_register): Don't call __ashldi3,
+	instead do the shifting inline.
+	* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Don't compute %r5
+	shift count unconditionally.  Simplify load sequences for 1, 2, 3, 4
+	and 8 byte structs, for the remaining struct sizes don't call
+	__lshrdi3, instead do the shifting inline.
+
+2005-12-07  Thiemo Seufer  <ths@networkno.de>
+
+	* src/mips/ffitarget.h: Remove obsolete sgidefs.h include. Add
+	missing parentheses.
+	* src/mips/o32.S (ffi_call_O32): Code formatting. Define
+	and use A3_OFF, FP_OFF, RA_OFF. Micro-optimizations.
+	(ffi_closure_O32): Likewise, but with newly defined A3_OFF2,
+	A2_OFF2, A1_OFF2, A0_OFF2, RA_OFF2, FP_OFF2, S0_OFF2, GP_OFF2,
+	V1_OFF2, V0_OFF2, FA_1_1_OFF2, FA_1_0_OFF2, FA_0_1_OFF2,
+	FA_0_0_OFF2.
+	* src/mips/ffi.c (ffi_prep_args): Code formatting. Fix
+	endianness bugs.
+	(ffi_prep_closure): Improve trampoline instruction scheduling.
+	(ffi_closure_mips_inner_O32): Fix endianness bugs.
+
+2005-12-03  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/powerpc/ffi.c: Formatting.
+	(ffi_prep_args_SYSV): Avoid possible aliasing problems by using unions.
+	(ffi_prep_args64): Likewise.
+
+2005-09-30  Geoffrey Keating  <geoffk@apple.com>
+
+	* testsuite/lib/libffi-dg.exp (libffi_target_compile): For
+	darwin, use -shared-libgcc not -lgcc_s, and explain why.
+
+2005-09-26  Tom Tromey  <tromey@redhat.com>
+
+	* testsuite/libffi.call/float1.c (value_type): New typedef.
+	(CANARY): New define.
+	(main): Check for result buffer overflow.
+	* src/powerpc/linux64.S: Handle linux64 long double returns.
+	* src/powerpc/ffi.c (FLAG_RETURNS_128BITS): New constant.
+	(ffi_prep_cif_machdep): Handle linux64 long double returns.
+
+2005-08-25  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/23404
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Correct placement of stack
+	homed fp args.
+	(ffi_status ffi_prep_cif_machdep): Correct stack sizing for same.
+
+2005-08-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.ac (HAVE_HIDDEN_VISIBILITY_ATTRIBUTE): New test.
+	(AH_BOTTOM): Add FFI_HIDDEN definition.
+	* configure: Rebuilt.
+	* fficonfig.h.in: Rebuilt.
+	* src/powerpc/ffi.c (hidden): Remove.
+	(ffi_closure_LINUX64, ffi_prep_args64, ffi_call_LINUX64,
+	ffi_closure_helper_LINUX64): Use FFI_HIDDEN instead of hidden.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64,
+	.ffi_closure_LINUX64): Use FFI_HIDDEN instead of .hidden.
+	* src/x86/ffi.c (ffi_closure_SYSV, ffi_closure_raw_SYSV): Remove,
+	add FFI_HIDDEN to its prototype.
+	(ffi_closure_SYSV_inner): New.
+	* src/x86/sysv.S (ffi_closure_SYSV, ffi_closure_raw_SYSV): New.
+	* src/x86/win32.S (ffi_closure_SYSV, ffi_closure_raw_SYSV): New.
+
+2005-08-10  Alfred M. Szmidt  <ams@gnu.org>
+
+	PR libffi/21819:
+	* configure: Rebuilt.
+	* configure.ac: Handle i*86-*-gnu*.
+
+2005-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Use
+	DW_CFA_offset_extended_sf rather than
+	DW_CFA_GNU_negative_offset_extended.
+	* src/powerpc/sysv.S (ffi_call_SYSV): Likewise.
+
+2005-07-22  SUGIOKA Toshinobu  <sugioka@itonet.co.jp>
+
+	* src/sh/sysv.S (ffi_call_SYSV): Stop argument popping correctly
+	on sh3.
+	(ffi_closure_SYSV): Change the stack layout for sh3 struct argument.
+	* src/sh/ffi.c (ffi_prep_args): Fix sh3 argument copy, when it is
+	partially on register.
+	(ffi_closure_helper_SYSV): Likewise.
+	(ffi_prep_cif_machdep): Don't set too many cif->flags.
+
+2005-07-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_call): Handle small structures correctly.
+	Remove empty line.
+	* src/sh64/ffi.c (simple_type): Remove.
+	(return_type): Handle small structures correctly.
+	(ffi_prep_args): Likewise.
+	(ffi_call): Likewise.
+	(ffi_closure_helper_SYSV): Likewise.
+	* src/sh64/sysv.S (ffi_call_SYSV): Handle 1, 2 and 4-byte return.
+	Emit position independent code if PIC and remove wrong datalabel
+	prefixes from EH data.
+
+2005-07-19  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* Makefile.am (nodist_libffi_la_SOURCES): Add POWERPC_FREEBSD.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+	* configure.ac: Add POWERPC_FREEBSD rules.
+	* configure: Regenerate.
+	* src/powerpc/ffitarget.h: Add POWERPC_FREEBSD rules.
+	(FFI_SYSV_TYPE_SMALL_STRUCT): Define.
+	* src/powerpc/ffi.c: Add flags to handle small structure returns
+	in ffi_call_SYSV.
+	(ffi_prep_cif_machdep): Handle small structures for SYSV 4 ABI.
+	Aka FFI_SYSV.
+	(ffi_closure_helper_SYSV): Likewise.
+	* src/powerpc/ppc_closure.S: Add return types for small structures.
+	* src/powerpc/sysv.S: Add bits to handle small structures for
+	final SYSV 4 ABI.
+
+2005-07-10  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/cls_5_1_byte.c: New test file.
+	* testsuite/libffi.call/cls_6_1_byte.c: Likewise.
+	* testsuite/libffi.call/cls_7_1_byte.c: Likewise.
+
+2005-07-05  Randolph Chung  <tausq@debian.org>
+
+	* src/pa/ffi.c (ffi_struct_type): Rename FFI_TYPE_SMALL_STRUCT1
+	as FFI_TYPE_SMALL_STRUCT3.  Break out handling for 5-7 byte
+	structures.  Kill compilation warnings.
+	(ffi_closure_inner_LINUX): Print return values as hex in debug
+	message.  Rename FFI_TYPE_SMALL_STRUCT1 as FFI_TYPE_SMALL_STRUCT3.
+	Properly handle 5-7 byte structure returns.
+	* src/pa/ffitarget.h (FFI_TYPE_SMALL_STRUCT1)
+	(FFI_TYPE_SMALL_STRUCT2): Remove.
+	(FFI_TYPE_SMALL_STRUCT3, FFI_TYPE_SMALL_STRUCT5)
+	(FFI_TYPE_SMALL_STRUCT6, FFI_TYPE_SMALL_STRUCT7): Define.
+	* src/pa/linux.S: Mark source file as using PA1.1 assembly.
+	(checksmst1, checksmst2): Remove.
+	(checksmst3): Optimize handling of 3-byte struct returns.
+	(checksmst567): Properly handle 5-7 byte struct returns.
+
+2005-06-15  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR libgcj/21943
+	* src/mips/n32.S: Enforce PIC code.
+	* src/mips/o32.S: Likewise.
+
+2005-06-15  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.ac: Treat i*86-*-solaris2.10 and up as X86_64.
+	* configure: Regenerate.
+
+2005-06-01  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Don't use JUMPTARGET
+	to call ffi_closure_helper_SYSV.  Append @local instead.
+	* src/powerpc/sysv.S (ffi_call_SYSV): Likewise for ffi_prep_args_SYSV.
+
+2005-05-17  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.ac: Use AC_C_BIGENDIAN instead of AC_C_BIGENDIAN_CROSS.
+	Use AC_CHECK_SIZEOF instead of AC_COMPILE_CHECK_SIZEOF.
+	* Makefile.am (ACLOCAL_AMFLAGS): Remove -I ../config.
+	* aclocal.m4, configure, fficonfig.h.in, Makefile.in,
+	include/Makefile.in, testsuite/Makefile.in: Regenerate.
+
+2005-05-09  Mike Stump  <mrs@apple.com>
+
+	* configure: Regenerate.
+
+2005-05-08  Richard Henderson  <rth@redhat.com>
+
+	PR libffi/21285
+	* src/alpha/osf.S: Update unwind into to match code.
+
+2005-05-04  Andreas Degert <ad@papyrus-gmbh.de>
+	    Richard Henderson  <rth@redhat.com>
+
+	* src/x86/ffi64.c (ffi_prep_cif_machdep): Save sse-used flag in
+	bit 11 of flags.
+	(ffi_call): Mask return type field.  Pass ssecount to ffi_call_unix64.
+	(ffi_prep_closure): Set carry bit if sse-used flag set.
+	* src/x86/unix64.S (ffi_call_unix64): Add ssecount argument.
+	Only load sse registers if ssecount non-zero.
+	(ffi_closure_unix64): Only save sse registers if carry set on entry.
+
+2005-04-29  Ralf Corsepius  <ralf.corsepius@rtems.org>
+
+	* configure.ac: Add i*86-*-rtems*, sparc*-*-rtems*,
+	powerpc-*rtems*, arm*-*-rtems*, sh-*-rtems*.
+	* configure: Regenerate.
+
+2005-04-20  Hans-Peter Nilsson  <hp@axis.com>
+
+	* testsuite/lib/libffi-dg.exp (libffi-dg-test-1): In regsub use,
+	have Tcl8.3-compatible intermediate variable.
+
+2005-04-18  Simon Posnjak <simon.posnjak@siol.net>
+	    Hans-Peter Nilsson  <hp@axis.com>
+
+	* Makefile.am: Add CRIS support.
+	* configure.ac: Likewise.
+	* Makefile.in, configure, testsuite/Makefile.in,
+	include/Makefile.in: Regenerate.
+	* src/cris: New directory.
+	* src/cris/ffi.c, src/cris/sysv.S, src/cris/ffitarget.h: New files.
+	* src/prep_cif.c (ffi_prep_cif): Wrap in #ifndef __CRIS__.
+
+	* testsuite/lib/libffi-dg.exp (libffi-dg-test-1): Replace \n with
+	\r?\n in output tests.
+
+2005-04-12  Mike Stump  <mrs@apple.com>
+
+	* configure: Regenerate.
+
+2005-03-30  Hans Boehm  <Hans.Boehm@hp.com>
+
+	* src/ia64/ffitarget.h (ffi_arg): Use long long instead of DI.
+
+2005-03-30  Steve Ellcey  <sje@cup.hp.com>
+
+	* src/ia64/ffitarget.h (ffi_arg) ADD DI attribute.
+	(ffi_sarg) Ditto.
+	* src/ia64/unix.S (ffi_closure_unix): Extend gp
+	to 64 bits in ILP32 mode.
+	Load 64 bits even for short data.
+
+2005-03-23  Mike Stump  <mrs@apple.com>
+
+	* src/powerpc/darwin.S: Update for -m64 multilib.
+	* src/powerpc/darwin_closure.S: Likewise.
+
+2005-03-21  Zack Weinberg  <zack@codesourcery.com>
+
+	* configure.ac: Do not invoke TL_AC_GCC_VERSION.
+	Do not set tool_include_dir.
+	* aclocal.m4, configure, Makefile.in, testsuite/Makefile.in:
+	Regenerate.
+	* include/Makefile.am: Set gcc_version and toollibffidir.
+	* include/Makefile.in: Regenerate.
+
+2005-02-22  Andrew Haley  <aph@redhat.com>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep): Bump alignment to
+	odd-numbered register pairs for 64-bit integer types.
+
+2005-02-23  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	PR libffi/20104
+	* testsuite/libffi.call/return_ll1.c: New test case.
+
+2005-02-11  Janis Johnson  <janis187@us.ibm.com>
+
+	* testsuite/libffi.call/cls_align_longdouble.c: Remove dg-options.
+	* testsuite/libffi.call/float.c: Ditto.
+	* testsuite/libffi.call/float2.c: Ditto.
+	* testsuite/libffi.call/float3.c: Ditto.
+
+2005-02-08  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/frv/ffitarget.h: Remove PPC stuff which does not belong to frv.
+
+2005-01-12  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* testsuite/libffi.special/special.exp (cxx_options): Add
+	-shared-libgcc.
+
+2004-12-31  Richard Henderson  <rth@redhat.com>
+
+	* src/types.c (FFI_AGGREGATE_TYPEDEF): Remove.
+	(FFI_TYPEDEF): Rename from FFI_INTEGRAL_TYPEDEF.  Replace size and
+	offset parameters with a type parameter; deduce size and structure
+	alignment.  Update all users.
+
+2004-12-31  Richard Henderson  <rth@redhat.com>
+
+	* src/types.c (FFI_TYPE_POINTER): Define with sizeof.
+	(FFI_TYPE_LONGDOUBLE): Fix for ia64.
+	* src/ia64/ffitarget.h (struct ffi_ia64_trampoline_struct): Move
+	into ffi_prep_closure.
+	* src/ia64/ia64_flags.h, src/ia64/ffi.c, src/ia64/unix.S: Rewrite
+	from scratch.
+
+2004-12-27  Richard Henderson  <rth@redhat.com>
+
+	* src/x86/unix64.S: Fix typo in unwind info.
+
+2004-12-25  Richard Henderson  <rth@redhat.com>
+
+	* src/x86/ffi64.c (struct register_args): Rename from stackLayout.
+	(enum x86_64_reg_class): Add X86_64_COMPLEX_X87_CLASS.
+	(merge_classes): Check for it.
+	(SSE_CLASS_P): New.
+	(classify_argument): Pass byte_offset by value; perform all updates
+	inside struct case.
+	(examine_argument): Add classes argument; handle
+	X86_64_COMPLEX_X87_CLASS.
+	(ffi_prep_args): Merge into ...
+	(ffi_call): ... here.  Share stack frame with ffi_call_unix64.
+	(ffi_prep_cif_machdep): Setup cif->flags for proper structure return.
+	(ffi_fill_return_value): Remove.
+	(ffi_prep_closure): Remove dead assert.
+	(ffi_closure_unix64_inner): Rename from ffi_closure_UNIX64_inner.
+	Rewrite to use struct register_args instead of va_list.  Create
+	flags for handling structure returns.
+	* src/x86/unix64.S: Remove dead strings.
+	(ffi_call_unix64): Rename from ffi_call_UNIX64.  Rewrite to share
+	stack frame with ffi_call.  Handle structure returns properly.
+	(float2sse, floatfloat2sse, double2sse): Remove.
+	(sse2float, sse2double, sse2floatfloat): Remove.
+	(ffi_closure_unix64): Rename from ffi_closure_UNIX64.  Rewrite
+	to handle structure returns properly.
+
+2004-12-08  David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.am (AM_MAKEFLAGS): Remove duplicate LIBCFLAGS and
+	PICFLAG.
+	* Makefile.in: Regenerated.
+
+2004-12-02  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.ac: Use TL_AC_GCC_VERSION to set gcc_version.
+	* configure, aclocal.m4, Makefile.in: Regenerate.
+	* include/Makefile.in, testsuite/Makefile.in: Regenerate.
+
+2004-11-29  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure: Regenerate for libtool change.
+
+2004-11-25  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure: Regenerate for libtool reversion.
+
+2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure: Regenerate for libtool change.
+
+2004-11-23  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* testsuite/lib/libffi-dg.exp: Use new procs in target-libpath.exp.
+
+2004-11-23  Richard Sandiford  <rsandifo@redhat.com>
+
+	* src/mips/o32.S (ffi_call_O32, ffi_closure_O32): Use jalr instead
+	of jal.  Use an absolute encoding for the frame information.
+
+2004-11-23  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* Makefile.am: Remove no-dependencies.  Add ACLOCAL_AMFLAGS.
+	* acinclude.m4: Delete logic for sincludes.
+	* aclocal.m4, Makefile.in, configure: Regenerate.
+	* include/Makefile: Likewise.
+	* testsuite/Makefile: Likewise.
+
+2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* src/sparc/ffi.c (ffi_prep_closure): Align doubles and 64-bit integers
+	on a 8-byte boundary.
+	* src/sparc/v8.S (ffi_closure_v8): Reserve frame space for arguments.
+
+2004-10-27  Richard Earnshaw  <rearnsha@arm.com>
+
+	* src/arm/ffi.c (ffi_prep_cif_machdep): Handle functions that return
+	long long values.  Round stack allocation to a multiple of 8 bytes
+	for ATPCS compatibility.
+	* src/arm/sysv.S (ffi_call_SYSV): Rework to avoid use of APCS register
+	names.  Handle returning long long types.  Add Thumb and interworking
+	support.  Improve soft-float code.
+
+2004-10-27  Richard Earnshaw  <rearnsha@arm.com>
+
+	* testsuite/lib/libffi-db.exp (load_gcc_lib): New function.
+	(libffi_exit): New function.
+	(libffi_init): Build the testglue wrapper if needed.
+
+2004-10-25  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR other/18138
+	* testsuite/lib/libffi-dg.exp: Accept more than one multilib libgcc.
+
+2004-10-25  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* src/m32r/libffitarget.h (FFI_CLOSURES): Set to 0.
+
+2004-10-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/sysv.S (ffi_call_SYSV): Don't align for double data.
+	* testsuite/libffi.call/float3.c: New test case.
+
+2004-10-18  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_prep_closure): Set T bit in trampoline for
+	the function returning a structure pointed with R2.
+	* src/sh/sysv.S (ffi_closure_SYSV): Use R2 as the pointer to
+	the structure return value if T bit set.  Emit position
+	independent code and EH data if PIC.
+
+2004-10-13  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>
+
+	* Makefile.am: Add m32r support.
+	* configure.ac: Likewise.
+	* Makefile.in: Regenerate.
+	* confiugre: Regenerate.
+	* src/types.c: Add m32r port to FFI_INTERNAL_TYPEDEF
+	(uint64, sint64, double, longdouble)
+	* src/m32r: New directory.
+	* src/m32r/ffi.c: New file.
+	* src/m32r/sysv.S: Likewise.
+	* src/m32r/ffitarget.h: Likewise.
+
+2004-10-02  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* testsuite/libffi.call/negint.c: New test case.
+
+2004-09-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libgcj/17465
+	* testsuite/lib/libffi-dg.exp: Don't use global ld_library_path.
+	Set up LD_LIBRARY_PATH, SHLIB_PATH, LD_LIBRARYN32_PATH,
+	LD_LIBRARY64_PATH, LD_LIBRARY_PATH_32, LD_LIBRARY_PATH_64 and
+	DYLD_LIBRARY_PATH.
+
+2004-09-05  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/many_win32.c: Remove whitespaces.
+	* testsuite/libffi.call/promotion.c: Likewise.
+	* testsuite/libffi.call/return_ll.c: Remove unused var. Cleanup
+	whitespaces.
+	* testsuite/libffi.call/return_sc.c: Likewise.
+	* testsuite/libffi.call/return_uc.c: Likewise.
+
+2004-09-05  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/darwin.S: Fix comments and identation.
+	* src/powerpc/darwin_closure.S: Likewise.
+
+2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/ffi_darwin.c: Add flag for longdouble return values.
+	(ffi_prep_args): Handle longdouble arguments.
+	(ffi_prep_cif_machdep): Set flags for longdouble. Calculate space for
+	longdouble.
+	(ffi_closure_helper_DARWIN): Add closure handling for longdouble.
+	* src/powerpc/darwin.S (_ffi_call_DARWIN): Add handling of longdouble
+	values.
+	* src/powerpc/darwin_closure.S (_ffi_closure_ASM): Likewise.
+	* src/types.c: Defined longdouble size and alignment for darwin.
+
+2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/aix.S: Remove whitespaces.
+	* src/powerpc/aix_closure.S: Likewise.
+	* src/powerpc/asm.h: Likewise.
+	* src/powerpc/ffi.c: Likewise.
+	* src/powerpc/ffitarget.h: Likewise.
+	* src/powerpc/linux64.S: Likewise.
+	* src/powerpc/linux64_closure.S: Likewise.
+	* src/powerpc/ppc_closure.S: Likewise.
+	* src/powerpc/sysv.S: Likewise.
+
+2004-08-30  Anthony Green  <green@redhat.com>
+
+	* Makefile.am: Add frv support.
+	* Makefile.in, testsuite/Makefile.in: Rebuilt.
+	* configure.ac: Read configure.host.
+	* configure.in: Read configure.host.
+	* configure.host: New file.  frv-elf needs libgloss.
+	* include/ffi.h.in: Force ffi_closure to have a nice big (8)
+	alignment.  This is needed to frv and shouldn't harm the others.
+	* include/ffi_common.h (ALIGN_DOWN): New macro.
+	* src/frv/ffi.c, src/frv/ffitarget.h, src/frv/eabi.S: New files.
+
+2004-08-24  David Daney  <daney@avtrex.com>
+
+	* testsuite/libffi.call/closure_fn0.c: Xfail mips64* instead of mips*.
+	* testsuite/libffi.call/closure_fn1.c: Likewise.
+	* testsuite/libffi.call/closure_fn2.c  Likewise.
+	* testsuite/libffi.call/closure_fn3.c: Likewise.
+	* testsuite/libffi.call/closure_fn4.c: Likewise.
+	* testsuite/libffi.call/closure_fn5.c: Likewise.
+	* testsuite/libffi.call/cls_18byte.c: Likewise.
+	* testsuite/libffi.call/cls_19byte.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte1.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_64byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_9byte1.c: Likewise.
+	* testsuite/libffi.call/cls_9byte2.c: Likewise.
+	* testsuite/libffi.call/cls_align_double.c: Likewise.
+	* testsuite/libffi.call/cls_align_float.c: Likewise.
+	* testsuite/libffi.call/cls_align_longdouble.c: Likewise.
+	* testsuite/libffi.call/cls_align_pointer.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint64.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint64.c: Likewise.
+	* testsuite/libffi.call/cls_double.c: Likewise.
+	* testsuite/libffi.call/cls_float.c: Likewise.
+	* testsuite/libffi.call/cls_multi_schar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_sshort.c: Likewise.
+	* testsuite/libffi.call/cls_multi_sshortchar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_ushort.c: Likewise.
+	* testsuite/libffi.call/cls_multi_ushortchar.c: Likewise.
+	* testsuite/libffi.call/cls_schar.c: Likewise.
+	* testsuite/libffi.call/cls_sint.c: Likewise.
+	* testsuite/libffi.call/cls_sshort.c: Likewise.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/nested_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct1.c: Likewise.
+	* testsuite/libffi.call/nested_struct2.c: Likewise.
+	* testsuite/libffi.call/nested_struct3.c: Likewise.
+	* testsuite/libffi.call/problem1.c: Likewise.
+	* testsuite/libffi.special/unwindtest.cc: Likewise.
+	* testsuite/libffi.call/cls_12byte.c: Likewise and set return value
+	to zero.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+
+2004-08-23  David Daney <daney@avtrex.com>
+
+	PR libgcj/13141
+	* src/mips/ffitarget.h (FFI_O32_SOFT_FLOAT): New ABI.
+	* src/mips/ffi.c (ffi_prep_args): Fix alignment calculation.
+	(ffi_prep_cif_machdep): Handle FFI_O32_SOFT_FLOAT floating point
+	parameters and return types.
+	(ffi_call): Handle FFI_O32_SOFT_FLOAT ABI.
+	(ffi_prep_closure): Ditto.
+	(ffi_closure_mips_inner_O32): Handle FFI_O32_SOFT_FLOAT ABI, fix
+	alignment calculations.
+	* src/mips/o32.S (ffi_closure_O32): Don't use floating point
+	instructions if FFI_O32_SOFT_FLOAT, make stack frame ABI compliant.
+
+2004-08-14  Casey Marshall <csm@gnu.org>
+
+	* src/mips/ffi.c (ffi_pref_cif_machdep): set `cif->flags' to
+	contain `FFI_TYPE_UINT64' as return type for any 64-bit
+	integer (O32 ABI only).
+	(ffi_prep_closure): new function.
+	(ffi_closure_mips_inner_O32): new function.
+	* src/mips/ffitarget.h: Define `FFI_CLOSURES' and
+	`FFI_TRAMPOLINE_SIZE' appropriately if the ABI is o32.
+	* src/mips/o32.S (ffi_call_O32): add labels for .eh_frame. Return
+	64 bit integers correctly.
+	(ffi_closure_O32): new function.
+	Added DWARF-2 unwind info for both functions.
+
+2004-08-10  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/ffi64.c (ffi_prep_args ): 8-align all stack arguments.
+
+2004-08-01  Robert Millan  <robertmh@gnu.org>
+
+	* configure.ac: Detect knetbsd-gnu and kfreebsd-gnu.
+	* configure: Regenerate.
+
+2004-07-30  Maciej W. Rozycki  <macro@linux-mips.org>
+
+	* acinclude.m4 (AC_FUNC_MMAP_BLACKLIST): Check for <sys/mman.h>
+	and mmap() explicitly instead of relying on preset autoconf cache
+	variables.
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+
+2004-07-11  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* src/s390/ffi.c (ffi_prep_args): Fix C aliasing violation.
+	(ffi_check_float_struct): Remove unused prototype.
+
+2004-06-30  Geoffrey Keating  <geoffk@apple.com>
+
+	* src/powerpc/ffi_darwin.c (flush_icache): ';' is a comment
+	character on Darwin, use '\n\t' instead.
+
+2004-06-26  Matthias Klose  <doko@debian.org>
+
+	* libtool-version: Fix typo in revision/age.
+
+2004-06-17  Matthias Klose  <doko@debian.org>
+
+	* libtool-version: New.
+	* Makefile.am (libffi_la_LDFLAGS): Use -version-info for soname.
+	* Makefile.in: Regenerate.
+
+2004-06-15  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.am: Remove useless multilib rules.
+	* Makefile.in: Regenerate.
+	* aclocal.m4: Regenerate with automake 1.8.5.
+	* configure.ac: Remove useless multilib configury.
+	* configure: Regenerate.
+
+2004-06-15  Paolo Bonzini  <bonzini@gnu.org>
+
+	* .cvsignore: New file.
+
+2004-06-10  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/ia64/unix.S (ffi_call_unix): Insert group barrier break
+	fp_done.
+	(ffi_closure_UNIX): Fix f14/f15 adjustment if FLOAT_SZ is ever
+	changed from 8.
+
+2004-06-06  Sean McNeil  <sean@mcneil.com>
+
+	* configure.ac: Add x86_64-*-freebsd* support.
+	* configure: Regenerate.
+
+2004-04-26  Joe Buck <jbuck@welsh-buck.org>
+
+	Bug 15093
+	* configure.ac: Test for existence of mmap and sys/mman.h before
+	checking blacklist.  Fix suggested by Jim Wilson.
+	* configure: Regenerate.
+
+2004-04-26  Matt Austern  <austern@apple.com>
+
+	* src/powerpc/darwin.S: Go through a non-lazy pointer for initial
+	FDE location.
+	* src/powerpc/darwin_closure.S: Likewise.
+
+2004-04-24  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/cls_multi_schar.c (main): Fix initialization
+	error. Reported by Thomas Heller <theller@python.net>.
+	* testsuite/libffi.call/cls_multi_sshort.c (main): Likewise.
+	* testsuite/libffi.call/cls_multi_ushort.c (main): Likewise.
+
+2004-03-20  Matthias Klose  <doko@debian.org>
+
+	* src/pa/linux.S: Fix typo.
+
+2004-03-19  Matthias Klose  <doko@debian.org>
+
+	* Makefile.am: Update.
+	* Makefile.in: Regenerate.
+	* src/pa/ffi.h.in: Remove.
+	* src/pa/ffitarget.h: New file.
+
+2004-02-10  Randolph Chung  <tausq@debian.org>
+
+	* Makefile.am: Add PA support.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* configure.ac: Add PA target.
+	* configure: Regenerate.
+	* src/pa/ffi.c: New file.
+	* src/pa/ffi.h.in: Add PA support.
+	* src/pa/linux.S: New file.
+	* prep_cif.c: Add PA support.
+
+2004-03-16  Hosaka Yuji  <hos@tamanegi.org>
+
+	* src/types.c: Fix alignment size of X86_WIN32 case int64 and
+	double.
+	* src/x86/ffi.c (ffi_prep_args): Replace ecif->cif->rtype->type
+	with ecif->cif->flags.
+	(ffi_call, ffi_prep_incoming_args_SYSV): Replace cif->rtype->type
+	with cif->flags.
+	(ffi_prep_cif_machdep): Add X86_WIN32 struct case.
+	(ffi_closure_SYSV): Add 1 or 2-bytes struct case for X86_WIN32.
+	* src/x86/win32.S (retstruct1b, retstruct2b, sc_retstruct1b,
+	sc_retstruct2b): Add for 1 or 2-bytes struct case.
+
+2004-03-15 Kelley Cook <kcook@gcc.gnu.org>
+
+	* configure.in: Rename file to ...
+	* configure.ac: ... this.
+	* fficonfig.h.in: Regenerate.
+	* Makefile.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2004-03-12  Matt Austern  <austern@apple.com>
+
+	* src/powerpc/darwin.S: Fix EH information so it corresponds to
+	changes in EH format resulting from addition of linkonce support.
+	* src/powerpc/darwin_closure.S: Likewise.
+
+2004-03-11  Andreas Tobler  <a.tobler@schweiz.ch>
+	    Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.am (AUTOMAKE_OPTIONS): Set them.
+	Remove VPATH. Remove rules for object files. Remove multilib support.
+	(AM_CCASFLAGS): Add.
+	* configure.in (AC_CONFIG_HEADERS): Relace AM_CONFIG_HEADER.
+	(AC_PREREQ): Bump version to 2.59.
+	(AC_INIT): Fill with version info and bug address.
+	(ORIGINAL_LD_FOR_MULTILIBS): Remove.
+	(AM_ENABLE_MULTILIB): Use this instead of AC_ARG_ENABLE.
+	De-precious CC so that the right flags are passed down to multilibs.
+	(AC_MSG_ERROR): Replace obsolete macro AC_ERROR.
+	(AC_CONFIG_FILES): Replace obsolete macro AC_LINK_FILES.
+	(AC_OUTPUT): Reorganize the output with AC_CONFIG_COMMANDS.
+	* configure: Rebuilt.
+	* aclocal.m4: Likewise.
+	* Makefile.in, include/Makefile.in, testsuite/Makefile.in: Likewise.
+	* fficonfig.h.in: Likewise.
+
+2004-03-11  Andreas Schwab  <schwab@suse.de>
+
+	* src/ia64/ffi.c (ffi_prep_incoming_args_UNIX): Get floating point
+	arguments from fp registers only for the first 8 parameter slots.
+	Don't convert a float parameter when passed in memory.
+
+2004-03-09  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure: Regenerate for config/accross.m4 correction.
+
+2004-02-25  Matt Kraai  <kraai@alumni.cmu.edu>
+
+	* src/powerpc/ffi.c (ffi_prep_args_SYSV): Change
+	ecif->cif->bytes to bytes.
+	(ffi_prep_cif_machdep): Add braces around nested if statement.
+
+2004-02-09  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/types.c (pointer): POWERPC64 has 8 byte pointers.
+
+	* src/powerpc/ffi.c (ffi_prep_args64): Correct long double handling.
+	(ffi_closure_helper_LINUX64): Fix typo.
+	* testsuite/libffi.call/cls_align_longdouble.c: Pass -mlong-double-128
+	for powerpc64-*-*.
+	* testsuite/libffi.call/float.c: Likewise.
+	* testsuite/libffi.call/float2.c: Likewise.
+
+2004-02-08  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/powerpc/ffi.c (ffi_prep_cif_machdep <FFI_LINUX64>): Correct
+	long double function return and long double arg handling.
+	(ffi_closure_helper_LINUX64): Formatting.  Delete unused "ng" var.
+	Use "end_pfr" instead of "nf".  Correct long double handling.
+	Localise "temp".
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Save f2 long double
+	return value.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Allocate
+	space for long double return value.  Adjust stack frame and offsets.
+	Load f2 long double return.
+
+2004-02-07  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/types.c: Use 16 byte long double for POWERPC64.
+
+2004-01-25  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* src/sparc/ffi.c (ffi_prep_args_v9): Shift the parameter array
+	when the structure return address is passed in %o0.
+	(ffi_V9_return_struct): Rename into ffi_v9_layout_struct.
+	(ffi_v9_layout_struct): Align the field following a nested structure
+	on a word boundary.  Use memmove instead of memcpy.
+	(ffi_call): Update call to ffi_V9_return_struct.
+	(ffi_prep_closure): Define 'ctx' only for V8.
+	(ffi_closure_sparc_inner): Clone into ffi_closure_sparc_inner_v8
+	and ffi_closure_sparc_inner_v9.
+	(ffi_closure_sparc_inner_v8): Return long doubles by reference.
+	Always skip the structure return address.  For structures and long
+	doubles, copy the argument directly.
+	(ffi_closure_sparc_inner_v9): Skip the structure return address only
+	if required.  Shift the maximum floating-point slot accordingly.  For
+	big structures, copy the argument directly; otherwise, left-justify the
+	argument and call ffi_v9_layout_struct to lay out the structure on
+	the stack.
+	* src/sparc/v8.S: Undef STACKFRAME before defining it.
+	(ffi_closure_v8): Pass the structure return address.  Update call to
+	ffi_closure_sparc_inner_v8.  Short-circuit FFI_TYPE_INT handling.
+	Skip the 'unimp' insn when returning long doubles and structures.
+	* src/sparc/v9.S: Undef STACKFRAME before defining it.
+	(ffi_closure_v9): Increase the frame size by 2 words.  Short-circuit
+	FFI_TYPE_INT handling.  Load structures both in integers and
+	floating-point registers on return.
+	* README: Update status of the SPARC port.
+
+2004-01-24  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/pyobjc-tc.c (main): Treat result value
+	as of type ffi_arg.
+	* testsuite/libffi.call/struct3.c (main): Fix CHECK.
+
+2004-01-22  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* testsuite/libffi.call/cls_uint.c (cls_ret_uint_fn): Treat result
+	value as of type ffi_arg, not unsigned int.
+
+2004-01-21  Michael Ritzert  <ritzert@t-online.de>
+
+	* ffi64.c (ffi_prep_args): Cast the RHS of an assignment instead
+	of the LHS.
+
+2004-01-12  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/lib/libffi-dg.exp: Set LD_LIBRARY_PATH_32 for
+	Solaris.
+
+2004-01-08  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/ffitest.h (allocate_mmap): Cast MAP_FAILED
+	to void *.
+
+2003-12-10  Richard Henderson  <rth@redhat.com>
+
+	* testsuite/libffi.call/cls_align_pointer.c: Cast pointers to
+	size_t instead of int.
+
+2003-12-04  Hosaka Yuji  <hos@tamanegi.org>
+
+	* testsuite/libffi.call/many_win32.c: Include <float.h>.
+	* testsuite/libffi.call/many_win32.c (main): Replace variable
+	int i with unsigned long ul.
+
+	* testsuite/libffi.call/cls_align_uint64.c: New test case.
+	* testsuite/libffi.call/cls_align_sint64.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint32.c: Likewise.
+	* testsuite/libffi.call/cls_align_uint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_sint16.c: Likewise.
+	* testsuite/libffi.call/cls_align_float.c: Likewise.
+	* testsuite/libffi.call/cls_align_double.c: Likewise.
+	* testsuite/libffi.call/cls_align_longdouble.c: Likewise.
+	* testsuite/libffi.call/cls_align_pointer.c: Likewise.
+
+2003-12-02  Hosaka Yuji  <hos@tamanegi.org>
+
+	PR other/13221
+	* src/x86/ffi.c (ffi_prep_args, ffi_prep_incoming_args_SYSV):
+	Align arguments to 32 bits.
+
+2003-12-01  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	PR other/13221
+	* testsuite/libffi.call/cls_multi_sshort.c: New test case.
+	* testsuite/libffi.call/cls_multi_sshortchar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_schar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_ushortchar.c: Likewise.
+	* testsuite/libffi.call/cls_multi_ushort.c: Likewise.
+
+	* testsuite/libffi.special/unwindtest.cc: Cosmetics.
+
+2003-11-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* testsuite/libffi.call/ffitest.h: Include <fcntl.h>.
+	* testsuite/libffi.special/ffitestcxx.h: Likewise.
+
+2003-11-22  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* Makefile.in: Rebuilt.
+	* configure: Likewise.
+	* testsuite/libffi.special/unwindtest.cc: Convert the mmap to
+	the right type.
+
+2003-11-21  Andreas Jaeger  <aj@suse.de>
+	    Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* acinclude.m4: Add AC_FUNC_MMAP_BLACKLIST.
+	* configure.in: Call AC_FUNC_MMAP_BLACKLIST.
+	* Makefile.in: Rebuilt.
+	* aclocal.m4: Likewise.
+	* configure: Likewise.
+	* fficonfig.h.in: Likewise.
+	* testsuite/lib/libffi-dg.exp: Add include dir.
+	* testsuite/libffi.call/ffitest.h: Add MMAP definitions.
+	* testsuite/libffi.special/ffitestcxx.h: Likewise.
+	* testsuite/libffi.call/closure_fn0.c: Use MMAP functionality
+	for ffi_closure if available.
+	* testsuite/libffi.call/closure_fn1.c: Likewise.
+	* testsuite/libffi.call/closure_fn2.c: Likewise.
+	* testsuite/libffi.call/closure_fn3.c: Likewise.
+	* testsuite/libffi.call/closure_fn4.c: Likewise.
+	* testsuite/libffi.call/closure_fn5.c: Likewise.
+	* testsuite/libffi.call/cls_12byte.c: Likewise.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_18byte.c: Likewise.
+	* testsuite/libffi.call/cls_19byte.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte1.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+	* testsuite/libffi.call/cls_64byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_9byte1.c: Likewise.
+	* testsuite/libffi.call/cls_9byte2.c: Likewise.
+	* testsuite/libffi.call/cls_double.c: Likewise.
+	* testsuite/libffi.call/cls_float.c: Likewise.
+	* testsuite/libffi.call/cls_schar.c: Likewise.
+	* testsuite/libffi.call/cls_sint.c: Likewise.
+	* testsuite/libffi.call/cls_sshort.c: Likewise.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/nested_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct1.c: Likewise.
+	* testsuite/libffi.call/nested_struct2.c: Likewise.
+	* testsuite/libffi.call/nested_struct3.c: Likewise.
+	* testsuite/libffi.call/problem1.c: Likewise.
+	* testsuite/libffi.special/unwindtest.cc: Likewise.
+
+2003-11-20  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/lib/libffi-dg.exp: Make the -lgcc_s conditional.
+
+2003-11-19  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/lib/libffi-dg.exp: Add DYLD_LIBRARY_PATH for darwin.
+	Add -lgcc_s to additional flags.
+
+2003-11-12  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* configure.in, include/Makefile.am: PR libgcj/11147, install
+	the ffitarget.h header file in a gcc versioned and target
+	dependent place.
+	* configure: Regenerated.
+	* Makefile.in, include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2003-11-09  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/closure_fn0.c: Print result and check
+	with dg-output to make debugging easier.
+	* testsuite/libffi.call/closure_fn1.c: Likewise.
+	* testsuite/libffi.call/closure_fn2.c: Likewise.
+	* testsuite/libffi.call/closure_fn3.c: Likewise.
+	* testsuite/libffi.call/closure_fn4.c: Likewise.
+	* testsuite/libffi.call/closure_fn5.c: Likewise.
+	* testsuite/libffi.call/cls_12byte.c: Likewise.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_18byte.c: Likewise.
+	* testsuite/libffi.call/cls_19byte.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte1.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+	* testsuite/libffi.call/cls_64byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_9byte1.c: Likewise.
+	* testsuite/libffi.call/cls_9byte2.c: Likewise.
+	* testsuite/libffi.call/cls_double.c: Likewise.
+	* testsuite/libffi.call/cls_float.c: Likewise.
+	* testsuite/libffi.call/cls_schar.c: Likewise.
+	* testsuite/libffi.call/cls_sint.c: Likewise.
+	* testsuite/libffi.call/cls_sshort.c: Likewise.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/problem1.c: Likewise.
+
+	* testsuite/libffi.special/unwindtest.cc: Make ffi_closure
+	static.
+
+2003-11-08  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/cls_9byte2.c: New test case.
+	* testsuite/libffi.call/cls_9byte1.c: Likewise.
+	* testsuite/libffi.call/cls_64byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte1.c: Likewise.
+	* testsuite/libffi.call/cls_19byte.c: Likewise.
+	* testsuite/libffi.call/cls_18byte.c: Likewise.
+	* testsuite/libffi.call/closure_fn4.c: Likewise.
+	* testsuite/libffi.call/closure_fn5.c: Likewise.
+	* testsuite/libffi.call/cls_schar.c: Likewise.
+	* testsuite/libffi.call/cls_sint.c: Likewise.
+	* testsuite/libffi.call/cls_sshort.c: Likewise.
+	* testsuite/libffi.call/nested_struct2.c: Likewise.
+	* testsuite/libffi.call/nested_struct3.c: Likewise.
+
+2003-11-08  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/cls_double.c: Do a check on the result.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/return_sc.c: Cleanup whitespaces.
+
+2003-11-06  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/prep_cif.c (ffi_prep_cif): Move the validity check after
+	the initialization.
+
+2003-10-23  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/java_raw_api.c (ffi_java_ptrarray_to_raw): Replace
+	FFI_ASSERT(FALSE) with FFI_ASSERT(0).
+
+2003-10-22  David Daney  <ddaney@avtrex.com>
+
+	* src/mips/ffitarget.h: Replace undefined UINT32 and friends with
+	__attribute__((__mode__(__SI__))) and friends.
+
+2003-10-22  Andreas Schwab  <schwab@suse.de>
+
+	* src/ia64/ffi.c: Replace FALSE/TRUE with false/true.
+
+2003-10-21  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* configure.in: AC_LINK_FILES(ffitarget.h).
+	* configure: Regenerate.
+	* Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+	* fficonfig.h.in: Likewise.
+
+2003-10-21  Paolo Bonzini  <bonzini@gnu.org>
+	    Richard Henderson  <rth@redhat.com>
+
+	Avoid that ffi.h includes fficonfig.h.
+
+	* Makefile.am (EXTRA_DIST): Include ffitarget.h files
+	(TARGET_SRC_MIPS_GCC): Renamed to TARGET_SRC_MIPS_IRIX.
+	(TARGET_SRC_MIPS_SGI): Removed.
+	(MIPS_GCC): Renamed to TARGET_SRC_MIPS_IRIX.
+	(MIPS_SGI): Removed.
+	(CLEANFILES): Removed.
+	(mostlyclean-am, clean-am, mostlyclean-sub, clean-sub): New
+	targets.
+	* acconfig.h: Removed.
+	* configure.in: Compute sizeofs only for double and long double.
+	Use them to define and subst HAVE_LONG_DOUBLE.  Include comments
+	into AC_DEFINE instead of using acconfig.h.  Create
+	include/ffitarget.h instead of include/fficonfig.h.  Rename
+	MIPS_GCC to MIPS_IRIX, drop MIPS_SGI since we are in gcc's tree.
+	AC_DEFINE EH_FRAME_FLAGS.
+	* include/Makefile.am (DISTCLEANFILES): New automake macro.
+	(hack_DATA): Add ffitarget.h.
+	* include/ffi.h.in: Remove all system specific definitions.
+	Declare raw API even if it is not installed, why bother?
+	Use limits.h instead of SIZEOF_* to define ffi_type_*.  Do
+	not define EH_FRAME_FLAGS, it is in fficonfig.h now.  Include
+	ffitarget.h instead of fficonfig.h.  Remove ALIGN macro.
+	(UINT_ARG, INT_ARG): Removed, use ffi_arg and ffi_sarg instead.
+	* include/ffi_common.h (bool): Do not define.
+	(ffi_assert): Accept failed assertion.
+	(ffi_type_test): Return void and accept file/line.
+	(FFI_ASSERT): Pass stringized failed assertion.
+	(FFI_ASSERT_AT): New macro.
+	(FFI_ASSERT_VALID_TYPE): New macro.
+	(UINT8, SINT8, UINT16, SINT16, UINT32, SINT32,
+	UINT64, SINT64): Define here with gcc's __attribute__ macro
+	instead of in ffi.h
+	(FLOAT32, ALIGN): Define here instead of in ffi.h
+	* include/ffi-mips.h: Removed.  Its content moved to
+	src/mips/ffitarget.h after separating assembly and C sections.
+	* src/alpha/ffi.c, src/alpha/ffi.c, src/java_raw_api.c
+	src/prep_cif.c, src/raw_api.c, src/ia64/ffi.c,
+	src/mips/ffi.c, src/mips/n32.S, src/mips/o32.S,
+	src/mips/ffitarget.h, src/sparc/ffi.c, src/x86/ffi64.c:
+	SIZEOF_ARG -> FFI_SIZEOF_ARG.
+	* src/ia64/ffi.c: Include stdbool.h (provided by GCC 2.95+).
+	* src/debug.c (ffi_assert): Accept stringized failed assertion.
+	(ffi_type_test): Rewritten.
+	* src/prep-cif.c (initialize_aggregate, ffi_prep_cif): Call
+	FFI_ASSERT_VALID_TYPE.
+	* src/alpha/ffitarget.h, src/arm/ffitarget.h,
+	src/ia64/ffitarget.h, src/m68k/ffitarget.h,
+	src/mips/ffitarget.h, src/powerpc/ffitarget.h,
+	src/s390/ffitarget.h, src/sh/ffitarget.h,
+	src/sh64/ffitarget.h, src/sparc/ffitarget.h,
+	src/x86/ffitarget.h: New files.
+	* src/alpha/osf.S, src/arm/sysv.S, src/ia64/unix.S,
+	src/m68k/sysv.S, src/mips/n32.S, src/mips/o32.S,
+	src/powerpc/aix.S, src/powerpc/darwin.S,
+	src/powerpc/ffi_darwin.c, src/powerpc/linux64.S,
+	src/powerpc/linux64_closure.S, src/powerpc/ppc_closure.S,
+	src/powerpc/sysv.S, src/s390/sysv.S, src/sh/sysv.S,
+	src/sh64/sysv.S, src/sparc/v8.S, src/sparc/v9.S,
+	src/x86/sysv.S, src/x86/unix64.S, src/x86/win32.S:
+	include fficonfig.h
+
+2003-10-20  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* src/mips/ffi.c: Use _ABIN32, _ABIO32 instead of external
+	_MIPS_SIM_NABI32, _MIPS_SIM_ABI32.
+
+2003-10-19  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Declare bytes again.
+	Used when FFI_DEBUG = 1.
+
+2003-10-14  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/types.c (double, longdouble): Default POWERPC64 to 8 byte size
+	and align.
+
+2003-10-06  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* include/ffi_mips.h: Define FFI_MIPS_N32 for N32/N64 ABIs,
+	FFI_MIPS_O32 for O32 ABI.
+
+2003-10-01  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/lib/libffi-dg.exp: Set LD_LIBRARY_PATH_64 for
+	SPARC64. Cleanup whitespaces.
+
+2003-09-19  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* testsuite/libffi.call/closure_fn0.c: Xfail mips, arm,
+	strongarm, xscale. Cleanup whitespaces.
+	* testsuite/libffi.call/closure_fn1.c: Likewise.
+	* testsuite/libffi.call/closure_fn2.c: Likewise.
+	* testsuite/libffi.call/closure_fn3.c: Likewise.
+	* testsuite/libffi.call/cls_12byte.c: Likewise.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_double.c: Likewise.
+	* testsuite/libffi.call/cls_float.c: Likewise.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/nested_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct1.c: Likewise.
+	* testsuite/libffi.call/problem1.c: Likewise.
+	* testsuite/libffi.special/unwindtest.cc: Likewise.
+	* testsuite/libffi.call/pyobjc-tc.c: Cleanup whitespaces.
+
+2003-09-18  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/aix.S: Cleanup whitespaces.
+	* src/powerpc/aix_closure.S: Likewise.
+
+2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/darwin.S: Cleanup whitespaces, comment formatting.
+	* src/powerpc/darwin_closure.S: Likewise.
+	* src/powerpc/ffi_darwin.c: Likewise.
+
+2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>
+	    David Edelsohn  <edelsohn@gnu.org>
+
+	* src/types.c (double): Add AIX and Darwin to the right TYPEDEF.
+	* src/powerpc/aix_closure.S: Remove the pointer to the outgoing
+	parameter stack.
+	* src/powerpc/darwin_closure.S: Likewise.
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Handle structures
+	according to the Darwin/AIX ABI.
+	(ffi_prep_cif_machdep): Likewise.
+	(ffi_closure_helper_DARWIN): Likewise.
+	Remove the outgoing parameter stack logic. Simplify the evaluation
+	of the different CASE types.
+	(ffi_prep_clousure): Avoid the casts on lvalues. Change the branch
+	statement in the trampoline code.
+
+2003-09-18  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_prep_args): Take account into the alignement
+	for the register size.
+	(ffi_closure_helper_SYSV): Handle the structure return value
+	address correctly.
+	(ffi_closure_helper_SYSV): Return the appropriate type when
+	the registers are used for the structure return value.
+	* src/sh/sysv.S (ffi_closure_SYSV): Fix the stack layout for
+	the 64-bit return value.  Update copyright years.
+
+2003-09-17  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* testsuite/lib/libffi-dg.exp (libffi_target_compile): Search in
+	srcdir for ffi_mips.h.
+
+2003-09-12  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/prep_cif.c (initialize_aggregate): Include tail padding in
+	structure size.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Correct
+	placement of float result.
+	* testsuite/libffi.special/unwindtest.cc (closure_test_fn1): Correct
+	cast of "resp" for big-endian 64 bit machines.
+
+2003-09-11  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/types.c (double, longdouble): Merge identical SH and ARM
+	typedefs, and add POWERPC64.
+	* src/powerpc/ffi.c (ffi_prep_args64): Correct next_arg calc for
+	struct split over gpr and rest.
+	(ffi_prep_cif_machdep): Correct intarg_count for structures.
+	* src/powerpc/linux64.S (ffi_call_LINUX64): Fix gpr offsets.
+
+2003-09-09  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/ffi.c (ffi_closure_helper_SYSV) Handle struct
+	passing correctly.
+
+2003-09-09  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure: Regenerate.
+
+2003-09-04  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* Makefile.am: Remove build rules for ffitest.
+	* Makefile.in: Rebuilt.
+
+2003-09-04  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/java_raw_api.c: Include <stdlib.h> to fix compiler warning
+	about implicit declaration of abort().
+
+2003-09-04  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* Makefile.am: Add dejagnu test framework. Fixes PR other/11411.
+	* Makefile.in: Rebuilt.
+	* configure.in: Add dejagnu test framework.
+	* configure: Rebuilt.
+
+	* testsuite/Makefile.am: New file.
+	* testsuite/Makefile.in: Built
+	* testsuite/lib/libffi-dg.exp: New file.
+	* testsuite/config/default.exp: Likewise.
+	* testsuite/libffi.call/call.exp: Likewise.
+	* testsuite/libffi.call/ffitest.h: Likewise.
+	* testsuite/libffi.call/closure_fn0.c: Likewise.
+	* testsuite/libffi.call/closure_fn1.c: Likewise.
+	* testsuite/libffi.call/closure_fn2.c: Likewise.
+	* testsuite/libffi.call/closure_fn3.c: Likewise.
+	* testsuite/libffi.call/cls_1_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_3_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_4_1byte.c: Likewise.
+	* testsuite/libffi.call/cls_2byte.c: Likewise.
+	* testsuite/libffi.call/cls_3byte1.c: Likewise.
+	* testsuite/libffi.call/cls_3byte2.c: Likewise.
+	* testsuite/libffi.call/cls_4byte.c: Likewise.
+	* testsuite/libffi.call/cls_5byte.c: Likewise.
+	* testsuite/libffi.call/cls_6byte.c: Likewise.
+	* testsuite/libffi.call/cls_7byte.c: Likewise.
+	* testsuite/libffi.call/cls_8byte.c: Likewise.
+	* testsuite/libffi.call/cls_12byte.c: Likewise.
+	* testsuite/libffi.call/cls_16byte.c: Likewise.
+	* testsuite/libffi.call/cls_20byte.c: Likewise.
+	* testsuite/libffi.call/cls_24byte.c: Likewise.
+	* testsuite/libffi.call/cls_double.c: Likewise.
+	* testsuite/libffi.call/cls_float.c: Likewise.
+	* testsuite/libffi.call/cls_uchar.c: Likewise.
+	* testsuite/libffi.call/cls_uint.c: Likewise.
+	* testsuite/libffi.call/cls_ulonglong.c: Likewise.
+	* testsuite/libffi.call/cls_ushort.c: Likewise.
+	* testsuite/libffi.call/float.c: Likewise.
+	* testsuite/libffi.call/float1.c: Likewise.
+	* testsuite/libffi.call/float2.c: Likewise.
+	* testsuite/libffi.call/many.c: Likewise.
+	* testsuite/libffi.call/many_win32.c: Likewise.
+	* testsuite/libffi.call/nested_struct.c: Likewise.
+	* testsuite/libffi.call/nested_struct1.c: Likewise.
+	* testsuite/libffi.call/pyobjc-tc.c: Likewise.
+	* testsuite/libffi.call/problem1.c: Likewise.
+	* testsuite/libffi.call/promotion.c: Likewise.
+	* testsuite/libffi.call/return_ll.c: Likewise.
+	* testsuite/libffi.call/return_sc.c: Likewise.
+	* testsuite/libffi.call/return_uc.c: Likewise.
+	* testsuite/libffi.call/strlen.c: Likewise.
+	* testsuite/libffi.call/strlen_win32.c: Likewise.
+	* testsuite/libffi.call/struct1.c: Likewise.
+	* testsuite/libffi.call/struct2.c: Likewise.
+	* testsuite/libffi.call/struct3.c: Likewise.
+	* testsuite/libffi.call/struct4.c: Likewise.
+	* testsuite/libffi.call/struct5.c: Likewise.
+	* testsuite/libffi.call/struct6.c: Likewise.
+	* testsuite/libffi.call/struct7.c: Likewise.
+	* testsuite/libffi.call/struct8.c: Likewise.
+	* testsuite/libffi.call/struct9.c: Likewise.
+	* testsuite/libffi.special/special.exp: New file.
+	* testsuite/libffi.special/ffitestcxx.h: Likewise.
+	* testsuite/libffi.special/unwindtest.cc: Likewise.
+
+
+2003-08-13  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (OFS_INT16): Set 0 for little endian case.  Update
+	copyright years.
+
+2003-08-02  Alan Modra  <amodra@bigpond.net.au>
+
+	* src/powerpc/ffi.c (ffi_prep_args64): Modify for changed gcc
+	structure passing.
+	(ffi_closure_helper_LINUX64): Likewise.
+	* src/powerpc/linux64.S: Remove code writing to parm save area.
+	* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Use return
+	address in lr from ffi_closure_helper_LINUX64 call to calculate
+	table address.  Optimize function tail.
+
+2003-07-28  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/sparc/ffi.c: Handle all floating point registers.
+	* src/sparc/v9.S: Likewise. Fixes second part of PR target/11410.
+
+2003-07-11  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
+
+	* README: Note that libffi is not part of GCC.  Update the project
+	URL and status.
+
+2003-06-19  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* src/powerpc/ppc_closure.S: Include ffi.h.
+
+2003-06-13  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* src/x86/sysv.S: Avoid gas-only .uleb128/.sleb128 directives.
+	Use C style comments.
+
+2003-06-13  Kaz Kojima  <kkojima@rr.iij4u.or.jp>
+
+	* Makefile.am: Add SHmedia support.  Fix a typo of SH support.
+	* Makefile.in: Regenerate.
+	* configure.in (sh64-*-linux*, sh5*-*-linux*): Add target.
+	* configure: Regenerate.
+	* include/ffi.h.in: Add SHmedia support.
+	* src/sh64/ffi.c: New file.
+	* src/sh64/sysv.S: New file.
+
+2003-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (HAVE_RO_EH_FRAME): Check whether .eh_frame section
+	should be read-only.
+	* configure: Rebuilt.
+	* fficonfig.h.in: Rebuilt.
+	* include/ffi.h.in (EH_FRAME_FLAGS): Define.
+	* src/alpha/osf.S: Use EH_FRAME_FLAGS.
+	* src/powerpc/linux64.S: Likewise.
+	* src/powerpc/linux64_closure.S: Likewise.  Include ffi.h.
+	* src/powerpc/sysv.S: Use EH_FRAME_FLAGS.  Use pcrel encoding
+	if -fpic/-fPIC/-mrelocatable.
+	* src/powerpc/powerpc_closure.S: Likewise.
+	* src/sparc/v8.S: If HAVE_RO_EH_FRAME is defined, don't include
+	#write in .eh_frame flags.
+	* src/sparc/v9.S: Likewise.
+	* src/x86/unix64.S: Use EH_FRAME_FLAGS.
+	* src/x86/sysv.S: Likewise.  Use pcrel encoding if -fpic/-fPIC.
+	* src/s390/sysv.S: Use EH_FRAME_FLAGS.  Include ffi.h.
+
+2003-05-07  Jeff Sturm  <jsturm@one-point.com>
+
+	Fixes PR bootstrap/10656
+	* configure.in (HAVE_AS_REGISTER_PSEUDO_OP): Test assembler
+	support for .register pseudo-op.
+	* src/sparc/v8.S: Use it.
+	* fficonfig.h.in: Rebuilt.
+	* configure: Rebuilt.
+
+2003-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/ffi.h.in (POWERPC64): Define if 64-bit.
+	(enum ffi_abi): Add FFI_LINUX64 on POWERPC.
+	Make it the default on POWERPC64.
+	(FFI_TRAMPOLINE_SIZE): Define to 24 on POWERPC64.
+	* configure.in: Change powerpc-*-linux* into powerpc*-*-linux*.
+	* configure: Rebuilt.
+	* src/powerpc/ffi.c (hidden): Define.
+	(ffi_prep_args_SYSV): Renamed from
+	ffi_prep_args.  Cast pointers to unsigned long to shut up warnings.
+	(NUM_GPR_ARG_REGISTERS64, NUM_FPR_ARG_REGISTERS64,
+	ASM_NEEDS_REGISTERS64): New.
+	(ffi_prep_args64): New function.
+	(ffi_prep_cif_machdep): Handle FFI_LINUX64 ABI.
+	(ffi_call): Likewise.
+	(ffi_prep_closure): Likewise.
+	(flush_icache): Surround by #ifndef POWERPC64.
+	(ffi_dblfl): New union type.
+	(ffi_closure_helper_SYSV): Use it to avoid aliasing problems.
+	(ffi_closure_helper_LINUX64): New function.
+	* src/powerpc/ppc_closure.S: Surround whole file by #ifndef
+	__powerpc64__.
+	* src/powerpc/sysv.S: Likewise.
+	(ffi_call_SYSV): Rename ffi_prep_args to ffi_prep_args_SYSV.
+	* src/powerpc/linux64.S: New file.
+	* src/powerpc/linux64_closure.S: New file.
+	* Makefile.am (EXTRA_DIST): Add src/powerpc/linux64.S and
+	src/powerpc/linux64_closure.S.
+	(TARGET_SRC_POWERPC): Likewise.
+
+	* src/ffitest.c (closure_test_fn, closure_test_fn1, closure_test_fn2,
+	closure_test_fn3): Fix result printing on big-endian 64-bit
+	machines.
+	(main): Print tst2_arg instead of uninitialized tst2_result.
+
+	* src/ffitest.c (main): Hide what closure pointer really points to
+	from the compiler.
+
+2003-04-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	* configure.in (arm-*-netbsdelf*): Add configuration.
+	(configure): Regenerated.
+
+2003-04-04  Loren J. Rittle  <ljrittle@acm.org>
+
+	* include/Makefile.in: Regenerate.
+
+2003-03-21  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>
+
+	* libffi/include/ffi.h.in: Define X86 instead of X86_64 in 32
+	bit mode.
+	* libffi/src/x86/ffi.c (ffi_closure_SYSV, ffi_closure_raw_SYSV):
+	Receive closure pointer through parameter, read args using
+	__builtin_dwarf_cfa.
+	(FFI_INIT_TRAMPOLINE): Send closure reference through eax.
+
+2003-03-12  Andreas Schwab  <schwab@suse.de>
+
+	* configure.in: Avoid trailing /. in toolexeclibdir.
+	* configure: Rebuilt.
+
+2003-03-03  Andreas Tobler <a.tobler@schweiz.ch>
+
+	* src/powerpc/darwin_closure.S: Recode to fit dynamic libraries.
+
+2003-02-06  Andreas Tobler <a.tobler@schweiz.ch>
+
+	* libffi/src/powerpc/darwin_closure.S:
+	Fix alignement bug, allocate 8 bytes for the result.
+	* libffi/src/powerpc/aix_closure.S:
+	Likewise.
+	* libffi/src/powerpc/ffi_darwin.c:
+	Update stackframe description for aix/darwin_closure.S.
+
+2003-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/s390/ffi.c (ffi_closure_helper_SYSV): Add hidden visibility
+	attribute.
+
+2003-01-31  Christian Cornelssen  <ccorn@cs.tu-berlin.de>,
+	    Andreas Schwab  <schwab@suse.de>
+
+	* configure.in: Adjust command to source config-ml.in to account
+	for changes to the libffi_basedir definition.
+	(libffi_basedir): Remove ${srcdir} from value and include trailing
+	slash if nonempty.
+
+	* configure: Regenerate.
+
+2003-01-29  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* src/powerpc/ppc_closure.S: Recode to fit shared libs.
+
+2003-01-28  Andrew Haley  <aph@redhat.com>
+
+	* include/ffi.h.in: Enable FFI_CLOSURES for x86_64.
+	* src/x86/ffi64.c (ffi_prep_closure): New.
+	(ffi_closure_UNIX64_inner): New.
+	* src/x86/unix64.S (ffi_closure_UNIX64): New.
+
+2003-01-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (toolexecdir, toolexeclibdir): Set and AC_SUBST.
+	Remove USE_LIBDIR conditional.
+	* Makefile.am (toolexecdir, toolexeclibdir): Don't override.
+	* Makefile.in, configure: Rebuilt.
+
+2003-01027  David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.am (TARGET_SRC_POWERPC_AIX): Fix typo.
+	* Makefile.in: Regenerate.
+
+2003-01-22  Andrew Haley  <aph@redhat.com>
+
+	* src/powerpc/darwin.S (_ffi_call_AIX): Add Augmentation size to
+	unwind info.
+
+2003-01-21  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/darwin.S: Add unwind info.
+	* src/powerpc/darwin_closure.S: Likewise.
+
+2003-01-14  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/ffi64.c (ffi_prep_args): Check for void retval.
+	(ffi_prep_cif_machdep): Likewise.
+	* src/x86/unix64.S: Add unwind info.
+
+2003-01-14  Andreas Jaeger  <aj@suse.de>
+
+	* src/ffitest.c (main): Only use ffi_closures if those are
+	supported.
+
+2003-01-13 Andreas Tobler <a.tobler@schweiz.ch>
+
+	* libffi/src/ffitest.c
+	 add closure testcases
+
+2003-01-13 Kevin B. Hendricks <khendricks@ivey.uwo.ca>
+
+	* libffi/src/powerpc/ffi.c
+	 fix alignment bug for float (4 byte aligned iso 8 byte)
+
+2003-01-09  Geoffrey Keating  <geoffk@apple.com>
+
+	* src/powerpc/ffi_darwin.c: Remove RCS version string.
+	* src/powerpc/darwin.S: Remove RCS version string.
+
+2003-01-03  Jeff Sturm  <jsturm@one-point.com>
+
+	* include/ffi.h.in: Add closure defines for SPARC, SPARC64.
+	* src/ffitest.c (main): Use static storage for closure.
+	* src/sparc/ffi.c (ffi_prep_closure, ffi_closure_sparc_inner): New.
+	* src/sparc/v8.S (ffi_closure_v8): New.
+	* src/sparc/v9.S (ffi_closure_v9): New.
+
+2002-11-10  Ranjit Mathew <rmathew@hotmail.com>
+
+	* include/ffi.h.in: Added FFI_STDCALL ffi_type
+	  enumeration for X86_WIN32.
+	* src/x86/win32.S: Added ffi_call_STDCALL function
+	  definition.
+	* src/x86/ffi.c (ffi_call/ffi_raw_call): Added
+	  switch cases for recognising FFI_STDCALL and
+	  calling ffi_call_STDCALL if target is X86_WIN32.
+	* src/ffitest.c (my_stdcall_strlen/stdcall_many):
+	  stdcall versions of the "my_strlen" and "many"
+	  test functions (for X86_WIN32).
+	  Added test cases to test stdcall invocation using
+	  these functions.
+
+2002-12-02  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/sysv.S: Add DWARF2 unwind info.
+
+2002-11-27  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* src/s390/sysv.S (.eh_frame section): Make section read-only.
+
+2002-11-26  Jim Wilson  <wilson@redhat.com>
+
+	* src/types.c (FFI_TYPE_POINTER): Has size 8 on IA64.
+
+2002-11-23  H.J. Lu <hjl@gnu.org>
+
+	* acinclude.m4: Add dummy AM_PROG_LIBTOOL.
+	Include ../config/accross.m4.
+	* aclocal.m4; Rebuild.
+	* configure: Likewise.
+
+2002-11-15  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* src/s390/sysv.S (.eh_frame section): Adapt to pcrel FDE encoding.
+
+2002-11-11  DJ Delorie  <dj@redhat.com>
+
+	* configure.in: Look for common files in the right place.
+
+2002-10-08  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* src/java_raw_api.c (ffi_java_raw_to_ptrarray): Interpret
+	raw data as _Jv_word values, not ffi_raw.
+	(ffi_java_ptrarray_to_raw): Likewise.
+	(ffi_java_rvalue_to_raw): New function.
+	(ffi_java_raw_call): Call it.
+	(ffi_java_raw_to_rvalue): New function.
+	(ffi_java_translate_args): Call it.
+	* src/ffitest.c (closure_test_fn): Interpret return value
+	as ffi_arg, not int.
+	* src/s390/ffi.c (ffi_prep_cif_machdep): Add missing
+	FFI_TYPE_POINTER case.
+	(ffi_closure_helper_SYSV): Likewise.  Also, assume return
+	values extended to word size.
+
+2002-10-02  Andreas Jaeger  <aj@suse.de>
+
+	* src/x86/ffi64.c (ffi_prep_cif_machdep): Remove debug output.
+
+2002-10-01  Bo Thorsen  <bo@smetana.suse.de>
+
+	* include/ffi.h.in: Fix i386 win32 compilation.
+
+2002-09-30  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* configure.in: Add s390x-*-linux-* target.
+	* configure: Regenerate.
+	* include/ffi.h.in: Define S390X for s390x targets.
+	(FFI_CLOSURES): Define for s390/s390x.
+	(FFI_TRAMPOLINE_SIZE): Likewise.
+	(FFI_NATIVE_RAW_API): Likewise.
+	* src/prep_cif.c (ffi_prep_cif): Do not compute stack space for s390.
+	* src/types.c (FFI_TYPE_POINTER): Use 8-byte pointers on s390x.
+	* src/s390/ffi.c: Major rework of existing code.  Add support for
+	s390x targets.  Add closure support.
+	* src/s390/sysv.S: Likewise.
+
+2002-09-29  Richard Earnshaw  <rearnsha@arm.com>
+
+	* src/arm/sysv.S: Fix typo.
+
+2002-09-28  Richard Earnshaw  <rearnsha@arm.com>
+
+	* src/arm/sysv.S: If we don't have machine/asm.h and the pre-processor
+	has defined __USER_LABEL_PREFIX__, then use it in CNAME.
+	(ffi_call_SYSV): Handle soft-float.
+
+2002-09-27  Bo Thorsen  <bo@suse.de>
+
+	* include/ffi.h.in: Fix multilib x86-64 support.
+
+2002-09-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* Makefile.am (all-multi): Fix multilib parallel build.
+
+2002-07-19  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* configure.in (sh[34]*-*-linux*): Add brackets.
+	* configure: Regenerate.
+
+2002-07-18  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* Makefile.am: Add SH support.
+	* Makefile.in: Regenerate.
+	* configure.in (sh-*-linux*, sh[34]*-*-linux*): Add target.
+	* configure: Regenerate.
+	* include/ffi.h.in: Add SH support.
+	* src/sh/ffi.c: New file.
+	* src/sh/sysv.S: New file.
+	* src/types.c: Add SH support.
+
+2002-07-16  Bo Thorsen  <bo@suse.de>
+
+	* src/x86/ffi64.c: New file that adds x86-64 support.
+	* src/x86/unix64.S: New file that handles argument setup for
+	x86-64.
+	* src/x86/sysv.S: Don't use this on x86-64.
+	* src/x86/ffi.c: Don't use this on x86-64.
+	Remove unused vars.
+	* src/prep_cif.c (ffi_prep_cif): Don't do stack size calculation
+	for x86-64.
+	* src/ffitest.c (struct6): New test that tests a special case in
+	the x86-64 ABI.
+	(struct7): Likewise.
+	(struct8): Likewise.
+	(struct9): Likewise.
+	(closure_test_fn): Silence warning about this when it's not used.
+	(main): Add the new tests.
+	(main): Fix a couple of wrong casts and silence some compiler warnings.
+	* include/ffi.h.in: Add x86-64 ABI definition.
+	* fficonfig.h.in: Regenerate.
+	* Makefile.am: Add x86-64 support.
+	* configure.in: Likewise.
+	* Makefile.in: Regenerate.
+	* configure: Likewise.
+
+2002-06-24  Bo Thorsen  <bo@suse.de>
+
+	* src/types.c: Merge settings for similar architectures.
+	Add x86-64 sizes and alignments.
+
+2002-06-23  Bo Thorsen  <bo@suse.de>
+
+	* src/arm/ffi.c (ffi_prep_args): Remove unused vars.
+	* src/sparc/ffi.c (ffi_prep_args_v8): Likewise.
+	* src/mips/ffi.c (ffi_prep_args): Likewise.
+	* src/m68k/ffi.c (ffi_prep_args): Likewise.
+
+2002-07-18  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile.am (TARGET_SRC_MIPS_LINUX): New.
+	(libffi_la_SOURCES): Support MIPS_LINUX.
+	(libffi_convenience_la_SOURCES): Likewise.
+	* Makefile.in: Regenerated.
+
+	* configure.in (mips64*-*): Skip.
+	(mips*-*-linux*): New.
+	* configure: Regenerated.
+
+	* src/mips/ffi.c: Include <sgidefs.h>.
+
+2002-06-06  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* src/s390/sysv.S: Save/restore %r6.  Add DWARF-2 unwind info.
+
+2002-05-27  Roger Sayle  <roger@eyesopen.com>
+
+	* src/x86/ffi.c (ffi_prep_args): Remove reference to avn.
+
+2002-05-27  Bo Thorsen  <bo@suse.de>
+
+	* src/x86/ffi.c (ffi_prep_args): Remove unused variable and
+	fix formatting.
+
+2002-05-13  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_closure): Declare fd at
+	beginning of function (for older apple cc).
+
+2002-05-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (ORIGINAL_LD_FOR_MULTILIBS): Preserve LD at
+	script entry, and set LD to it when configuring multilibs.
+	* configure: Rebuilt.
+
+2002-05-05  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (sparc64-*-netbsd*): Add target.
+	(sparc-*-netbsdelf*): Likewise.
+	* configure: Regenerate.
+
+2002-04-28  David S. Miller  <davem@redhat.com>
+
+	* configure.in, configure: Fix SPARC test in previous change.
+
+2002-04-29  Gerhard Tonn  <GerhardTonn@swol.de>
+
+	* Makefile.am: Add Linux for S/390 support.
+	* Makefile.in: Regenerate.
+	* configure.in: Add Linux for S/390 support.
+	* configure: Regenerate.
+	* include/ffi.h.in: Add Linux for S/390 support.
+	* src/s390/ffi.c: New file from libffi CVS tree.
+	* src/s390/sysv.S: New file from libffi CVS tree.
+
+2002-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (HAVE_AS_SPARC_UA_PCREL): Check for working
+	%r_disp32().
+	* src/sparc/v8.S: Use it.
+	* src/sparc/v9.S: Likewise.
+	* fficonfig.h.in: Rebuilt.
+	* configure: Rebuilt.
+
+2002-04-08  Hans Boehm  <Hans_Boehm@hp.com>
+
+	* src/java_raw_api.c (ffi_java_raw_size): Handle FFI_TYPE_DOUBLE
+	correctly.
+	* src/ia64/unix.S: Add unwind information. Fix comments.
+	Save sp in a way that's compatible with unwind info.
+	(ffi_call_unix): Correctly restore sp in all cases.
+	* src/ia64/ffi.c: Add, fix comments.
+
+2002-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/sparc/v8.S: Make .eh_frame dependent on target word size.
+
+2002-04-06  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (alpha*-*-netbsd*): Add target.
+	* configure: Regenerate.
+
+2002-04-04  Jeff Sturm  <jsturm@one-point.com>
+
+	* src/sparc/v8.S: Add unwind info.
+	* src/sparc/v9.S: Likewise.
+
+2002-03-30  Krister Walfridsson  <cato@df.lth.se>
+
+	* configure.in: Enable i*86-*-netbsdelf*.
+	* configure: Rebuilt.
+
+2002-03-29  David Billinghurst <David.Billinghurst@riotinto.com>
+
+	PR other/2620
+	* src/mips/n32.s: Delete
+	* src/mips/o32.s: Delete
+
+2002-03-21  Loren J. Rittle  <ljrittle@acm.org>
+
+	* configure.in: Enable alpha*-*-freebsd*.
+	* configure: Rebuilt.
+
+2002-03-17  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>
+
+	* Makefile.am: libfficonvenience -> libffi_convenience.
+	* Makefile.in: Rebuilt.
+
+	* Makefile.am: Define ffitest_OBJECTS.
+	* Makefile.in: Rebuilt.
+
+2002-03-07  Andreas Tobler  <toa@pop.agri.ch>
+	    David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.am (EXTRA_DIST): Add Darwin and AIX closure files.
+	(TARGET_SRC_POWERPC_AIX): Add aix_closure.S.
+	(TARGET_SRC_POWERPC_DARWIN): Add darwin_closure.S.
+	* Makefile.in: Regenerate.
+	* include/ffi.h.in: Add AIX and Darwin closure definitions.
+	* src/powerpc/ffi_darwin.c (ffi_prep_closure): New function.
+	(flush_icache, flush_range): New functions.
+	(ffi_closure_helper_DARWIN): New function.
+	* src/powerpc/aix_closure.S: New file.
+	* src/powerpc/darwin_closure.S: New file.
+
+2002-02-24  Jeff Sturm  <jsturm@one-point.com>
+
+	* include/ffi.h.in: Add typedef for ffi_arg.
+	* src/ffitest.c (main): Declare rint with ffi_arg.
+
+2002-02-21  Andreas Tobler  <toa@pop.agri.ch>
+
+	* src/powerpc/ffi_darwin.c (ffi_prep_args): Skip appropriate
+	number of GPRs for floating-point arguments.
+
+2002-01-31  Anthony Green  <green@redhat.com>
+
+	* configure: Rebuilt.
+	* configure.in: Replace CHECK_SIZEOF and endian tests with
+	cross-compiler friendly macros.
+	* aclocal.m4 (AC_COMPILE_CHECK_SIZEOF, AC_C_BIGENDIAN_CROSS): New
+	macros.
+
+2002-01-18  David Edelsohn  <edelsohn@gnu.org>
+
+	* src/powerpc/darwin.S (_ffi_call_AIX): New.
+	* src/powerpc/aix.S (ffi_call_DARWIN): New.
+
+2002-01-17  David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.am (EXTRA_DIST): Add Darwin and AIX files.
+	(TARGET_SRC_POWERPC_AIX): New.
+	(POWERPC_AIX): New stanza.
+	* Makefile.in: Regenerate.
+	* configure.in: Add AIX case.
+	* configure: Regenerate.
+	* include/ffi.h.in (ffi_abi): Add FFI_AIX.
+	* src/powerpc/ffi_darwin.c (ffi_status): Use "long" to scale frame
+	size.  Fix "long double" support.
+	(ffi_call): Add FFI_AIX case.
+	* src/powerpc/aix.S: New.
+
+2001-10-09  John Hornkvist  <john@toastedmarshmallow.com>
+
+	Implement Darwin PowerPC ABI.
+	* configure.in: Handle powerpc-*-darwin*.
+	* Makefile.am: Set source files for POWERPC_DARWIN.
+	* configure: Rebuilt.
+	* Makefile.in: Rebuilt.
+	* include/ffi.h.in: Define FFI_DARWIN and FFI_DEFAULT_ABI for
+	POWERPC_DARWIN.
+	* src/powerpc/darwin.S: New file.
+	* src/powerpc/ffi_darwin.c: New file.
+
+2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* src/x86/ffi.c: Fix spelling error of "separate" as "seperate".
+
+2001-07-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* src/x86/sysv.S: Avoid gas-only .balign directive.
+	Use C style comments.
+
+2001-07-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* src/alpha/ffi.c (ffi_prep_closure): Avoid gas-only mnemonic.
+	Fixes PR bootstrap/3563.
+
+2001-06-26  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* src/alpha/osf.S (ffi_closure_osf): Use .rdata for ECOFF.
+
+2001-06-25  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in: Recognize sparc*-sun-* host.
+	* configure: Regenerate.
+
+2001-06-06  Andrew Haley  <aph@redhat.com>
+
+	* src/alpha/osf.S (__FRAME_BEGIN__): Conditionalize for ELF.
+
+2001-06-03  Andrew Haley  <aph@redhat.com>
+
+	* src/alpha/osf.S: Add unwind info.
+	* src/powerpc/sysv.S: Add unwind info.
+	* src/powerpc/ppc_closure.S: Likewise.
+
+2000-05-31  Jeff Sturm  <jsturm@one-point.com>
+
+	* configure.in: Fix AC_ARG_ENABLE usage.
+	* configure: Rebuilt.
+
+2001-05-06  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>
+
+	* configure.in: Remove warning about beta code.
+	* configure: Rebuilt.
+
+2001-04-25  Hans Boehm <Hans_Boehm@hp.com>
+
+	* src/ia64/unix.S: Restore stack pointer when returning from
+	ffi_closure_UNIX.
+	* src/ia64/ffi.c: Fix typo in comment.
+
+2001-04-18  Jim Wilson  <wilson@redhat.com>
+
+	* src/ia64/unix.S: Delete unnecessary increment and decrement of loc2
+	to eliminate RAW DV.
+
+2001-04-12  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* Makefile.am: Make a libtool convenience library.
+	* Makefile.in: Rebuilt.
+
+2001-03-29  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Use different syntax for subdirectory creation.
+	* configure: Rebuilt.
+
+2001-03-27  Jon Beniston  <jon@beniston.com>
+
+	* configure.in: Added X86_WIN32 target (Win32, CygWin, MingW).
+	* configure: Rebuilt.
+	* Makefile.am: Added X86_WIN32 target support.
+	* Makefile.in: Rebuilt.
+
+	* include/ffi.h.in: Added X86_WIN32 target support.
+
+	* src/ffitest.c: Doesn't run structure tests for X86_WIN32 targets.
+	* src/types.c: Added X86_WIN32 target support.
+
+	* src/x86/win32.S: New file. Based on sysv.S, but with EH
+	stuff removed and made to work with CygWin's gas.
+
+2001-03-26  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Make target subdirectory in build dir.
+	* Makefile.am: Override suffix based rules to specify correct output
+	subdirectory.
+	* Makefile.in: Rebuilt.
+	* configure: Rebuilt.
+
+2001-03-23  Kevin B Hendricks  <khendricks@ivey.uwo.ca>
+
+	* src/powerpc/ppc_closure.S: New file.
+	* src/powerpc/ffi.c (ffi_prep_args): Fixed ABI compatibility bug
+	involving long long and register pairs.
+	(ffi_prep_closure): New function.
+	(flush_icache): Likewise.
+	(ffi_closure_helper_SYSV): Likewise.
+	* include/ffi.h.in (FFI_CLOSURES): Define on PPC.
+	(FFI_TRAMPOLINE_SIZE): Likewise.
+	(FFI_NATIVE_RAW_API): Likewise.
+	* Makefile.in: Rebuilt.
+	* Makefile.am (EXTRA_DIST): Added src/powerpc/ppc_closure.S.
+	(TARGET_SRC_POWERPC): Likewise.
+
+2001-03-19  Tom Tromey  <tromey@redhat.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.am (ffitest_LDFLAGS): New macro.
+
+2001-03-02  Nick Clifton  <nickc@redhat.com>
+
+	* include/ffi.h.in: Remove RCS ident string.
+	* include/ffi_mips.h: Remove RCS ident string.
+	* src/debug.c: Remove RCS ident string.
+	* src/ffitest.c: Remove RCS ident string.
+	* src/prep_cif.c: Remove RCS ident string.
+	* src/types.c: Remove RCS ident string.
+	* src/alpha/ffi.c: Remove RCS ident string.
+	* src/alpha/osf.S: Remove RCS ident string.
+	* src/arm/ffi.c: Remove RCS ident string.
+	* src/arm/sysv.S: Remove RCS ident string.
+	* src/mips/ffi.c: Remove RCS ident string.
+	* src/mips/n32.S: Remove RCS ident string.
+	* src/mips/o32.S: Remove RCS ident string.
+	* src/sparc/ffi.c: Remove RCS ident string.
+	* src/sparc/v8.S: Remove RCS ident string.
+	* src/sparc/v9.S: Remove RCS ident string.
+	* src/x86/ffi.c: Remove RCS ident string.
+	* src/x86/sysv.S: Remove RCS ident string.
+
+2001-02-08  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* include/ffi.h.in: Change sourceware.cygnus.com references to
+	gcc.gnu.org.
+
+2000-12-09  Richard Henderson  <rth@redhat.com>
+
+	* src/alpha/ffi.c (ffi_call): Simplify struct return test.
+	(ffi_closure_osf_inner): Index rather than increment avalue
+	and arg_types.  Give ffi_closure_osf the raw return value type.
+	* src/alpha/osf.S (ffi_closure_osf): Handle return value type
+	promotion.
+
+2000-12-07  Richard Henderson  <rth@redhat.com>
+
+	* src/raw_api.c (ffi_translate_args): Fix typo.
+	(ffi_prep_closure): Likewise.
+
+	* include/ffi.h.in [ALPHA]: Define FFI_CLOSURES and
+	FFI_TRAMPOLINE_SIZE.
+	* src/alpha/ffi.c (ffi_prep_cif_machdep): Adjust minimal
+	cif->bytes for new ffi_call_osf implementation.
+	(ffi_prep_args): Absorb into ...
+	(ffi_call): ... here.  Do all stack allocation here and
+	avoid a callback function.
+	(ffi_prep_closure, ffi_closure_osf_inner): New.
+	* src/alpha/osf.S (ffi_call_osf): Reimplement with no callback.
+	(ffi_closure_osf): New.
+
+2000-09-10  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config.guess, config.sub, install-sh: Removed.
+	* ltconfig, ltmain.sh, missing, mkinstalldirs: Likewise.
+	* Makefile.in: Rebuilt.
+
+	* acinclude.m4: Include libtool macros from the top level.
+	* aclocal.m4, configure: Rebuilt.
+
+2000-08-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in [i*86-*-freebsd*] (TARGET, TARGETDIR): Set.
+	* configure: Rebuilt.
+
+2000-05-11  Scott Bambrough  <scottb@netwinder.org>
+
+	* libffi/src/arm/sysv.S (ffi_call_SYSV): Doubles are not saved to
+	memory correctly.  Use conditional instructions, not branches where
+	possible.
+
+2000-05-04  Tom Tromey  <tromey@cygnus.com>
+
+	* configure: Rebuilt.
+	* configure.in: Match `arm*-*-linux-*'.
+	From Chris Dornan <cdornan@arm.com>.
+
+2000-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	* Makefile.am (SUBDIRS): Define.
+	(AM_MAKEFLAGS): Likewise.
+	(Multilib support.): Add section.
+	* Makefile.in: Rebuilt.
+	* ltconfig (extra_compiler_flags, extra_compiler_flags_value):
+	New variables. Set for gcc using -print-multi-lib. Export them
+	to libtool.
+	(sparc64-*-linux-gnu*): Use libsuff 64 for search paths.
+	* ltmain.sh (B|b|V): Don't throw away gcc's -B, -b and -V options
+	for -shared links.
+	(extra_compiler_flags_value, extra_compiler_flags): Check these
+	for extra compiler options which need to be passed down in
+	compiler_flags.
+
+2000-04-16  Anthony Green  <green@redhat.com>
+
+	* configure: Rebuilt.
+	* configure.in: Change i*86-pc-linux* to i*86-*-linux*.
+
+2000-04-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/ffi.h.in (SPARC64): Define for 64bit SPARC builds.
+	Set SPARC FFI_DEFAULT_ABI based on SPARC64 define.
+	* src/sparc/ffi.c (ffi_prep_args_v8): Renamed from ffi_prep_args.
+	Replace all void * sizeofs with sizeof(int).
+	Only compare type with FFI_TYPE_LONGDOUBLE if LONGDOUBLE is
+	different than DOUBLE.
+	Remove FFI_TYPE_SINT32 and FFI_TYPE_UINT32 cases (handled elsewhere).
+	(ffi_prep_args_v9): New function.
+	(ffi_prep_cif_machdep): Handle V9 ABI and long long on V8.
+	(ffi_V9_return_struct): New function.
+	(ffi_call): Handle FFI_V9 ABI from 64bit code and FFI_V8 ABI from
+	32bit code (not yet cross-arch calls).
+	* src/sparc/v8.S: Add struct return delay nop.
+	Handle long long.
+	* src/sparc/v9.S: New file.
+	* src/prep_cif.c (ffi_prep_cif): Return structure pointer
+	is used on sparc64 only for structures larger than 32 bytes.
+	Pass by reference for structures is done for structure arguments
+	larger than 16 bytes.
+	* src/ffitest.c (main): Use 64bit rint on sparc64.
+	Run long long tests on sparc.
+	* src/types.c (FFI_TYPE_POINTER): Pointer is 64bit on alpha and
+	sparc64.
+	(FFI_TYPE_LONGDOUBLE): long double is 128 bit aligned to 128 bits
+	on sparc64.
+	* configure.in (sparc-*-linux*): New supported target.
+	(sparc64-*-linux*): Likewise.
+	* configure: Rebuilt.
+	* Makefile.am: Add v9.S to SPARC files.
+	* Makefile.in: Likewise.
+	(LINK): Surround $(CCLD) into double quotes, so that multilib
+	compiles work correctly.
+
+2000-04-04  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* configure: Rebuilt.
+	* configure.in: (i*86-*-solaris*): New libffi target. Patch
+	proposed by Bryce McKinlay.
+
+2000-03-20  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in: Hand edit for java_raw_api.lo.
+
+2000-03-08  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* config.guess, config.sub: Update from the gcc tree.
+	Fix for PR libgcj/168.
+
+2000-03-03  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in: Fixed ia64 by hand.
+
+	* configure: Rebuilt.
+	* configure.in (--enable-multilib): New option.
+	(libffi_basedir): New subst.
+	(AC_OUTPUT): Added multilib code.
+
+2000-03-02  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.am (TARGET_SRC_IA64): Use `ia64', not `alpha', as
+	directory name.
+
+2000-02-25  Hans Boehm <boehm@acm.org>
+
+	* src/ia64/ffi.c, src/ia64/ia64_flags.h, src/ia64/unix.S: New
+	files.
+	* src/raw_api.c (ffi_translate_args): Fixed typo in argument
+	list.
+	(ffi_prep_raw_closure): Use ffi_translate_args, not
+	ffi_closure_translate.
+	* src/java_raw_api.c: New file.
+	* src/ffitest.c (closure_test_fn): New function.
+	(main): Define `rint' as long long on IA64.  Added new test when
+	FFI_CLOSURES is defined.
+	* include/ffi.h.in (ALIGN): Use size_t, not unsigned.
+	(ffi_abi): Recognize IA64.
+	(ffi_raw): Added `flt' field.
+	Added "Java raw API" code.
+	* configure.in: Recognize ia64.
+	* Makefile.am (TARGET_SRC_IA64): New macro.
+	(libffi_la_common_SOURCES): Added java_raw_api.c.
+	(libffi_la_SOURCES): Define in IA64 case.
+
+2000-01-04  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in: Rebuilt with newer automake.
+
+1999-12-31  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.am (INCLUDES): Added -I$(top_srcdir)/src.
+
+1999-09-01  Tom Tromey  <tromey@cygnus.com>
+
+	* include/ffi.h.in: Removed PACKAGE and VERSION defines and
+	undefs.
+	* fficonfig.h.in: Rebuilt.
+	* configure: Rebuilt.
+	* configure.in: Pass 3rd argument to AM_INIT_AUTOMAKE.
+	Use AM_PROG_LIBTOOL (automake 1.4 compatibility).
+	* acconfig.h: Don't #undef PACKAGE or VERSION.
+
+1999-08-09  Anthony Green  <green@cygnus.com>
+
+	* include/ffi.h.in: Try to work around messy header problem
+	with PACKAGE and VERSION.
+
+	* configure: Rebuilt.
+	* configure.in: Change version to 2.00-beta.
+
+	* fficonfig.h.in: Rebuilt.
+	* acconfig.h (FFI_NO_STRUCTS, FFI_NO_RAW_API): Define.
+
+	* src/x86/ffi.c (ffi_raw_call): Rename.
+
+1999-08-02  Kresten Krab Thorup  <krab@dominiq.is.s.u-tokyo.ac.jp>
+
+	* src/x86/ffi.c (ffi_closure_SYSV): New function.
+	(ffi_prep_incoming_args_SYSV): Ditto.
+	(ffi_prep_closure): Ditto.
+	(ffi_closure_raw_SYSV): Ditto.
+	(ffi_prep_raw_closure): More ditto.
+	(ffi_call_raw): Final ditto.
+
+	* include/ffi.h.in: Add definitions for closure and raw API.
+
+	* src/x86/ffi.c (ffi_prep_cif_machdep): Added case for
+	FFI_TYPE_UINT64.
+
+	* Makefile.am (libffi_la_common_SOURCES): Added raw_api.c
+
+	* src/raw_api.c: New file.
+
+	* include/ffi.h.in (ffi_raw): New type.
+	(UINT_ARG, SINT_ARG): New defines.
+	(ffi_closure, ffi_raw_closure): New types.
+	(ffi_prep_closure, ffi_prep_raw_closure): New declarations.
+
+	* configure.in: Add check for endianness and sizeof void*.
+
+	* src/x86/sysv.S (ffi_call_SYSV): Call fixup routine via argument,
+	instead of directly.
+
+	* configure: Rebuilt.
+
+Thu Jul  8 14:28:42 1999  Anthony Green  <green@cygnus.com>
+
+	* configure.in: Add x86 and powerpc BeOS configurations.
+	From Makoto Kato <m_kato@ga2.so-net.ne.jp>.
+
+1999-05-09  Anthony Green  <green@cygnus.com>
+
+	* configure.in: Add warning about this being beta code.
+	Remove src/Makefile.am from the picture.
+	* configure: Rebuilt.
+
+	* Makefile.am: Move logic from src/Makefile.am.  Add changes
+	to support libffi as a target library.
+	* Makefile.in: Rebuilt.
+
+	* aclocal.m4, config.guess, config.sub, ltconfig, ltmain.sh:
+	Upgraded to new autoconf, automake, libtool.
+
+	* README: Tweaks.
+
+	* LICENSE: Update copyright date.
+
+	* src/Makefile.am, src/Makefile.in: Removed.
+
+1998-11-29  Anthony Green  <green@cygnus.com>
+
+	* include/ChangeLog: Removed.
+	* src/ChangeLog: Removed.
+	* src/mips/ChangeLog: Removed.
+	* src/sparc/ChangeLog: Remboved.
+	* src/x86/ChangeLog: Removed.
+
+	* ChangeLog.v1: Created.
+
+=============================================================================
+From the old ChangeLog.libffi file....
+
+2011-02-08  Andreas Tobler  <andreast@fgznet.ch>
+
+	* testsuite/lib/libffi.exp: Tweak for stand-alone mode.
+
+2009-12-25  Samuli Suominen  <ssuominen@gentoo.org>
+
+	* configure.ac: Undefine _AC_ARG_VAR_PRECIOUS for autoconf 2.64.
+	* configure: Rebuilt.
+	* fficonfig.h.in: Rebuilt.
+
+2009-06-16  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/return_ll1.c,
+	testsuite/libffi.call/stret_medium2.c: Fix printf format
+	specifiers.
+	* testsuite/libffi.call/huge_struct.c: Ad x86 XFAILs.
+	* testsuite/libffi.call/float2.c: Fix dg-excess-errors.
+	* testsuite/libffi.call/ffitest.h,
+	testsuite/libffi.special/ffitestcxx.h (PRIdLL, PRIuLL): Define.
+
+2009-06-12  Andrew Haley  <aph@redhat.com>
+
+	* testsuite/libffi.call/cls_align_sint64.c,
+	testsuite/libffi.call/cls_align_uint64.c,
+	testsuite/libffi.call/cls_ulonglong.c,
+	testsuite/libffi.call/return_ll1.c,
+	testsuite/libffi.call/stret_medium2.c: Fix printf format
+	specifiers.
+	testsuite/libffi.special/unwindtest.cc: include stdint.h.
+
+2009-06-11  Timothy Wall  <twall@users.sf.net>
+
+	* Makefile.am,
+        configure.ac,
+        include/ffi.h.in,
+        include/ffi_common.h,
+        src/closures.c,
+        src/dlmalloc.c,
+        src/x86/ffi.c,
+        src/x86/ffitarget.h,
+        src/x86/win64.S (new),
+	README: Added win64 support (mingw or MSVC)
+        * Makefile.in,
+        include/Makefile.in,
+        man/Makefile.in,
+        testsuite/Makefile.in,
+        configure,
+        aclocal.m4: Regenerated
+        * ltcf-c.sh: properly escape cygwin/w32 path
+        * man/ffi_call.3: Clarify size requirements for return value.
+        * src/x86/ffi64.c: Fix filename in comment.
+        * src/x86/win32.S: Remove unused extern.
+
+        * testsuite/libffi.call/closure_fn0.c,
+        testsuite/libffi.call/closure_fn1.c,
+        testsuite/libffi.call/closure_fn2.c,
+        testsuite/libffi.call/closure_fn3.c,
+        testsuite/libffi.call/closure_fn4.c,
+        testsuite/libffi.call/closure_fn5.c,
+        testsuite/libffi.call/closure_fn6.c,
+	testsuite/libffi.call/closure_stdcall.c,
+	testsuite/libffi.call/cls_12byte.c,
+	testsuite/libffi.call/cls_16byte.c,
+	testsuite/libffi.call/cls_18byte.c,
+	testsuite/libffi.call/cls_19byte.c,
+	testsuite/libffi.call/cls_1_1byte.c,
+	testsuite/libffi.call/cls_20byte.c,
+	testsuite/libffi.call/cls_20byte1.c,
+	testsuite/libffi.call/cls_24byte.c,
+	testsuite/libffi.call/cls_2byte.c,
+	testsuite/libffi.call/cls_3_1byte.c,
+	testsuite/libffi.call/cls_3byte1.c,
+ 	testsuite/libffi.call/cls_3byte2.c,
+ 	testsuite/libffi.call/cls_4_1byte.c,
+ 	testsuite/libffi.call/cls_4byte.c,
+ 	testsuite/libffi.call/cls_5_1_byte.c,
+ 	testsuite/libffi.call/cls_5byte.c,
+ 	testsuite/libffi.call/cls_64byte.c,
+ 	testsuite/libffi.call/cls_6_1_byte.c,
+ 	testsuite/libffi.call/cls_6byte.c,
+ 	testsuite/libffi.call/cls_7_1_byte.c,
+ 	testsuite/libffi.call/cls_7byte.c,
+ 	testsuite/libffi.call/cls_8byte.c,
+ 	testsuite/libffi.call/cls_9byte1.c,
+ 	testsuite/libffi.call/cls_9byte2.c,
+ 	testsuite/libffi.call/cls_align_double.c,
+ 	testsuite/libffi.call/cls_align_float.c,
+ 	testsuite/libffi.call/cls_align_longdouble.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split.c,
+ 	testsuite/libffi.call/cls_align_longdouble_split2.c,
+ 	testsuite/libffi.call/cls_align_pointer.c,
+ 	testsuite/libffi.call/cls_align_sint16.c,
+ 	testsuite/libffi.call/cls_align_sint32.c,
+ 	testsuite/libffi.call/cls_align_sint64.c,
+ 	testsuite/libffi.call/cls_align_uint16.c,
+ 	testsuite/libffi.call/cls_align_uint32.c,
+ 	testsuite/libffi.call/cls_align_uint64.c,
+ 	testsuite/libffi.call/cls_dbls_struct.c,
+ 	testsuite/libffi.call/cls_double.c,
+ 	testsuite/libffi.call/cls_double_va.c,
+ 	testsuite/libffi.call/cls_float.c,
+ 	testsuite/libffi.call/cls_longdouble.c,
+ 	testsuite/libffi.call/cls_longdouble_va.c,
+ 	testsuite/libffi.call/cls_multi_schar.c,
+ 	testsuite/libffi.call/cls_multi_sshort.c,
+ 	testsuite/libffi.call/cls_multi_sshortchar.c,
+ 	testsuite/libffi.call/cls_multi_uchar.c,
+ 	testsuite/libffi.call/cls_multi_ushort.c,
+ 	testsuite/libffi.call/cls_multi_ushortchar.c,
+ 	testsuite/libffi.call/cls_pointer.c,
+ 	testsuite/libffi.call/cls_pointer_stack.c,
+ 	testsuite/libffi.call/cls_schar.c,
+ 	testsuite/libffi.call/cls_sint.c,
+ 	testsuite/libffi.call/cls_sshort.c,
+ 	testsuite/libffi.call/cls_uchar.c,
+ 	testsuite/libffi.call/cls_uint.c,
+ 	testsuite/libffi.call/cls_ulonglong.c,
+ 	testsuite/libffi.call/cls_ushort.c,
+ 	testsuite/libffi.call/err_bad_abi.c,
+ 	testsuite/libffi.call/err_bad_typedef.c,
+ 	testsuite/libffi.call/float2.c,
+ 	testsuite/libffi.call/huge_struct.c,
+ 	testsuite/libffi.call/nested_struct.c,
+ 	testsuite/libffi.call/nested_struct1.c,
+ 	testsuite/libffi.call/nested_struct10.c,
+ 	testsuite/libffi.call/nested_struct2.c,
+ 	testsuite/libffi.call/nested_struct3.c,
+ 	testsuite/libffi.call/nested_struct4.c,
+ 	testsuite/libffi.call/nested_struct5.c,
+ 	testsuite/libffi.call/nested_struct6.c,
+ 	testsuite/libffi.call/nested_struct7.c,
+ 	testsuite/libffi.call/nested_struct8.c,
+ 	testsuite/libffi.call/nested_struct9.c,
+ 	testsuite/libffi.call/problem1.c,
+ 	testsuite/libffi.call/return_ldl.c,
+ 	testsuite/libffi.call/return_ll1.c,
+ 	testsuite/libffi.call/stret_large.c,
+ 	testsuite/libffi.call/stret_large2.c,
+ 	testsuite/libffi.call/stret_medium.c,
+ 	testsuite/libffi.call/stret_medium2.c,
+        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead
+        of checking for MMAP.  Use intptr_t instead of long casts.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/powerpc/ffitarget.h: Fix misapplied merge from gcc.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/mips/o32.S,
+	src/mips/n32.S: Fix licence formatting.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/x86/darwin.S: Fix licence formatting.
+	src/x86/win32.S: Likewise.
+	src/sh64/sysv.S: Likewise.
+	src/sh/sysv.S: Likewise.
+
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/sh64/ffi.c: Remove lint directives.  Was missing from merge
+	of Andreas Tobler's patch from 2006-04-22.
+	
+2009-06-04  Andrew Haley  <aph@redhat.com>
+
+	* src/sh/ffi.c: Apply missing hunk from Alexandre Oliva's patch of
+	2007-03-07.
+
+2008-12-26  Timothy Wall  <twall@users.sf.net>
+
+	* testsuite/libffi.call/cls_longdouble.c,
+        testsuite/libffi.call/cls_longdouble_va.c,
+        testsuite/libffi.call/cls_align_longdouble.c,
+        testsuite/libffi.call/cls_align_longdouble_split.c,
+        testsuite/libffi.call/cls_align_longdouble_split2.c: mark expected
+        failures on x86_64 cygwin/mingw.
+
+2008-12-22  Timothy Wall  <twall@users.sf.net>
+
+	* testsuite/libffi.call/closure_fn0.c,
+        testsuite/libffi.call/closure_fn1.c,    
+        testsuite/libffi.call/closure_fn2.c,    
+        testsuite/libffi.call/closure_fn3.c,    
+        testsuite/libffi.call/closure_fn4.c,    
+        testsuite/libffi.call/closure_fn5.c,    
+        testsuite/libffi.call/closure_fn6.c,    
+        testsuite/libffi.call/closure_loc_fn0.c,    
+        testsuite/libffi.call/closure_stdcall.c,    
+        testsuite/libffi.call/cls_align_pointer.c,    
+        testsuite/libffi.call/cls_pointer.c,    
+        testsuite/libffi.call/cls_pointer_stack.c: use portable cast from
+        pointer to integer (intptr_t).
+        * testsuite/libffi.call/cls_longdouble.c: disable for win64.
+	
+2008-12-19  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.8.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-11-11  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.7.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-08-25  Andreas Tobler  <a.tobler@schweiz.org>
+
+	* src/powerpc/ffitarget.h (ffi_abi): Add FFI_LINUX and
+	FFI_LINUX_SOFT_FLOAT to the POWERPC_FREEBSD enum.
+	Add note about flag bits used for FFI_SYSV_TYPE_SMALL_STRUCT.
+	Adjust copyright notice.
+	* src/powerpc/ffi.c: Add two new flags to indicate if we have one
+	register or two register to use for FFI_SYSV structs.
+	(ffi_prep_cif_machdep): Pass the right register flag introduced above.
+	(ffi_closure_helper_SYSV): Fix the return type for
+	FFI_SYSV_TYPE_SMALL_STRUCT. Comment.
+	Adjust copyright notice.
+
+2008-07-24  Anthony Green  <green@redhat.com>
+
+	* testsuite/libffi.call/cls_dbls_struct.c,
+	testsuite/libffi.call/cls_double_va.c,
+	testsuite/libffi.call/cls_longdouble.c,
+	testsuite/libffi.call/cls_longdouble_va.c,
+	testsuite/libffi.call/cls_pointer.c,
+	testsuite/libffi.call/cls_pointer_stack.c,
+	testsuite/libffi.call/err_bad_abi.c: Clean up failures from
+	compiler warnings.
+
+2008-07-17  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.6.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.  Add documentation.
+	* README: Update for new release.
+
+2008-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/ffi.c (ffi_prep_closure_loc): Turn INSN into an unsigned
+	int.
+
+2008-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* src/sh/sysv.S: Add .note.GNU-stack on Linux.
+	* src/sh64/sysv.S: Likewise.
+
+2008-04-03  Anthony Green  <green@redhat.com>
+
+	* libffi.pc.in (Libs): Add -L${libdir}.
+	* configure.ac: Bump version to 3.0.5.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-04-03  Anthony Green  <green@redhat.com>
+	    Xerces Ranby  <xerxes@zafena.se>
+
+	* include/ffi.h.in: Wrap definition of target architecture to
+	protect from double definitions.
+
+2008-03-22  Moriyoshi Koizumi  <moriyoshi@gmail.com>
+
+	* src/x86/ffi.c (ffi_prep_closure_loc): Fix for bug revealed in
+	closure_loc_fn0.c.
+	* testsuite/libffi.call/closure_loc_fn0.c (closure_loc_test_fn0):
+	New test.
+
+2008-03-04  Anthony Green  <green@redhat.com>
+	    Blake Chaffin
+	    hos@tamanegi.org
+
+	* testsuite/libffi.call/cls_align_longdouble_split2.c
+          testsuite/libffi.call/cls_align_longdouble_split.c
+          testsuite/libffi.call/cls_dbls_struct.c
+          testsuite/libffi.call/cls_double_va.c
+          testsuite/libffi.call/cls_longdouble.c
+          testsuite/libffi.call/cls_longdouble_va.c
+          testsuite/libffi.call/cls_pointer.c
+          testsuite/libffi.call/cls_pointer_stack.c
+          testsuite/libffi.call/err_bad_abi.c
+          testsuite/libffi.call/err_bad_typedef.c
+          testsuite/libffi.call/huge_struct.c
+          testsuite/libffi.call/stret_large2.c
+          testsuite/libffi.call/stret_large.c
+          testsuite/libffi.call/stret_medium2.c
+          testsuite/libffi.call/stret_medium.c: New tests from Apple.
+
+2008-02-26  Jakub Jelinek  <jakub@redhat.com>
+            Anthony Green  <green@redhat.com>
+
+	* src/alpha/osf.S: Add .note.GNU-stack on Linux.
+	* src/s390/sysv.S: Likewise.
+	* src/powerpc/linux64.S: Likewise.
+	* src/powerpc/linux64_closure.S: Likewise.
+	* src/powerpc/ppc_closure.S: Likewise.
+	* src/powerpc/sysv.S: Likewise.
+	* src/x86/unix64.S: Likewise.
+	* src/x86/sysv.S: Likewise.
+	* src/sparc/v8.S: Likewise.
+	* src/sparc/v9.S: Likewise.
+	* src/m68k/sysv.S: Likewise.
+	* src/ia64/unix.S: Likewise.
+	* src/arm/sysv.S: Likewise.
+
+2008-02-26  Anthony Green  <green@redhat.com>
+            Thomas Heller  <theller@ctypes.org>
+
+	* src/x86/ffi.c (ffi_closure_SYSV_inner): Change C++ comment to C
+	comment.
+
+2008-02-26  Anthony Green  <green@redhat.org>
+            Thomas Heller  <theller@ctypes.org>
+
+	* include/ffi.h.in: Change void (*)() to void (*)(void).
+
+2008-02-26  Anthony Green  <green@redhat.org>
+            Thomas Heller  <theller@ctypes.org>
+
+	* src/alpha/ffi.c: Change void (*)() to void (*)(void).
+	src/alpha/osf.S, src/arm/ffi.c, src/frv/ffi.c, src/ia64/ffi.c,
+	src/ia64/unix.S, src/java_raw_api.c, src/m32r/ffi.c,
+	src/mips/ffi.c, src/pa/ffi.c, src/pa/hpux32.S, src/pa/linux.S,
+	src/powerpc/ffi.c, src/powerpc/ffi_darwin.c, src/raw_api.c,
+	src/s390/ffi.c, src/sh/ffi.c, src/sh64/ffi.c, src/sparc/ffi.c,
+	src/x86/ffi.c, src/x86/unix64.S, src/x86/darwin64.S,
+	src/x86/ffi64.c: Ditto.
+
+2008-02-24  Anthony Green  <green@redhat.org>
+
+	* configure.ac: Accept openbsd*, not just openbsd.
+	Bump version to 3.0.4.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-02-22  Anthony Green  <green@redhat.com>
+
+	* README: Clean up list of tested platforms.
+
+2008-02-22  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.3.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.  Clean up test docs.
+
+2008-02-22  Bjoern Koenig  <bkoenig@alpha-tierchen.de>
+	    Andreas Tobler  <a.tobler@schweiz.org>
+
+	* configure.ac: Add amd64-*-freebsd* target.
+	* configure: Regenerate.
+
+2008-02-22  Thomas Heller <theller@ctypes.org>
+
+	* configure.ac: Add x86 OpenBSD support.
+	* configure: Rebuilt.
+
+2008-02-21  Thomas Heller <theller@ctypes.org>
+
+	* README: Change "make test" to "make check".
+
+2008-02-21  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.2.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-02-21  Björn König <bkoenig@alpha-tierchen.de>
+
+	* src/x86/freebsd.S: New file.
+	* configure.ac: Add x86 FreeBSD support.
+	* Makefile.am: Ditto.
+
+2008-02-15  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.1.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* libtool-version: Increment revision.
+	* README: Update for new release.
+
+2008-02-15  David Daney	 <ddaney@avtrex.com>
+
+	* src/mips/ffi.c: Remove extra '>' from include directive.
+	(ffi_prep_closure_loc): Use clear_location instead of tramp.
+
+2008-02-15  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 3.0.0.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+2008-02-15  David Daney	 <ddaney@avtrex.com>
+
+	* src/mips/ffi.c (USE__BUILTIN___CLEAR_CACHE):
+	Define (conditionally), and use it to include cachectl.h.
+	(ffi_prep_closure_loc): Fix cache flushing.
+	* src/mips/ffitarget.h (_ABIN32, _ABI64, _ABIO32): Define.
+
+2008-02-15  Anthony Green  <green@redhat.com>
+
+        * man/ffi_call.3, man/ffi_prep_cif.3, man/ffi.3:
+	Update dates and remove all references to ffi_prep_closure.
+	* configure.ac: Bump version to 2.99.9.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+2008-02-15  Anthony Green  <green@redhat.com>
+
+	* man/ffi_prep_closure.3: Delete.
+	* man/Makefile.am (EXTRA_DIST): Remove ffi_prep_closure.3.
+	(man_MANS): Ditto.
+	* man/Makefile.in: Rebuilt.
+	* configure.ac: Bump version to 2.99.8.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 2.99.7.
+	* configure, doc/stamp-vti, doc/version.texi: Rebuilt.
+	* include/ffi.h.in LICENSE src/debug.c src/closures.c
+          src/ffitest.c src/s390/sysv.S src/s390/ffitarget.h
+          src/types.c src/m68k/ffitarget.h src/raw_api.c src/frv/ffi.c
+          src/frv/ffitarget.h src/sh/ffi.c src/sh/sysv.S
+          src/sh/ffitarget.h src/powerpc/ffitarget.h src/pa/ffi.c
+          src/pa/ffitarget.h src/pa/linux.S src/java_raw_api.c
+          src/cris/ffitarget.h src/x86/ffi.c src/x86/sysv.S
+          src/x86/unix64.S src/x86/win32.S src/x86/ffitarget.h
+          src/x86/ffi64.c src/x86/darwin.S src/ia64/ffi.c
+          src/ia64/ffitarget.h src/ia64/ia64_flags.h src/ia64/unix.S
+          src/sparc/ffi.c src/sparc/v9.S src/sparc/ffitarget.h
+          src/sparc/v8.S src/alpha/ffi.c src/alpha/ffitarget.h
+          src/alpha/osf.S src/sh64/ffi.c src/sh64/sysv.S
+          src/sh64/ffitarget.h src/mips/ffi.c src/mips/ffitarget.h
+          src/mips/n32.S src/mips/o32.S src/arm/ffi.c src/arm/sysv.S
+          src/arm/ffitarget.h src/prep_cif.c: Update license text.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* README: Update tested platforms.
+	* configure.ac: Bump version to 2.99.6.
+	* configure: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* configure.ac: Bump version to 2.99.5.
+	* configure: Rebuilt.
+	* Makefile.am (EXTRA_DIST): Add darwin64.S
+	* Makefile.in: Rebuilt.
+	* testsuite/lib/libffi-dg.exp: Remove libstdc++ bits from GCC tree.
+	* LICENSE: Update WARRANTY.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* libffi.pc.in (libdir): Fix libdir definition.
+	* configure.ac: Bump version to 2.99.4.
+	* configure: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* README: Update.
+	* libffi.info: New file.
+	* doc/stamp-vti: New file.
+	* configure.ac: Bump version to 2.99.3.
+	* configure: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* Makefile.am (SUBDIRS): Add man dir.
+	* Makefile.in: Rebuilt.
+	* configure.ac: Create Makefile.
+	* configure: Rebuilt.
+        * man/ffi_call.3 man/ffi_prep_cif.3 man/ffi_prep_closure.3
+          man/Makefile.am man/Makefile.in: New files.
+
+2008-02-14  Tom Tromey  <tromey@redhat.com>
+
+	* aclocal.m4, Makefile.in, configure, fficonfig.h.in: Rebuilt.
+	* mdate-sh, texinfo.tex: New files.
+	* Makefile.am (info_TEXINFOS): New variable.
+	* doc/libffi.texi: New file.
+	* doc/version.texi: Likewise.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* Makefile.am (AM_CFLAGS): Don't compile with -D$(TARGET).
+	(lib_LTLIBRARIES): Define.
+	(toolexeclib_LIBRARIES): Undefine.
+	* Makefile.in: Rebuilt.
+	* configure.ac: Reset version to 2.99.1.
+	* configure.in: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* libffi.pc.in: Use @PACKAGE_NAME@ and @PACKAGE_VERSION@.
+	* configure.ac: Reset version to 2.99.1.
+	* configure.in: Rebuilt.
+	* Makefile.am (EXTRA_DIST): Add ChangeLog.libffi.
+	* Makefile.in: Rebuilt.
+	* LICENSE: Update copyright notice.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* include/Makefile.am (nodist_includes_HEADERS): Define.  Don't
+	distribute ffitarget.h or ffi.h from the build include dir.
+	* Makefile.in: Rebuilt.
+
+2008-02-14  Anthony Green  <green@redhat.com>
+
+	* include/Makefile.am (includesdir): Install headers under libdir.
+	(pkgconfigdir): Define. Install libffi.pc.
+	* include/Makefile.in: Rebuilt.
+	* libffi.pc.in: Create.
+	* libtool-version: Increment CURRENT
+	* configure.ac: Add libffi.pc.in
+	* configure: Rebuilt.
+
+2008-02-03  Anthony Green  <green@redhat.com>
+
+	* include/Makefile.am (includesdir): Fix header install with
+	DESTDIR.
+	* include/Makefile.in: Rebuilt.
+
+2008-02-03  Timothy Wall  <twall@users.sf.net>
+
+	* src/x86/ffi.c (FFI_INIT_TRAMPOLINE_STDCALL): Calculate jump return
+          offset based on code pointer, not data pointer.
+
+2008-02-01  Anthony Green  <green@redhat.com>
+
+	* include/Makefile.am: Fix header installs.
+	* Makefile.am: Ditto.
+	* include/Makefile.in: Rebuilt.
+	* Makefile.in: Ditto.
+
+2008-02-01  Anthony Green  <green@redhat.com>
+
+	* src/x86/ffi.c (FFI_INIT_TRAMPOLINE_STDCALL,
+	FFI_INIT_TRAMPOLINE): Revert my broken changes to twall's last
+	patch.
+
+2008-01-31  Anthony Green  <green@redhat.com>
+
+	* Makefile.am (EXTRA_DIST): Add missing files.
+	* testsuite/Makefile.am: Ditto.
+	* Makefile.in, testsuite/Makefile.in: Rebuilt.
+
+2008-01-31  Timothy Wall <twall@users.sf.net>
+
+	* testsuite/libffi.call/closure_stdcall.c: Add test for stdcall
+	closures.
+	* src/x86/ffitarget.h: Increase size of trampoline for stdcall
+	closures.
+	* src/x86/win32.S: Add assembly for stdcall closure.
+	* src/x86/ffi.c: Initialize stdcall closure trampoline.
+
+2008-01-30  H.J. Lu <hongjiu.lu@intel.com>
+
+	PR libffi/34612
+	* src/x86/sysv.S (ffi_closure_SYSV): Pop 4 byte from stack when
+	returning struct.
+
+	* testsuite/libffi.call/call.exp: Add "-O2 -fomit-frame-pointer"
+	tests.
+
+2008-01-30  Anthony Green  <green@redhat.com>
+
+	* Makefile.am, include/Makefile.am: Move headers to
+	libffi_la_SOURCES for new automake.
+	* Makefile.in, include/Makefile.in: Rebuilt.
+
+	* testsuite/lib/wrapper.exp: Copied from gcc tree to allow for
+	execution outside of gcc tree.
+	* testsuite/lib/target-libpath.exp: Ditto.
+
+	* testsuite/lib/libffi-dg.exp: Many changes to allow for execution
+	outside of gcc tree.
+
+
+=============================================================================
+From the old ChangeLog.libgcj file....
+
+2004-01-14  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.in: Add in AC_PREREQ(2.13)
+
+2003-02-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Propagate ORIGINAL_LD_FOR_MULTILIBS to
+	config.status.
+	* configure: Rebuilt.
+
+2002-01-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (toolexecdir, toolexeclibdir): Set and AC_SUBST.
+	Remove USE_LIBDIR conditional.
+	* Makefile.am (toolexecdir, toolexeclibdir): Don't override.
+	* Makefile.in, configure: Rebuilt.
+
+Mon Aug  9 18:33:38 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* include/Makefile.in: Rebuilt.
+	* Makefile.in: Rebuilt
+	* Makefile.am (toolexeclibdir): Add $(MULTISUBDIR) even for native
+	builds.
+	Use USE_LIBDIR.
+
+	* configure: Rebuilt.
+	* configure.in (USE_LIBDIR): Define for native builds.
+	Use lowercase in configure --help explanations.
+
+1999-08-08  Anthony Green  <green@cygnus.com>
+
+	* include/ffi.h.in (FFI_FN): Remove `...'.
+
+1999-08-08  Anthony Green  <green@cygnus.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.am (AM_CFLAGS): Compile with -fexceptions.
+
+	* src/x86/sysv.S: Add exception handling metadata.
+
+
+=============================================================================
+	
+The libffi version 1 ChangeLog archive.
+
+Version 1 of libffi had per-directory ChangeLogs.  Current and future
+versions have a single ChangeLog file in the root directory.  The
+version 1 ChangeLogs have all been concatenated into this file for
+future reference only.
+
+--- libffi ----------------------------------------------------------------
+
+Mon Oct  5 02:17:50 1998  Anthony Green  <green@cygnus.com>
+
+	* configure.in: Boosted rev.
+	* configure, Makefile.in, aclocal.m4: Rebuilt.
+	* README: Boosted rev and updated release notes.
+
+Mon Oct  5 01:03:03 1998  Anthony Green  <green@cygnus.com>
+
+	* configure.in: Boosted rev.
+	* configure, Makefile.in, aclocal.m4: Rebuilt.
+	* README: Boosted rev and updated release notes.
+
+1998-07-25  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* m68k/ffi.c (ffi_prep_cif_machdep): Use bitmask for cif->flags.
+	Correctly handle small structures.
+	(ffi_prep_args): Also handle small structures.
+	(ffi_call): Pass size of return type to ffi_call_SYSV.
+	* m68k/sysv.S: Adjust for above changes.  Correctly align small
+	structures in the return value.
+
+	* types.c (uint64, sint64) [M68K]: Change alignment to 4.
+
+Fri Apr 17 17:26:58 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* configure.in: Boosted rev.
+	* configure,Makefile.in,aclocal.m4: Rebuilt.
+	* README: Boosted rev and added release notes.
+
+Sun Feb 22 00:50:41 1998  Geoff Keating  <geoffk@ozemail.com.au>
+
+	* configure.in: Add PowerPC config bits.
+
+1998-02-14  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* configure.in: Add m68k config bits.  Change AC_CANONICAL_SYSTEM
+	to AC_CANONICAL_HOST, this is not a compiler.  Use $host instead
+	of $target.  Remove AC_CHECK_SIZEOF(char), we already know the
+	result.  Fix argument of AC_ARG_ENABLE.
+	* configure, fficonfig.h.in: Rebuilt.
+
+Tue Feb 10 20:53:40 1998  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: Add Alpha config bits.
+
+Tue May 13 13:39:20 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* README: Updated dates and reworded Irix comments.
+
+	* configure.in: Removed AC_PROG_RANLIB.
+
+	* Makefile.in, aclocal.m4, config.guess, config.sub, configure,
+	ltmain.sh, */Makefile.in: libtoolized again and	rebuilt with 
+	automake and autoconf.
+	
+Sat May 10 18:44:50 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* configure, aclocal.m4: Rebuilt.
+	* configure.in: Don't compute EXTRADIST; now handled in
+	src/Makefile.in.  Removed macros implied by AM_INIT_AUTOMAKE.
+	Don't run AM_MAINTAINER_MODE.
+
+Thu May  8 14:34:05 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* missing, ltmain.sh, ltconfig.sh: Created. These are new files
+	required by automake and libtool.
+
+	* README: Boosted rev to 1.14. Added notes.
+
+	* acconfig.h: Moved PACKAGE and VERSION for new automake.
+	
+	* configure.in: Changes for libtool.
+	
+	* Makefile.am (check): make test now make check. Uses libtool now.
+
+	* Makefile.in, configure.in, aclocal.h, fficonfig.h.in: Rebuilt.
+
+Thu May  1 16:27:07 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* missing: Added file required by new automake.
+
+Tue Nov 26 14:10:42 1996  Anthony Green  <green@csk3.cygnus.com>
+
+	* acconfig.h: Added USING_PURIFY flag. This is defined when
+	--enable-purify-safety was used at configure time.
+
+	* configure.in (allsources): Added --enable-purify-safety switch.
+	(VERSION): Boosted rev to 1.13.
+	* configure: Rebuilt.
+
+Fri Nov 22 06:46:12 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* configure.in (VERSION): Boosted rev to 1.12.
+	Removed special CFLAGS hack for gcc.
+	* configure: Rebuilt.
+
+	* README: Boosted rev to 1.12. Added notes.
+
+	* Many files: Cygnus Support changed to Cygnus Solutions.
+
+Wed Oct 30 11:15:25 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* configure.in (VERSION): Boosted rev to 1.11.
+	* configure: Rebuilt.
+
+	* README: Boosted rev to 1.11. Added notes about GNU make.
+
+Tue Oct 29 12:25:12 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* configure.in: Fixed -Wall trick.
+	(VERSION): Boosted rev.
+	* configure: Rebuilt
+
+	* acconfig.h: Needed for --enable-debug configure switch.
+
+	* README: Boosted rev to 1.09. Added more notes on building
+	libffi, and LCLint.
+
+	* configure.in: Added --enable-debug switch. Boosted rev to
+	1.09.
+	* configure: Rebuilt
+
+Tue Oct 15 13:11:28 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* configure.in (VERSION): Boosted rev to 1.08
+	* configure: Rebuilt.
+
+	* README: Added n32 bug fix notes.
+
+	* Makefile.am: Added "make lint" production. 
+	* Makefile.in: Rebuilt.
+
+Mon Oct 14 10:54:46 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* README: Added web page reference.
+
+	* configure.in, README: Boosted rev to 1.05
+	* configure: Rebuilt.
+
+	* README: Fixed n32 sample code.
+
+Fri Oct 11 17:09:28 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* README: Added sparc notes.
+
+	* configure.in, README: Boosted rev to 1.04.
+	* configure: Rebuilt.
+
+Thu Oct 10 10:31:03 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* configure.in, README: Boosted rev to 1.03.
+	* configure: Rebuilt.
+
+	* README: Added struct notes. 
+
+	* Makefile.am (EXTRA_DIST): Added LICENSE to distribution.
+	* Makefile.in: Rebuilt.
+
+	* README: Removed Linux section. No special notes now
+	because aggregates arg/return types work.
+
+Wed Oct  9 16:16:42 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* README, configure.in (VERSION): Boosted rev to 1.02
+	* configure: Rebuilt.
+
+Tue Oct  8 11:56:33 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* README (NOTE): Added n32 notes.
+
+	* Makefile.am: Added test production.
+	* Makefile: Rebuilt
+
+	* README: spell checked!
+
+	* configure.in (VERSION): Boosted rev to 1.01
+	* configure: Rebuilt.
+
+Mon Oct  7 15:50:22 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* configure.in: Added nasty bit to support SGI tools.
+	* configure: Rebuilt.
+	
+	* README: Added SGI notes. Added note about automake bug.
+
+Mon Oct  7 11:00:28 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* README: Rewrote intro, and fixed examples.
+
+Fri Oct  4 10:19:55 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* configure.in: -D$TARGET is no longer used as a compiler switch.
+	It is now inserted into ffi.h at configure time.
+	* configure: Rebuilt.
+
+	* FFI_ABI and FFI_STATUS are now ffi_abi and ffi_status.
+
+Thu Oct  3 13:47:34 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* README, LICENSE: Created. Wrote some docs.
+
+	* configure.in: Don't barf on i586-unknown-linuxaout.
+	Added EXTRADIST code for "make dist".
+	* configure: Rebuilt.
+
+	* */Makefile.in: Rebuilt with patched automake. 
+
+Tue Oct  1 17:12:25 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* Makefile.am, aclocal.m4, config.guess, config.sub,
+	configure.in, fficonfig.h.in, install-sh, mkinstalldirs, 
+	stamp-h.in: Created
+	* Makefile.in, configure: Generated
+
+--- libffi/include --------------------------------------------------------
+
+Tue Feb 24 13:09:36 1998  Anthony Green  <green@gerbil.cygnus.com>
+
+	* ffi_mips.h: Updated FFI_TYPE_STRUCT_* values based on
+	ffi.h.in changes.  This is a work-around for SGI's "simple"
+	assembler.
+
+Sun Feb 22 00:51:55 1998  Geoff Keating  <geoffk@ozemail.com.au>
+
+	* ffi.h.in: PowerPC support.
+
+1998-02-14  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* ffi.h.in: Add m68k support.
+	(FFI_TYPE_LONGDOUBLE): Make it a separate value.
+
+Tue Feb 10 20:55:16 1998  Richard Henderson  <rth@cygnus.com>
+
+	* ffi.h.in (SIZEOF_ARG): Use a pointer type by default.
+
+	* ffi.h.in: Alpha support.
+
+Fri Nov 22 06:48:45 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in, ffi_common.h: Cygnus Support -> Cygnus Solutions.
+
+Wed Nov 20 22:31:01 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.h.in: Added ffi_type_void definition.
+
+Tue Oct 29 12:22:40 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* Makefile.am (hack_DATA): Always install ffi_mips.h.
+
+	* ffi.h.in: Removed FFI_DEBUG. It's now in the correct
+	place (acconfig.h).
+	Added #include <stddef.h> for size_t definition.
+
+Tue Oct 15 17:23:35 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.h.in, ffi_common.h, ffi_mips.h: More clean up.
+	Commented out #define of FFI_DEBUG.
+
+Tue Oct 15 13:01:06 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi_common.h: Added bool definition.
+
+	* ffi.h.in, ffi_common.h: Clean up based on LCLint output.
+	Added funny /*@...@*/ comments to annotate source.
+
+Mon Oct 14 12:29:23 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in: Interface changes based on feedback from Jim
+	Blandy.
+
+Fri Oct 11 16:49:35 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in: Small change for sparc support.
+
+Thu Oct 10 14:53:37 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi_mips.h: Added FFI_TYPE_STRUCT_* definitions for 
+	special structure return types.
+
+Wed Oct  9 13:55:57 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in: Added SIZEOF_ARG definition for X86
+
+Tue Oct  8 11:40:36 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in (FFI_FN): Added macro for eliminating compiler warnings.
+	Use it to case your function pointers to the proper type.
+
+	* ffi_mips.h (SIZEOF_ARG): Added magic to fix type promotion bug.
+
+	* Makefile.am (EXTRA_DIST): Added ffi_mips.h to EXTRA_DIST.
+	* Makefile: Rebuilt.
+
+	* ffi_mips.h: Created. Moved all common mips definitions here.
+
+Mon Oct  7 10:58:12 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.h.in: The SGI assember is very picky about parens. Redefined
+ 	some macros to avoid problems.
+
+	* ffi.h.in: Added FFI_DEFAULT_ABI definitions. Also added
+	externs for pointer, and 64bit integral ffi_types.
+
+Fri Oct  4 09:51:37 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.h.in: Added FFI_ABI member to ffi_cif and changed
+	function prototypes accordingly.
+	Added #define @TARGET@. Now programs including ffi.h don't 
+	have to specify this themselves.
+
+Thu Oct  3 15:36:44 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.h.in: Changed ffi_prep_cif's values from void* to void**
+
+	* Makefile.am (EXTRA_DIST): Added EXTRA_DIST for "make dist"
+	to work.
+	* Makefile.in: Regenerated.
+
+Wed Oct  2 10:16:59 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* Makefile.am: Created
+	* Makefile.in: Generated
+
+	* ffi_common.h: Added rcsid comment
+
+Tue Oct  1 17:13:51 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.h.in, ffi_common.h: Created
+
+--- libffi/src ------------------------------------------------------------
+
+Mon Oct  5 02:17:50 1998  Anthony Green  <green@cygnus.com>
+
+	* arm/ffi.c, arm/sysv.S: Created.
+
+	* Makefile.am: Added arm files.
+	* Makefile.in: Rebuilt.
+
+Mon Oct  5 01:41:38 1998  Anthony Green  <green@rtl.cygnus.com>
+
+	* Makefile.am (libffi_la_LDFLAGS): Incremented revision.
+
+Sun Oct  4 16:27:17 1998  Anthony Green  <green@cygnus.com>
+
+	* alpha/osf.S (ffi_call_osf): Patch for DU assembler.
+
+	* ffitest.c (main): long long and long double return values work
+	for x86.
+
+Fri Apr 17 11:50:58 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* Makefile.in: Rebuilt.
+
+	* ffitest.c (main): Floating point tests not executed for systems
+ 	with broken lond double (SunOS 4 w/ GCC).
+
+	* types.c: Fixed x86 alignment info for long long types.
+
+Thu Apr 16 07:15:28 1998  Anthony Green  <green@ada.cygnus.com>
+
+	* ffitest.c: Added more notes about GCC bugs under Irix 6.
+
+Wed Apr 15 08:42:22 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffitest.c (struct5): New test function.
+	(main): New test with struct5.
+
+Thu Mar  5 10:48:11 1998  Anthony Green  <green@tootie.to.cygnus.com>
+
+	* prep_cif.c (initialize_aggregate): Fix assertion for
+	nested structures.
+
+Tue Feb 24 16:33:41 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* prep_cif.c (ffi_prep_cif): Added long double support for sparc.
+
+Sun Feb 22 00:52:18 1998  Geoff Keating  <geoffk@ozemail.com.au>
+
+	* powerpc/asm.h: New file.
+	* powerpc/ffi.c: New file.
+	* powerpc/sysv.S: New file.
+	* Makefile.am: PowerPC port.
+	* ffitest.c (main): Allow all tests to run even in presence of gcc
+ 	bug on PowerPC.
+
+1998-02-17  Anthony Green  <green@hoser.cygnus.com>
+
+	* mips/ffi.c: Fixed comment typo.
+
+	* x86/ffi.c (ffi_prep_cif_machdep), x86/sysv.S (retfloat): 
+	Fixed x86 long double return handling.
+
+	* types.c: Fixed x86 long double alignment info.
+
+1998-02-14  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* types.c: Add m68k support.
+
+	* ffitest.c (floating): Add long double parameter.
+	(return_ll, ldblit): New functions to test long long and long
+	double return value.
+	(main): Fix type error in assignment of ts[1-4]_type.elements.
+	Add tests for long long and long double arguments and return
+	values.
+
+	* prep_cif.c (ffi_prep_cif) [M68K]: Don't allocate argument for
+	struct value pointer.
+
+	* m68k/ffi.c, m68k/sysv.S: New files.
+	* Makefile.am: Add bits for m68k port.  Add kludge to work around
+	automake deficiency.
+	(test): Don't require "." in $PATH.
+	* Makefile.in: Rebuilt.
+
+Wed Feb 11 07:36:50 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* Makefile.in: Rebuilt.
+
+Tue Feb 10 20:56:00 1998  Richard Henderson  <rth@cygnus.com>
+
+	* alpha/ffi.c, alpha/osf.S: New files.
+	* Makefile.am: Alpha port.
+
+Tue Nov 18 14:12:07 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* mips/ffi.c (ffi_prep_cif_machdep): Initialize rstruct_flag
+	for n32.
+
+Tue Jun  3 17:18:20 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffitest.c (main): Added hack to get structure tests working
+	correctly.
+
+Sat May 10 19:06:42 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.am (EXTRA_DIST): Explicitly list all distributable
+	files in subdirs.
+	(VERSION, CC): Removed.
+
+Thu May  8 17:19:01 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* Makefile.am: Many changes for new automake and libtool.
+	* Makefile.in: Rebuilt.
+
+Fri Nov 22 06:57:56 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffitest.c (main): Fixed test case for non mips machines.
+
+Wed Nov 20 22:31:59 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* types.c: Added ffi_type_void declaration.
+
+Tue Oct 29 13:07:19 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffitest.c (main): Fixed character constants.
+	(main): Emit warning for structure test 3 failure on Sun.
+
+	* Makefile.am (VPATH): Fixed VPATH def'n so automake won't
+	strip it out. 
+	Moved distdir hack from libffi to automake. 
+	(ffitest): Added missing -c for $(COMPILE) (change in automake).
+	* Makefile.in: Rebuilt.
+	
+Tue Oct 15 13:08:20 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* Makefile.am: Added "make lint" production. 
+	* Makefile.in: Rebuilt.
+
+	* prep_cif.c (STACK_ARG_SIZE): Improved STACK_ARG_SIZE macro.
+  	Clean up based on LCLint output. Added funny /*@...@*/ comments to
+ 	annotate source.
+
+	* ffitest.c, debug.c: Cleaned up code.
+
+Mon Oct 14 12:26:56 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffitest.c: Changes based on interface changes.
+
+	* prep_cif.c (ffi_prep_cif): Cleaned up interface based on
+	feedback from Jim Blandy.
+
+Fri Oct 11 15:53:18 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffitest.c: Reordered tests while porting to sparc.
+	Made changes to handle lame structure passing for sparc.
+	Removed calls to fflush().
+
+	* prep_cif.c (ffi_prep_cif): Added special case for sparc
+	aggregate type arguments.
+
+Thu Oct 10 09:56:51 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffitest.c (main): Added structure passing/returning tests.
+
+	* prep_cif.c (ffi_prep_cif): Perform proper initialization
+	of structure return types if needed.
+	(initialize_aggregate): Bug fix
+
+Wed Oct  9 16:04:20 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* types.c: Added special definitions for x86 (double doesn't
+	need double word alignment).
+
+	* ffitest.c: Added many tests
+
+Tue Oct  8 09:19:22 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* prep_cif.c (ffi_prep_cif): Fixed assertion.
+
+	* debug.c (ffi_assert): Must return a non void now.
+
+	* Makefile.am: Added test production.
+	* Makefile: Rebuilt.
+
+	* ffitest.c (main): Created. 
+
+	* types.c: Created. Stripped common code out of */ffi.c.
+
+	* prep_cif.c: Added missing stdlib.h include.
+
+	* debug.c (ffi_type_test): Used "a" to eliminate compiler
+	warnings in non-debug builds. Included ffi_common.h.
+
+Mon Oct  7 15:36:42 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* Makefile.am: Added a rule for .s -> .o
+	This is required by the SGI compiler.
+	* Makefile: Rebuilt.
+
+Fri Oct  4 09:51:08 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* prep_cif.c (initialize_aggregate): Moved abi specification
+	to ffi_prep_cif().
+
+Thu Oct  3 15:37:37 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* prep_cif.c (ffi_prep_cif): Changed values from void* to void**.
+	(initialize_aggregate): Fixed aggregate type initialization.
+
+	* Makefile.am (EXTRA_DIST): Added support code for "make dist".
+	* Makefile.in: Regenerated.
+
+Wed Oct  2 11:41:57 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* debug.c, prep_cif: Created.
+
+	* Makefile.am: Added debug.o and prep_cif.o to OBJ.
+	* Makefile.in: Regenerated.
+
+	* Makefile.am (INCLUDES): Added missing -I../include
+	* Makefile.in: Regenerated.
+
+Tue Oct  1 17:11:51 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* error.c, Makefile.am: Created.
+	* Makefile.in: Generated.
+
+--- libffi/src/x86 --------------------------------------------------------
+
+Sun Oct  4 16:27:17 1998  Anthony Green  <green@cygnus.com>
+
+	* sysv.S (retlongdouble): Fixed long long return value support.
+	* ffi.c (ffi_prep_cif_machdep): Ditto.
+
+Wed May 13 04:30:33 1998  Anthony Green  <green@raft.ppp.tsoft.net>
+
+	* ffi.c (ffi_prep_cif_machdep): Fixed long double return value
+	support.
+
+Wed Apr 15 08:43:20 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c (ffi_prep_args): small struct support was missing.
+
+Thu May  8 16:53:58 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* objects.mak: Removed.
+
+Mon Dec  2 15:12:58 1996  Tom Tromey  <tromey@cygnus.com>
+
+	* sysv.S: Use .balign, for a.out Linux boxes.
+
+Tue Oct 15 13:06:50 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c: Clean up based on LCLint output.
+	Added funny /*@...@*/ comments to annotate source.
+
+Fri Oct 11 16:43:38 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c (ffi_call): Added assertion for bad ABIs.
+
+Wed Oct  9 13:57:27 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* sysv.S (retdouble): Fixed double return problems.
+
+	* ffi.c	(ffi_call): Corrected fn arg definition.
+	(ffi_prep_cif_machdep): Fixed double return problems
+
+Tue Oct  8 12:12:49 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c: Moved ffi_type definitions to types.c.
+	(ffi_prep_args): Fixed type promotion bug.
+
+Mon Oct  7 15:53:06 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c (FFI_*_TYPEDEF): Removed redundant ';'
+
+Fri Oct  4 09:54:53 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c (ffi_call): Removed FFI_ABI arg, and swapped
+	remaining args.
+
+Wed Oct  2 10:07:05 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c, sysv.S, objects.mak: Created.
+	(ffi_prep_cif): cif->rvalue no longer initialized to NULL.
+	(ffi_prep_cif_machdep): Moved machine independent cif processing
+	to src/prep_cif.c. Introduced ffi_prep_cif_machdep().
+
+--- libffi/src/mips -------------------------------------------------------
+
+Tue Feb 17 17:18:07 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* o32.S: Fixed typo in comment.
+
+	* ffi.c (ffi_prep_cif_machdep): Fixed argument processing.
+
+Thu May  8 16:53:58 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* o32.s, n32.s: Wrappers for SGI tool support.
+
+	* objects.mak: Removed.
+
+Tue Oct 29 14:37:45 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c (ffi_prep_args): Changed int z to size_t z.
+
+Tue Oct 15 13:17:25 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* n32.S: Fixed bad stack munging. 
+
+	* ffi.c: Moved prototypes for ffi_call_?32() to here from
+	ffi_mips.h because extended_cif is not defined in ffi_mips.h.
+
+Mon Oct 14 12:42:02 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c: Interface changes based on feedback from Jim Blandy.
+
+Thu Oct 10 11:22:16 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* n32.S, ffi.c: Lots of changes to support passing and 
+	returning structures with the n32 calling convention.
+
+	* n32.S: Fixed fn pointer bug.
+
+	* ffi.c (ffi_prep_cif_machdep): Fix for o32 structure
+	return values.
+	(ffi_prep_args): Fixed n32 structure passing when structures
+	partially fit in registers.
+
+Wed Oct  9 13:49:25 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* objects.mak: Added n32.o.
+
+	* n32.S: Created.
+
+	* ffi.c (ffi_prep_args): Added magic to support proper
+	n32 processing.
+
+Tue Oct  8 10:37:35 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c: Moved ffi_type definitions to types.c.
+	(ffi_prep_args): Fixed type promotion bug.
+
+	* o32.S: This code is only built for o32 compiles.
+	A lot of the #define cruft has moved to ffi_mips.h.
+
+	* ffi.c (ffi_prep_cif_machdep): Fixed arg flags. Second arg
+	is only processed if the first is either a float or double.
+
+Mon Oct  7 15:33:59 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* o32.S: Modified to compile under each of o32, n32 and n64.
+
+	* ffi.c (FFI_*_TYPEDEF): Removed redundant ';'
+
+Fri Oct  4 09:53:25 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c (ffi_call): Removed FFI_ABI arg, and swapped
+	remaining args.
+
+Wed Oct  2 17:41:22 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* o32.S: Removed crufty definitions.
+
+Wed Oct  2 12:53:42 1996  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c (ffi_prep_cif): cif->rvalue no longer initialized to NULL.
+	(ffi_prep_cif_machdep): Moved all machine independent cif processing
+	to src/prep_cif.c. Introduced ffi_prep_cif_machdep. Return types
+	of FFI_TYPE_STRUCT are no different than FFI_TYPE_INT.
+
+Tue Oct  1 17:11:02 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c, o32.S, object.mak: Created
+	
+--- libffi/src/sparc ------------------------------------------------------
+
+Tue Feb 24 16:33:18 1998  Anthony Green  <green@hoser.cygnus.com>
+
+	* ffi.c (ffi_prep_args): Added long double support.
+
+Thu May  8 16:53:58 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* objects.mak: Removed.
+
+Thu May  1 16:07:56 1997  Anthony Green  <green@hoser.cygnus.com>
+
+	* v8.S: Fixed minor portability problem reported by 
+	Russ McManus <mcmanr@eq.gs.com>.
+
+Tue Nov 26 14:12:43 1996  Anthony Green  <green@csk3.cygnus.com>
+
+	* v8.S: Used STACKFRAME define elsewhere. 
+
+	* ffi.c (ffi_prep_args): Zero out space when USING_PURIFY
+	is set.
+	(ffi_prep_cif_machdep): Allocate the correct stack frame 
+	space for functions with < 6 args.
+
+Tue Oct 29 15:08:55 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c (ffi_prep_args): int z is now size_t z.
+
+Mon Oct 14 13:31:24 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* v8.S (ffi_call_V8): Gordon rewrites this again. It looks
+	great now.
+
+	* ffi.c (ffi_call): The comment about hijacked registers
+	is no longer valid after gordoni hacked v8.S.
+
+        * v8.S (ffi_call_V8): Rewrote with gordoni. Much simpler.
+	
+	* v8.S, ffi.c: ffi_call() had changed to accept more than
+	two args, so v8.S had to change (because it hijacks incoming
+	arg registers).
+
+	* ffi.c: Interface changes based on feedback from Jim Blandy.
+
+Thu Oct 10 17:48:16 1996  Anthony Green  <green@rtl.cygnus.com>
+
+	* ffi.c, v8.S, objects.mak: Created.
+	
+
Index: libffi-3.4.6/libffi.map.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/libffi.map.in b/libffi-3.4.6/libffi.map.in
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/libffi.map.in	
@@ -0,0 +1,81 @@
+#define LIBFFI_ASM
+#define LIBFFI_H
+#include <fficonfig.h>
+#include <ffitarget.h>
+
+/* These version numbers correspond to the libtool-version abi numbers,
+   not to the libffi release numbers.  */
+
+LIBFFI_BASE_8.0 {
+  global:
+	/* Exported data variables.  */
+	ffi_type_void;
+	ffi_type_uint8;
+	ffi_type_sint8;
+	ffi_type_uint16;
+	ffi_type_sint16;
+	ffi_type_uint32;
+	ffi_type_sint32;
+	ffi_type_uint64;
+	ffi_type_sint64;
+	ffi_type_float;
+	ffi_type_double;
+	ffi_type_longdouble;
+	ffi_type_pointer;
+
+	/* Exported functions.  */
+	ffi_call;
+	ffi_prep_cif;
+	ffi_prep_cif_var;
+
+	ffi_raw_call;
+	ffi_ptrarray_to_raw;
+	ffi_raw_to_ptrarray;
+	ffi_raw_size;
+
+#if !FFI_NATIVE_RAW_API
+	ffi_java_raw_call;
+#endif
+
+	ffi_java_ptrarray_to_raw;
+	ffi_java_raw_to_ptrarray;
+	ffi_java_raw_size;
+
+	ffi_get_struct_offsets;
+  local:
+	*;
+};
+
+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
+LIBFFI_COMPLEX_8.0 {
+  global:
+	/* Exported data variables.  */
+	ffi_type_complex_float;
+	ffi_type_complex_double;
+	ffi_type_complex_longdouble;
+} LIBFFI_BASE_8.0;
+#endif
+
+#if FFI_CLOSURES
+LIBFFI_CLOSURE_8.0 {
+  global:
+	ffi_closure_alloc;
+	ffi_closure_free;
+	ffi_prep_closure;
+	ffi_prep_closure_loc;
+	ffi_prep_raw_closure;
+	ffi_prep_raw_closure_loc;
+#if !FFI_NATIVE_RAW_API
+	ffi_prep_java_raw_closure;
+	ffi_prep_java_raw_closure_loc;
+#endif
+} LIBFFI_BASE_8.0;
+#endif
+
+#if FFI_GO_CLOSURES
+LIBFFI_GO_CLOSURE_8.0 {
+  global:
+	ffi_call_go;
+	ffi_prep_go_closure;
+} LIBFFI_CLOSURE_8.0;
+#endif
Index: libffi-3.4.6/.gitattributes
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/.gitattributes b/libffi-3.4.6/.gitattributes
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/.gitattributes	
@@ -0,0 +1,4 @@
+*	text=auto
+
+*.sln	text eol=crlf
+*.vcxproj*	text eol=crlf
Index: libffi-3.4.6/configure.host
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/configure.host b/libffi-3.4.6/configure.host
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/configure.host	
@@ -0,0 +1,337 @@
+# configure.host
+#
+# This shell script handles all host based configuration for libffi.
+#
+
+# THIS TABLE IS SORTED.  KEEP IT THAT WAY.
+# Most of the time we can define all the variables all at once...
+case "${host}" in
+  aarch64*-*-cygwin* | aarch64*-*-msys* | aarch64*-*-mingw* | aarch64*-*-win* )
+	TARGET=ARM_WIN64; TARGETDIR=aarch64
+	if test "${ax_cv_c_compiler_vendor}" = "microsoft"; then
+	  MSVC=1
+	fi
+	;;
+
+  aarch64*-*-*)
+	TARGET=AARCH64; TARGETDIR=aarch64
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  alpha*-*-*)
+	TARGET=ALPHA; TARGETDIR=alpha;
+	# Support 128-bit long double, changeable via command-line switch.
+	HAVE_LONG_DOUBLE='defined(__LONG_DOUBLE_128__)'
+	SOURCES="ffi.c osf.S"
+	;;
+
+  arc*-*-*)
+	TARGET=ARC; TARGETDIR=arc
+	SOURCES="ffi.c arcompact.S"
+	;;
+
+  arm*-*-cygwin* | arm*-*-msys* | arm*-*-mingw* | arm*-*-win* )
+	TARGET=ARM_WIN32; TARGETDIR=arm
+	if test "${ax_cv_c_compiler_vendor}" = "microsoft"; then
+	  MSVC=1
+	fi
+	;;
+
+  arm*-*-*)
+	TARGET=ARM; TARGETDIR=arm
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  avr32*-*-*)
+	TARGET=AVR32; TARGETDIR=avr32
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  bfin*)
+	TARGET=BFIN; TARGETDIR=bfin
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  cris-*-*)
+	TARGET=LIBFFI_CRIS; TARGETDIR=cris
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  csky-*-*)
+        TARGET=CSKY; TARGETDIR=csky
+        SOURCES="ffi.c sysv.S"
+        ;;
+
+  frv-*-*)
+	TARGET=FRV; TARGETDIR=frv
+	SOURCES="ffi.c eabi.S"
+	;;
+
+  hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)
+	TARGET=PA_LINUX; TARGETDIR=pa
+	SOURCES="ffi.c linux.S"
+	;;
+  hppa*64-*-hpux*)
+	TARGET=PA64_HPUX; TARGETDIR=pa
+	SOURCES="ffi64.c hpux64.S"
+	;;
+  hppa*-*-hpux*)
+	TARGET=PA_HPUX; TARGETDIR=pa
+	SOURCES="ffi.c hpux32.S"
+	;;
+
+  i?86-*-freebsd* | i?86-*-openbsd*)
+	TARGET=X86_FREEBSD; TARGETDIR=x86
+	;;
+
+  i?86-*-cygwin* | i?86-*-msys* | i?86-*-mingw* | i?86-*-win* | i?86-*-os2* | i?86-*-interix* \
+  | x86_64-*-cygwin* | x86_64-*-msys* | x86_64-*-mingw* | x86_64-*-win* )
+	TARGETDIR=x86
+	if test $ac_cv_sizeof_size_t = 4; then
+	  TARGET=X86_WIN32
+	else
+	  TARGET=X86_WIN64
+	fi
+	if test "${ax_cv_c_compiler_vendor}" = "microsoft"; then
+	  MSVC=1
+	fi
+	# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.
+	# We must also check with_cross_host to decide if this is a native
+	# or cross-build and select where to install dlls appropriately.
+	if test -n "$with_cross_host" &&
+	   test x"$with_cross_host" != x"no"; then
+	  AM_LTLDFLAGS='-no-undefined -bindir "$(toolexeclibdir)"';
+	else
+	  AM_LTLDFLAGS='-no-undefined -bindir "$(bindir)"';
+	fi
+	;;
+
+  i?86-*-darwin* | x86_64-*-darwin* | i?86-*-ios | x86_64-*-ios)
+	TARGETDIR=x86
+	if test $ac_cv_sizeof_size_t = 4; then
+	  TARGET=X86_DARWIN
+	else
+	  TARGET=X86_64
+	fi
+	;;
+
+  i?86-*-* | x86_64-*-* | amd64-*)
+	TARGETDIR=x86
+	if test $ac_cv_sizeof_size_t = 4; then
+	  echo 'int foo (void) { return __x86_64__; }' > conftest.c
+	  if $CC $CFLAGS -Werror -S conftest.c -o conftest.s > /dev/null 2>&1; then
+	    TARGET_X32=yes
+	    TARGET=X86_64
+	  else
+	    TARGET=X86;
+	  fi
+	  rm -f conftest.*
+	else
+	  TARGET=X86_64;
+	fi
+	;;
+
+  ia64*-*-*)
+	TARGET=IA64; TARGETDIR=ia64
+	SOURCES="ffi.c unix.S"
+	;;
+
+  kvx-*-*)
+	TARGET=KVX; TARGETDIR=kvx
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  loongarch64-*-*)
+	TARGET=LOONGARCH64; TARGETDIR=loongarch64
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  m32r*-*-*)
+	TARGET=M32R; TARGETDIR=m32r
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  m68k-*-*)
+	TARGET=M68K; TARGETDIR=m68k
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  m88k-*-*)
+	TARGET=M88K; TARGETDIR=m88k
+	SOURCES="ffi.c obsd.S"
+	;;
+
+  microblaze*-*-*)
+	TARGET=MICROBLAZE; TARGETDIR=microblaze
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  moxie-*-*)
+	TARGET=MOXIE; TARGETDIR=moxie
+	SOURCES="ffi.c eabi.S"
+	;;
+
+  metag-*-*)
+	TARGET=METAG; TARGETDIR=metag
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)
+	TARGET=MIPS; TARGETDIR=mips
+	;;
+  mips*-*linux* | mips*-*-openbsd* | mips*-*-freebsd*)
+	# Support 128-bit long double for NewABI.
+	HAVE_LONG_DOUBLE='defined(__mips64)'
+	TARGET=MIPS; TARGETDIR=mips
+	;;
+
+  nios2*-linux*)
+	TARGET=NIOS2; TARGETDIR=nios2
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  or1k*-*-*)
+	TARGET=OR1K; TARGETDIR=or1k
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  powerpc*-*-linux* | powerpc-*-sysv*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	HAVE_LONG_DOUBLE_VARIANT=1
+	;;
+  powerpc-*-amigaos*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	;;
+  powerpc-*-eabi*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	;;
+  powerpc-*-beos* | powerpc-*-haiku*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	;;
+  powerpc-*-darwin* | powerpc64-*-darwin*)
+	TARGET=POWERPC_DARWIN; TARGETDIR=powerpc
+	;;
+  powerpc-*-aix* | rs6000-*-aix*)
+	TARGET=POWERPC_AIX; TARGETDIR=powerpc
+	# Create AIX-style "FAT" libraries.
+	tmake_file="t-aix"
+	;;
+  powerpc-*-freebsd* | powerpc-*-openbsd* | powerpc-*-netbsd*)
+	TARGET=POWERPC_FREEBSD; TARGETDIR=powerpc
+	HAVE_LONG_DOUBLE_VARIANT=1
+	;;
+  powerpcspe-*-freebsd*)
+	TARGET=POWERPC_FREEBSD; TARGETDIR=powerpc
+	CFLAGS="$CFLAGS -D__NO_FPRS__"
+	;;
+  powerpc64-*-freebsd* | powerpc64le-*-freebsd*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	;;
+  powerpc*-*-rtems*)
+	TARGET=POWERPC; TARGETDIR=powerpc
+	;;
+
+  riscv*-*)
+	TARGET=RISCV; TARGETDIR=riscv
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  s390-*-* | s390x-*-*)
+	TARGET=S390; TARGETDIR=s390
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  sh-*-* | sh[34]*-*-*)
+	TARGET=SH; TARGETDIR=sh
+	SOURCES="ffi.c sysv.S"
+	;;
+  sh64-*-* | sh5*-*-*)
+	TARGET=SH64; TARGETDIR=sh64
+	SOURCES="ffi.c sysv.S"
+	;;
+
+  sparc*-*-*)
+	TARGET=SPARC; TARGETDIR=sparc
+	SOURCES="ffi.c ffi64.c v8.S v9.S"
+	;;
+
+  tile*-*)
+        TARGET=TILE; TARGETDIR=tile
+	SOURCES="ffi.c tile.S"
+        ;;
+
+  vax-*-*)
+	TARGET=VAX; TARGETDIR=vax
+	SOURCES="ffi.c elfbsd.S"
+	;;
+
+  wasm32-*-*)
+	TARGET=wasm32; TARGETDIR=wasm32
+	SOURCES="ffi.c"
+	;;
+
+  xtensa*-*)
+	TARGET=XTENSA; TARGETDIR=xtensa
+	SOURCES="ffi.c sysv.S"
+	;;
+esac
+
+# ... but some of the cases above share configury.
+case "${TARGET}" in
+  ARM_WIN32)
+	if test "$MSVC" = 1; then
+		SOURCES="ffi.c sysv_msvc_arm32.S"
+	else
+		SOURCES="ffi.c sysv.S"
+	fi
+	;;
+  ARM_WIN64)
+	if test "$MSVC" = 1; then
+		SOURCES="ffi.c win64_armasm.S"
+	else
+		SOURCES="ffi.c sysv.S"
+	fi
+	;;
+  MIPS)
+	SOURCES="ffi.c o32.S n32.S"
+	;;
+  POWERPC)
+	SOURCES="ffi.c ffi_sysv.c ffi_linux64.c sysv.S ppc_closure.S"
+	SOURCES="${SOURCES} linux64.S linux64_closure.S"
+	;;
+  POWERPC_AIX)
+	SOURCES="ffi_darwin.c aix.S aix_closure.S"
+	;;
+  POWERPC_DARWIN)
+	SOURCES="ffi_darwin.c darwin.S darwin_closure.S"
+	;;
+  POWERPC_FREEBSD)
+	SOURCES="ffi.c ffi_sysv.c sysv.S ppc_closure.S"
+	;;
+  X86 | X86_DARWIN | X86_FREEBSD | X86_WIN32)
+	if test "$MSVC" = 1; then
+		SOURCES="ffi.c sysv_intel.S"
+	else
+		SOURCES="ffi.c sysv.S"
+	fi
+	;;
+  X86_64)
+	if test x"$TARGET_X32" = xyes; then
+		SOURCES="ffi64.c unix64.S"
+	else
+		SOURCES="ffi64.c unix64.S ffiw64.c win64.S"
+	fi
+	;;
+  X86_WIN64)
+	if test "$MSVC" = 1; then
+		SOURCES="ffiw64.c win64_intel.S"
+	else
+		SOURCES="ffiw64.c win64.S"
+	fi
+	;;
+esac
+
+# If we failed to configure SOURCES, we can't do anything.
+if test -z "${SOURCES}"; then
+  UNSUPPORTED=1
+fi
Index: libffi-3.4.6/make_sunver.pl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/make_sunver.pl b/libffi-3.4.6/make_sunver.pl
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/make_sunver.pl	
@@ -0,0 +1,333 @@
+#!/usr/bin/perl -w
+
+# make_sunver.pl
+#
+# This script takes at least two arguments, a GNU style version script and
+# a list of object and archive files, and generates a corresponding Sun
+# style version script as follows:
+#
+# Each glob pattern, C++ mangled pattern or literal in the input script is
+# matched against all global symbols in the input objects, emitting those
+# that matched (or nothing if no match was found).
+# A comment with the original pattern and its type is left in the output
+# file to make it easy to understand the matches.
+#
+# It uses elfdump when present (native), GNU readelf otherwise.
+# It depends on the GNU version of c++filt, since it must understand the
+# GNU mangling style.
+
+use FileHandle;
+use IPC::Open2;
+
+# Enforce C locale.
+$ENV{'LC_ALL'} = "C";
+$ENV{'LANG'} = "C";
+
+# Input version script, GNU style.
+my $symvers = shift;
+
+##########
+# Get all the symbols from the library, match them, and add them to a hash.
+
+my %sym_hash = ();
+
+# List of objects and archives to process.
+my @OBJECTS = ();
+
+# List of shared objects to omit from processing.
+my @SHAREDOBJS = ();
+
+# Filter out those input archives that have corresponding shared objects to
+# avoid adding all symbols matched in the archive to the output map.
+foreach $file (@ARGV) {
+    if (($so = $file) =~ s/\.a$/.so/ && -e $so) {
+	printf STDERR "omitted $file -> $so\n";
+	push (@SHAREDOBJS, $so);
+    } else {
+	push (@OBJECTS, $file);
+    }
+}
+
+# We need to detect and ignore hidden symbols.  Solaris nm can only detect
+# this in the harder to parse default output format, and GNU nm not at all,
+# so use elfdump -s in the native case and GNU readelf -s otherwise.
+# GNU objdump -t cannot be used since it produces a variable number of
+# columns.
+
+# The path to elfdump.
+my $elfdump = "/usr/ccs/bin/elfdump";
+
+if (-f $elfdump) {
+    open ELFDUMP,$elfdump.' -s '.(join ' ',@OBJECTS).'|' or die $!;
+    my $skip_arsym = 0;
+
+    while (<ELFDUMP>) {
+	chomp;
+
+	# Ignore empty lines.
+	if (/^$/) {
+	    # End of archive symbol table, stop skipping.
+	    $skip_arsym = 0 if $skip_arsym;
+	    next;
+	}
+
+	# Keep skipping until end of archive symbol table.
+	next if ($skip_arsym);
+
+	# Ignore object name header for individual objects and archives.
+	next if (/:$/);
+
+	# Ignore table header lines.
+	next if (/^Symbol Table Section:/);
+	next if (/index.*value.*size/);
+
+	# Start of archive symbol table: start skipping.
+	if (/^Symbol Table: \(archive/) {
+	    $skip_arsym = 1;
+	    next;
+	}
+
+	# Split table.
+	(undef, undef, undef, undef, $bind, $oth, undef, $shndx, $name) = split;
+
+	# Error out for unknown input.
+	die "unknown input line:\n$_" unless defined($bind);
+
+	# Ignore local symbols.
+	next if ($bind eq "LOCL");
+	# Ignore hidden symbols.
+	next if ($oth eq "H");
+	# Ignore undefined symbols.
+	next if ($shndx eq "UNDEF");
+	# Error out for unhandled cases.
+	if ($bind !~ /^(GLOB|WEAK)/ or $oth ne "D") {
+	    die "unhandled symbol:\n$_";
+	}
+
+	# Remember symbol.
+	$sym_hash{$name}++;
+    }
+    close ELFDUMP or die "$elfdump error";
+} else {
+    open READELF, 'readelf -s -W '.(join ' ',@OBJECTS).'|' or die $!;
+    # Process each symbol.
+    while (<READELF>) {
+	chomp;
+
+	# Ignore empty lines.
+	next if (/^$/);
+
+	# Ignore object name header.
+	next if (/^File: .*$/);
+
+	# Ignore table header lines.
+	next if (/^Symbol table.*contains.*:/);
+	next if (/Num:.*Value.*Size/);
+
+	# Split table.
+	(undef, undef, undef, undef, $bind, $vis, $ndx, $name) = split;
+
+	# Error out for unknown input.
+	die "unknown input line:\n$_" unless defined($bind);
+
+	# Ignore local symbols.
+	next if ($bind eq "LOCAL");
+	# Ignore hidden symbols.
+	next if ($vis eq "HIDDEN");
+	# Ignore undefined symbols.
+	next if ($ndx eq "UND");
+	# Error out for unhandled cases.
+	if ($bind !~ /^(GLOBAL|WEAK)/ or $vis ne "DEFAULT") {
+	    die "unhandled symbol:\n$_";
+	}
+
+	# Remember symbol.
+	$sym_hash{$name}++;
+    }
+    close READELF or die "readelf error";
+}
+
+##########
+# The various types of glob patterns.
+#
+# A glob pattern that is to be applied to the demangled name: 'cxx'.
+# A glob patterns that applies directly to the name in the .o files: 'glob'.
+# This pattern is ignored; used for local variables (usually just '*'): 'ign'.
+
+# The type of the current pattern.
+my $glob = 'glob';
+
+# We're currently inside `extern "C++"', which Sun ld doesn't understand.
+my $in_extern = 0;
+
+# The c++filt command to use.  This *must* be GNU c++filt; the Sun Studio
+# c++filt doesn't handle the GNU mangling style.
+my $cxxfilt = $ENV{'CXXFILT'} || "c++filt";
+
+# The current version name.
+my $current_version = "";
+
+# Was there any attempt to match a symbol to this version?
+my $matches_attempted;
+
+# The number of versions which matched this symbol.
+my $matched_symbols;
+
+open F,$symvers or die $!;
+
+# Print information about generating this file
+print "# This file was generated by make_sunver.pl.  DO NOT EDIT!\n";
+print "# It was generated by:\n";
+printf "# %s %s %s\n", $0, $symvers, (join ' ',@ARGV);
+printf "# Omitted archives with corresponding shared libraries: %s\n",
+    (join ' ', @SHAREDOBJS) if $#SHAREDOBJS >= 0;
+print "#\n\n";
+
+while (<F>) {
+    # Lines of the form '};'
+    if (/^([ \t]*)(\}[ \t]*;[ \t]*)$/) {
+	$glob = 'glob';
+	if ($in_extern) {
+	    $in_extern--;
+	    print "$1##$2\n";
+	} else {
+	    print;
+	}
+	next;
+    }
+
+    # Lines of the form '} SOME_VERSION_NAME_1.0;'
+    if (/^[ \t]*\}[ \tA-Z0-9_.a-z]+;[ \t]*$/) {
+	$glob = 'glob';
+	# We tried to match symbols agains this version, but none matched.
+	# Emit dummy hidden symbol to avoid marking this version WEAK.
+	if ($matches_attempted && $matched_symbols == 0) {
+	    print "  hidden:\n";
+	    print "    .force_WEAK_off_$current_version = DATA S0x0 V0x0;\n";
+	}
+	print; next;
+    }
+
+    # Comment and blank lines
+    if (/^[ \t]*\#/) { print; next; }
+    if (/^[ \t]*$/) { print; next; }
+
+    # Lines of the form '{'
+    if (/^([ \t]*){$/) {
+	if ($in_extern) {
+	    print "$1##{\n";
+	} else {
+	    print;
+	}
+	next;
+    }
+
+    # Lines of the form 'SOME_VERSION_NAME_1.1 {'
+    if (/^([A-Z0-9_.]+)[ \t]+{$/) {
+	# Record version name.
+	$current_version = $1;
+	# Reset match attempts, #matched symbols for this version.
+	$matches_attempted = 0;
+	$matched_symbols = 0;
+	print;
+	next;
+    }
+
+    # Ignore 'global:'
+    if (/^[ \t]*global:$/) { print; next; }
+
+    # After 'local:', globs should be ignored, they won't be exported.
+    if (/^[ \t]*local:$/) {
+	$glob = 'ign';
+	print;
+	next;
+    }
+
+    # After 'extern "C++"', globs are C++ patterns
+    if (/^([ \t]*)(extern \"C\+\+\"[ \t]*)$/) {
+	$in_extern++;
+	$glob = 'cxx';
+	# Need to comment, Sun ld cannot handle this.
+	print "$1##$2\n"; next;
+    }
+
+    # Chomp newline now we're done with passing through the input file.
+    chomp;
+
+    # Catch globs.  Note that '{}' is not allowed in globs by this script,
+    # so only '*' and '[]' are available.
+    if (/^([ \t]*)([^ \t;{}#]+);?[ \t]*$/) {
+	my $ws = $1;
+	my $ptn = $2;
+	# Turn the glob into a regex by replacing '*' with '.*', '?' with '.'.
+	# Keep $ptn so we can still print the original form.
+	($pattern = $ptn) =~ s/\*/\.\*/g;
+	$pattern =~ s/\?/\./g;
+
+	if ($glob eq 'ign') {
+	    # We're in a local: * section; just continue.
+	    print "$_\n";
+	    next;
+	}
+
+	# Print the glob commented for human readers.
+	print "$ws##$ptn ($glob)\n";
+	# We tried to match a symbol to this version.
+	$matches_attempted++;
+
+	if ($glob eq 'glob') {
+	    my %ptn_syms = ();
+
+	    # Match ptn against symbols in %sym_hash.
+	    foreach my $sym (keys %sym_hash) {
+		# Maybe it matches one of the patterns based on the symbol in
+		# the .o file.
+		$ptn_syms{$sym}++ if ($sym =~ /^$pattern$/);
+	    }
+
+	    foreach my $sym (sort keys(%ptn_syms)) {
+		$matched_symbols++;
+		print "$ws$sym;\n";
+	    }
+	} elsif ($glob eq 'cxx') {
+	    my %dem_syms = ();
+
+	    # Verify that we're actually using GNU c++filt.  Other versions
+	    # most likely cannot handle GNU style symbol mangling.
+	    my $cxxout = `$cxxfilt --version 2>&1`;
+	    $cxxout =~ m/GNU/ or die "$0 requires GNU c++filt to function";
+
+	    # Talk to c++filt through a pair of file descriptors.
+	    # Need to start a fresh instance per pattern, otherwise the
+	    # process grows to 500+ MB.
+	    my $pid = open2(*FILTIN, *FILTOUT, $cxxfilt) or die $!;
+
+	    # Match ptn against symbols in %sym_hash.
+	    foreach my $sym (keys %sym_hash) {
+		# No?  Well, maybe its demangled form matches one of those
+		# patterns.
+		printf FILTOUT "%s\n",$sym;
+		my $dem = <FILTIN>;
+		chomp $dem;
+		$dem_syms{$sym}++ if ($dem =~ /^$pattern$/);
+	    }
+
+	    close FILTOUT or die "c++filt error";
+	    close FILTIN or die "c++filt error";
+	    # Need to wait for the c++filt process to avoid lots of zombies.
+	    waitpid $pid, 0;
+
+	    foreach my $sym (sort keys(%dem_syms)) {
+		$matched_symbols++;
+		print "$ws$sym;\n";
+	    }
+	} else {
+	    # No?  Well, then ignore it.
+	}
+	next;
+    }
+    # Important sanity check.  This script can't handle lots of formats
+    # that GNU ld can, so be sure to error out if one is seen!
+    die "strange line `$_'";
+}
+close F;
Index: libffi-3.4.6/x86_64-pc-msys/include/ffi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/x86_64-pc-msys/include/ffi.h b/libffi-3.4.6/x86_64-pc-msys/include/ffi.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/x86_64-pc-msys/include/ffi.h	
@@ -0,0 +1,518 @@
+/* -----------------------------------------------------------------*-C-*-
+   libffi 3.4.6
+     - Copyright (c) 2011, 2014, 2019, 2021, 2022, 2024 Anthony Green
+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the ``Software''), to deal in the Software without
+   restriction, including without limitation the rights to use, copy,
+   modify, merge, publish, distribute, sublicense, and/or sell copies
+   of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------
+   Most of the API is documented in doc/libffi.texi.
+
+   The raw API is designed to bypass some of the argument packing and
+   unpacking on architectures for which it can be avoided.  Routines
+   are provided to emulate the raw API if the underlying platform
+   doesn't allow faster implementation.
+
+   More details on the raw API can be found in:
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00138.html
+
+   and
+
+   http://gcc.gnu.org/ml/java/1999-q3/msg00174.html
+   -------------------------------------------------------------------- */
+
+#ifndef LIBFFI_H
+#define LIBFFI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Specify which architecture libffi is configured for. */
+#ifndef X86_WIN64
+#define X86_WIN64
+#endif
+
+/* ---- System configuration information --------------------------------- */
+
+/* If these change, update src/mips/ffitarget.h. */
+#define FFI_TYPE_VOID       0
+#define FFI_TYPE_INT        1
+#define FFI_TYPE_FLOAT      2
+#define FFI_TYPE_DOUBLE     3
+#if 1
+#define FFI_TYPE_LONGDOUBLE 4
+#else
+#define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE
+#endif
+#define FFI_TYPE_UINT8      5
+#define FFI_TYPE_SINT8      6
+#define FFI_TYPE_UINT16     7
+#define FFI_TYPE_SINT16     8
+#define FFI_TYPE_UINT32     9
+#define FFI_TYPE_SINT32     10
+#define FFI_TYPE_UINT64     11
+#define FFI_TYPE_SINT64     12
+#define FFI_TYPE_STRUCT     13
+#define FFI_TYPE_POINTER    14
+#define FFI_TYPE_COMPLEX    15
+
+/* This should always refer to the last type code (for sanity checks).  */
+#define FFI_TYPE_LAST       FFI_TYPE_COMPLEX
+
+#include <ffitarget.h>
+
+#ifndef LIBFFI_ASM
+
+#if defined(_MSC_VER) && !defined(__clang__)
+#define __attribute__(X)
+#endif
+
+#include <stddef.h>
+#include <limits.h>
+
+/* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).
+   But we can find it either under the correct ANSI name, or under GNU
+   C's internal name.  */
+
+#define FFI_64_BIT_MAX 9223372036854775807
+
+#ifdef LONG_LONG_MAX
+# define FFI_LONG_LONG_MAX LONG_LONG_MAX
+#else
+# ifdef LLONG_MAX
+#  define FFI_LONG_LONG_MAX LLONG_MAX
+#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */
+#   undef FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif /* _AIX52 or newer */
+# else
+#  ifdef __GNUC__
+#   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__
+#  endif
+#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */
+#   ifndef __PPC64__
+#    if defined (__IBMC__) || defined (__IBMCPP__)
+#     define FFI_LONG_LONG_MAX LONGLONG_MAX
+#    endif
+#   endif /* __PPC64__ */
+#   undef  FFI_64_BIT_MAX
+#   define FFI_64_BIT_MAX 9223372036854775807LL
+#  endif
+# endif
+#endif
+
+/* The closure code assumes that this works on pointers, i.e. a size_t
+   can hold a pointer.  */
+
+typedef struct _ffi_type
+{
+  size_t size;
+  unsigned short alignment;
+  unsigned short type;
+  struct _ffi_type **elements;
+} ffi_type;
+
+/* Need minimal decorations for DLLs to work on Windows.  GCC has
+   autoimport and autoexport.  Always mark externally visible symbols
+   as dllimport for MSVC clients, even if it means an extra indirection
+   when using the static version of the library.
+   Besides, as a workaround, they can define FFI_BUILDING if they
+   *know* they are going to link with the static library.  */
+#if defined _MSC_VER && !defined(FFI_STATIC_BUILD)
+# if defined FFI_BUILDING_DLL /* Building libffi.DLL with msvcc.sh */
+#  define FFI_API __declspec(dllexport)
+# else  /* Importing libffi.DLL */
+#  define FFI_API __declspec(dllimport)
+# endif
+#else
+# define FFI_API
+#endif
+
+/* The externally visible type declarations also need the MSVC DLL
+   decorations, or they will not be exported from the object file.  */
+#if defined LIBFFI_HIDE_BASIC_TYPES
+# define FFI_EXTERN FFI_API
+#else
+# define FFI_EXTERN extern FFI_API
+#endif
+
+#ifndef LIBFFI_HIDE_BASIC_TYPES
+#if SCHAR_MAX == 127
+# define ffi_type_uchar                ffi_type_uint8
+# define ffi_type_schar                ffi_type_sint8
+#else
+ #error "char size not supported"
+#endif
+
+#if SHRT_MAX == 32767
+# define ffi_type_ushort       ffi_type_uint16
+# define ffi_type_sshort       ffi_type_sint16
+#elif SHRT_MAX == 2147483647
+# define ffi_type_ushort       ffi_type_uint32
+# define ffi_type_sshort       ffi_type_sint32
+#else
+ #error "short size not supported"
+#endif
+
+#if INT_MAX == 32767
+# define ffi_type_uint         ffi_type_uint16
+# define ffi_type_sint         ffi_type_sint16
+#elif INT_MAX == 2147483647
+# define ffi_type_uint         ffi_type_uint32
+# define ffi_type_sint         ffi_type_sint32
+#elif INT_MAX == 9223372036854775807
+# define ffi_type_uint         ffi_type_uint64
+# define ffi_type_sint         ffi_type_sint64
+#else
+ #error "int size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX
+ #error "no 64-bit data type supported"
+# endif
+#elif LONG_MAX != FFI_64_BIT_MAX
+ #error "long size not supported"
+#endif
+
+#if LONG_MAX == 2147483647
+# define ffi_type_ulong        ffi_type_uint32
+# define ffi_type_slong        ffi_type_sint32
+#elif LONG_MAX == FFI_64_BIT_MAX
+# define ffi_type_ulong        ffi_type_uint64
+# define ffi_type_slong        ffi_type_sint64
+#else
+ #error "long size not supported"
+#endif
+
+/* These are defined in types.c.  */
+FFI_EXTERN ffi_type ffi_type_void;
+FFI_EXTERN ffi_type ffi_type_uint8;
+FFI_EXTERN ffi_type ffi_type_sint8;
+FFI_EXTERN ffi_type ffi_type_uint16;
+FFI_EXTERN ffi_type ffi_type_sint16;
+FFI_EXTERN ffi_type ffi_type_uint32;
+FFI_EXTERN ffi_type ffi_type_sint32;
+FFI_EXTERN ffi_type ffi_type_uint64;
+FFI_EXTERN ffi_type ffi_type_sint64;
+FFI_EXTERN ffi_type ffi_type_float;
+FFI_EXTERN ffi_type ffi_type_double;
+FFI_EXTERN ffi_type ffi_type_pointer;
+FFI_EXTERN ffi_type ffi_type_longdouble;
+
+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
+FFI_EXTERN ffi_type ffi_type_complex_float;
+FFI_EXTERN ffi_type ffi_type_complex_double;
+FFI_EXTERN ffi_type ffi_type_complex_longdouble;
+#endif
+#endif /* LIBFFI_HIDE_BASIC_TYPES */
+
+typedef enum {
+  FFI_OK = 0,
+  FFI_BAD_TYPEDEF,
+  FFI_BAD_ABI,
+  FFI_BAD_ARGTYPE
+} ffi_status;
+
+typedef struct {
+  ffi_abi abi;
+  unsigned nargs;
+  ffi_type **arg_types;
+  ffi_type *rtype;
+  unsigned bytes;
+  unsigned flags;
+#ifdef FFI_EXTRA_CIF_FIELDS
+  FFI_EXTRA_CIF_FIELDS;
+#endif
+} ffi_cif;
+
+/* ---- Definitions for the raw API -------------------------------------- */
+
+#ifndef FFI_SIZEOF_ARG
+# if LONG_MAX == 2147483647
+#  define FFI_SIZEOF_ARG        4
+# elif LONG_MAX == FFI_64_BIT_MAX
+#  define FFI_SIZEOF_ARG        8
+# endif
+#endif
+
+#ifndef FFI_SIZEOF_JAVA_RAW
+#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG
+#endif
+
+typedef union {
+  ffi_sarg  sint;
+  ffi_arg   uint;
+  float	    flt;
+  char      data[FFI_SIZEOF_ARG];
+  void*     ptr;
+} ffi_raw;
+
+#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8
+/* This is a special case for mips64/n32 ABI (and perhaps others) where
+   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */
+typedef union {
+  signed int	sint;
+  unsigned int	uint;
+  float		flt;
+  char		data[FFI_SIZEOF_JAVA_RAW];
+  void*		ptr;
+} ffi_java_raw;
+#else
+typedef ffi_raw ffi_java_raw;
+#endif
+
+
+FFI_API
+void ffi_raw_call (ffi_cif *cif,
+		   void (*fn)(void),
+		   void *rvalue,
+		   ffi_raw *avalue);
+
+FFI_API void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
+FFI_API void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
+FFI_API size_t ffi_raw_size (ffi_cif *cif);
+
+/* This is analogous to the raw API, except it uses Java parameter
+   packing, even on 64-bit machines.  I.e. on 64-bit machines longs
+   and doubles are followed by an empty 64-bit word.  */
+
+#if !FFI_NATIVE_RAW_API
+FFI_API
+void ffi_java_raw_call (ffi_cif *cif,
+			void (*fn)(void),
+			void *rvalue,
+			ffi_java_raw *avalue) __attribute__((deprecated));
+#endif
+
+FFI_API
+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));
+FFI_API
+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));
+FFI_API
+size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#if FFI_CLOSURES
+
+#ifdef _MSC_VER
+__declspec(align(8))
+#endif
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  union {
+    char tramp[FFI_TRAMPOLINE_SIZE];
+    void *ftramp;
+  };
+#endif
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+  void      *user_data;
+#if defined(_MSC_VER) && defined(_M_IX86)
+  void      *padding;
+#endif
+} ffi_closure
+#ifdef __GNUC__
+    __attribute__((aligned (8)))
+#endif
+    ;
+
+#ifndef __GNUC__
+# ifdef __sgi
+#  pragma pack 0
+# endif
+#endif
+
+FFI_API void *ffi_closure_alloc (size_t size, void **code);
+FFI_API void ffi_closure_free (void *);
+
+FFI_API ffi_status
+ffi_prep_closure (ffi_closure*,
+		  ffi_cif *,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+#if defined(__GNUC__) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 405)
+  __attribute__((deprecated ("use ffi_prep_closure_loc instead")))
+#elif defined(__GNUC__) && __GNUC__ >= 3
+  __attribute__((deprecated))
+#endif
+  ;
+
+FFI_API ffi_status
+ffi_prep_closure_loc (ffi_closure*,
+		      ffi_cif *,
+		      void (*fun)(ffi_cif*,void*,void**,void*),
+		      void *user_data,
+		      void *codeloc);
+
+#ifdef __sgi
+# pragma pack 8
+#endif
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout
+     as a regular closure.  We use this to install an intermediate
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_raw*,void*);
+  void      *user_data;
+
+} ffi_raw_closure;
+
+typedef struct {
+#if 0
+  void *trampoline_table;
+  void *trampoline_table_entry;
+#else
+  char tramp[FFI_TRAMPOLINE_SIZE];
+#endif
+
+  ffi_cif   *cif;
+
+#if !FFI_NATIVE_RAW_API
+
+  /* If this is enabled, then a raw closure has the same layout
+     as a regular closure.  We use this to install an intermediate
+     handler to do the translation, void** -> ffi_raw*.  */
+
+  void     (*translate_args)(ffi_cif*,void*,void**,void*);
+  void      *this_closure;
+
+#endif
+
+  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
+  void      *user_data;
+
+} ffi_java_raw_closure;
+
+FFI_API ffi_status
+ffi_prep_raw_closure (ffi_raw_closure*,
+		      ffi_cif *cif,
+		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+		      void *user_data);
+
+FFI_API ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure*,
+			  ffi_cif *cif,
+			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+			  void *user_data,
+			  void *codeloc);
+
+#if !FFI_NATIVE_RAW_API
+FFI_API ffi_status
+ffi_prep_java_raw_closure (ffi_java_raw_closure*,
+		           ffi_cif *cif,
+		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+		           void *user_data) __attribute__((deprecated));
+
+FFI_API ffi_status
+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
+			       ffi_cif *cif,
+			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
+			       void *user_data,
+			       void *codeloc) __attribute__((deprecated));
+#endif
+
+#endif /* FFI_CLOSURES */
+
+#ifdef FFI_GO_CLOSURES
+
+typedef struct {
+  void      *tramp;
+  ffi_cif   *cif;
+  void     (*fun)(ffi_cif*,void*,void**,void*);
+} ffi_go_closure;
+
+FFI_API ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
+				void (*fun)(ffi_cif*,void*,void**,void*));
+
+FFI_API void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
+		  void **avalue, void *closure);
+
+#endif /* FFI_GO_CLOSURES */
+
+/* ---- Public interface definition -------------------------------------- */
+
+FFI_API
+ffi_status ffi_prep_cif(ffi_cif *cif,
+			ffi_abi abi,
+			unsigned int nargs,
+			ffi_type *rtype,
+			ffi_type **atypes);
+
+FFI_API
+ffi_status ffi_prep_cif_var(ffi_cif *cif,
+			    ffi_abi abi,
+			    unsigned int nfixedargs,
+			    unsigned int ntotalargs,
+			    ffi_type *rtype,
+			    ffi_type **atypes);
+
+FFI_API
+void ffi_call(ffi_cif *cif,
+	      void (*fn)(void),
+	      void *rvalue,
+	      void **avalue);
+
+FFI_API
+ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
+				   size_t *offsets);
+
+/* Convert between closure and function pointers.  */
+#if defined(PA_LINUX) || defined(PA_HPUX)
+#define FFI_FN(f) ((void (*)(void))((unsigned int)(f) | 2))
+#define FFI_CL(f) ((void *)((unsigned int)(f) & ~3))
+#else
+#define FFI_FN(f) ((void (*)(void))f)
+#define FFI_CL(f) ((void *)(f))
+#endif
+
+/* ---- Definitions shared with assembly code ---------------------------- */
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: libffi-3.4.6/x86_64-pc-msys/include/ffitarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/x86_64-pc-msys/include/ffitarget.h b/libffi-3.4.6/x86_64-pc-msys/include/ffitarget.h
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/x86_64-pc-msys/include/ffitarget.h	
@@ -0,0 +1,164 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - Copyright (c) 2012, 2014, 2018  Anthony Green
+                 Copyright (c) 1996-2003, 2010  Red Hat, Inc.
+                 Copyright (C) 2008  Free Software Foundation, Inc.
+
+   Target configuration macros for x86 and x86-64.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+/* ---- System specific configurations ----------------------------------- */
+
+/* For code common to all platforms on x86 and x86_64. */
+#define X86_ANY
+
+#if defined (X86_64) && defined (__i386__)
+#undef X86_64
+#warning ******************************************************
+#warning ********** X86 IS DEFINED ****************************
+#warning ******************************************************
+#define X86
+#endif
+
+#ifdef X86_WIN64
+#define FFI_SIZEOF_ARG 8
+#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
+#endif
+
+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
+#ifndef _MSC_VER
+#define FFI_TARGET_HAS_COMPLEX_TYPE
+#endif
+
+/* ---- Generic type definitions ----------------------------------------- */
+
+#ifndef LIBFFI_ASM
+#ifdef X86_WIN64
+#ifdef _MSC_VER
+typedef unsigned __int64       ffi_arg;
+typedef __int64                ffi_sarg;
+#else
+typedef unsigned long long     ffi_arg;
+typedef long long              ffi_sarg;
+#endif
+#else
+#if defined __x86_64__ && defined __ILP32__
+#define FFI_SIZEOF_ARG 8
+#define FFI_SIZEOF_JAVA_RAW  4
+typedef unsigned long long     ffi_arg;
+typedef long long              ffi_sarg;
+#else
+typedef unsigned long          ffi_arg;
+typedef signed long            ffi_sarg;
+#endif
+#endif
+
+typedef enum ffi_abi {
+#if defined(X86_WIN64)
+  FFI_FIRST_ABI = 0,
+  FFI_WIN64,            /* sizeof(long double) == 8  - microsoft compilers */
+  FFI_GNUW64,           /* sizeof(long double) == 16 - GNU compilers */
+  FFI_LAST_ABI,
+#ifdef __GNUC__
+  FFI_DEFAULT_ABI = FFI_GNUW64
+#else
+  FFI_DEFAULT_ABI = FFI_WIN64
+#endif
+
+#elif defined(X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))
+  FFI_FIRST_ABI = 1,
+  FFI_UNIX64,
+  FFI_WIN64,
+  FFI_EFI64 = FFI_WIN64,
+  FFI_GNUW64,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_UNIX64
+
+#elif defined(X86_WIN32)
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV      = 1,
+  FFI_STDCALL   = 2,
+  FFI_THISCALL  = 3,
+  FFI_FASTCALL  = 4,
+  FFI_MS_CDECL  = 5,
+  FFI_PASCAL    = 6,
+  FFI_REGISTER  = 7,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_MS_CDECL
+#else
+  FFI_FIRST_ABI = 0,
+  FFI_SYSV      = 1,
+  FFI_THISCALL  = 3,
+  FFI_FASTCALL  = 4,
+  FFI_STDCALL   = 5,
+  FFI_PASCAL    = 6,
+  FFI_REGISTER  = 7,
+  FFI_MS_CDECL  = 8,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_SYSV
+#endif
+} ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+
+#define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
+#define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
+#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)
+#define FFI_TYPE_MS_STRUCT       (FFI_TYPE_LAST + 4)
+
+#if defined (X86_64) || defined(X86_WIN64) \
+    || (defined (__x86_64__) && defined (X86_DARWIN))
+/* 4 bytes of ENDBR64 + 7 bytes of LEA + 6 bytes of JMP + 7 bytes of NOP
+   + 8 bytes of pointer.  */
+# define FFI_TRAMPOLINE_SIZE 32
+# define FFI_NATIVE_RAW_API 0
+#else
+/* 4 bytes of ENDBR32 + 5 bytes of MOV + 5 bytes of JMP + 2 unused
+   bytes.  */
+# define FFI_TRAMPOLINE_SIZE 16
+# define FFI_NATIVE_RAW_API 1  /* x86 has native raw api support */
+#endif
+
+#if !defined(GENERATE_LIBFFI_MAP) && defined(__CET__)
+# include <cet.h>
+# if (__CET__ & 1) != 0
+#   define ENDBR_PRESENT
+# endif
+# define _CET_NOTRACK notrack
+#else
+# define _CET_ENDBR
+# define _CET_NOTRACK
+#endif
+
+#endif
Index: libffi-3.4.6/x86_64-pc-msys/local.exp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/x86_64-pc-msys/local.exp b/libffi-3.4.6/x86_64-pc-msys/local.exp
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/x86_64-pc-msys/local.exp	
@@ -0,0 +1,3 @@
+set CC_FOR_TARGET "gcc"
+set CXX_FOR_TARGET "g++"
+set compiler_vendor "gnu"
Index: libffi-3.4.6/libtool-ldflags
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/libtool-ldflags b/libffi-3.4.6/libtool-ldflags
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/libtool-ldflags	
@@ -0,0 +1,106 @@
+#! /bin/sh
+
+# Script to translate LDFLAGS into a form suitable for use with libtool.
+
+# Copyright (C) 2005 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+# MA 02110-1301, USA. 
+
+# Contributed by CodeSourcery, LLC.
+
+# This script is designed to be used from a Makefile that uses libtool
+# to build libraries as follows: 
+#
+#   LTLDFLAGS = $(shell libtool-ldflags $(LDFLAGS))
+#
+# Then, use (LTLDFLAGS) in place of $(LDFLAGS) in your link line.
+
+# The output of the script.  This string is built up as we process the
+# arguments.
+result=
+prev_arg=
+
+for arg
+do
+    case $arg in
+	-f*|--*)
+	    # Libtool does not ascribe any special meaning options
+	    # that begin with -f or with a double-dash.  So, it will
+	    # think these options are linker options, and prefix them
+	    # with "-Wl,".  Then, the compiler driver will ignore the
+	    # options.  So, we prefix these options with -Xcompiler to
+	    # make clear to libtool that they are in fact compiler
+	    # options.
+	    case $prev_arg in
+		-Xpreprocessor|-Xcompiler|-Xlinker)
+		    # This option is already prefixed; don't prefix it again.
+		    ;;
+		*)
+		    result="$result -Xcompiler"
+		    ;;
+	    esac
+	    ;;
+	*)
+	    # We do not want to add -Xcompiler to other options because
+	    # that would prevent libtool itself from recognizing them.
+	    ;;
+    esac
+    prev_arg=$arg
+
+    # If $(LDFLAGS) is (say):
+    #   a "b'c d" e
+    # then the user expects that:
+    #   $(LD) $(LDFLAGS)
+    # will pass three arguments to $(LD):
+    #   1) a
+    #   2) b'c d
+    #   3) e
+    # We must ensure, therefore, that the arguments are appropriately
+    # quoted so that using:
+    #   libtool --mode=link ... $(LTLDFLAGS)
+    # will result in the same number of arguments being passed to
+    # libtool.   In other words, when this script was invoked, the shell 
+    # removed one level of quoting, present in $(LDFLAGS); we have to put 
+    # it back.
+
+    # Quote any embedded single quotes.
+    case $arg in
+	*"'"*)
+	    # The following command creates the script:
+	    #   1s,^X,,;s|'|'"'"'|g
+	    # which removes a leading X, and then quotes and embedded single
+	    # quotes.
+	    sed_script="1s,^X,,;s|'|'\"'\"'|g"
+	    # Add a leading "X" so that if $arg starts with a dash,
+	    # the echo command will not try to interpret the argument
+	    # as a command-line option.
+	    arg="X$arg"
+	    # Generate the quoted string.
+	    quoted_arg=`echo "$arg" | sed -e "$sed_script"`
+	    ;;
+	*)
+	    quoted_arg=$arg
+	    ;;
+    esac
+    # Surround the entire argument with single quotes.
+    quoted_arg="'"$quoted_arg"'" 
+
+    # Add it to the string.
+    result="$result $quoted_arg"
+done
+
+# Output the string we have built up.
+echo "$result"
Index: libffi-3.4.6/libtool-version
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/libtool-version b/libffi-3.4.6/libtool-version
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/libtool-version	
@@ -0,0 +1,29 @@
+# This file is used to maintain libtool version info for libffi.  See
+# the libtool manual to understand the meaning of the fields.  This is
+# a separate file so that version updates don't involve re-running
+# automake.
+#
+# Here are a set of rules to help you update your library version
+# information:
+#
+# 1. Start with version information of `0:0:0' for each libtool library.
+#
+# 2. Update the version information only immediately before a public
+#    release of your software. More frequent updates are unnecessary,
+#    and only guarantee that the current interface number gets larger
+#    faster.
+#
+# 3. If the library source code has changed at all since the last
+#    update, then increment revision (`c:r:a' becomes `c:r+1:a').
+#
+# 4. If any interfaces have been added, removed, or changed since the
+#    last update, increment current, and set revision to 0.
+#
+# 5. If any interfaces have been added since the last public release,
+#    then increment age.
+#
+# 6. If any interfaces have been removed since the last public
+#    release, then set age to 0.
+#
+# CURRENT:REVISION:AGE
+9:4:1
Index: libffi-3.4.6/libffi.xcodeproj/project.pbxproj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/libffi.xcodeproj/project.pbxproj b/libffi-3.4.6/libffi.xcodeproj/project.pbxproj
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/libffi.xcodeproj/project.pbxproj	
@@ -0,0 +1,997 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		43B5D3F81D35473200D1E1FD /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */; };
+		43B5D3FA1D3547CE00D1E1FD /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */; };
+		43E9A5C81D352C1500926A8F /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43E9A5C61D352C1500926A8F /* unix64_x86_64.S */; };
+		DBFA714A187F1D8600A76262 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };
+		DBFA714B187F1D8600A76262 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713F187F1D8600A76262 /* ffi_common.h */; };
+		DBFA714C187F1D8600A76262 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7140187F1D8600A76262 /* fficonfig.h */; };
+		DBFA714D187F1D8600A76262 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };
+		DBFA714E187F1D8600A76262 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };
+		DBFA714F187F1D8600A76262 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };
+		DBFA7156187F1D8600A76262 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };
+		DBFA7157187F1D8600A76262 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };
+		DBFA7158187F1D8600A76262 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };
+		DBFA7159187F1D8600A76262 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };
+		DBFA715A187F1D8600A76262 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };
+		DBFA715B187F1D8600A76262 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };
+		DBFA7177187F1D9B00A76262 /* ffi_arm64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716C187F1D9B00A76262 /* ffi_arm64.c */; };
+		DBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716D187F1D9B00A76262 /* sysv_arm64.S */; };
+		DBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716F187F1D9B00A76262 /* ffi_armv7.c */; };
+		DBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7170187F1D9B00A76262 /* sysv_armv7.S */; };
+		DBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */; };
+		DBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7183187F1DA100A76262 /* ffi_x86_64.h */; };
+		DBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */; };
+		DBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */; };
+		DBFA7194187F1DA100A76262 /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* unix64_x86_64.S */; };
+		DBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */; };
+		FDB52FB31F6144FA00AA92E6 /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43E9A5C61D352C1500926A8F /* unix64_x86_64.S */; };
+		FDB52FB51F6144FA00AA92E6 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */; };
+		FDB52FB61F6144FA00AA92E6 /* ffi_armv7.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716F187F1D9B00A76262 /* ffi_armv7.c */; };
+		FDB52FB71F6144FA00AA92E6 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };
+		FDB52FB81F6144FA00AA92E6 /* sysv_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7170187F1D9B00A76262 /* sysv_armv7.S */; };
+		FDB52FB91F6144FA00AA92E6 /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */; };
+		FDB52FBA1F6144FA00AA92E6 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };
+		FDB52FBC1F6144FA00AA92E6 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };
+		FDB52FBD1F6144FA00AA92E6 /* sysv_arm64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716D187F1D9B00A76262 /* sysv_arm64.S */; };
+		FDB52FBE1F6144FA00AA92E6 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };
+		FDB52FBF1F6144FA00AA92E6 /* ffi_arm64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716C187F1D9B00A76262 /* ffi_arm64.c */; };
+		FDB52FC01F6144FA00AA92E6 /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */; };
+		FDB52FD01F614A8B00AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };
+		FDB52FD11F614AA700AA92E6 /* ffi_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715E187F1D9B00A76262 /* ffi_arm64.h */; };
+		FDB52FD21F614AAB00AA92E6 /* ffi_armv7.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715F187F1D9B00A76262 /* ffi_armv7.h */; };
+		FDB52FD41F614AB500AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */; };
+		FDB52FD51F614AE200AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };
+		FDB52FD61F614AEA00AA92E6 /* ffi_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715E187F1D9B00A76262 /* ffi_arm64.h */; };
+		FDB52FD71F614AED00AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */; };
+		FDB52FD81F614B8700AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };
+		FDB52FD91F614B8E00AA92E6 /* ffitarget_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */; };
+		FDB52FDA1F614B9300AA92E6 /* ffitarget_armv7.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */; };
+		FDB52FDD1F614BA900AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */; };
+		FDB52FDE1F6155E300AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };
+		FDB52FDF1F6155EA00AA92E6 /* ffitarget_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */; };
+		FDB52FE01F6155EF00AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */; };
+		FDB52FE21F6156FA00AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };
+		FDB52FE31F61571A00AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7183187F1DA100A76262 /* ffi_x86_64.h */; };
+		FDB52FE41F61571D00AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };
+		FDB52FE61F61573100AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */; };
+		FDDB2F411F5D66E200EF414E /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */; };
+		FDDB2F461F5D691E00EF414E /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F441F5D68C900EF414E /* win64_x86_64.S */; };
+		FDDB2F4A1F5D846400EF414E /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */; };
+		FDDB2F4C1F5D846400EF414E /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };
+		FDDB2F4E1F5D846400EF414E /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */; };
+		FDDB2F4F1F5D846400EF414E /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };
+		FDDB2F501F5D846400EF414E /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };
+		FDDB2F511F5D846400EF414E /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };
+		FDDB2F521F5D846400EF414E /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* unix64_x86_64.S */; };
+		FDDB2F531F5D846400EF414E /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F441F5D68C900EF414E /* win64_x86_64.S */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXCopyFilesBuildPhase section */
+		DB13B1641849DF1E0010F42D /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 12;
+			dstPath = "include/$(PRODUCT_NAME)";
+			dstSubfolderSpec = 16;
+			files = (
+				FDB52FD01F614A8B00AA92E6 /* ffi.h in CopyFiles */,
+				FDB52FD11F614AA700AA92E6 /* ffi_arm64.h in CopyFiles */,
+				FDB52FD21F614AAB00AA92E6 /* ffi_armv7.h in CopyFiles */,
+				FDB52FD41F614AB500AA92E6 /* ffi_x86_64.h in CopyFiles */,
+				FDB52FD81F614B8700AA92E6 /* ffitarget.h in CopyFiles */,
+				FDB52FD91F614B8E00AA92E6 /* ffitarget_arm64.h in CopyFiles */,
+				FDB52FDA1F614B9300AA92E6 /* ffitarget_armv7.h in CopyFiles */,
+				FDB52FDD1F614BA900AA92E6 /* ffitarget_x86_64.h in CopyFiles */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDB52FC11F6144FA00AA92E6 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 12;
+			dstPath = "include/$(PRODUCT_NAME)";
+			dstSubfolderSpec = 16;
+			files = (
+				FDB52FD51F614AE200AA92E6 /* ffi.h in CopyFiles */,
+				FDB52FD61F614AEA00AA92E6 /* ffi_arm64.h in CopyFiles */,
+				FDB52FD71F614AED00AA92E6 /* ffi_x86_64.h in CopyFiles */,
+				FDB52FDE1F6155E300AA92E6 /* ffitarget.h in CopyFiles */,
+				FDB52FDF1F6155EA00AA92E6 /* ffitarget_arm64.h in CopyFiles */,
+				FDB52FE01F6155EF00AA92E6 /* ffitarget_x86_64.h in CopyFiles */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDB52FE11F6156E000AA92E6 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "include/$(PRODUCT_NAME)";
+			dstSubfolderSpec = 16;
+			files = (
+				FDB52FE21F6156FA00AA92E6 /* ffi.h in CopyFiles */,
+				FDB52FE31F61571A00AA92E6 /* ffi_x86_64.h in CopyFiles */,
+				FDB52FE41F61571D00AA92E6 /* ffitarget.h in CopyFiles */,
+				FDB52FE61F61573100AA92E6 /* ffitarget_x86_64.h in CopyFiles */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
+/* Begin PBXFileReference section */
+		43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffiw64_x86_64.c; sourceTree = "<group>"; };
+		43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = win64_x86_64.S; sourceTree = "<group>"; };
+		43E9A5C61D352C1500926A8F /* unix64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = unix64_x86_64.S; sourceTree = "<group>"; };
+		43E9A5DA1D35373600926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = "<group>"; };
+		43E9A5DB1D35374400926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = "<group>"; };
+		43E9A5DC1D35375400926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = "<group>"; };
+		43E9A5DD1D35375400926A8F /* internal64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal64.h; sourceTree = "<group>"; };
+		DB13B1661849DF1E0010F42D /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		DB13B1911849DF510010F42D /* ffi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = ffi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		DBFA713E187F1D8600A76262 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = "<group>"; };
+		DBFA713F187F1D8600A76262 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = "<group>"; };
+		DBFA7140187F1D8600A76262 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = "<group>"; };
+		DBFA7141187F1D8600A76262 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = "<group>"; };
+		DBFA7143187F1D8600A76262 /* closures.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = closures.c; sourceTree = "<group>"; };
+		DBFA7145187F1D8600A76262 /* dlmalloc.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dlmalloc.c; sourceTree = "<group>"; };
+		DBFA7147187F1D8600A76262 /* prep_cif.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = prep_cif.c; sourceTree = "<group>"; };
+		DBFA7148187F1D8600A76262 /* raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = raw_api.c; sourceTree = "<group>"; };
+		DBFA7149187F1D8600A76262 /* types.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = types.c; sourceTree = "<group>"; };
+		DBFA715E187F1D9B00A76262 /* ffi_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_arm64.h; sourceTree = "<group>"; };
+		DBFA715F187F1D9B00A76262 /* ffi_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_armv7.h; sourceTree = "<group>"; };
+		DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = "<group>"; };
+		DBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_arm64.h; sourceTree = "<group>"; };
+		DBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_armv7.h; sourceTree = "<group>"; };
+		DBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = "<group>"; };
+		DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_arm64.h; sourceTree = "<group>"; };
+		DBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_armv7.h; sourceTree = "<group>"; };
+		DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = "<group>"; };
+		DBFA716C187F1D9B00A76262 /* ffi_arm64.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi_arm64.c; sourceTree = "<group>"; };
+		DBFA716D187F1D9B00A76262 /* sysv_arm64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_arm64.S; sourceTree = "<group>"; };
+		DBFA716F187F1D9B00A76262 /* ffi_armv7.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi_armv7.c; sourceTree = "<group>"; };
+		DBFA7170187F1D9B00A76262 /* sysv_armv7.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_armv7.S; sourceTree = "<group>"; };
+		DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = "<group>"; };
+		DBFA7183187F1DA100A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = "<group>"; };
+		DBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = "<group>"; };
+		DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = "<group>"; };
+		DBFA718A187F1DA100A76262 /* unix64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = unix64_x86_64.S; sourceTree = "<group>"; };
+		DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = "<group>"; };
+		FDB52FC51F6144FA00AA92E6 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		FDDB2F3E1F5D61BC00EF414E /* asmnames.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = asmnames.h; sourceTree = "<group>"; };
+		FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffiw64_x86_64.c; sourceTree = "<group>"; };
+		FDDB2F421F5D68C900EF414E /* internal64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal64.h; sourceTree = "<group>"; };
+		FDDB2F431F5D68C900EF414E /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = "<group>"; };
+		FDDB2F441F5D68C900EF414E /* win64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = win64_x86_64.S; sourceTree = "<group>"; };
+		FDDB2F621F5D846400EF414E /* libffi.a */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXGroup section */
+		DB13B15B1849DEB70010F42D = {
+			isa = PBXGroup;
+			children = (
+				DBFA713C187F1D8600A76262 /* darwin_common */,
+				DBFA715C187F1D9B00A76262 /* darwin_ios */,
+				DBFA7180187F1DA100A76262 /* darwin_osx */,
+				DB13B1671849DF1E0010F42D /* Products */,
+			);
+			sourceTree = "<group>";
+		};
+		DB13B1671849DF1E0010F42D /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				DB13B1661849DF1E0010F42D /* libffi.a */,
+				DB13B1911849DF510010F42D /* ffi.dylib */,
+				FDDB2F621F5D846400EF414E /* libffi.a */,
+				FDB52FC51F6144FA00AA92E6 /* libffi.a */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		DBFA713C187F1D8600A76262 /* darwin_common */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA713D187F1D8600A76262 /* include */,
+				DBFA7142187F1D8600A76262 /* src */,
+			);
+			path = darwin_common;
+			sourceTree = "<group>";
+		};
+		DBFA713D187F1D8600A76262 /* include */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA713E187F1D8600A76262 /* ffi.h */,
+				DBFA713F187F1D8600A76262 /* ffi_common.h */,
+				DBFA7140187F1D8600A76262 /* fficonfig.h */,
+				DBFA7141187F1D8600A76262 /* ffitarget.h */,
+			);
+			path = include;
+			sourceTree = "<group>";
+		};
+		DBFA7142187F1D8600A76262 /* src */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA7143187F1D8600A76262 /* closures.c */,
+				DBFA7145187F1D8600A76262 /* dlmalloc.c */,
+				DBFA7147187F1D8600A76262 /* prep_cif.c */,
+				DBFA7148187F1D8600A76262 /* raw_api.c */,
+				DBFA7149187F1D8600A76262 /* types.c */,
+			);
+			path = src;
+			sourceTree = "<group>";
+		};
+		DBFA715C187F1D9B00A76262 /* darwin_ios */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA715D187F1D9B00A76262 /* include */,
+				DBFA716A187F1D9B00A76262 /* src */,
+			);
+			path = darwin_ios;
+			sourceTree = "<group>";
+		};
+		DBFA715D187F1D9B00A76262 /* include */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA715E187F1D9B00A76262 /* ffi_arm64.h */,
+				DBFA715F187F1D9B00A76262 /* ffi_armv7.h */,
+				DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */,
+				DBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */,
+				DBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */,
+				DBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */,
+				DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */,
+				DBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */,
+				DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */,
+			);
+			path = include;
+			sourceTree = "<group>";
+		};
+		DBFA716A187F1D9B00A76262 /* src */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA716B187F1D9B00A76262 /* aarch64 */,
+				DBFA716E187F1D9B00A76262 /* arm */,
+				DBFA7172187F1D9B00A76262 /* x86 */,
+			);
+			path = src;
+			sourceTree = "<group>";
+		};
+		DBFA716B187F1D9B00A76262 /* aarch64 */ = {
+			isa = PBXGroup;
+			children = (
+				43E9A5DA1D35373600926A8F /* internal.h */,
+				DBFA716C187F1D9B00A76262 /* ffi_arm64.c */,
+				DBFA716D187F1D9B00A76262 /* sysv_arm64.S */,
+			);
+			path = aarch64;
+			sourceTree = "<group>";
+		};
+		DBFA716E187F1D9B00A76262 /* arm */ = {
+			isa = PBXGroup;
+			children = (
+				43E9A5DB1D35374400926A8F /* internal.h */,
+				DBFA716F187F1D9B00A76262 /* ffi_armv7.c */,
+				DBFA7170187F1D9B00A76262 /* sysv_armv7.S */,
+			);
+			path = arm;
+			sourceTree = "<group>";
+		};
+		DBFA7172187F1D9B00A76262 /* x86 */ = {
+			isa = PBXGroup;
+			children = (
+				43E9A5DC1D35375400926A8F /* internal.h */,
+				43E9A5DD1D35375400926A8F /* internal64.h */,
+				DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */,
+				43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */,
+				43E9A5C61D352C1500926A8F /* unix64_x86_64.S */,
+				43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */,
+			);
+			path = x86;
+			sourceTree = "<group>";
+		};
+		DBFA7180187F1DA100A76262 /* darwin_osx */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA7181187F1DA100A76262 /* include */,
+				DBFA7188187F1DA100A76262 /* src */,
+			);
+			path = darwin_osx;
+			sourceTree = "<group>";
+		};
+		DBFA7181187F1DA100A76262 /* include */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA7183187F1DA100A76262 /* ffi_x86_64.h */,
+				DBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */,
+				DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */,
+			);
+			path = include;
+			sourceTree = "<group>";
+		};
+		DBFA7188187F1DA100A76262 /* src */ = {
+			isa = PBXGroup;
+			children = (
+				DBFA7189187F1DA100A76262 /* x86 */,
+			);
+			path = src;
+			sourceTree = "<group>";
+		};
+		DBFA7189187F1DA100A76262 /* x86 */ = {
+			isa = PBXGroup;
+			children = (
+				FDDB2F431F5D68C900EF414E /* internal.h */,
+				FDDB2F421F5D68C900EF414E /* internal64.h */,
+				FDDB2F3E1F5D61BC00EF414E /* asmnames.h */,
+				DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */,
+				FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */,
+				DBFA718A187F1DA100A76262 /* unix64_x86_64.S */,
+				FDDB2F441F5D68C900EF414E /* win64_x86_64.S */,
+			);
+			path = x86;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		DB13B18F1849DF510010F42D /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DBFA714C187F1D8600A76262 /* fficonfig.h in Headers */,
+				DBFA714D187F1D8600A76262 /* ffitarget.h in Headers */,
+				DBFA714A187F1D8600A76262 /* ffi.h in Headers */,
+				DBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */,
+				DBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */,
+				DBFA714B187F1D8600A76262 /* ffi_common.h in Headers */,
+				DBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		DB13B1651849DF1E0010F42D /* libffi-iOS */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DB13B18B1849DF1E0010F42D /* Build configuration list for PBXNativeTarget "libffi-iOS" */;
+			buildPhases = (
+				43B5D3FB1D35480D00D1E1FD /* Run Script */,
+				DB13B1621849DF1E0010F42D /* Sources */,
+				DB13B1641849DF1E0010F42D /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "libffi-iOS";
+			productName = ffi;
+			productReference = DB13B1661849DF1E0010F42D /* libffi.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+		DB13B1901849DF510010F42D /* libffi-Mac */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DB13B1B01849DF520010F42D /* Build configuration list for PBXNativeTarget "libffi-Mac" */;
+			buildPhases = (
+				DB13B3061849E0490010F42D /* ShellScript */,
+				DB13B18D1849DF510010F42D /* Sources */,
+				DB13B18F1849DF510010F42D /* Headers */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "libffi-Mac";
+			productName = ffi;
+			productReference = DB13B1911849DF510010F42D /* ffi.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		FDB52FB01F6144FA00AA92E6 /* libffi-tvOS */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = FDB52FC21F6144FA00AA92E6 /* Build configuration list for PBXNativeTarget "libffi-tvOS" */;
+			buildPhases = (
+				FDB52FB11F6144FA00AA92E6 /* Run Script */,
+				FDB52FB21F6144FA00AA92E6 /* Sources */,
+				FDB52FC11F6144FA00AA92E6 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "libffi-tvOS";
+			productName = ffi;
+			productReference = FDB52FC51F6144FA00AA92E6 /* libffi.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+		FDDB2F471F5D846400EF414E /* libffi-static-Mac */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = FDDB2F5F1F5D846400EF414E /* Build configuration list for PBXNativeTarget "libffi-static-Mac" */;
+			buildPhases = (
+				FDDB2F481F5D846400EF414E /* ShellScript */,
+				FDDB2F491F5D846400EF414E /* Sources */,
+				FDB52FE11F6156E000AA92E6 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "libffi-static-Mac";
+			productName = ffi;
+			productReference = FDDB2F621F5D846400EF414E /* libffi.a */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		DB13B15C1849DEB70010F42D /* Project object */ = {
+			isa = PBXProject;
+			attributes = {
+				LastUpgradeCheck = 0830;
+			};
+			buildConfigurationList = DB13B15F1849DEB70010F42D /* Build configuration list for PBXProject "libffi" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+			);
+			mainGroup = DB13B15B1849DEB70010F42D;
+			productRefGroup = DB13B1671849DF1E0010F42D /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				DB13B1651849DF1E0010F42D /* libffi-iOS */,
+				FDB52FB01F6144FA00AA92E6 /* libffi-tvOS */,
+				DB13B1901849DF510010F42D /* libffi-Mac */,
+				FDDB2F471F5D846400EF414E /* libffi-static-Mac */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXShellScriptBuildPhase section */
+		43B5D3FB1D35480D00D1E1FD /* Run Script */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			name = "Run Script";
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "if [ ! -f \"./compile\" ]\nthen\nautoreconf -i -f -v\nif [ -f \"../ltmain.sh\" ]\nthen\necho \"fixing ltmain.sh for some reason\"\nmv ../ltmain.sh ./\nautoreconf -i -f -v\nfi\n/usr/bin/python generate-darwin-source-and-headers.py --only-ios\nfi";
+		};
+		DB13B3061849E0490010F42D /* ShellScript */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "if [ ! -f \"./compile\" ]\nthen\nautoreconf -i -f -v\nif [ -f \"../ltmain.sh\" ]\nthen\necho \"fixing ltmain.sh for some reason\"\nmv ../ltmain.sh ./\nautoreconf -i -f -v\nfi\n/usr/bin/python generate-darwin-source-and-headers.py --only-osx\nfi";
+		};
+		FDB52FB11F6144FA00AA92E6 /* Run Script */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			name = "Run Script";
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "if [ ! -f \"./compile\" ]\nthen\nautoreconf -i -f -v\nif [ -f \"../ltmain.sh\" ]\nthen\necho \"fixing ltmain.sh for some reason\"\nmv ../ltmain.sh ./\nautoreconf -i -f -v\nfi\n/usr/bin/python generate-darwin-source-and-headers.py --only-ios\nfi";
+		};
+		FDDB2F481F5D846400EF414E /* ShellScript */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "if [ ! -f \"./compile\" ]\nthen\nautoreconf -i -f -v\nif [ -f \"../ltmain.sh\" ]\nthen\necho \"fixing ltmain.sh for some reason\"\nmv ../ltmain.sh ./\nautoreconf -i -f -v\nfi\n/usr/bin/python generate-darwin-source-and-headers.py --only-osx\nfi";
+		};
+/* End PBXShellScriptBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		DB13B1621849DF1E0010F42D /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				43E9A5C81D352C1500926A8F /* unix64_x86_64.S in Sources */,
+				DBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */,
+				DBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */,
+				DBFA714E187F1D8600A76262 /* closures.c in Sources */,
+				DBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */,
+				43B5D3F81D35473200D1E1FD /* ffiw64_x86_64.c in Sources */,
+				DBFA7156187F1D8600A76262 /* prep_cif.c in Sources */,
+				DBFA7158187F1D8600A76262 /* raw_api.c in Sources */,
+				DBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */,
+				DBFA715A187F1D8600A76262 /* types.c in Sources */,
+				DBFA7177187F1D9B00A76262 /* ffi_arm64.c in Sources */,
+				43B5D3FA1D3547CE00D1E1FD /* win64_x86_64.S in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DB13B18D1849DF510010F42D /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */,
+				DBFA7157187F1D8600A76262 /* prep_cif.c in Sources */,
+				FDDB2F411F5D66E200EF414E /* ffiw64_x86_64.c in Sources */,
+				DBFA715B187F1D8600A76262 /* types.c in Sources */,
+				DBFA7159187F1D8600A76262 /* raw_api.c in Sources */,
+				DBFA714F187F1D8600A76262 /* closures.c in Sources */,
+				DBFA7194187F1DA100A76262 /* unix64_x86_64.S in Sources */,
+				FDDB2F461F5D691E00EF414E /* win64_x86_64.S in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDB52FB21F6144FA00AA92E6 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				FDB52FB31F6144FA00AA92E6 /* unix64_x86_64.S in Sources */,
+				FDB52FB51F6144FA00AA92E6 /* ffi64_x86_64.c in Sources */,
+				FDB52FB61F6144FA00AA92E6 /* ffi_armv7.c in Sources */,
+				FDB52FB71F6144FA00AA92E6 /* closures.c in Sources */,
+				FDB52FB81F6144FA00AA92E6 /* sysv_armv7.S in Sources */,
+				FDB52FB91F6144FA00AA92E6 /* ffiw64_x86_64.c in Sources */,
+				FDB52FBA1F6144FA00AA92E6 /* prep_cif.c in Sources */,
+				FDB52FBC1F6144FA00AA92E6 /* raw_api.c in Sources */,
+				FDB52FBD1F6144FA00AA92E6 /* sysv_arm64.S in Sources */,
+				FDB52FBE1F6144FA00AA92E6 /* types.c in Sources */,
+				FDB52FBF1F6144FA00AA92E6 /* ffi_arm64.c in Sources */,
+				FDB52FC01F6144FA00AA92E6 /* win64_x86_64.S in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDDB2F491F5D846400EF414E /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				FDDB2F4A1F5D846400EF414E /* ffi64_x86_64.c in Sources */,
+				FDDB2F4C1F5D846400EF414E /* prep_cif.c in Sources */,
+				FDDB2F4E1F5D846400EF414E /* ffiw64_x86_64.c in Sources */,
+				FDDB2F4F1F5D846400EF414E /* types.c in Sources */,
+				FDDB2F501F5D846400EF414E /* raw_api.c in Sources */,
+				FDDB2F511F5D846400EF414E /* closures.c in Sources */,
+				FDDB2F521F5D846400EF414E /* unix64_x86_64.S in Sources */,
+				FDDB2F531F5D846400EF414E /* win64_x86_64.S in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin XCBuildConfiguration section */
+		DB13B1601849DEB70010F42D /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				ENABLE_TESTABILITY = YES;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_common/include,
+				);
+				ONLY_ACTIVE_ARCH = YES;
+			};
+			name = Debug;
+		};
+		DB13B1611849DEB70010F42D /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_common/include,
+				);
+			};
+			name = Release;
+		};
+		DB13B1871849DF1E0010F42D /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = NO;
+				DSTROOT = /tmp/ffi.dst;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_ios/include,
+				);
+				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
+				PRODUCT_NAME = ffi;
+				SDKROOT = iphoneos;
+				SKIP_INSTALL = YES;
+				VALID_ARCHS = "arm64 armv7 armv7s x86_64";
+			};
+			name = Debug;
+		};
+		DB13B1881849DF1E0010F42D /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = YES;
+				DSTROOT = /tmp/ffi.dst;
+				ENABLE_NS_ASSERTIONS = NO;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_ios/include,
+				);
+				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
+				PRODUCT_NAME = ffi;
+				SDKROOT = iphoneos;
+				SKIP_INSTALL = YES;
+				VALIDATE_PRODUCT = YES;
+				VALID_ARCHS = "arm64 armv7 armv7s x86_64";
+			};
+			name = Release;
+		};
+		DB13B1B11849DF520010F42D /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COMBINE_HIDPI_IMAGES = YES;
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_osx/include,
+				);
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				ONLY_ACTIVE_ARCH = YES;
+				OTHER_LDFLAGS = "-Wl,-no_compact_unwind";
+				PRODUCT_NAME = ffi;
+				SDKROOT = macosx;
+			};
+			name = Debug;
+		};
+		DB13B1B21849DF520010F42D /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COMBINE_HIDPI_IMAGES = YES;
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				ENABLE_NS_ASSERTIONS = NO;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_osx/include,
+				);
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				OTHER_LDFLAGS = "-Wl,-no_compact_unwind";
+				PRODUCT_NAME = ffi;
+				SDKROOT = macosx;
+			};
+			name = Release;
+		};
+		FDB52FC31F6144FA00AA92E6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = NO;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_ios/include,
+				);
+				PRODUCT_NAME = ffi;
+				SDKROOT = appletvos;
+				SKIP_INSTALL = YES;
+				TVOS_DEPLOYMENT_TARGET = 9.0;
+			};
+			name = Debug;
+		};
+		FDB52FC41F6144FA00AA92E6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = YES;
+				ENABLE_NS_ASSERTIONS = NO;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_ios/include,
+				);
+				PRODUCT_NAME = ffi;
+				SDKROOT = appletvos;
+				SKIP_INSTALL = YES;
+				TVOS_DEPLOYMENT_TARGET = 9.0;
+				VALIDATE_PRODUCT = YES;
+			};
+			name = Release;
+		};
+		FDDB2F601F5D846400EF414E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COMBINE_HIDPI_IMAGES = YES;
+				COPY_PHASE_STRIP = NO;
+				EXECUTABLE_EXTENSION = a;
+				EXECUTABLE_PREFIX = lib;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_osx/include,
+				);
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				ONLY_ACTIVE_ARCH = YES;
+				PRODUCT_NAME = ffi;
+				SDKROOT = macosx;
+			};
+			name = Debug;
+		};
+		FDDB2F611F5D846400EF414E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COMBINE_HIDPI_IMAGES = YES;
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				ENABLE_NS_ASSERTIONS = NO;
+				EXECUTABLE_EXTENSION = a;
+				EXECUTABLE_PREFIX = lib;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					darwin_osx/include,
+				);
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.6;
+				PRODUCT_NAME = ffi;
+				SDKROOT = macosx;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		DB13B15F1849DEB70010F42D /* Build configuration list for PBXProject "libffi" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DB13B1601849DEB70010F42D /* Debug */,
+				DB13B1611849DEB70010F42D /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		DB13B18B1849DF1E0010F42D /* Build configuration list for PBXNativeTarget "libffi-iOS" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DB13B1871849DF1E0010F42D /* Debug */,
+				DB13B1881849DF1E0010F42D /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		DB13B1B01849DF520010F42D /* Build configuration list for PBXNativeTarget "libffi-Mac" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DB13B1B11849DF520010F42D /* Debug */,
+				DB13B1B21849DF520010F42D /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		FDB52FC21F6144FA00AA92E6 /* Build configuration list for PBXNativeTarget "libffi-tvOS" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				FDB52FC31F6144FA00AA92E6 /* Debug */,
+				FDB52FC41F6144FA00AA92E6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		FDDB2F5F1F5D846400EF414E /* Build configuration list for PBXNativeTarget "libffi-static-Mac" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				FDDB2F601F5D846400EF414E /* Debug */,
+				FDDB2F611F5D846400EF414E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = DB13B15C1849DEB70010F42D /* Project object */;
+}
Index: libffi-3.4.6/LICENSE-BUILDTOOLS
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/LICENSE-BUILDTOOLS b/libffi-3.4.6/LICENSE-BUILDTOOLS
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/LICENSE-BUILDTOOLS	
@@ -0,0 +1,353 @@
+The libffi source distribution contains certain code that is not part
+of libffi, and is only used as tooling to assist with the building and
+testing of libffi.  This includes the msvcc.sh script used to wrap the
+Microsoft compiler with GNU compatible command-line options,
+make_sunver.pl, and the libffi test code distributed in the
+testsuite/libffi.bhaible directory.  This code is distributed with
+libffi for the purpose of convenience only, and libffi is in no way
+derived from this code.
+
+msvcc.sh an testsuite/libffi.bhaible are both distributed under the
+terms of the GNU GPL version 2, as below.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
Index: libffi-3.4.6/generate-darwin-source-and-headers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libffi-3.4.6/generate-darwin-source-and-headers.py b/libffi-3.4.6/generate-darwin-source-and-headers.py
new file mode 100644
--- /dev/null	
+++ b/libffi-3.4.6/generate-darwin-source-and-headers.py	
@@ -0,0 +1,312 @@
+#!/usr/bin/env python
+import subprocess
+import os
+import errno
+import collections
+import glob
+import argparse
+
+
+class Platform(object):
+    pass
+
+
+class i386_platform(Platform):
+    arch = 'i386'
+
+    prefix = "#ifdef __i386__\n\n"
+    suffix = "\n\n#endif"
+    src_dir = 'x86'
+    src_files = ['sysv.S', 'ffi.c', 'internal.h']
+
+
+class x86_64_platform(Platform):
+    arch = 'x86_64'
+
+    prefix = "#ifdef __x86_64__\n\n"
+    suffix = "\n\n#endif"
+    src_dir = 'x86'
+    src_files = ['unix64.S', 'ffi64.c', 'ffiw64.c', 'win64.S', 'internal64.h', 'asmnames.h']
+
+
+class arm64_platform(Platform):
+    arch = 'arm64'
+
+    prefix = "#ifdef __arm64__\n\n"
+    suffix = "\n\n#endif"
+    src_dir = 'aarch64'
+    src_files = ['sysv.S', 'ffi.c', 'internal.h']
+
+
+class armv7_platform(Platform):
+    arch = 'armv7'
+
+    prefix = "#ifdef __arm__\n\n"
+    suffix = "\n\n#endif"
+    src_dir = 'arm'
+    src_files = ['sysv.S', 'ffi.c', 'internal.h']
+
+
+class ios_simulator_i386_platform(i386_platform):
+    target = 'i386-apple-ios-simulator'
+    directory = 'darwin_ios'
+    sdk = 'iphonesimulator'
+    version_min = '-miphoneos-version-min=7.0'
+
+
+class ios_simulator_x86_64_platform(x86_64_platform):
+    target = 'x86_64-apple-ios-simulator'
+    directory = 'darwin_ios'
+    sdk = 'iphonesimulator'
+    version_min = '-miphoneos-version-min=7.0'
+
+
+class ios_simulator_arm64_platform(arm64_platform):
+    target = 'arm64-apple-ios-simulator'
+    directory = 'darwin_ios'
+    sdk = 'iphonesimulator'
+    version_min = '-miphoneos-version-min=7.0'
+
+
+class ios_device_armv7_platform(armv7_platform):
+    target = 'armv7-apple-ios'
+    directory = 'darwin_ios'
+    sdk = 'iphoneos'
+    version_min = '-miphoneos-version-min=7.0'
+
+
+class ios_device_arm64_platform(arm64_platform):
+    target = 'arm64-apple-ios'
+    directory = 'darwin_ios'
+    sdk = 'iphoneos'
+    version_min = '-miphoneos-version-min=7.0'
+
+
+class desktop_x86_64_platform(x86_64_platform):
+    target = 'x86_64-apple-macos'
+    directory = 'darwin_osx'
+    sdk = 'macosx'
+    version_min = '-mmacosx-version-min=10.6'
+
+
+class desktop_arm64_platform(arm64_platform):
+    target = 'arm64-apple-macos'
+    directory = 'darwin_osx'
+    sdk = 'macosx'
+    version_min = '-mmacosx-version-min=11.0'
+
+
+class tvos_simulator_x86_64_platform(x86_64_platform):
+    target = 'x86_64-apple-tvos-simulator'
+    directory = 'darwin_tvos'
+    sdk = 'appletvsimulator'
+    version_min = '-mtvos-version-min=9.0'
+
+
+class tvos_simulator_arm64_platform(arm64_platform):
+    target = 'arm64-apple-tvos-simulator'
+    directory = 'darwin_tvos'
+    sdk = 'appletvsimulator'
+    version_min = '-mtvos-version-min=9.0'
+
+
+class tvos_device_arm64_platform(arm64_platform):
+    target = 'arm64-apple-tvos'
+    directory = 'darwin_tvos'
+    sdk = 'appletvos'
+    version_min = '-mtvos-version-min=9.0'
+
+
+class watchos_simulator_i386_platform(i386_platform):
+    target = 'i386-apple-watchos-simulator'
+    directory = 'darwin_watchos'
+    sdk = 'watchsimulator'
+    version_min = '-mwatchos-version-min=4.0'
+
+
+class watchos_simulator_x86_64_platform(x86_64_platform):
+    target = 'x86_64-apple-watchos-simulator'
+    directory = 'darwin_watchos'
+    sdk = 'watchsimulator'
+    version_min = '-mwatchos-version-min=4.0'
+
+
+class watchos_simulator_arm64_platform(arm64_platform):
+    target = 'arm64-apple-watchos-simulator'
+    directory = 'darwin_watchos'
+    sdk = 'watchsimulator'
+    version_min = '-mwatchos-version-min=4.0'
+
+
+class watchos_device_armv7k_platform(armv7_platform):
+    target = 'armv7k-apple-watchos'
+    directory = 'darwin_watchos'
+    sdk = 'watchos'
+    arch = 'armv7k'
+    version_min = '-mwatchos-version-min=4.0'
+
+
+class watchos_device_arm64_32_platform(arm64_platform):
+    target = 'arm64_32-apple-watchos'
+    directory = 'darwin_watchos'
+    sdk = 'watchos'
+    arch = 'arm64_32'
+    version_min = '-mwatchos-version-min=4.0'
+
+
+def mkdir_p(path):
+    try:
+        os.makedirs(path)
+    except OSError as exc:  # Python >2.5
+        if exc.errno != errno.EEXIST:
+            raise
+
+
+def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):
+    mkdir_p(dst_dir)
+    out_filename = filename
+
+    if file_suffix:
+        if filename in ['internal64.h', 'asmnames.h', 'internal.h']:
+            out_filename = filename
+        else:
+            split_name = os.path.splitext(filename)
+            out_filename = "%s_%s%s" % (split_name[0], file_suffix, split_name[1])
+
+    with open(os.path.join(src_dir, filename)) as in_file:
+        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:
+            if prefix:
+                out_file.write(prefix)
+
+            out_file.write(in_file.read())
+
+            if suffix:
+                out_file.write(suffix)
+
+
+def list_files(src_dir, pattern=None, filelist=None):
+    if pattern: filelist = glob.iglob(os.path.join(src_dir, pattern))
+    for file in filelist:
+        yield os.path.basename(file)
+
+
+def copy_files(src_dir, dst_dir, pattern=None, filelist=None, file_suffix=None, prefix=None, suffix=None):
+    for filename in list_files(src_dir, pattern=pattern, filelist=filelist):
+        move_file(src_dir, dst_dir, filename, file_suffix=file_suffix, prefix=prefix, suffix=suffix)
+
+
+def copy_src_platform_files(platform):
+    src_dir = os.path.join('src', platform.src_dir)
+    dst_dir = os.path.join(platform.directory, 'src', platform.src_dir)
+    copy_files(src_dir, dst_dir, filelist=platform.src_files, file_suffix=platform.arch, prefix=platform.prefix, suffix=platform.suffix)
+
+
+def build_target(platform, platform_headers):
+    def xcrun_cmd(cmd):
+        return 'xcrun -sdk %s %s -target %s' % (platform.sdk, cmd, platform.target)
+
+    tag='%s-%s' % (platform.sdk, platform.arch)
+    build_dir = 'build_%s' % tag
+    mkdir_p(build_dir)
+    env = dict(CC=xcrun_cmd('clang'),
+               LD=xcrun_cmd('ld'),
+               CFLAGS='%s -fembed-bitcode' % (platform.version_min))
+    working_dir = os.getcwd()
+    try:
+        os.chdir(build_dir)
+        subprocess.check_call(
+            [
+                "../configure",
+                f"--host={platform.target}",
+            ] + (
+                [] if platform.sdk == "macosx" else [f"--build={os.uname().machine}-apple-darwin"]
+            ),
+            env=env
+        )
+    finally:
+        os.chdir(working_dir)
+
+    for src_dir in [build_dir, os.path.join(build_dir, 'include')]:
+        copy_files(src_dir,
+                   os.path.join(platform.directory, 'include'),
+                   pattern='*.h',
+                   file_suffix=platform.arch,
+                   prefix=platform.prefix,
+                   suffix=platform.suffix)
+
+        for filename in list_files(src_dir, pattern='*.h'):
+            platform_headers[filename].add((platform.prefix, platform.arch, platform.suffix))
+
+
+def generate_source_and_headers(
+    generate_osx=True,
+    generate_ios=True,
+    generate_tvos=True,
+    generate_watchos=True,
+):
+    copy_files('src', 'darwin_common/src', pattern='*.c')
+    copy_files('include', 'darwin_common/include', pattern='*.h')
+
+    if generate_ios:
+        copy_src_platform_files(ios_simulator_i386_platform)
+        copy_src_platform_files(ios_simulator_x86_64_platform)
+        copy_src_platform_files(ios_simulator_arm64_platform)
+        copy_src_platform_files(ios_device_armv7_platform)
+        copy_src_platform_files(ios_device_arm64_platform)
+    if generate_osx:
+        copy_src_platform_files(desktop_x86_64_platform)
+        copy_src_platform_files(desktop_arm64_platform)
+    if generate_tvos:
+        copy_src_platform_files(tvos_simulator_x86_64_platform)
+        copy_src_platform_files(tvos_simulator_arm64_platform)
+        copy_src_platform_files(tvos_device_arm64_platform)
+    if generate_watchos:
+        copy_src_platform_files(watchos_simulator_i386_platform)
+        copy_src_platform_files(watchos_simulator_x86_64_platform)
+        copy_src_platform_files(watchos_simulator_arm64_platform)
+        copy_src_platform_files(watchos_device_armv7k_platform)
+        copy_src_platform_files(watchos_device_arm64_32_platform)
+
+    platform_headers = collections.defaultdict(set)
+
+    if generate_ios:
+        build_target(ios_simulator_i386_platform, platform_headers)
+        build_target(ios_simulator_x86_64_platform, platform_headers)
+        build_target(ios_simulator_arm64_platform, platform_headers)
+        build_target(ios_device_armv7_platform, platform_headers)
+        build_target(ios_device_arm64_platform, platform_headers)
+    if generate_osx:
+        build_target(desktop_x86_64_platform, platform_headers)
+        build_target(desktop_arm64_platform, platform_headers)
+    if generate_tvos:
+        build_target(tvos_simulator_x86_64_platform, platform_headers)
+        build_target(tvos_simulator_arm64_platform, platform_headers)
+        build_target(tvos_device_arm64_platform, platform_headers)
+    if generate_watchos:
+        build_target(watchos_simulator_i386_platform, platform_headers)
+        build_target(watchos_simulator_x86_64_platform, platform_headers)
+        build_target(watchos_simulator_arm64_platform, platform_headers)
+        build_target(watchos_device_armv7k_platform, platform_headers)
+        build_target(watchos_device_arm64_32_platform, platform_headers)
+
+    mkdir_p('darwin_common/include')
+    for header_name, tag_tuples in platform_headers.items():
+        basename, suffix = os.path.splitext(header_name)
+        with open(os.path.join('darwin_common/include', header_name), 'w') as header:
+            for tag_tuple in tag_tuples:
+                header.write('%s#include <%s_%s%s>\n%s\n' % (tag_tuple[0], basename, tag_tuple[1], suffix, tag_tuple[2]))
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--only-ios', action='store_true', default=False)
+    parser.add_argument('--only-osx', action='store_true', default=False)
+    parser.add_argument('--only-tvos', action='store_true', default=False)
+    parser.add_argument('--only-watchos', action='store_true', default=False)
+    args = parser.parse_args()
+
+    generate_source_and_headers(
+        generate_osx=not args.only_ios and not args.only_tvos and not args.only_watchos,
+        generate_ios=not args.only_osx and not args.only_tvos and not args.only_watchos,
+        generate_tvos=not args.only_ios and not args.only_osx and not args.only_watchos,
+        generate_watchos=not args.only_ios and not args.only_osx and not args.only_tvos,
+    )
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
new file mode 100644
--- /dev/null	
+++ b/build.gradle.kts	
@@ -0,0 +1,6 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    alias(libs.plugins.android.application) apply false
+    alias(libs.plugins.kotlin.android) apply false
+    alias(libs.plugins.kotlin.compose) apply false
+}
\ No newline at end of file
Index: local.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/local.properties b/local.properties
new file mode 100644
--- /dev/null	
+++ b/local.properties	
@@ -0,0 +1,8 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+# For customization when using a Version Control System, please read the
+# header note.
+#Mon Nov 11 13:31:51 EST 2024
+sdk.dir=C\:\\Users\\Owner\\AppData\\Local\\Android\\Sdk
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
--- /dev/null	
+++ b/gradle.properties	
@@ -0,0 +1,23 @@
+# Project-wide Gradle settings.
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. For more details, visit
+# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
+# org.gradle.parallel=true
+# AndroidX package structure to make it clearer which packages are bundled with the
+# Android operating system, and which are packaged with your app's APK
+# https://developer.android.com/topic/libraries/support-library/androidx-rn
+android.useAndroidX=true
+# Kotlin code style for this project: "official" or "obsolete":
+kotlin.code.style=official
+# Enables namespacing of each library's R class so that its R class includes only the
+# resources declared in the library itself and none from the library's dependencies,
+# thereby reducing the size of the R class for that library
+android.nonTransitiveRClass=true
\ No newline at end of file
Index: settings.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/settings.gradle.kts b/settings.gradle.kts
new file mode 100644
--- /dev/null	
+++ b/settings.gradle.kts	
@@ -0,0 +1,24 @@
+pluginManagement {
+    repositories {
+        google {
+            content {
+                includeGroupByRegex("com\\.android.*")
+                includeGroupByRegex("com\\.google.*")
+                includeGroupByRegex("androidx.*")
+            }
+        }
+        mavenCentral()
+        gradlePluginPortal()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+
+rootProject.name = "LET'S GO"
+include(":app")
+ 
\ No newline at end of file
diff --git a/db/test.sqlite3 b/db/test.sqlite3
new file mode 100644
diff --git a/tmp/storage/.keep b/tmp/storage/.keep
new file mode 100644
diff --git a/libffi-3.4.6/.allow-ai-service b/libffi-3.4.6/.allow-ai-service
new file mode 100644
diff --git a/libffi-3.4.6} b/libffi-3.4.6}
new file mode 100644
diff --git a/db/development.sqlite3 b/db/development.sqlite3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-hdpi/ic_launcher.webp b/app/src/main/res/mipmap-hdpi/ic_launcher.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-mdpi/ic_launcher.webp b/app/src/main/res/mipmap-mdpi/ic_launcher.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xhdpi/ic_launcher.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp b/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp b/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/src/assets/uber_logo_white.webp.png b/src/assets/uber_logo_white.webp.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/load-path-cache b/tmp/cache/bootsnap/load-path-cache
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/00/07a93040ba583c b/tmp/cache/bootsnap/compile-cache-iseq/00/07a93040ba583c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/00/53dabcd390442e b/tmp/cache/bootsnap/compile-cache-iseq/00/53dabcd390442e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/00/677ca9fcba04ad b/tmp/cache/bootsnap/compile-cache-iseq/00/677ca9fcba04ad
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/00/bf3c1fe491f78c b/tmp/cache/bootsnap/compile-cache-iseq/00/bf3c1fe491f78c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/00/e056bb3cbc7d1f b/tmp/cache/bootsnap/compile-cache-iseq/00/e056bb3cbc7d1f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/25bb519bfd2c40 b/tmp/cache/bootsnap/compile-cache-iseq/01/25bb519bfd2c40
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/40b31c8865348c b/tmp/cache/bootsnap/compile-cache-iseq/01/40b31c8865348c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/42e651d2075506 b/tmp/cache/bootsnap/compile-cache-iseq/01/42e651d2075506
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/52123dba02702c b/tmp/cache/bootsnap/compile-cache-iseq/01/52123dba02702c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/9a6ca5a8d6bdbb b/tmp/cache/bootsnap/compile-cache-iseq/01/9a6ca5a8d6bdbb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/a8303866fa2f16 b/tmp/cache/bootsnap/compile-cache-iseq/01/a8303866fa2f16
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/bd263a05e1b345 b/tmp/cache/bootsnap/compile-cache-iseq/01/bd263a05e1b345
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/01/ed2767554d9a07 b/tmp/cache/bootsnap/compile-cache-iseq/01/ed2767554d9a07
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/2df73ad4a66506 b/tmp/cache/bootsnap/compile-cache-iseq/02/2df73ad4a66506
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/5c268751f47364 b/tmp/cache/bootsnap/compile-cache-iseq/02/5c268751f47364
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/62c4dce50c4813 b/tmp/cache/bootsnap/compile-cache-iseq/02/62c4dce50c4813
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/6e42894f423a56 b/tmp/cache/bootsnap/compile-cache-iseq/02/6e42894f423a56
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/7d90b380724759 b/tmp/cache/bootsnap/compile-cache-iseq/02/7d90b380724759
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/e8ff9c7f080e6a b/tmp/cache/bootsnap/compile-cache-iseq/02/e8ff9c7f080e6a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/f8f1b9d84e6dd5 b/tmp/cache/bootsnap/compile-cache-iseq/02/f8f1b9d84e6dd5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/02/fe2697e9e385af b/tmp/cache/bootsnap/compile-cache-iseq/02/fe2697e9e385af
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/03/48fefe2115b759 b/tmp/cache/bootsnap/compile-cache-iseq/03/48fefe2115b759
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/03/499fd22958c3db b/tmp/cache/bootsnap/compile-cache-iseq/03/499fd22958c3db
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/03/892e0099b8c2c3 b/tmp/cache/bootsnap/compile-cache-iseq/03/892e0099b8c2c3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/03/aa0c15d27a50ce b/tmp/cache/bootsnap/compile-cache-iseq/03/aa0c15d27a50ce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/03/b16d3486f53889 b/tmp/cache/bootsnap/compile-cache-iseq/03/b16d3486f53889
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/04/4c527b3671f3f0 b/tmp/cache/bootsnap/compile-cache-iseq/04/4c527b3671f3f0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/04/5a470345352253 b/tmp/cache/bootsnap/compile-cache-iseq/04/5a470345352253
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/04/7ae19364395fcc b/tmp/cache/bootsnap/compile-cache-iseq/04/7ae19364395fcc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/05/38cc773a8bf197 b/tmp/cache/bootsnap/compile-cache-iseq/05/38cc773a8bf197
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/05/4d240c88daebd3 b/tmp/cache/bootsnap/compile-cache-iseq/05/4d240c88daebd3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/05/acbaabf0da067c b/tmp/cache/bootsnap/compile-cache-iseq/05/acbaabf0da067c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/255d11260a6596 b/tmp/cache/bootsnap/compile-cache-iseq/06/255d11260a6596
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/2c000911951b2c b/tmp/cache/bootsnap/compile-cache-iseq/06/2c000911951b2c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/2c7ebca680ee2e b/tmp/cache/bootsnap/compile-cache-iseq/06/2c7ebca680ee2e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/444bd9f6df5784 b/tmp/cache/bootsnap/compile-cache-iseq/06/444bd9f6df5784
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/67ffef1f6ab036 b/tmp/cache/bootsnap/compile-cache-iseq/06/67ffef1f6ab036
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/7f8e037ca1bf38 b/tmp/cache/bootsnap/compile-cache-iseq/06/7f8e037ca1bf38
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/bd23a23e972e7d b/tmp/cache/bootsnap/compile-cache-iseq/06/bd23a23e972e7d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/e8f087d472003a b/tmp/cache/bootsnap/compile-cache-iseq/06/e8f087d472003a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/06/f37d472273ad9b b/tmp/cache/bootsnap/compile-cache-iseq/06/f37d472273ad9b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/0a67155bbed704 b/tmp/cache/bootsnap/compile-cache-iseq/07/0a67155bbed704
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/1449bc8d4c8032 b/tmp/cache/bootsnap/compile-cache-iseq/07/1449bc8d4c8032
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/5bcccd571a4277 b/tmp/cache/bootsnap/compile-cache-iseq/07/5bcccd571a4277
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/8bf0383e3f36db b/tmp/cache/bootsnap/compile-cache-iseq/07/8bf0383e3f36db
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/c62c1d65e7e560 b/tmp/cache/bootsnap/compile-cache-iseq/07/c62c1d65e7e560
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/c8335c448090c7 b/tmp/cache/bootsnap/compile-cache-iseq/07/c8335c448090c7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/d2e6e2da37d2a1 b/tmp/cache/bootsnap/compile-cache-iseq/07/d2e6e2da37d2a1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/d8036f805d26e1 b/tmp/cache/bootsnap/compile-cache-iseq/07/d8036f805d26e1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/dd4b1de41da2a3 b/tmp/cache/bootsnap/compile-cache-iseq/07/dd4b1de41da2a3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/e071dfa33d8577 b/tmp/cache/bootsnap/compile-cache-iseq/07/e071dfa33d8577
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/ed851734927398 b/tmp/cache/bootsnap/compile-cache-iseq/07/ed851734927398
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/07/fed91dea2eb03e b/tmp/cache/bootsnap/compile-cache-iseq/07/fed91dea2eb03e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/08/391dc02eede303 b/tmp/cache/bootsnap/compile-cache-iseq/08/391dc02eede303
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/08/707fb16c789e47 b/tmp/cache/bootsnap/compile-cache-iseq/08/707fb16c789e47
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/08/afd540ea57bd0e b/tmp/cache/bootsnap/compile-cache-iseq/08/afd540ea57bd0e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/08/d5d76fe7c09289 b/tmp/cache/bootsnap/compile-cache-iseq/08/d5d76fe7c09289
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/08/dcc5a82cfd607a b/tmp/cache/bootsnap/compile-cache-iseq/08/dcc5a82cfd607a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/0a585243b57f3a b/tmp/cache/bootsnap/compile-cache-iseq/09/0a585243b57f3a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/64b8f67eafa2d7 b/tmp/cache/bootsnap/compile-cache-iseq/09/64b8f67eafa2d7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/76a9f7184ef91a b/tmp/cache/bootsnap/compile-cache-iseq/09/76a9f7184ef91a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/b2b46bcd42c50e b/tmp/cache/bootsnap/compile-cache-iseq/09/b2b46bcd42c50e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/d315cc0bf7f447 b/tmp/cache/bootsnap/compile-cache-iseq/09/d315cc0bf7f447
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/09/dbb6a52a9d29d9 b/tmp/cache/bootsnap/compile-cache-iseq/09/dbb6a52a9d29d9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/499f5f4a8b98aa b/tmp/cache/bootsnap/compile-cache-iseq/0a/499f5f4a8b98aa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/5140afba8053a0 b/tmp/cache/bootsnap/compile-cache-iseq/0a/5140afba8053a0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/57777deca9073d b/tmp/cache/bootsnap/compile-cache-iseq/0a/57777deca9073d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/5cd17a37b53ada b/tmp/cache/bootsnap/compile-cache-iseq/0a/5cd17a37b53ada
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/b7a1be7f358da8 b/tmp/cache/bootsnap/compile-cache-iseq/0a/b7a1be7f358da8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/bc357a4dd91701 b/tmp/cache/bootsnap/compile-cache-iseq/0a/bc357a4dd91701
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0a/ea530c17de55a0 b/tmp/cache/bootsnap/compile-cache-iseq/0a/ea530c17de55a0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/0170000c38085e b/tmp/cache/bootsnap/compile-cache-iseq/0b/0170000c38085e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/42a38845d36f86 b/tmp/cache/bootsnap/compile-cache-iseq/0b/42a38845d36f86
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/5366e6b74884d7 b/tmp/cache/bootsnap/compile-cache-iseq/0b/5366e6b74884d7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/5e39018a3f31ca b/tmp/cache/bootsnap/compile-cache-iseq/0b/5e39018a3f31ca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/6e6aa9586ec69e b/tmp/cache/bootsnap/compile-cache-iseq/0b/6e6aa9586ec69e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/838b43fc7f344a b/tmp/cache/bootsnap/compile-cache-iseq/0b/838b43fc7f344a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/88b62d9cf19339 b/tmp/cache/bootsnap/compile-cache-iseq/0b/88b62d9cf19339
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/b10c43fee38e75 b/tmp/cache/bootsnap/compile-cache-iseq/0b/b10c43fee38e75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/bbeaa1405bf1ab b/tmp/cache/bootsnap/compile-cache-iseq/0b/bbeaa1405bf1ab
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/cefd9c669ea57d b/tmp/cache/bootsnap/compile-cache-iseq/0b/cefd9c669ea57d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0b/fe2097a618343d b/tmp/cache/bootsnap/compile-cache-iseq/0b/fe2097a618343d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/14cceb49cb4281 b/tmp/cache/bootsnap/compile-cache-iseq/0c/14cceb49cb4281
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/2a080d5422e7bb b/tmp/cache/bootsnap/compile-cache-iseq/0c/2a080d5422e7bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/37bd54c8d56f01 b/tmp/cache/bootsnap/compile-cache-iseq/0c/37bd54c8d56f01
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/3e26c5416daa56 b/tmp/cache/bootsnap/compile-cache-iseq/0c/3e26c5416daa56
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/440a6785eb449d b/tmp/cache/bootsnap/compile-cache-iseq/0c/440a6785eb449d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/4e36e01d336081 b/tmp/cache/bootsnap/compile-cache-iseq/0c/4e36e01d336081
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/68eea7bd49fb09 b/tmp/cache/bootsnap/compile-cache-iseq/0c/68eea7bd49fb09
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/af37ad28a80494 b/tmp/cache/bootsnap/compile-cache-iseq/0c/af37ad28a80494
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/d066fef94045e0 b/tmp/cache/bootsnap/compile-cache-iseq/0c/d066fef94045e0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0c/e3beb346f59276 b/tmp/cache/bootsnap/compile-cache-iseq/0c/e3beb346f59276
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/41369bb896b81f b/tmp/cache/bootsnap/compile-cache-iseq/0d/41369bb896b81f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/4aaba46a69c648 b/tmp/cache/bootsnap/compile-cache-iseq/0d/4aaba46a69c648
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/867bc2c7bed84b b/tmp/cache/bootsnap/compile-cache-iseq/0d/867bc2c7bed84b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/889a52f13f6ddf b/tmp/cache/bootsnap/compile-cache-iseq/0d/889a52f13f6ddf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/9448c6c25dafb5 b/tmp/cache/bootsnap/compile-cache-iseq/0d/9448c6c25dafb5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/b1c1bc86251c0f b/tmp/cache/bootsnap/compile-cache-iseq/0d/b1c1bc86251c0f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0d/bc677157198a02 b/tmp/cache/bootsnap/compile-cache-iseq/0d/bc677157198a02
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/0b6418bbefeb16 b/tmp/cache/bootsnap/compile-cache-iseq/0e/0b6418bbefeb16
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/243d1e32cc1d3b b/tmp/cache/bootsnap/compile-cache-iseq/0e/243d1e32cc1d3b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/44ec804fcc6f5b b/tmp/cache/bootsnap/compile-cache-iseq/0e/44ec804fcc6f5b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/513d2db9b80e5e b/tmp/cache/bootsnap/compile-cache-iseq/0e/513d2db9b80e5e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/5440c0c85ba2d5 b/tmp/cache/bootsnap/compile-cache-iseq/0e/5440c0c85ba2d5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/5d8d816a67c216 b/tmp/cache/bootsnap/compile-cache-iseq/0e/5d8d816a67c216
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0e/fa01489fa31a32 b/tmp/cache/bootsnap/compile-cache-iseq/0e/fa01489fa31a32
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/2006fd78ddee45 b/tmp/cache/bootsnap/compile-cache-iseq/0f/2006fd78ddee45
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/2460ba2c531bda b/tmp/cache/bootsnap/compile-cache-iseq/0f/2460ba2c531bda
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/3d95fdccd045e6 b/tmp/cache/bootsnap/compile-cache-iseq/0f/3d95fdccd045e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/42459e11a6599f b/tmp/cache/bootsnap/compile-cache-iseq/0f/42459e11a6599f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/45d2258f32624a b/tmp/cache/bootsnap/compile-cache-iseq/0f/45d2258f32624a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/46125b7b8a0723 b/tmp/cache/bootsnap/compile-cache-iseq/0f/46125b7b8a0723
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/52b2ca798e63c7 b/tmp/cache/bootsnap/compile-cache-iseq/0f/52b2ca798e63c7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/7667d724c340dc b/tmp/cache/bootsnap/compile-cache-iseq/0f/7667d724c340dc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/9a9106120b479d b/tmp/cache/bootsnap/compile-cache-iseq/0f/9a9106120b479d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/af64e788d2a6c8 b/tmp/cache/bootsnap/compile-cache-iseq/0f/af64e788d2a6c8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/c6bebd3b82a294 b/tmp/cache/bootsnap/compile-cache-iseq/0f/c6bebd3b82a294
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/0f/fa6dbdea13ac5c b/tmp/cache/bootsnap/compile-cache-iseq/0f/fa6dbdea13ac5c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/3288225635ed0d b/tmp/cache/bootsnap/compile-cache-iseq/10/3288225635ed0d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/4381ea18161f80 b/tmp/cache/bootsnap/compile-cache-iseq/10/4381ea18161f80
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/4c61dca2161b07 b/tmp/cache/bootsnap/compile-cache-iseq/10/4c61dca2161b07
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/6a863ae24766af b/tmp/cache/bootsnap/compile-cache-iseq/10/6a863ae24766af
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/926c9dffe8c3f9 b/tmp/cache/bootsnap/compile-cache-iseq/10/926c9dffe8c3f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/10/d5beeb7e69a23d b/tmp/cache/bootsnap/compile-cache-iseq/10/d5beeb7e69a23d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/121f8c7051a300 b/tmp/cache/bootsnap/compile-cache-iseq/11/121f8c7051a300
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/3a908bbfef5f89 b/tmp/cache/bootsnap/compile-cache-iseq/11/3a908bbfef5f89
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/7643cee17c4f9a b/tmp/cache/bootsnap/compile-cache-iseq/11/7643cee17c4f9a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/a52a4dfeffbd15 b/tmp/cache/bootsnap/compile-cache-iseq/11/a52a4dfeffbd15
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/b77247435cb478 b/tmp/cache/bootsnap/compile-cache-iseq/11/b77247435cb478
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/11/d1c2812c573db1 b/tmp/cache/bootsnap/compile-cache-iseq/11/d1c2812c573db1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/19d155136e41ba b/tmp/cache/bootsnap/compile-cache-iseq/12/19d155136e41ba
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/1f4c46d9af30d4 b/tmp/cache/bootsnap/compile-cache-iseq/12/1f4c46d9af30d4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/4bf1934fd9d1a7 b/tmp/cache/bootsnap/compile-cache-iseq/12/4bf1934fd9d1a7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/717fc09bf2f2bd b/tmp/cache/bootsnap/compile-cache-iseq/12/717fc09bf2f2bd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/956deb8876dbd4 b/tmp/cache/bootsnap/compile-cache-iseq/12/956deb8876dbd4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/b061c5fc4591ea b/tmp/cache/bootsnap/compile-cache-iseq/12/b061c5fc4591ea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/bb22d83a0c0f5b b/tmp/cache/bootsnap/compile-cache-iseq/12/bb22d83a0c0f5b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/12/dcf56c0842cfc6 b/tmp/cache/bootsnap/compile-cache-iseq/12/dcf56c0842cfc6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/0f824a9fe2e1b5 b/tmp/cache/bootsnap/compile-cache-iseq/13/0f824a9fe2e1b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/1c7e7eea5ac64c b/tmp/cache/bootsnap/compile-cache-iseq/13/1c7e7eea5ac64c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/33525ff020dcc6 b/tmp/cache/bootsnap/compile-cache-iseq/13/33525ff020dcc6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/4052546d22d50b b/tmp/cache/bootsnap/compile-cache-iseq/13/4052546d22d50b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/6f9cc36bf622f2 b/tmp/cache/bootsnap/compile-cache-iseq/13/6f9cc36bf622f2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/7b09a202a6c8b2 b/tmp/cache/bootsnap/compile-cache-iseq/13/7b09a202a6c8b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/8e72fdb1eafabd b/tmp/cache/bootsnap/compile-cache-iseq/13/8e72fdb1eafabd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/9aa36079d19405 b/tmp/cache/bootsnap/compile-cache-iseq/13/9aa36079d19405
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/a1583241652466 b/tmp/cache/bootsnap/compile-cache-iseq/13/a1583241652466
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/13/bcb1b4f2fc29e7 b/tmp/cache/bootsnap/compile-cache-iseq/13/bcb1b4f2fc29e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/14a5978942badc b/tmp/cache/bootsnap/compile-cache-iseq/14/14a5978942badc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/2d2cff50c4f3c1 b/tmp/cache/bootsnap/compile-cache-iseq/14/2d2cff50c4f3c1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/39609eb8e48e0d b/tmp/cache/bootsnap/compile-cache-iseq/14/39609eb8e48e0d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/3f27287a949318 b/tmp/cache/bootsnap/compile-cache-iseq/14/3f27287a949318
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/4d699339314ae2 b/tmp/cache/bootsnap/compile-cache-iseq/14/4d699339314ae2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/743ca67e3ab773 b/tmp/cache/bootsnap/compile-cache-iseq/14/743ca67e3ab773
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/8944f038098edf b/tmp/cache/bootsnap/compile-cache-iseq/14/8944f038098edf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/8f3a06acbe2c20 b/tmp/cache/bootsnap/compile-cache-iseq/14/8f3a06acbe2c20
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/a84304ee7f98b5 b/tmp/cache/bootsnap/compile-cache-iseq/14/a84304ee7f98b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/d8045145994835 b/tmp/cache/bootsnap/compile-cache-iseq/14/d8045145994835
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/14/efdabc818bb306 b/tmp/cache/bootsnap/compile-cache-iseq/14/efdabc818bb306
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/0814180eeb7926 b/tmp/cache/bootsnap/compile-cache-iseq/15/0814180eeb7926
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/74896667da47b0 b/tmp/cache/bootsnap/compile-cache-iseq/15/74896667da47b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/7865f836c77a45 b/tmp/cache/bootsnap/compile-cache-iseq/15/7865f836c77a45
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/83981738a83dc9 b/tmp/cache/bootsnap/compile-cache-iseq/15/83981738a83dc9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/88a65cca298736 b/tmp/cache/bootsnap/compile-cache-iseq/15/88a65cca298736
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/90b0ff9f51f068 b/tmp/cache/bootsnap/compile-cache-iseq/15/90b0ff9f51f068
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/15/bd2f69e480a870 b/tmp/cache/bootsnap/compile-cache-iseq/15/bd2f69e480a870
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/03356a0f10f591 b/tmp/cache/bootsnap/compile-cache-iseq/16/03356a0f10f591
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/2145ca4b96f98f b/tmp/cache/bootsnap/compile-cache-iseq/16/2145ca4b96f98f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/5d023a230f4d11 b/tmp/cache/bootsnap/compile-cache-iseq/16/5d023a230f4d11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/8b0a1ee87e212a b/tmp/cache/bootsnap/compile-cache-iseq/16/8b0a1ee87e212a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/90b8e122c7ca5d b/tmp/cache/bootsnap/compile-cache-iseq/16/90b8e122c7ca5d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/aafdd21f4d5f77 b/tmp/cache/bootsnap/compile-cache-iseq/16/aafdd21f4d5f77
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/bb98862ce456d8 b/tmp/cache/bootsnap/compile-cache-iseq/16/bb98862ce456d8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/dfea92e6072900 b/tmp/cache/bootsnap/compile-cache-iseq/16/dfea92e6072900
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/16/e1390e58b20dd4 b/tmp/cache/bootsnap/compile-cache-iseq/16/e1390e58b20dd4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/09d8e915adccec b/tmp/cache/bootsnap/compile-cache-iseq/17/09d8e915adccec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/31e37191c2e87d b/tmp/cache/bootsnap/compile-cache-iseq/17/31e37191c2e87d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/37e5c7a73ede8b b/tmp/cache/bootsnap/compile-cache-iseq/17/37e5c7a73ede8b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/4dfd3da2f30ffd b/tmp/cache/bootsnap/compile-cache-iseq/17/4dfd3da2f30ffd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/6b64b139f5d72b b/tmp/cache/bootsnap/compile-cache-iseq/17/6b64b139f5d72b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/17/ff552949e16d2c b/tmp/cache/bootsnap/compile-cache-iseq/17/ff552949e16d2c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/0e75288a589e4f b/tmp/cache/bootsnap/compile-cache-iseq/18/0e75288a589e4f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/14b6681c3a6bdb b/tmp/cache/bootsnap/compile-cache-iseq/18/14b6681c3a6bdb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/4f6e8d3ae00124 b/tmp/cache/bootsnap/compile-cache-iseq/18/4f6e8d3ae00124
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/6d0e1e5026f7b0 b/tmp/cache/bootsnap/compile-cache-iseq/18/6d0e1e5026f7b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/bbbaa3851e036a b/tmp/cache/bootsnap/compile-cache-iseq/18/bbbaa3851e036a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/e7ba9ab60e26d6 b/tmp/cache/bootsnap/compile-cache-iseq/18/e7ba9ab60e26d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/18/ffb8c0686072ae b/tmp/cache/bootsnap/compile-cache-iseq/18/ffb8c0686072ae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/19/0230b787e72fcc b/tmp/cache/bootsnap/compile-cache-iseq/19/0230b787e72fcc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/19/836a80e96e3e9d b/tmp/cache/bootsnap/compile-cache-iseq/19/836a80e96e3e9d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/19/9b54677cec3907 b/tmp/cache/bootsnap/compile-cache-iseq/19/9b54677cec3907
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/224646d38a7e11 b/tmp/cache/bootsnap/compile-cache-iseq/1a/224646d38a7e11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/6650b02a23130c b/tmp/cache/bootsnap/compile-cache-iseq/1a/6650b02a23130c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/6c3658870cebd9 b/tmp/cache/bootsnap/compile-cache-iseq/1a/6c3658870cebd9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/7de4921ebc926b b/tmp/cache/bootsnap/compile-cache-iseq/1a/7de4921ebc926b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/c0004e164d2dc7 b/tmp/cache/bootsnap/compile-cache-iseq/1a/c0004e164d2dc7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1a/de9b2a53965e25 b/tmp/cache/bootsnap/compile-cache-iseq/1a/de9b2a53965e25
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1b/08cfc953b947ee b/tmp/cache/bootsnap/compile-cache-iseq/1b/08cfc953b947ee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1b/20958bb1dde584 b/tmp/cache/bootsnap/compile-cache-iseq/1b/20958bb1dde584
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1b/7f556cbde23d59 b/tmp/cache/bootsnap/compile-cache-iseq/1b/7f556cbde23d59
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1b/824953e23b4702 b/tmp/cache/bootsnap/compile-cache-iseq/1b/824953e23b4702
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/009ede973dfda5 b/tmp/cache/bootsnap/compile-cache-iseq/1c/009ede973dfda5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/154ef981eb4373 b/tmp/cache/bootsnap/compile-cache-iseq/1c/154ef981eb4373
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/274e6a8c410941 b/tmp/cache/bootsnap/compile-cache-iseq/1c/274e6a8c410941
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/5157c8bde27640 b/tmp/cache/bootsnap/compile-cache-iseq/1c/5157c8bde27640
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/838b7a6e172757 b/tmp/cache/bootsnap/compile-cache-iseq/1c/838b7a6e172757
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1c/df0c02fcf335ff b/tmp/cache/bootsnap/compile-cache-iseq/1c/df0c02fcf335ff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/3047057ad5a762 b/tmp/cache/bootsnap/compile-cache-iseq/1d/3047057ad5a762
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/35590f17e45757 b/tmp/cache/bootsnap/compile-cache-iseq/1d/35590f17e45757
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/3683b27fe5b8fa b/tmp/cache/bootsnap/compile-cache-iseq/1d/3683b27fe5b8fa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/3d2b0815bf19f1 b/tmp/cache/bootsnap/compile-cache-iseq/1d/3d2b0815bf19f1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/4bbffcfb3c1793 b/tmp/cache/bootsnap/compile-cache-iseq/1d/4bbffcfb3c1793
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/57b89f273bcb4b b/tmp/cache/bootsnap/compile-cache-iseq/1d/57b89f273bcb4b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/7e022bc417f549 b/tmp/cache/bootsnap/compile-cache-iseq/1d/7e022bc417f549
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/9d4decfb1bd8b5 b/tmp/cache/bootsnap/compile-cache-iseq/1d/9d4decfb1bd8b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1d/f7e1e1950ddd77 b/tmp/cache/bootsnap/compile-cache-iseq/1d/f7e1e1950ddd77
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/00ad065cd12f20 b/tmp/cache/bootsnap/compile-cache-iseq/1e/00ad065cd12f20
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/2b05131e801ccd b/tmp/cache/bootsnap/compile-cache-iseq/1e/2b05131e801ccd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/2e6528320daee4 b/tmp/cache/bootsnap/compile-cache-iseq/1e/2e6528320daee4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/4cd555748a4b42 b/tmp/cache/bootsnap/compile-cache-iseq/1e/4cd555748a4b42
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/a8d7f95f154dde b/tmp/cache/bootsnap/compile-cache-iseq/1e/a8d7f95f154dde
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1e/d343baa85f30ab b/tmp/cache/bootsnap/compile-cache-iseq/1e/d343baa85f30ab
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/04d5393833b1bc b/tmp/cache/bootsnap/compile-cache-iseq/1f/04d5393833b1bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/18d3039725e392 b/tmp/cache/bootsnap/compile-cache-iseq/1f/18d3039725e392
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/297a6895be634c b/tmp/cache/bootsnap/compile-cache-iseq/1f/297a6895be634c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/37cefb8d81b7c9 b/tmp/cache/bootsnap/compile-cache-iseq/1f/37cefb8d81b7c9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/5d643d4c90f194 b/tmp/cache/bootsnap/compile-cache-iseq/1f/5d643d4c90f194
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/79f185898d24d0 b/tmp/cache/bootsnap/compile-cache-iseq/1f/79f185898d24d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/7d85b1eab4d82c b/tmp/cache/bootsnap/compile-cache-iseq/1f/7d85b1eab4d82c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/816bb8efbaaa71 b/tmp/cache/bootsnap/compile-cache-iseq/1f/816bb8efbaaa71
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/894d7b9c8e4237 b/tmp/cache/bootsnap/compile-cache-iseq/1f/894d7b9c8e4237
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/a0bccac81f57ec b/tmp/cache/bootsnap/compile-cache-iseq/1f/a0bccac81f57ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/a36b682778cab3 b/tmp/cache/bootsnap/compile-cache-iseq/1f/a36b682778cab3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/a884cbf054eff6 b/tmp/cache/bootsnap/compile-cache-iseq/1f/a884cbf054eff6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/b6ca30c96f12ee b/tmp/cache/bootsnap/compile-cache-iseq/1f/b6ca30c96f12ee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/1f/e30d15a207c95a b/tmp/cache/bootsnap/compile-cache-iseq/1f/e30d15a207c95a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/734ebf8c95f1d0 b/tmp/cache/bootsnap/compile-cache-iseq/20/734ebf8c95f1d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/7ac3c858bab947 b/tmp/cache/bootsnap/compile-cache-iseq/20/7ac3c858bab947
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/8a307a1ae09c65 b/tmp/cache/bootsnap/compile-cache-iseq/20/8a307a1ae09c65
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/c7ac583707a3ff b/tmp/cache/bootsnap/compile-cache-iseq/20/c7ac583707a3ff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/ce27b268cfca0a b/tmp/cache/bootsnap/compile-cache-iseq/20/ce27b268cfca0a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/20/e5f8fcb3b92cf0 b/tmp/cache/bootsnap/compile-cache-iseq/20/e5f8fcb3b92cf0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/21/3e099a6a3a8cc6 b/tmp/cache/bootsnap/compile-cache-iseq/21/3e099a6a3a8cc6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/21/5f7fe9629c5737 b/tmp/cache/bootsnap/compile-cache-iseq/21/5f7fe9629c5737
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/21/745036f7929ae6 b/tmp/cache/bootsnap/compile-cache-iseq/21/745036f7929ae6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/21/7c3ed28821bb6e b/tmp/cache/bootsnap/compile-cache-iseq/21/7c3ed28821bb6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/3572dc8fb7e290 b/tmp/cache/bootsnap/compile-cache-iseq/22/3572dc8fb7e290
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/5b6009fe9e3f89 b/tmp/cache/bootsnap/compile-cache-iseq/22/5b6009fe9e3f89
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/ca68d26ed3e638 b/tmp/cache/bootsnap/compile-cache-iseq/22/ca68d26ed3e638
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/ddec699512f2b6 b/tmp/cache/bootsnap/compile-cache-iseq/22/ddec699512f2b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/e56d380207daf8 b/tmp/cache/bootsnap/compile-cache-iseq/22/e56d380207daf8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/22/fd086cee94158c b/tmp/cache/bootsnap/compile-cache-iseq/22/fd086cee94158c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/01b8737c58f969 b/tmp/cache/bootsnap/compile-cache-iseq/23/01b8737c58f969
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/466511a6eebac4 b/tmp/cache/bootsnap/compile-cache-iseq/23/466511a6eebac4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/774996b12c69c4 b/tmp/cache/bootsnap/compile-cache-iseq/23/774996b12c69c4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/95db45f9772dc5 b/tmp/cache/bootsnap/compile-cache-iseq/23/95db45f9772dc5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/962c4a28d6d683 b/tmp/cache/bootsnap/compile-cache-iseq/23/962c4a28d6d683
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/a04742c672ccb0 b/tmp/cache/bootsnap/compile-cache-iseq/23/a04742c672ccb0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/23/f199f3f1bd633e b/tmp/cache/bootsnap/compile-cache-iseq/23/f199f3f1bd633e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/02da7c5667dfb7 b/tmp/cache/bootsnap/compile-cache-iseq/24/02da7c5667dfb7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/08a4c53108e44b b/tmp/cache/bootsnap/compile-cache-iseq/24/08a4c53108e44b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/2e5e4c938ddec5 b/tmp/cache/bootsnap/compile-cache-iseq/24/2e5e4c938ddec5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/5bcff64fbe8b43 b/tmp/cache/bootsnap/compile-cache-iseq/24/5bcff64fbe8b43
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/7e52142378d234 b/tmp/cache/bootsnap/compile-cache-iseq/24/7e52142378d234
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/803a27970b854f b/tmp/cache/bootsnap/compile-cache-iseq/24/803a27970b854f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/dc5482d904a01a b/tmp/cache/bootsnap/compile-cache-iseq/24/dc5482d904a01a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/e0e2c530d276ee b/tmp/cache/bootsnap/compile-cache-iseq/24/e0e2c530d276ee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/f2c4390064b35a b/tmp/cache/bootsnap/compile-cache-iseq/24/f2c4390064b35a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/24/faa86100f5888f b/tmp/cache/bootsnap/compile-cache-iseq/24/faa86100f5888f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/25/c7eb92347f54bb b/tmp/cache/bootsnap/compile-cache-iseq/25/c7eb92347f54bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/25/db1cb4bfd395fa b/tmp/cache/bootsnap/compile-cache-iseq/25/db1cb4bfd395fa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/0f03f9165801c8 b/tmp/cache/bootsnap/compile-cache-iseq/26/0f03f9165801c8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/230f40b01dda2a b/tmp/cache/bootsnap/compile-cache-iseq/26/230f40b01dda2a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/374e76739dfe3e b/tmp/cache/bootsnap/compile-cache-iseq/26/374e76739dfe3e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/60ead09040fa75 b/tmp/cache/bootsnap/compile-cache-iseq/26/60ead09040fa75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/b276378910ef90 b/tmp/cache/bootsnap/compile-cache-iseq/26/b276378910ef90
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/b40eb8f011f1ba b/tmp/cache/bootsnap/compile-cache-iseq/26/b40eb8f011f1ba
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/26/d42248dd81b078 b/tmp/cache/bootsnap/compile-cache-iseq/26/d42248dd81b078
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/30f7ae8be83f7f b/tmp/cache/bootsnap/compile-cache-iseq/27/30f7ae8be83f7f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/395f90526dc134 b/tmp/cache/bootsnap/compile-cache-iseq/27/395f90526dc134
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/7447bac7bcee9b b/tmp/cache/bootsnap/compile-cache-iseq/27/7447bac7bcee9b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/9147fced6b5a7c b/tmp/cache/bootsnap/compile-cache-iseq/27/9147fced6b5a7c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/b85798fdd1b070 b/tmp/cache/bootsnap/compile-cache-iseq/27/b85798fdd1b070
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/27/f6f1a1bb6bce04 b/tmp/cache/bootsnap/compile-cache-iseq/27/f6f1a1bb6bce04
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/0fc440e6a4108d b/tmp/cache/bootsnap/compile-cache-iseq/28/0fc440e6a4108d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/443175891c5e7d b/tmp/cache/bootsnap/compile-cache-iseq/28/443175891c5e7d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/576a59915056e8 b/tmp/cache/bootsnap/compile-cache-iseq/28/576a59915056e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/8241538879a373 b/tmp/cache/bootsnap/compile-cache-iseq/28/8241538879a373
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/aa4df903e9945c b/tmp/cache/bootsnap/compile-cache-iseq/28/aa4df903e9945c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/be095349f688f6 b/tmp/cache/bootsnap/compile-cache-iseq/28/be095349f688f6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/28/f29ec84cec4a7f b/tmp/cache/bootsnap/compile-cache-iseq/28/f29ec84cec4a7f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/0b674bb4fef508 b/tmp/cache/bootsnap/compile-cache-iseq/29/0b674bb4fef508
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/139ab3c01098d7 b/tmp/cache/bootsnap/compile-cache-iseq/29/139ab3c01098d7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/3bb7217f96355d b/tmp/cache/bootsnap/compile-cache-iseq/29/3bb7217f96355d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/c5defba4660d34 b/tmp/cache/bootsnap/compile-cache-iseq/29/c5defba4660d34
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/cd8cfc1bf270e3 b/tmp/cache/bootsnap/compile-cache-iseq/29/cd8cfc1bf270e3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/29/f9531ae559222b b/tmp/cache/bootsnap/compile-cache-iseq/29/f9531ae559222b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/123bdd6b14a3bd b/tmp/cache/bootsnap/compile-cache-iseq/2a/123bdd6b14a3bd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/12ff97f163a62f b/tmp/cache/bootsnap/compile-cache-iseq/2a/12ff97f163a62f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/40197ecb805a49 b/tmp/cache/bootsnap/compile-cache-iseq/2a/40197ecb805a49
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/4985166a08995f b/tmp/cache/bootsnap/compile-cache-iseq/2a/4985166a08995f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/523493ca2352e6 b/tmp/cache/bootsnap/compile-cache-iseq/2a/523493ca2352e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/71779673c98bb1 b/tmp/cache/bootsnap/compile-cache-iseq/2a/71779673c98bb1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/9b4495b3ec32a5 b/tmp/cache/bootsnap/compile-cache-iseq/2a/9b4495b3ec32a5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/c24dd048f2eafd b/tmp/cache/bootsnap/compile-cache-iseq/2a/c24dd048f2eafd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2a/f0ed7a7e7edd54 b/tmp/cache/bootsnap/compile-cache-iseq/2a/f0ed7a7e7edd54
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/0b353f959c53e2 b/tmp/cache/bootsnap/compile-cache-iseq/2b/0b353f959c53e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/1c3bf9948b8f29 b/tmp/cache/bootsnap/compile-cache-iseq/2b/1c3bf9948b8f29
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/7cc48275581030 b/tmp/cache/bootsnap/compile-cache-iseq/2b/7cc48275581030
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/81089ef19e99f2 b/tmp/cache/bootsnap/compile-cache-iseq/2b/81089ef19e99f2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/9981ea4ceabf0a b/tmp/cache/bootsnap/compile-cache-iseq/2b/9981ea4ceabf0a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/99fd6a901c5793 b/tmp/cache/bootsnap/compile-cache-iseq/2b/99fd6a901c5793
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/ca0ea92a8f6a22 b/tmp/cache/bootsnap/compile-cache-iseq/2b/ca0ea92a8f6a22
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2b/d0a92c6f0fac50 b/tmp/cache/bootsnap/compile-cache-iseq/2b/d0a92c6f0fac50
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/0aabb2259a1202 b/tmp/cache/bootsnap/compile-cache-iseq/2c/0aabb2259a1202
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/0c6c483d84f21d b/tmp/cache/bootsnap/compile-cache-iseq/2c/0c6c483d84f21d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/285f18b60664e8 b/tmp/cache/bootsnap/compile-cache-iseq/2c/285f18b60664e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/2cebaa51cb0e18 b/tmp/cache/bootsnap/compile-cache-iseq/2c/2cebaa51cb0e18
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/2ff3267c452b13 b/tmp/cache/bootsnap/compile-cache-iseq/2c/2ff3267c452b13
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/684a28a60fbd03 b/tmp/cache/bootsnap/compile-cache-iseq/2c/684a28a60fbd03
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/7418f6ca8286b8 b/tmp/cache/bootsnap/compile-cache-iseq/2c/7418f6ca8286b8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/7ca13166934235 b/tmp/cache/bootsnap/compile-cache-iseq/2c/7ca13166934235
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/9a47c77dd55988 b/tmp/cache/bootsnap/compile-cache-iseq/2c/9a47c77dd55988
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/bb57731056e999 b/tmp/cache/bootsnap/compile-cache-iseq/2c/bb57731056e999
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/c03302d3fafcb6 b/tmp/cache/bootsnap/compile-cache-iseq/2c/c03302d3fafcb6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/da04e80e7d3817 b/tmp/cache/bootsnap/compile-cache-iseq/2c/da04e80e7d3817
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2c/e5f98d20755de5 b/tmp/cache/bootsnap/compile-cache-iseq/2c/e5f98d20755de5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/03b1bf7594fb14 b/tmp/cache/bootsnap/compile-cache-iseq/2d/03b1bf7594fb14
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/6ebe8dd5755ae5 b/tmp/cache/bootsnap/compile-cache-iseq/2d/6ebe8dd5755ae5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/6f127b9b1c9a6c b/tmp/cache/bootsnap/compile-cache-iseq/2d/6f127b9b1c9a6c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/762d0a9afec8b9 b/tmp/cache/bootsnap/compile-cache-iseq/2d/762d0a9afec8b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/ab2d725e301748 b/tmp/cache/bootsnap/compile-cache-iseq/2d/ab2d725e301748
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2d/b24cb5562b3353 b/tmp/cache/bootsnap/compile-cache-iseq/2d/b24cb5562b3353
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2e/00fb8046c1c16f b/tmp/cache/bootsnap/compile-cache-iseq/2e/00fb8046c1c16f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2e/20888d77b4b72f b/tmp/cache/bootsnap/compile-cache-iseq/2e/20888d77b4b72f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2e/3014b741326142 b/tmp/cache/bootsnap/compile-cache-iseq/2e/3014b741326142
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2e/3d0792cdd6460c b/tmp/cache/bootsnap/compile-cache-iseq/2e/3d0792cdd6460c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2e/c8aec4d262a407 b/tmp/cache/bootsnap/compile-cache-iseq/2e/c8aec4d262a407
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2f/18cf499f400aaf b/tmp/cache/bootsnap/compile-cache-iseq/2f/18cf499f400aaf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2f/53d587d9aa0e3b b/tmp/cache/bootsnap/compile-cache-iseq/2f/53d587d9aa0e3b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2f/82fc3d21b0f200 b/tmp/cache/bootsnap/compile-cache-iseq/2f/82fc3d21b0f200
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/2f/e729204307720a b/tmp/cache/bootsnap/compile-cache-iseq/2f/e729204307720a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/611cd557937e63 b/tmp/cache/bootsnap/compile-cache-iseq/30/611cd557937e63
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/6d25aee4ea2b5b b/tmp/cache/bootsnap/compile-cache-iseq/30/6d25aee4ea2b5b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/71b9ba4f63ef00 b/tmp/cache/bootsnap/compile-cache-iseq/30/71b9ba4f63ef00
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/794a5afb23e52f b/tmp/cache/bootsnap/compile-cache-iseq/30/794a5afb23e52f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/8ce35b199f0610 b/tmp/cache/bootsnap/compile-cache-iseq/30/8ce35b199f0610
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/960e68f3617a11 b/tmp/cache/bootsnap/compile-cache-iseq/30/960e68f3617a11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/30/e577113dd2a8b5 b/tmp/cache/bootsnap/compile-cache-iseq/30/e577113dd2a8b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/31/09c961d35a570c b/tmp/cache/bootsnap/compile-cache-iseq/31/09c961d35a570c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/31/24260c06581327 b/tmp/cache/bootsnap/compile-cache-iseq/31/24260c06581327
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/31/3d930d0f24daec b/tmp/cache/bootsnap/compile-cache-iseq/31/3d930d0f24daec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/31/64d5a4cc0f71e9 b/tmp/cache/bootsnap/compile-cache-iseq/31/64d5a4cc0f71e9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/31/f7de039933f807 b/tmp/cache/bootsnap/compile-cache-iseq/31/f7de039933f807
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/32/4734927bf500d9 b/tmp/cache/bootsnap/compile-cache-iseq/32/4734927bf500d9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/32/5be0c8b87b3e67 b/tmp/cache/bootsnap/compile-cache-iseq/32/5be0c8b87b3e67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/32/6b67a7c0339543 b/tmp/cache/bootsnap/compile-cache-iseq/32/6b67a7c0339543
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/32/f4cf5bd9f36475 b/tmp/cache/bootsnap/compile-cache-iseq/32/f4cf5bd9f36475
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/13c234e3365d6d b/tmp/cache/bootsnap/compile-cache-iseq/33/13c234e3365d6d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/456c377c76fd09 b/tmp/cache/bootsnap/compile-cache-iseq/33/456c377c76fd09
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/4ec308640b6d5d b/tmp/cache/bootsnap/compile-cache-iseq/33/4ec308640b6d5d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/64f7d5b50e789d b/tmp/cache/bootsnap/compile-cache-iseq/33/64f7d5b50e789d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/b9875fa12e4982 b/tmp/cache/bootsnap/compile-cache-iseq/33/b9875fa12e4982
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/33/d1ed7fbcce3e5b b/tmp/cache/bootsnap/compile-cache-iseq/33/d1ed7fbcce3e5b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/070c6cb74ee81e b/tmp/cache/bootsnap/compile-cache-iseq/34/070c6cb74ee81e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/17dd28bc91aba9 b/tmp/cache/bootsnap/compile-cache-iseq/34/17dd28bc91aba9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/258a64bb42291b b/tmp/cache/bootsnap/compile-cache-iseq/34/258a64bb42291b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/2e23c11269b138 b/tmp/cache/bootsnap/compile-cache-iseq/34/2e23c11269b138
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/53f7b5cff9fbc6 b/tmp/cache/bootsnap/compile-cache-iseq/34/53f7b5cff9fbc6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/652c465b794418 b/tmp/cache/bootsnap/compile-cache-iseq/34/652c465b794418
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/96143d8ef8b849 b/tmp/cache/bootsnap/compile-cache-iseq/34/96143d8ef8b849
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/b69290e8f9f88b b/tmp/cache/bootsnap/compile-cache-iseq/34/b69290e8f9f88b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/e01e4e00ae7953 b/tmp/cache/bootsnap/compile-cache-iseq/34/e01e4e00ae7953
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/34/f6e7d9084981cc b/tmp/cache/bootsnap/compile-cache-iseq/34/f6e7d9084981cc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/2caaf00319a73f b/tmp/cache/bootsnap/compile-cache-iseq/35/2caaf00319a73f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/3b4649b6c3d3d2 b/tmp/cache/bootsnap/compile-cache-iseq/35/3b4649b6c3d3d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/5c4847020a3150 b/tmp/cache/bootsnap/compile-cache-iseq/35/5c4847020a3150
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/bcf519360d52f5 b/tmp/cache/bootsnap/compile-cache-iseq/35/bcf519360d52f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/c01f147e94ceb9 b/tmp/cache/bootsnap/compile-cache-iseq/35/c01f147e94ceb9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/c56b2d670c68ca b/tmp/cache/bootsnap/compile-cache-iseq/35/c56b2d670c68ca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/35/eaa3a0e1c76389 b/tmp/cache/bootsnap/compile-cache-iseq/35/eaa3a0e1c76389
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/36/733cae5b15047e b/tmp/cache/bootsnap/compile-cache-iseq/36/733cae5b15047e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/36/9866a57afcfb5c b/tmp/cache/bootsnap/compile-cache-iseq/36/9866a57afcfb5c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/36/dd57da69268603 b/tmp/cache/bootsnap/compile-cache-iseq/36/dd57da69268603
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/36/e241998d8cf905 b/tmp/cache/bootsnap/compile-cache-iseq/36/e241998d8cf905
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/36/ea8cc5b88a0c93 b/tmp/cache/bootsnap/compile-cache-iseq/36/ea8cc5b88a0c93
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/37/1bd338e1710644 b/tmp/cache/bootsnap/compile-cache-iseq/37/1bd338e1710644
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/37/412dcbdcf6c0e8 b/tmp/cache/bootsnap/compile-cache-iseq/37/412dcbdcf6c0e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/37/4526ade3287244 b/tmp/cache/bootsnap/compile-cache-iseq/37/4526ade3287244
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/37/e0cd2a70051733 b/tmp/cache/bootsnap/compile-cache-iseq/37/e0cd2a70051733
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/223894c62caa55 b/tmp/cache/bootsnap/compile-cache-iseq/38/223894c62caa55
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/235bcb7c1314ec b/tmp/cache/bootsnap/compile-cache-iseq/38/235bcb7c1314ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/328258f5fba6f5 b/tmp/cache/bootsnap/compile-cache-iseq/38/328258f5fba6f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/3995def01625cc b/tmp/cache/bootsnap/compile-cache-iseq/38/3995def01625cc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/5f0b003f48bf0d b/tmp/cache/bootsnap/compile-cache-iseq/38/5f0b003f48bf0d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/38/61bb4107a314a8 b/tmp/cache/bootsnap/compile-cache-iseq/38/61bb4107a314a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/39/2573af7ff0b2c2 b/tmp/cache/bootsnap/compile-cache-iseq/39/2573af7ff0b2c2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/39/3b0fe89a64c6a9 b/tmp/cache/bootsnap/compile-cache-iseq/39/3b0fe89a64c6a9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/39/753f1f85215ca7 b/tmp/cache/bootsnap/compile-cache-iseq/39/753f1f85215ca7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/39/dc9deee45fd4d2 b/tmp/cache/bootsnap/compile-cache-iseq/39/dc9deee45fd4d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3a/1b630bea45b130 b/tmp/cache/bootsnap/compile-cache-iseq/3a/1b630bea45b130
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3a/a0b7d97e554621 b/tmp/cache/bootsnap/compile-cache-iseq/3a/a0b7d97e554621
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3a/bf27989cb185f7 b/tmp/cache/bootsnap/compile-cache-iseq/3a/bf27989cb185f7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3a/c5647e3f001df3 b/tmp/cache/bootsnap/compile-cache-iseq/3a/c5647e3f001df3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3a/f3c853f166391f b/tmp/cache/bootsnap/compile-cache-iseq/3a/f3c853f166391f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3b/2e4894be257c74 b/tmp/cache/bootsnap/compile-cache-iseq/3b/2e4894be257c74
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3b/3926a40999d88e b/tmp/cache/bootsnap/compile-cache-iseq/3b/3926a40999d88e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3b/594de37a7141c6 b/tmp/cache/bootsnap/compile-cache-iseq/3b/594de37a7141c6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3b/8532254358d4e7 b/tmp/cache/bootsnap/compile-cache-iseq/3b/8532254358d4e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3b/f3cd711849abfd b/tmp/cache/bootsnap/compile-cache-iseq/3b/f3cd711849abfd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/0697d329368b6b b/tmp/cache/bootsnap/compile-cache-iseq/3c/0697d329368b6b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/11f870a7603539 b/tmp/cache/bootsnap/compile-cache-iseq/3c/11f870a7603539
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/2227fb49659cde b/tmp/cache/bootsnap/compile-cache-iseq/3c/2227fb49659cde
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/46cc277c94dbda b/tmp/cache/bootsnap/compile-cache-iseq/3c/46cc277c94dbda
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/6a5ee315ada81d b/tmp/cache/bootsnap/compile-cache-iseq/3c/6a5ee315ada81d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3c/92a77d3b77aaac b/tmp/cache/bootsnap/compile-cache-iseq/3c/92a77d3b77aaac
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/0226806e2108bd b/tmp/cache/bootsnap/compile-cache-iseq/3d/0226806e2108bd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/13520db3d0601f b/tmp/cache/bootsnap/compile-cache-iseq/3d/13520db3d0601f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/17863dce2154e6 b/tmp/cache/bootsnap/compile-cache-iseq/3d/17863dce2154e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/89a7554c125bf5 b/tmp/cache/bootsnap/compile-cache-iseq/3d/89a7554c125bf5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/95a378a032bfdd b/tmp/cache/bootsnap/compile-cache-iseq/3d/95a378a032bfdd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/bc844091dba34f b/tmp/cache/bootsnap/compile-cache-iseq/3d/bc844091dba34f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/c6f4236e0b3091 b/tmp/cache/bootsnap/compile-cache-iseq/3d/c6f4236e0b3091
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/c7e48c5bcf017f b/tmp/cache/bootsnap/compile-cache-iseq/3d/c7e48c5bcf017f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3d/f284387047d60f b/tmp/cache/bootsnap/compile-cache-iseq/3d/f284387047d60f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/05b7b525821041 b/tmp/cache/bootsnap/compile-cache-iseq/3e/05b7b525821041
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/227c0794e7af36 b/tmp/cache/bootsnap/compile-cache-iseq/3e/227c0794e7af36
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/4da277805fab2c b/tmp/cache/bootsnap/compile-cache-iseq/3e/4da277805fab2c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/6cccd1f0b7598d b/tmp/cache/bootsnap/compile-cache-iseq/3e/6cccd1f0b7598d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/85e2380f0a053b b/tmp/cache/bootsnap/compile-cache-iseq/3e/85e2380f0a053b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/9d41391ee8f000 b/tmp/cache/bootsnap/compile-cache-iseq/3e/9d41391ee8f000
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/aea2b404d84289 b/tmp/cache/bootsnap/compile-cache-iseq/3e/aea2b404d84289
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3e/cf74c2008bc35e b/tmp/cache/bootsnap/compile-cache-iseq/3e/cf74c2008bc35e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3f/23c9e847e7db3c b/tmp/cache/bootsnap/compile-cache-iseq/3f/23c9e847e7db3c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3f/287070495a7a41 b/tmp/cache/bootsnap/compile-cache-iseq/3f/287070495a7a41
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3f/94c614d557d68a b/tmp/cache/bootsnap/compile-cache-iseq/3f/94c614d557d68a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/3f/acf28c478cd6d2 b/tmp/cache/bootsnap/compile-cache-iseq/3f/acf28c478cd6d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/152fdfd77acda2 b/tmp/cache/bootsnap/compile-cache-iseq/40/152fdfd77acda2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/19ccc0797453f5 b/tmp/cache/bootsnap/compile-cache-iseq/40/19ccc0797453f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/2dd347a57d8f4e b/tmp/cache/bootsnap/compile-cache-iseq/40/2dd347a57d8f4e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/39c6e6078c9e1f b/tmp/cache/bootsnap/compile-cache-iseq/40/39c6e6078c9e1f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/6b5beca6ef5de5 b/tmp/cache/bootsnap/compile-cache-iseq/40/6b5beca6ef5de5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/7366955506f612 b/tmp/cache/bootsnap/compile-cache-iseq/40/7366955506f612
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/c4fe360a25026e b/tmp/cache/bootsnap/compile-cache-iseq/40/c4fe360a25026e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/c7ee52a70a22a3 b/tmp/cache/bootsnap/compile-cache-iseq/40/c7ee52a70a22a3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/d0751233e6ea74 b/tmp/cache/bootsnap/compile-cache-iseq/40/d0751233e6ea74
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/f54440850b530d b/tmp/cache/bootsnap/compile-cache-iseq/40/f54440850b530d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/40/f6f52c4b7e3152 b/tmp/cache/bootsnap/compile-cache-iseq/40/f6f52c4b7e3152
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/41/234d5b04b9e6d6 b/tmp/cache/bootsnap/compile-cache-iseq/41/234d5b04b9e6d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/41/91516022ed7194 b/tmp/cache/bootsnap/compile-cache-iseq/41/91516022ed7194
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/41/9e66f7484c55df b/tmp/cache/bootsnap/compile-cache-iseq/41/9e66f7484c55df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/41/c242b5775ef929 b/tmp/cache/bootsnap/compile-cache-iseq/41/c242b5775ef929
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/0f3d9669d52930 b/tmp/cache/bootsnap/compile-cache-iseq/42/0f3d9669d52930
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/465cc7ed3706a1 b/tmp/cache/bootsnap/compile-cache-iseq/42/465cc7ed3706a1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/9ba822b3109eff b/tmp/cache/bootsnap/compile-cache-iseq/42/9ba822b3109eff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/9ee48075a0d1d4 b/tmp/cache/bootsnap/compile-cache-iseq/42/9ee48075a0d1d4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/bb1608cf1f7fe9 b/tmp/cache/bootsnap/compile-cache-iseq/42/bb1608cf1f7fe9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/d35b47d38afb94 b/tmp/cache/bootsnap/compile-cache-iseq/42/d35b47d38afb94
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/d8c38fc5cb9390 b/tmp/cache/bootsnap/compile-cache-iseq/42/d8c38fc5cb9390
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/e7ce8cf889a630 b/tmp/cache/bootsnap/compile-cache-iseq/42/e7ce8cf889a630
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/42/f14a64f9733ed8 b/tmp/cache/bootsnap/compile-cache-iseq/42/f14a64f9733ed8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/141153f0bd2d06 b/tmp/cache/bootsnap/compile-cache-iseq/43/141153f0bd2d06
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/5258396b755dfd b/tmp/cache/bootsnap/compile-cache-iseq/43/5258396b755dfd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/67fa227b5c435e b/tmp/cache/bootsnap/compile-cache-iseq/43/67fa227b5c435e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/6f75f9796d1728 b/tmp/cache/bootsnap/compile-cache-iseq/43/6f75f9796d1728
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/826fe90cf9ea0d b/tmp/cache/bootsnap/compile-cache-iseq/43/826fe90cf9ea0d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/917ecd470558d0 b/tmp/cache/bootsnap/compile-cache-iseq/43/917ecd470558d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/b247fe61aa2423 b/tmp/cache/bootsnap/compile-cache-iseq/43/b247fe61aa2423
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/e349fa5d3816de b/tmp/cache/bootsnap/compile-cache-iseq/43/e349fa5d3816de
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/43/efabd7466507ca b/tmp/cache/bootsnap/compile-cache-iseq/43/efabd7466507ca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/44/eca8d3829c5060 b/tmp/cache/bootsnap/compile-cache-iseq/44/eca8d3829c5060
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/194293c723f4b9 b/tmp/cache/bootsnap/compile-cache-iseq/45/194293c723f4b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/1c922f33a88211 b/tmp/cache/bootsnap/compile-cache-iseq/45/1c922f33a88211
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/233c9af0d19fe0 b/tmp/cache/bootsnap/compile-cache-iseq/45/233c9af0d19fe0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/29a0074ac83495 b/tmp/cache/bootsnap/compile-cache-iseq/45/29a0074ac83495
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/9f6109717c7c09 b/tmp/cache/bootsnap/compile-cache-iseq/45/9f6109717c7c09
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/c52bb46f0bfadb b/tmp/cache/bootsnap/compile-cache-iseq/45/c52bb46f0bfadb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/e0f52feb3c0ce8 b/tmp/cache/bootsnap/compile-cache-iseq/45/e0f52feb3c0ce8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/45/ec015fd78f36b9 b/tmp/cache/bootsnap/compile-cache-iseq/45/ec015fd78f36b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/46/1bff9d0189cb97 b/tmp/cache/bootsnap/compile-cache-iseq/46/1bff9d0189cb97
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/46/63bfd52afe6476 b/tmp/cache/bootsnap/compile-cache-iseq/46/63bfd52afe6476
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/1f7b1a033abf28 b/tmp/cache/bootsnap/compile-cache-iseq/47/1f7b1a033abf28
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/3a1a4fb7bed4aa b/tmp/cache/bootsnap/compile-cache-iseq/47/3a1a4fb7bed4aa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/4f82646d782d61 b/tmp/cache/bootsnap/compile-cache-iseq/47/4f82646d782d61
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/60f958a4c33720 b/tmp/cache/bootsnap/compile-cache-iseq/47/60f958a4c33720
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/61e8bddee9e6b9 b/tmp/cache/bootsnap/compile-cache-iseq/47/61e8bddee9e6b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/a7f4db69a22ffb b/tmp/cache/bootsnap/compile-cache-iseq/47/a7f4db69a22ffb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/47/bc041cf7b324f4 b/tmp/cache/bootsnap/compile-cache-iseq/47/bc041cf7b324f4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/076edc1938d38a b/tmp/cache/bootsnap/compile-cache-iseq/48/076edc1938d38a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/47ef90056bc27e b/tmp/cache/bootsnap/compile-cache-iseq/48/47ef90056bc27e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/8b5c44f33aa0fe b/tmp/cache/bootsnap/compile-cache-iseq/48/8b5c44f33aa0fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/a54584563da1ed b/tmp/cache/bootsnap/compile-cache-iseq/48/a54584563da1ed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/a610a2dc5557f9 b/tmp/cache/bootsnap/compile-cache-iseq/48/a610a2dc5557f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/ee5905a78ec739 b/tmp/cache/bootsnap/compile-cache-iseq/48/ee5905a78ec739
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/fec7ce8da1129a b/tmp/cache/bootsnap/compile-cache-iseq/48/fec7ce8da1129a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/48/fff27843559dcc b/tmp/cache/bootsnap/compile-cache-iseq/48/fff27843559dcc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/49/31dc5a96d85ca8 b/tmp/cache/bootsnap/compile-cache-iseq/49/31dc5a96d85ca8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/49/5e567ad178ea6b b/tmp/cache/bootsnap/compile-cache-iseq/49/5e567ad178ea6b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/49/b875c00d34427f b/tmp/cache/bootsnap/compile-cache-iseq/49/b875c00d34427f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/49/f64805927bd21e b/tmp/cache/bootsnap/compile-cache-iseq/49/f64805927bd21e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4a/3275393dc2f07a b/tmp/cache/bootsnap/compile-cache-iseq/4a/3275393dc2f07a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4a/8e3ed6f6762c1d b/tmp/cache/bootsnap/compile-cache-iseq/4a/8e3ed6f6762c1d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4a/a218866432e502 b/tmp/cache/bootsnap/compile-cache-iseq/4a/a218866432e502
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4b/58d7611d707792 b/tmp/cache/bootsnap/compile-cache-iseq/4b/58d7611d707792
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4b/8327bcaa37e14c b/tmp/cache/bootsnap/compile-cache-iseq/4b/8327bcaa37e14c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4b/cff7baafc331cf b/tmp/cache/bootsnap/compile-cache-iseq/4b/cff7baafc331cf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4b/ef8fbc345427b5 b/tmp/cache/bootsnap/compile-cache-iseq/4b/ef8fbc345427b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/0d69f2dfe804e7 b/tmp/cache/bootsnap/compile-cache-iseq/4c/0d69f2dfe804e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/8dadfd9a3a8ba0 b/tmp/cache/bootsnap/compile-cache-iseq/4c/8dadfd9a3a8ba0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/a4d58d61b39dd8 b/tmp/cache/bootsnap/compile-cache-iseq/4c/a4d58d61b39dd8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/bab7739ee4441f b/tmp/cache/bootsnap/compile-cache-iseq/4c/bab7739ee4441f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/c6581ca3aa693e b/tmp/cache/bootsnap/compile-cache-iseq/4c/c6581ca3aa693e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4c/eb1597c70620ea b/tmp/cache/bootsnap/compile-cache-iseq/4c/eb1597c70620ea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/06448b4d47b3ab b/tmp/cache/bootsnap/compile-cache-iseq/4d/06448b4d47b3ab
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/0ee426fa9a1d4e b/tmp/cache/bootsnap/compile-cache-iseq/4d/0ee426fa9a1d4e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/7ead2b27585456 b/tmp/cache/bootsnap/compile-cache-iseq/4d/7ead2b27585456
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/839655e50a2a22 b/tmp/cache/bootsnap/compile-cache-iseq/4d/839655e50a2a22
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/aa60830085948d b/tmp/cache/bootsnap/compile-cache-iseq/4d/aa60830085948d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/d40c896db03259 b/tmp/cache/bootsnap/compile-cache-iseq/4d/d40c896db03259
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/d8acb615b3aab4 b/tmp/cache/bootsnap/compile-cache-iseq/4d/d8acb615b3aab4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4d/eb4d0d77a74c0c b/tmp/cache/bootsnap/compile-cache-iseq/4d/eb4d0d77a74c0c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/25f4203171c444 b/tmp/cache/bootsnap/compile-cache-iseq/4e/25f4203171c444
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/58c929826b6c8c b/tmp/cache/bootsnap/compile-cache-iseq/4e/58c929826b6c8c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/70ae4a26bf0d4d b/tmp/cache/bootsnap/compile-cache-iseq/4e/70ae4a26bf0d4d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/7e5e8c48f74941 b/tmp/cache/bootsnap/compile-cache-iseq/4e/7e5e8c48f74941
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/8e3e311779d401 b/tmp/cache/bootsnap/compile-cache-iseq/4e/8e3e311779d401
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/e72fdf8cc73d8b b/tmp/cache/bootsnap/compile-cache-iseq/4e/e72fdf8cc73d8b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/fa71c2e8b4063b b/tmp/cache/bootsnap/compile-cache-iseq/4e/fa71c2e8b4063b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4e/fbbc60381a6998 b/tmp/cache/bootsnap/compile-cache-iseq/4e/fbbc60381a6998
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/14e751b21ea50e b/tmp/cache/bootsnap/compile-cache-iseq/4f/14e751b21ea50e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/1c649ae38e1477 b/tmp/cache/bootsnap/compile-cache-iseq/4f/1c649ae38e1477
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/35e1020a9e6ad2 b/tmp/cache/bootsnap/compile-cache-iseq/4f/35e1020a9e6ad2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/3ae8dff501cc41 b/tmp/cache/bootsnap/compile-cache-iseq/4f/3ae8dff501cc41
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/3d835b09e6d680 b/tmp/cache/bootsnap/compile-cache-iseq/4f/3d835b09e6d680
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/7894dd3bb7f99f b/tmp/cache/bootsnap/compile-cache-iseq/4f/7894dd3bb7f99f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/827ad6fde9ac78 b/tmp/cache/bootsnap/compile-cache-iseq/4f/827ad6fde9ac78
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/95108ae83b4f32 b/tmp/cache/bootsnap/compile-cache-iseq/4f/95108ae83b4f32
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/ec17bf90e2c506 b/tmp/cache/bootsnap/compile-cache-iseq/4f/ec17bf90e2c506
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/4f/f4089a3a644c09 b/tmp/cache/bootsnap/compile-cache-iseq/4f/f4089a3a644c09
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/21fe719c8c1538 b/tmp/cache/bootsnap/compile-cache-iseq/50/21fe719c8c1538
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/635a41accac278 b/tmp/cache/bootsnap/compile-cache-iseq/50/635a41accac278
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/862f5615b26277 b/tmp/cache/bootsnap/compile-cache-iseq/50/862f5615b26277
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/aa8aaee833a419 b/tmp/cache/bootsnap/compile-cache-iseq/50/aa8aaee833a419
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/aef2fad35134f3 b/tmp/cache/bootsnap/compile-cache-iseq/50/aef2fad35134f3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/df3e5625c2befd b/tmp/cache/bootsnap/compile-cache-iseq/50/df3e5625c2befd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/fbc0a89a277c46 b/tmp/cache/bootsnap/compile-cache-iseq/50/fbc0a89a277c46
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/50/ff97cf84601df7 b/tmp/cache/bootsnap/compile-cache-iseq/50/ff97cf84601df7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/2e979fd946c1f9 b/tmp/cache/bootsnap/compile-cache-iseq/51/2e979fd946c1f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/36ef81cd629969 b/tmp/cache/bootsnap/compile-cache-iseq/51/36ef81cd629969
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/38060e27bd1bfa b/tmp/cache/bootsnap/compile-cache-iseq/51/38060e27bd1bfa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/9da17948e41f78 b/tmp/cache/bootsnap/compile-cache-iseq/51/9da17948e41f78
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/a64a76134846ef b/tmp/cache/bootsnap/compile-cache-iseq/51/a64a76134846ef
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/beadf3efe0ab75 b/tmp/cache/bootsnap/compile-cache-iseq/51/beadf3efe0ab75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/d86b1ce91ee70c b/tmp/cache/bootsnap/compile-cache-iseq/51/d86b1ce91ee70c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/f05b45d616fc0d b/tmp/cache/bootsnap/compile-cache-iseq/51/f05b45d616fc0d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/51/fded6a12fb64f5 b/tmp/cache/bootsnap/compile-cache-iseq/51/fded6a12fb64f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/034857c3cae49d b/tmp/cache/bootsnap/compile-cache-iseq/52/034857c3cae49d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/245c29988a916d b/tmp/cache/bootsnap/compile-cache-iseq/52/245c29988a916d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/5593d33892aab9 b/tmp/cache/bootsnap/compile-cache-iseq/52/5593d33892aab9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/9fdd5e0a42c96e b/tmp/cache/bootsnap/compile-cache-iseq/52/9fdd5e0a42c96e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/b80f7fad37e8bc b/tmp/cache/bootsnap/compile-cache-iseq/52/b80f7fad37e8bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/52/d00874863a77cb b/tmp/cache/bootsnap/compile-cache-iseq/52/d00874863a77cb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/53/20de727f8e2ba5 b/tmp/cache/bootsnap/compile-cache-iseq/53/20de727f8e2ba5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/53/3131e4a36d3d0f b/tmp/cache/bootsnap/compile-cache-iseq/53/3131e4a36d3d0f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/53/5c6e0c5f32bc2d b/tmp/cache/bootsnap/compile-cache-iseq/53/5c6e0c5f32bc2d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/53/8dfdac15284be3 b/tmp/cache/bootsnap/compile-cache-iseq/53/8dfdac15284be3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/1aef1a5d560a66 b/tmp/cache/bootsnap/compile-cache-iseq/54/1aef1a5d560a66
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/45c8106a70bc27 b/tmp/cache/bootsnap/compile-cache-iseq/54/45c8106a70bc27
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/7068b771bd05d0 b/tmp/cache/bootsnap/compile-cache-iseq/54/7068b771bd05d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/729c7a078d78bc b/tmp/cache/bootsnap/compile-cache-iseq/54/729c7a078d78bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/b45ef1bfe3f78b b/tmp/cache/bootsnap/compile-cache-iseq/54/b45ef1bfe3f78b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/c5d27920a63631 b/tmp/cache/bootsnap/compile-cache-iseq/54/c5d27920a63631
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/dc54378af65a9f b/tmp/cache/bootsnap/compile-cache-iseq/54/dc54378af65a9f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/e4265bd0fcdbea b/tmp/cache/bootsnap/compile-cache-iseq/54/e4265bd0fcdbea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/54/ff7183c5e06d2e b/tmp/cache/bootsnap/compile-cache-iseq/54/ff7183c5e06d2e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/55/7057d5b88a002c b/tmp/cache/bootsnap/compile-cache-iseq/55/7057d5b88a002c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/55/911087099256c3 b/tmp/cache/bootsnap/compile-cache-iseq/55/911087099256c3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/55/95144aeb654979 b/tmp/cache/bootsnap/compile-cache-iseq/55/95144aeb654979
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/55/af52a0971f0526 b/tmp/cache/bootsnap/compile-cache-iseq/55/af52a0971f0526
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/56/20cb8c6f4cefa6 b/tmp/cache/bootsnap/compile-cache-iseq/56/20cb8c6f4cefa6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/56/2da66c93744b6e b/tmp/cache/bootsnap/compile-cache-iseq/56/2da66c93744b6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/56/38dc3be4af0ff4 b/tmp/cache/bootsnap/compile-cache-iseq/56/38dc3be4af0ff4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/56/8e7af7ba7141c2 b/tmp/cache/bootsnap/compile-cache-iseq/56/8e7af7ba7141c2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/56/b85b2739fd6a63 b/tmp/cache/bootsnap/compile-cache-iseq/56/b85b2739fd6a63
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/0c567bf0bebf07 b/tmp/cache/bootsnap/compile-cache-iseq/57/0c567bf0bebf07
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/0fd2bed207945c b/tmp/cache/bootsnap/compile-cache-iseq/57/0fd2bed207945c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/232313236b9160 b/tmp/cache/bootsnap/compile-cache-iseq/57/232313236b9160
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/43b9026945dddf b/tmp/cache/bootsnap/compile-cache-iseq/57/43b9026945dddf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/8e037116251b46 b/tmp/cache/bootsnap/compile-cache-iseq/57/8e037116251b46
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/a1c893552e0c54 b/tmp/cache/bootsnap/compile-cache-iseq/57/a1c893552e0c54
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/d50009f51b7368 b/tmp/cache/bootsnap/compile-cache-iseq/57/d50009f51b7368
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/57/daf8e8196e821b b/tmp/cache/bootsnap/compile-cache-iseq/57/daf8e8196e821b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/3d735c497a52b8 b/tmp/cache/bootsnap/compile-cache-iseq/58/3d735c497a52b8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/4d3dcd4dcb09e6 b/tmp/cache/bootsnap/compile-cache-iseq/58/4d3dcd4dcb09e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/5ddcae6df33a1f b/tmp/cache/bootsnap/compile-cache-iseq/58/5ddcae6df33a1f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/604f3238401492 b/tmp/cache/bootsnap/compile-cache-iseq/58/604f3238401492
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/6740b5aa2d83bf b/tmp/cache/bootsnap/compile-cache-iseq/58/6740b5aa2d83bf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/b500ce07f3b593 b/tmp/cache/bootsnap/compile-cache-iseq/58/b500ce07f3b593
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/faf1a9a7720808 b/tmp/cache/bootsnap/compile-cache-iseq/58/faf1a9a7720808
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/58/fb7defd20445b8 b/tmp/cache/bootsnap/compile-cache-iseq/58/fb7defd20445b8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/1b4a0a94d121ec b/tmp/cache/bootsnap/compile-cache-iseq/59/1b4a0a94d121ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/6beb57d2d2c8e7 b/tmp/cache/bootsnap/compile-cache-iseq/59/6beb57d2d2c8e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/7b7add8043b83d b/tmp/cache/bootsnap/compile-cache-iseq/59/7b7add8043b83d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/7bc4cb6efcb42f b/tmp/cache/bootsnap/compile-cache-iseq/59/7bc4cb6efcb42f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/9945d8206ac578 b/tmp/cache/bootsnap/compile-cache-iseq/59/9945d8206ac578
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/d5e613550b9747 b/tmp/cache/bootsnap/compile-cache-iseq/59/d5e613550b9747
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/59/e200db0a686682 b/tmp/cache/bootsnap/compile-cache-iseq/59/e200db0a686682
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/61092d84a6d4b3 b/tmp/cache/bootsnap/compile-cache-iseq/5a/61092d84a6d4b3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/8ac29efcda1cdb b/tmp/cache/bootsnap/compile-cache-iseq/5a/8ac29efcda1cdb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/8bd0af0fcf3b90 b/tmp/cache/bootsnap/compile-cache-iseq/5a/8bd0af0fcf3b90
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/a1863a9d5ad3ac b/tmp/cache/bootsnap/compile-cache-iseq/5a/a1863a9d5ad3ac
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/ecf7c3929a16df b/tmp/cache/bootsnap/compile-cache-iseq/5a/ecf7c3929a16df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5a/fe354514348753 b/tmp/cache/bootsnap/compile-cache-iseq/5a/fe354514348753
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5b/34767c17985b81 b/tmp/cache/bootsnap/compile-cache-iseq/5b/34767c17985b81
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5b/cf1ee46629a8d2 b/tmp/cache/bootsnap/compile-cache-iseq/5b/cf1ee46629a8d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5b/dc8b4d64deb70e b/tmp/cache/bootsnap/compile-cache-iseq/5b/dc8b4d64deb70e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5b/ef82bbd0dc623c b/tmp/cache/bootsnap/compile-cache-iseq/5b/ef82bbd0dc623c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5c/a54d858437c1b5 b/tmp/cache/bootsnap/compile-cache-iseq/5c/a54d858437c1b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5c/a9d8ee3b2f4cf7 b/tmp/cache/bootsnap/compile-cache-iseq/5c/a9d8ee3b2f4cf7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5c/d221677337b473 b/tmp/cache/bootsnap/compile-cache-iseq/5c/d221677337b473
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5c/d5c90bb2915f99 b/tmp/cache/bootsnap/compile-cache-iseq/5c/d5c90bb2915f99
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5d/92a229f432f7c0 b/tmp/cache/bootsnap/compile-cache-iseq/5d/92a229f432f7c0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5d/a32c1e51eae504 b/tmp/cache/bootsnap/compile-cache-iseq/5d/a32c1e51eae504
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5d/c5b49156354538 b/tmp/cache/bootsnap/compile-cache-iseq/5d/c5b49156354538
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/20996ee99fecd2 b/tmp/cache/bootsnap/compile-cache-iseq/5e/20996ee99fecd2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/2508b5abeef99b b/tmp/cache/bootsnap/compile-cache-iseq/5e/2508b5abeef99b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/2eace3c99879a0 b/tmp/cache/bootsnap/compile-cache-iseq/5e/2eace3c99879a0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/65f3ed281e1216 b/tmp/cache/bootsnap/compile-cache-iseq/5e/65f3ed281e1216
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/b943e88e218953 b/tmp/cache/bootsnap/compile-cache-iseq/5e/b943e88e218953
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/e038f6488c33f3 b/tmp/cache/bootsnap/compile-cache-iseq/5e/e038f6488c33f3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/f3419e9e110893 b/tmp/cache/bootsnap/compile-cache-iseq/5e/f3419e9e110893
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5e/fd3caac6e14a8a b/tmp/cache/bootsnap/compile-cache-iseq/5e/fd3caac6e14a8a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5f/456f4d43f1fbb5 b/tmp/cache/bootsnap/compile-cache-iseq/5f/456f4d43f1fbb5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5f/794abd5286bac7 b/tmp/cache/bootsnap/compile-cache-iseq/5f/794abd5286bac7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5f/7bca8e05d81101 b/tmp/cache/bootsnap/compile-cache-iseq/5f/7bca8e05d81101
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/5f/9077c58353152a b/tmp/cache/bootsnap/compile-cache-iseq/5f/9077c58353152a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/60/1d4f1e174f265a b/tmp/cache/bootsnap/compile-cache-iseq/60/1d4f1e174f265a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/60/1d91dc5a7bdb9d b/tmp/cache/bootsnap/compile-cache-iseq/60/1d91dc5a7bdb9d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/60/8030afdaa3d2a8 b/tmp/cache/bootsnap/compile-cache-iseq/60/8030afdaa3d2a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/60/bb7eef4f9716e3 b/tmp/cache/bootsnap/compile-cache-iseq/60/bb7eef4f9716e3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/03953d3a0cf715 b/tmp/cache/bootsnap/compile-cache-iseq/61/03953d3a0cf715
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/2c7ae10a33841b b/tmp/cache/bootsnap/compile-cache-iseq/61/2c7ae10a33841b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/7ad1da6079ef02 b/tmp/cache/bootsnap/compile-cache-iseq/61/7ad1da6079ef02
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/c9da77f6103c06 b/tmp/cache/bootsnap/compile-cache-iseq/61/c9da77f6103c06
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/cbaf0ae028bd1b b/tmp/cache/bootsnap/compile-cache-iseq/61/cbaf0ae028bd1b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/61/cdce06d48f7ae1 b/tmp/cache/bootsnap/compile-cache-iseq/61/cdce06d48f7ae1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/32d74c2fabc6c2 b/tmp/cache/bootsnap/compile-cache-iseq/62/32d74c2fabc6c2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/3798ff8fcae49b b/tmp/cache/bootsnap/compile-cache-iseq/62/3798ff8fcae49b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/4f66312dffedee b/tmp/cache/bootsnap/compile-cache-iseq/62/4f66312dffedee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/8c544a840692a2 b/tmp/cache/bootsnap/compile-cache-iseq/62/8c544a840692a2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/9bebf51ab127e7 b/tmp/cache/bootsnap/compile-cache-iseq/62/9bebf51ab127e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/62/b6005351d3cea3 b/tmp/cache/bootsnap/compile-cache-iseq/62/b6005351d3cea3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/3a64301f5b680e b/tmp/cache/bootsnap/compile-cache-iseq/63/3a64301f5b680e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/5ee87d3a221619 b/tmp/cache/bootsnap/compile-cache-iseq/63/5ee87d3a221619
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/80be33fd4b8a83 b/tmp/cache/bootsnap/compile-cache-iseq/63/80be33fd4b8a83
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/b876ff7b5b24f1 b/tmp/cache/bootsnap/compile-cache-iseq/63/b876ff7b5b24f1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/c82ed8ebd24fa8 b/tmp/cache/bootsnap/compile-cache-iseq/63/c82ed8ebd24fa8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/63/f2fbf06c8d02f4 b/tmp/cache/bootsnap/compile-cache-iseq/63/f2fbf06c8d02f4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/08d044920b38e1 b/tmp/cache/bootsnap/compile-cache-iseq/64/08d044920b38e1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/6f212f4065e952 b/tmp/cache/bootsnap/compile-cache-iseq/64/6f212f4065e952
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/6ffeb81eaf6538 b/tmp/cache/bootsnap/compile-cache-iseq/64/6ffeb81eaf6538
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/8abb1309ee3627 b/tmp/cache/bootsnap/compile-cache-iseq/64/8abb1309ee3627
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/cfb849f54ed4dc b/tmp/cache/bootsnap/compile-cache-iseq/64/cfb849f54ed4dc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/64/fe136a06cde9a7 b/tmp/cache/bootsnap/compile-cache-iseq/64/fe136a06cde9a7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/0251964de2df7e b/tmp/cache/bootsnap/compile-cache-iseq/65/0251964de2df7e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/30731c02ae385d b/tmp/cache/bootsnap/compile-cache-iseq/65/30731c02ae385d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/3d2558bec1e778 b/tmp/cache/bootsnap/compile-cache-iseq/65/3d2558bec1e778
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/5f0ce32fb66bd2 b/tmp/cache/bootsnap/compile-cache-iseq/65/5f0ce32fb66bd2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/705b4c44d18b74 b/tmp/cache/bootsnap/compile-cache-iseq/65/705b4c44d18b74
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/7aaeeb60705531 b/tmp/cache/bootsnap/compile-cache-iseq/65/7aaeeb60705531
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/65/815300d93ba793 b/tmp/cache/bootsnap/compile-cache-iseq/65/815300d93ba793
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/66/2cb88bf175e3c7 b/tmp/cache/bootsnap/compile-cache-iseq/66/2cb88bf175e3c7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/66/45309287535584 b/tmp/cache/bootsnap/compile-cache-iseq/66/45309287535584
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/66/7fef77dbfc876f b/tmp/cache/bootsnap/compile-cache-iseq/66/7fef77dbfc876f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/66/f70ed18810c55f b/tmp/cache/bootsnap/compile-cache-iseq/66/f70ed18810c55f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/1b813cccfef491 b/tmp/cache/bootsnap/compile-cache-iseq/67/1b813cccfef491
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/20ce79e4ed4d35 b/tmp/cache/bootsnap/compile-cache-iseq/67/20ce79e4ed4d35
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/3d55e12b1a8b4b b/tmp/cache/bootsnap/compile-cache-iseq/67/3d55e12b1a8b4b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/a680c71d13d6e0 b/tmp/cache/bootsnap/compile-cache-iseq/67/a680c71d13d6e0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/d6e11a224e9f6d b/tmp/cache/bootsnap/compile-cache-iseq/67/d6e11a224e9f6d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/d7e590ad2af166 b/tmp/cache/bootsnap/compile-cache-iseq/67/d7e590ad2af166
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/67/d93e4cb607253b b/tmp/cache/bootsnap/compile-cache-iseq/67/d93e4cb607253b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/057e6a9c860dc0 b/tmp/cache/bootsnap/compile-cache-iseq/68/057e6a9c860dc0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/0b4e1629e574b1 b/tmp/cache/bootsnap/compile-cache-iseq/68/0b4e1629e574b1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/4cf1f6f133570a b/tmp/cache/bootsnap/compile-cache-iseq/68/4cf1f6f133570a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/5471a5ac1fd07c b/tmp/cache/bootsnap/compile-cache-iseq/68/5471a5ac1fd07c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/621bcc495f2a67 b/tmp/cache/bootsnap/compile-cache-iseq/68/621bcc495f2a67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/726b4a8edf5335 b/tmp/cache/bootsnap/compile-cache-iseq/68/726b4a8edf5335
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/68/7f5b3dc716a3f6 b/tmp/cache/bootsnap/compile-cache-iseq/68/7f5b3dc716a3f6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/0b5a765d4a2617 b/tmp/cache/bootsnap/compile-cache-iseq/69/0b5a765d4a2617
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/140d340a7b09b8 b/tmp/cache/bootsnap/compile-cache-iseq/69/140d340a7b09b8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/d3e6d1cbba9636 b/tmp/cache/bootsnap/compile-cache-iseq/69/d3e6d1cbba9636
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/e0ec30ff404b87 b/tmp/cache/bootsnap/compile-cache-iseq/69/e0ec30ff404b87
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/e73ba296b3b7f7 b/tmp/cache/bootsnap/compile-cache-iseq/69/e73ba296b3b7f7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/69/fe30975eb6b60f b/tmp/cache/bootsnap/compile-cache-iseq/69/fe30975eb6b60f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6a/04bf5b57b34742 b/tmp/cache/bootsnap/compile-cache-iseq/6a/04bf5b57b34742
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6a/05092e74344c37 b/tmp/cache/bootsnap/compile-cache-iseq/6a/05092e74344c37
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6a/2f0c2812d8896f b/tmp/cache/bootsnap/compile-cache-iseq/6a/2f0c2812d8896f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6a/5565d8ee06d461 b/tmp/cache/bootsnap/compile-cache-iseq/6a/5565d8ee06d461
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6a/92832cd6ee6b11 b/tmp/cache/bootsnap/compile-cache-iseq/6a/92832cd6ee6b11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/0c2024a356669f b/tmp/cache/bootsnap/compile-cache-iseq/6b/0c2024a356669f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/1b67956961f2a6 b/tmp/cache/bootsnap/compile-cache-iseq/6b/1b67956961f2a6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/5da895ffcab6e4 b/tmp/cache/bootsnap/compile-cache-iseq/6b/5da895ffcab6e4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/9daa9f2a62e3dc b/tmp/cache/bootsnap/compile-cache-iseq/6b/9daa9f2a62e3dc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/c7c0f52e6b29c5 b/tmp/cache/bootsnap/compile-cache-iseq/6b/c7c0f52e6b29c5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/e46bb99ec91196 b/tmp/cache/bootsnap/compile-cache-iseq/6b/e46bb99ec91196
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6b/f7a17ad2736304 b/tmp/cache/bootsnap/compile-cache-iseq/6b/f7a17ad2736304
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6c/11ae5d7c1dcf28 b/tmp/cache/bootsnap/compile-cache-iseq/6c/11ae5d7c1dcf28
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6c/f3bf2f2a05cba1 b/tmp/cache/bootsnap/compile-cache-iseq/6c/f3bf2f2a05cba1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6d/042c32cbb60c80 b/tmp/cache/bootsnap/compile-cache-iseq/6d/042c32cbb60c80
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6d/36bea6bbf0cfb6 b/tmp/cache/bootsnap/compile-cache-iseq/6d/36bea6bbf0cfb6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6d/52ee1b4af5063a b/tmp/cache/bootsnap/compile-cache-iseq/6d/52ee1b4af5063a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6d/77c4fe8273fdf9 b/tmp/cache/bootsnap/compile-cache-iseq/6d/77c4fe8273fdf9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6d/9730b2d8850df9 b/tmp/cache/bootsnap/compile-cache-iseq/6d/9730b2d8850df9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/14f25d87546134 b/tmp/cache/bootsnap/compile-cache-iseq/6e/14f25d87546134
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/4a45b25f576f5c b/tmp/cache/bootsnap/compile-cache-iseq/6e/4a45b25f576f5c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/5d0fc874a4f17d b/tmp/cache/bootsnap/compile-cache-iseq/6e/5d0fc874a4f17d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/8fea662bbc0130 b/tmp/cache/bootsnap/compile-cache-iseq/6e/8fea662bbc0130
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/a7622cdbb00cd1 b/tmp/cache/bootsnap/compile-cache-iseq/6e/a7622cdbb00cd1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/b8797c5af25c7b b/tmp/cache/bootsnap/compile-cache-iseq/6e/b8797c5af25c7b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6e/e60fdc5298ab04 b/tmp/cache/bootsnap/compile-cache-iseq/6e/e60fdc5298ab04
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/085e25ae3317bf b/tmp/cache/bootsnap/compile-cache-iseq/6f/085e25ae3317bf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/099debd5db96fe b/tmp/cache/bootsnap/compile-cache-iseq/6f/099debd5db96fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/173ac6c7235e18 b/tmp/cache/bootsnap/compile-cache-iseq/6f/173ac6c7235e18
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/32237caefa1dea b/tmp/cache/bootsnap/compile-cache-iseq/6f/32237caefa1dea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/32a277b38eeb08 b/tmp/cache/bootsnap/compile-cache-iseq/6f/32a277b38eeb08
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/44eade7fa52c11 b/tmp/cache/bootsnap/compile-cache-iseq/6f/44eade7fa52c11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/6f/45a55403ac0634 b/tmp/cache/bootsnap/compile-cache-iseq/6f/45a55403ac0634
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/051bb985e271c2 b/tmp/cache/bootsnap/compile-cache-iseq/70/051bb985e271c2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/73a75949e46f91 b/tmp/cache/bootsnap/compile-cache-iseq/70/73a75949e46f91
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/804e1772e84db7 b/tmp/cache/bootsnap/compile-cache-iseq/70/804e1772e84db7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/879362957cb8f1 b/tmp/cache/bootsnap/compile-cache-iseq/70/879362957cb8f1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/d2a783ab0dd8d3 b/tmp/cache/bootsnap/compile-cache-iseq/70/d2a783ab0dd8d3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/70/fb3d88b00ddbd3 b/tmp/cache/bootsnap/compile-cache-iseq/70/fb3d88b00ddbd3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/623ccc8683dcae b/tmp/cache/bootsnap/compile-cache-iseq/71/623ccc8683dcae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/9d7f7a698f327d b/tmp/cache/bootsnap/compile-cache-iseq/71/9d7f7a698f327d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/b8a99b5e8768e9 b/tmp/cache/bootsnap/compile-cache-iseq/71/b8a99b5e8768e9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/d7aee00b4b054a b/tmp/cache/bootsnap/compile-cache-iseq/71/d7aee00b4b054a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/db656abb85d0b5 b/tmp/cache/bootsnap/compile-cache-iseq/71/db656abb85d0b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/f4def782caf943 b/tmp/cache/bootsnap/compile-cache-iseq/71/f4def782caf943
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/71/fd58cc06feeac4 b/tmp/cache/bootsnap/compile-cache-iseq/71/fd58cc06feeac4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/021c6f2d7e342c b/tmp/cache/bootsnap/compile-cache-iseq/72/021c6f2d7e342c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/35687354c935db b/tmp/cache/bootsnap/compile-cache-iseq/72/35687354c935db
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/3f4562365b1a78 b/tmp/cache/bootsnap/compile-cache-iseq/72/3f4562365b1a78
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/4787665bde52a0 b/tmp/cache/bootsnap/compile-cache-iseq/72/4787665bde52a0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/62a5573234dc18 b/tmp/cache/bootsnap/compile-cache-iseq/72/62a5573234dc18
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/8d342a5873267f b/tmp/cache/bootsnap/compile-cache-iseq/72/8d342a5873267f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/9e65e89c0054ff b/tmp/cache/bootsnap/compile-cache-iseq/72/9e65e89c0054ff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/72/ceebe808691243 b/tmp/cache/bootsnap/compile-cache-iseq/72/ceebe808691243
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/184cc9d29f708b b/tmp/cache/bootsnap/compile-cache-iseq/73/184cc9d29f708b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/72f5b206ca1a9c b/tmp/cache/bootsnap/compile-cache-iseq/73/72f5b206ca1a9c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/89f57628172a36 b/tmp/cache/bootsnap/compile-cache-iseq/73/89f57628172a36
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/8e26ec4c151d59 b/tmp/cache/bootsnap/compile-cache-iseq/73/8e26ec4c151d59
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/96ca5e1ee118e0 b/tmp/cache/bootsnap/compile-cache-iseq/73/96ca5e1ee118e0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/bc33eb4a96a628 b/tmp/cache/bootsnap/compile-cache-iseq/73/bc33eb4a96a628
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/c2f6ab9198705e b/tmp/cache/bootsnap/compile-cache-iseq/73/c2f6ab9198705e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/dfca7024259eed b/tmp/cache/bootsnap/compile-cache-iseq/73/dfca7024259eed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/ed8902d020d43a b/tmp/cache/bootsnap/compile-cache-iseq/73/ed8902d020d43a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/73/fb199343e0eed1 b/tmp/cache/bootsnap/compile-cache-iseq/73/fb199343e0eed1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/0eb31728ad8881 b/tmp/cache/bootsnap/compile-cache-iseq/74/0eb31728ad8881
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/1250533a99f8b6 b/tmp/cache/bootsnap/compile-cache-iseq/74/1250533a99f8b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/1a42ce39833d09 b/tmp/cache/bootsnap/compile-cache-iseq/74/1a42ce39833d09
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/23c22d31d4a4a8 b/tmp/cache/bootsnap/compile-cache-iseq/74/23c22d31d4a4a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/536e5d35a66354 b/tmp/cache/bootsnap/compile-cache-iseq/74/536e5d35a66354
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/608775946bef22 b/tmp/cache/bootsnap/compile-cache-iseq/74/608775946bef22
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/6da6d2418b1a9d b/tmp/cache/bootsnap/compile-cache-iseq/74/6da6d2418b1a9d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/90471c8e5222bb b/tmp/cache/bootsnap/compile-cache-iseq/74/90471c8e5222bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/b55624d4731f6e b/tmp/cache/bootsnap/compile-cache-iseq/74/b55624d4731f6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/e99bced4b51c7e b/tmp/cache/bootsnap/compile-cache-iseq/74/e99bced4b51c7e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/f2496f922d6d9a b/tmp/cache/bootsnap/compile-cache-iseq/74/f2496f922d6d9a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/74/f3796862f219a1 b/tmp/cache/bootsnap/compile-cache-iseq/74/f3796862f219a1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/27c47fc285932d b/tmp/cache/bootsnap/compile-cache-iseq/75/27c47fc285932d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/7e2906b5d43430 b/tmp/cache/bootsnap/compile-cache-iseq/75/7e2906b5d43430
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/847d256ec8c5d8 b/tmp/cache/bootsnap/compile-cache-iseq/75/847d256ec8c5d8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/93fc2bb881024f b/tmp/cache/bootsnap/compile-cache-iseq/75/93fc2bb881024f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/c3f23966720be4 b/tmp/cache/bootsnap/compile-cache-iseq/75/c3f23966720be4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/cdfad129926911 b/tmp/cache/bootsnap/compile-cache-iseq/75/cdfad129926911
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/75/ef8f5a3370df4c b/tmp/cache/bootsnap/compile-cache-iseq/75/ef8f5a3370df4c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/31a216f0dbd8b9 b/tmp/cache/bootsnap/compile-cache-iseq/76/31a216f0dbd8b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/66fe57862b83cc b/tmp/cache/bootsnap/compile-cache-iseq/76/66fe57862b83cc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/89776089fa1a16 b/tmp/cache/bootsnap/compile-cache-iseq/76/89776089fa1a16
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/9f1e20ff72d1fc b/tmp/cache/bootsnap/compile-cache-iseq/76/9f1e20ff72d1fc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/a0d065e131ac61 b/tmp/cache/bootsnap/compile-cache-iseq/76/a0d065e131ac61
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/76/e4b140bb9a2ac8 b/tmp/cache/bootsnap/compile-cache-iseq/76/e4b140bb9a2ac8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/0788eaabffa644 b/tmp/cache/bootsnap/compile-cache-iseq/77/0788eaabffa644
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/1db2415670b131 b/tmp/cache/bootsnap/compile-cache-iseq/77/1db2415670b131
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/298e6c2373a650 b/tmp/cache/bootsnap/compile-cache-iseq/77/298e6c2373a650
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/2bfa9151817030 b/tmp/cache/bootsnap/compile-cache-iseq/77/2bfa9151817030
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/34275ba4e68715 b/tmp/cache/bootsnap/compile-cache-iseq/77/34275ba4e68715
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/418dd1a905454e b/tmp/cache/bootsnap/compile-cache-iseq/77/418dd1a905454e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/4608920eb801c0 b/tmp/cache/bootsnap/compile-cache-iseq/77/4608920eb801c0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/9146c05eeccf47 b/tmp/cache/bootsnap/compile-cache-iseq/77/9146c05eeccf47
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/9253cb5cb048be b/tmp/cache/bootsnap/compile-cache-iseq/77/9253cb5cb048be
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/a5fbab8f45ed80 b/tmp/cache/bootsnap/compile-cache-iseq/77/a5fbab8f45ed80
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/c468aa03cfb98e b/tmp/cache/bootsnap/compile-cache-iseq/77/c468aa03cfb98e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/77/d5d385937f695f b/tmp/cache/bootsnap/compile-cache-iseq/77/d5d385937f695f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/03587a184a44cb b/tmp/cache/bootsnap/compile-cache-iseq/78/03587a184a44cb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/231c3496857337 b/tmp/cache/bootsnap/compile-cache-iseq/78/231c3496857337
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/7f154ed5d14abe b/tmp/cache/bootsnap/compile-cache-iseq/78/7f154ed5d14abe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/e42c5e0f95139e b/tmp/cache/bootsnap/compile-cache-iseq/78/e42c5e0f95139e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/e6c01513f25179 b/tmp/cache/bootsnap/compile-cache-iseq/78/e6c01513f25179
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/e6efd97248eefe b/tmp/cache/bootsnap/compile-cache-iseq/78/e6efd97248eefe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/f593983f5b675f b/tmp/cache/bootsnap/compile-cache-iseq/78/f593983f5b675f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/78/f87d5c2ab6af51 b/tmp/cache/bootsnap/compile-cache-iseq/78/f87d5c2ab6af51
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/79/869b876e3012b2 b/tmp/cache/bootsnap/compile-cache-iseq/79/869b876e3012b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/79/b7239fd1945e3b b/tmp/cache/bootsnap/compile-cache-iseq/79/b7239fd1945e3b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/79/c7dc66c470bb88 b/tmp/cache/bootsnap/compile-cache-iseq/79/c7dc66c470bb88
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/79/eaed4f286e5a4c b/tmp/cache/bootsnap/compile-cache-iseq/79/eaed4f286e5a4c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/79/fffbf6a08b35ff b/tmp/cache/bootsnap/compile-cache-iseq/79/fffbf6a08b35ff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7a/7c2c1cde027d0e b/tmp/cache/bootsnap/compile-cache-iseq/7a/7c2c1cde027d0e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7a/a80fc511674776 b/tmp/cache/bootsnap/compile-cache-iseq/7a/a80fc511674776
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7a/d9770beffaf284 b/tmp/cache/bootsnap/compile-cache-iseq/7a/d9770beffaf284
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7b/1bbf9b1bca8ad3 b/tmp/cache/bootsnap/compile-cache-iseq/7b/1bbf9b1bca8ad3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7b/702685a7f09412 b/tmp/cache/bootsnap/compile-cache-iseq/7b/702685a7f09412
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7b/95dc680673b5eb b/tmp/cache/bootsnap/compile-cache-iseq/7b/95dc680673b5eb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7b/a5a3d8f027875f b/tmp/cache/bootsnap/compile-cache-iseq/7b/a5a3d8f027875f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7b/f107cb4c64222b b/tmp/cache/bootsnap/compile-cache-iseq/7b/f107cb4c64222b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7c/1829fcf95c90b0 b/tmp/cache/bootsnap/compile-cache-iseq/7c/1829fcf95c90b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7c/338a0f3a93c1ce b/tmp/cache/bootsnap/compile-cache-iseq/7c/338a0f3a93c1ce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7c/506474b6d298ea b/tmp/cache/bootsnap/compile-cache-iseq/7c/506474b6d298ea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/1eaeebc74bc9cf b/tmp/cache/bootsnap/compile-cache-iseq/7d/1eaeebc74bc9cf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/5858fb7a885f4d b/tmp/cache/bootsnap/compile-cache-iseq/7d/5858fb7a885f4d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/9ed67bc1ed924b b/tmp/cache/bootsnap/compile-cache-iseq/7d/9ed67bc1ed924b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/ad3407cad988d6 b/tmp/cache/bootsnap/compile-cache-iseq/7d/ad3407cad988d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/d778a8d716772f b/tmp/cache/bootsnap/compile-cache-iseq/7d/d778a8d716772f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7d/e548771bc32c7d b/tmp/cache/bootsnap/compile-cache-iseq/7d/e548771bc32c7d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/03c58260683ae2 b/tmp/cache/bootsnap/compile-cache-iseq/7e/03c58260683ae2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/0cdc5ad9892943 b/tmp/cache/bootsnap/compile-cache-iseq/7e/0cdc5ad9892943
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/26c9e4c2072634 b/tmp/cache/bootsnap/compile-cache-iseq/7e/26c9e4c2072634
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/3cc752954b816a b/tmp/cache/bootsnap/compile-cache-iseq/7e/3cc752954b816a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/62fe1ca7da9d17 b/tmp/cache/bootsnap/compile-cache-iseq/7e/62fe1ca7da9d17
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/754a5ce9a5682e b/tmp/cache/bootsnap/compile-cache-iseq/7e/754a5ce9a5682e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/b5bf348493dc55 b/tmp/cache/bootsnap/compile-cache-iseq/7e/b5bf348493dc55
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/c1c4217caae2c9 b/tmp/cache/bootsnap/compile-cache-iseq/7e/c1c4217caae2c9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/eaa2f8db1c192f b/tmp/cache/bootsnap/compile-cache-iseq/7e/eaa2f8db1c192f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7e/eb6a54947e1ce4 b/tmp/cache/bootsnap/compile-cache-iseq/7e/eb6a54947e1ce4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/06abc7a2e7ada8 b/tmp/cache/bootsnap/compile-cache-iseq/7f/06abc7a2e7ada8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/164b04e8d90846 b/tmp/cache/bootsnap/compile-cache-iseq/7f/164b04e8d90846
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/1d933974aaeab9 b/tmp/cache/bootsnap/compile-cache-iseq/7f/1d933974aaeab9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/37e2021b98f614 b/tmp/cache/bootsnap/compile-cache-iseq/7f/37e2021b98f614
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/5103cfc92d0225 b/tmp/cache/bootsnap/compile-cache-iseq/7f/5103cfc92d0225
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/57f41c68601ddd b/tmp/cache/bootsnap/compile-cache-iseq/7f/57f41c68601ddd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/5da79b0c8fb304 b/tmp/cache/bootsnap/compile-cache-iseq/7f/5da79b0c8fb304
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/5f6373350c8043 b/tmp/cache/bootsnap/compile-cache-iseq/7f/5f6373350c8043
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/754b8701145c63 b/tmp/cache/bootsnap/compile-cache-iseq/7f/754b8701145c63
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/787ed48e7b1d15 b/tmp/cache/bootsnap/compile-cache-iseq/7f/787ed48e7b1d15
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/af7b3e98bf9ace b/tmp/cache/bootsnap/compile-cache-iseq/7f/af7b3e98bf9ace
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/e065c178072485 b/tmp/cache/bootsnap/compile-cache-iseq/7f/e065c178072485
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/7f/f9002f1d52160e b/tmp/cache/bootsnap/compile-cache-iseq/7f/f9002f1d52160e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/0d34a758ce6318 b/tmp/cache/bootsnap/compile-cache-iseq/80/0d34a758ce6318
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/561a6e01feefce b/tmp/cache/bootsnap/compile-cache-iseq/80/561a6e01feefce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/785898ecb4cfa5 b/tmp/cache/bootsnap/compile-cache-iseq/80/785898ecb4cfa5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/7f03ac0e57db39 b/tmp/cache/bootsnap/compile-cache-iseq/80/7f03ac0e57db39
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/a737edc7f5250a b/tmp/cache/bootsnap/compile-cache-iseq/80/a737edc7f5250a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/d2001df99b20c8 b/tmp/cache/bootsnap/compile-cache-iseq/80/d2001df99b20c8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/80/eab66c14582804 b/tmp/cache/bootsnap/compile-cache-iseq/80/eab66c14582804
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/81/2b485b00cf2f6e b/tmp/cache/bootsnap/compile-cache-iseq/81/2b485b00cf2f6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/81/3c88dedd28951d b/tmp/cache/bootsnap/compile-cache-iseq/81/3c88dedd28951d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/81/495eac98259d9e b/tmp/cache/bootsnap/compile-cache-iseq/81/495eac98259d9e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/81/add08cb406224d b/tmp/cache/bootsnap/compile-cache-iseq/81/add08cb406224d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/12c48ae7f8f0f2 b/tmp/cache/bootsnap/compile-cache-iseq/82/12c48ae7f8f0f2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/295fee0c805518 b/tmp/cache/bootsnap/compile-cache-iseq/82/295fee0c805518
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/2f7f89d46d0424 b/tmp/cache/bootsnap/compile-cache-iseq/82/2f7f89d46d0424
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/3537e0f48946f6 b/tmp/cache/bootsnap/compile-cache-iseq/82/3537e0f48946f6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/812b61ef475bbf b/tmp/cache/bootsnap/compile-cache-iseq/82/812b61ef475bbf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/8cfc9bbbe62249 b/tmp/cache/bootsnap/compile-cache-iseq/82/8cfc9bbbe62249
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/966f6216b98021 b/tmp/cache/bootsnap/compile-cache-iseq/82/966f6216b98021
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/a741684a12c900 b/tmp/cache/bootsnap/compile-cache-iseq/82/a741684a12c900
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/ba1add8d36aca3 b/tmp/cache/bootsnap/compile-cache-iseq/82/ba1add8d36aca3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/be9d2b2956256a b/tmp/cache/bootsnap/compile-cache-iseq/82/be9d2b2956256a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/e5d9feb86fffde b/tmp/cache/bootsnap/compile-cache-iseq/82/e5d9feb86fffde
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/82/e73d5f7e0d5f72 b/tmp/cache/bootsnap/compile-cache-iseq/82/e73d5f7e0d5f72
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/40249abf1efdb7 b/tmp/cache/bootsnap/compile-cache-iseq/83/40249abf1efdb7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/641dc89dc21dfd b/tmp/cache/bootsnap/compile-cache-iseq/83/641dc89dc21dfd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/7d7971f0a150ea b/tmp/cache/bootsnap/compile-cache-iseq/83/7d7971f0a150ea
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/c374c5a3d7dc67 b/tmp/cache/bootsnap/compile-cache-iseq/83/c374c5a3d7dc67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/e2a37f542f378e b/tmp/cache/bootsnap/compile-cache-iseq/83/e2a37f542f378e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/e77d47e1573638 b/tmp/cache/bootsnap/compile-cache-iseq/83/e77d47e1573638
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/efe4ce14603749 b/tmp/cache/bootsnap/compile-cache-iseq/83/efe4ce14603749
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/83/f9e836669ed5b3 b/tmp/cache/bootsnap/compile-cache-iseq/83/f9e836669ed5b3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/4e552d80a42a9a b/tmp/cache/bootsnap/compile-cache-iseq/84/4e552d80a42a9a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/54ca460acd02de b/tmp/cache/bootsnap/compile-cache-iseq/84/54ca460acd02de
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/7b259070ba7c06 b/tmp/cache/bootsnap/compile-cache-iseq/84/7b259070ba7c06
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/d4537923339f16 b/tmp/cache/bootsnap/compile-cache-iseq/84/d4537923339f16
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/e0a11a291d942d b/tmp/cache/bootsnap/compile-cache-iseq/84/e0a11a291d942d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/84/f9c624340156e6 b/tmp/cache/bootsnap/compile-cache-iseq/84/f9c624340156e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/2b1ea9adfb6da8 b/tmp/cache/bootsnap/compile-cache-iseq/85/2b1ea9adfb6da8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/30c9496d67b473 b/tmp/cache/bootsnap/compile-cache-iseq/85/30c9496d67b473
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/54edef0f9fb7ff b/tmp/cache/bootsnap/compile-cache-iseq/85/54edef0f9fb7ff
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/ce9de103d6cc6d b/tmp/cache/bootsnap/compile-cache-iseq/85/ce9de103d6cc6d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/dc3fafe830693a b/tmp/cache/bootsnap/compile-cache-iseq/85/dc3fafe830693a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/e93db2a8f1624b b/tmp/cache/bootsnap/compile-cache-iseq/85/e93db2a8f1624b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/f42055afa4fb7a b/tmp/cache/bootsnap/compile-cache-iseq/85/f42055afa4fb7a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/85/ff7dd6207cbd53 b/tmp/cache/bootsnap/compile-cache-iseq/85/ff7dd6207cbd53
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/39b0c405957934 b/tmp/cache/bootsnap/compile-cache-iseq/86/39b0c405957934
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/52dcede517d206 b/tmp/cache/bootsnap/compile-cache-iseq/86/52dcede517d206
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/60074018328437 b/tmp/cache/bootsnap/compile-cache-iseq/86/60074018328437
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/702009d2c08827 b/tmp/cache/bootsnap/compile-cache-iseq/86/702009d2c08827
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/900660d32b9454 b/tmp/cache/bootsnap/compile-cache-iseq/86/900660d32b9454
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/86/ddc2d0e1df0452 b/tmp/cache/bootsnap/compile-cache-iseq/86/ddc2d0e1df0452
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/87/85d3aa2faf8575 b/tmp/cache/bootsnap/compile-cache-iseq/87/85d3aa2faf8575
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/87/8fe46e034890e3 b/tmp/cache/bootsnap/compile-cache-iseq/87/8fe46e034890e3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/87/a4674a8e973613 b/tmp/cache/bootsnap/compile-cache-iseq/87/a4674a8e973613
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/87/f22992905df2c4 b/tmp/cache/bootsnap/compile-cache-iseq/87/f22992905df2c4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/88/30c705215a78fd b/tmp/cache/bootsnap/compile-cache-iseq/88/30c705215a78fd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/88/3e21700fc4b400 b/tmp/cache/bootsnap/compile-cache-iseq/88/3e21700fc4b400
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/88/77dd503f490801 b/tmp/cache/bootsnap/compile-cache-iseq/88/77dd503f490801
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/88/f3d8675d576541 b/tmp/cache/bootsnap/compile-cache-iseq/88/f3d8675d576541
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/88/f9e5361c6e8d5e b/tmp/cache/bootsnap/compile-cache-iseq/88/f9e5361c6e8d5e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/43cb2597972fe5 b/tmp/cache/bootsnap/compile-cache-iseq/89/43cb2597972fe5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/8cb61adaf47c43 b/tmp/cache/bootsnap/compile-cache-iseq/89/8cb61adaf47c43
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/b31f75f6068bc1 b/tmp/cache/bootsnap/compile-cache-iseq/89/b31f75f6068bc1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/ee1d4e0fc32a0a b/tmp/cache/bootsnap/compile-cache-iseq/89/ee1d4e0fc32a0a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/f73d23b3d666c5 b/tmp/cache/bootsnap/compile-cache-iseq/89/f73d23b3d666c5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/89/fdd39045fc5221 b/tmp/cache/bootsnap/compile-cache-iseq/89/fdd39045fc5221
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8a/001d1f9a33c9fe b/tmp/cache/bootsnap/compile-cache-iseq/8a/001d1f9a33c9fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8a/70a14cf3cf5e1b b/tmp/cache/bootsnap/compile-cache-iseq/8a/70a14cf3cf5e1b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/0122caa0a51c5f b/tmp/cache/bootsnap/compile-cache-iseq/8b/0122caa0a51c5f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/1542fe2f37619e b/tmp/cache/bootsnap/compile-cache-iseq/8b/1542fe2f37619e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/21a460336168d0 b/tmp/cache/bootsnap/compile-cache-iseq/8b/21a460336168d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/5d84bef1328a79 b/tmp/cache/bootsnap/compile-cache-iseq/8b/5d84bef1328a79
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/d715fd1a60397b b/tmp/cache/bootsnap/compile-cache-iseq/8b/d715fd1a60397b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/e0336686782e28 b/tmp/cache/bootsnap/compile-cache-iseq/8b/e0336686782e28
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8b/ffa0a8ec191018 b/tmp/cache/bootsnap/compile-cache-iseq/8b/ffa0a8ec191018
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/1b49f1356842b6 b/tmp/cache/bootsnap/compile-cache-iseq/8c/1b49f1356842b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/27cd2a5e9cef7b b/tmp/cache/bootsnap/compile-cache-iseq/8c/27cd2a5e9cef7b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/2c1086ebc51fdc b/tmp/cache/bootsnap/compile-cache-iseq/8c/2c1086ebc51fdc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/674600f3c0fccf b/tmp/cache/bootsnap/compile-cache-iseq/8c/674600f3c0fccf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/720c45b27831c3 b/tmp/cache/bootsnap/compile-cache-iseq/8c/720c45b27831c3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/962704c2814766 b/tmp/cache/bootsnap/compile-cache-iseq/8c/962704c2814766
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/c32aa35bf3e4f7 b/tmp/cache/bootsnap/compile-cache-iseq/8c/c32aa35bf3e4f7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/e93660259b5d12 b/tmp/cache/bootsnap/compile-cache-iseq/8c/e93660259b5d12
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8c/f0fd495911adec b/tmp/cache/bootsnap/compile-cache-iseq/8c/f0fd495911adec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8d/5d7e6801aa67a9 b/tmp/cache/bootsnap/compile-cache-iseq/8d/5d7e6801aa67a9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8d/6b9ba25ebaaac2 b/tmp/cache/bootsnap/compile-cache-iseq/8d/6b9ba25ebaaac2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8d/8670c37e9c50f4 b/tmp/cache/bootsnap/compile-cache-iseq/8d/8670c37e9c50f4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8d/ea64fc5a2ab027 b/tmp/cache/bootsnap/compile-cache-iseq/8d/ea64fc5a2ab027
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/05b53232ef617d b/tmp/cache/bootsnap/compile-cache-iseq/8e/05b53232ef617d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/3fd512c8729be9 b/tmp/cache/bootsnap/compile-cache-iseq/8e/3fd512c8729be9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/475e9991f1af67 b/tmp/cache/bootsnap/compile-cache-iseq/8e/475e9991f1af67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/4c3c5d0f6fb9d2 b/tmp/cache/bootsnap/compile-cache-iseq/8e/4c3c5d0f6fb9d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/5bc359855e9fb2 b/tmp/cache/bootsnap/compile-cache-iseq/8e/5bc359855e9fb2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/6f2f83dad0439a b/tmp/cache/bootsnap/compile-cache-iseq/8e/6f2f83dad0439a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/76dd07389c0ce4 b/tmp/cache/bootsnap/compile-cache-iseq/8e/76dd07389c0ce4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/9042444410794a b/tmp/cache/bootsnap/compile-cache-iseq/8e/9042444410794a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/ae857c2b570e02 b/tmp/cache/bootsnap/compile-cache-iseq/8e/ae857c2b570e02
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/c9d153fa40edfc b/tmp/cache/bootsnap/compile-cache-iseq/8e/c9d153fa40edfc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/ee7170752f82bb b/tmp/cache/bootsnap/compile-cache-iseq/8e/ee7170752f82bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8e/f4fd55ac7f124c b/tmp/cache/bootsnap/compile-cache-iseq/8e/f4fd55ac7f124c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8f/a94729b8b83e9f b/tmp/cache/bootsnap/compile-cache-iseq/8f/a94729b8b83e9f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/8f/c1b734c44779b9 b/tmp/cache/bootsnap/compile-cache-iseq/8f/c1b734c44779b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/120a658db2f503 b/tmp/cache/bootsnap/compile-cache-iseq/90/120a658db2f503
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/17c9a614f0d301 b/tmp/cache/bootsnap/compile-cache-iseq/90/17c9a614f0d301
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/1b78bbb9ab1538 b/tmp/cache/bootsnap/compile-cache-iseq/90/1b78bbb9ab1538
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/4062b78fa51120 b/tmp/cache/bootsnap/compile-cache-iseq/90/4062b78fa51120
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/74011f62f1e4ca b/tmp/cache/bootsnap/compile-cache-iseq/90/74011f62f1e4ca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/8363a1b233de78 b/tmp/cache/bootsnap/compile-cache-iseq/90/8363a1b233de78
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/a9ce7c5d546acd b/tmp/cache/bootsnap/compile-cache-iseq/90/a9ce7c5d546acd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/b95923201ec8ba b/tmp/cache/bootsnap/compile-cache-iseq/90/b95923201ec8ba
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/c730a22a93bb48 b/tmp/cache/bootsnap/compile-cache-iseq/90/c730a22a93bb48
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/eee107c3ffc387 b/tmp/cache/bootsnap/compile-cache-iseq/90/eee107c3ffc387
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/90/f7c2ed48302110 b/tmp/cache/bootsnap/compile-cache-iseq/90/f7c2ed48302110
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/91/0153aec0efb16b b/tmp/cache/bootsnap/compile-cache-iseq/91/0153aec0efb16b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/91/0fa51418744300 b/tmp/cache/bootsnap/compile-cache-iseq/91/0fa51418744300
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/91/c9e6df59237c67 b/tmp/cache/bootsnap/compile-cache-iseq/91/c9e6df59237c67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/91/cd92850b83b8f0 b/tmp/cache/bootsnap/compile-cache-iseq/91/cd92850b83b8f0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/91/d089d9871c2ed8 b/tmp/cache/bootsnap/compile-cache-iseq/91/d089d9871c2ed8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/92/0e1aba20d5d416 b/tmp/cache/bootsnap/compile-cache-iseq/92/0e1aba20d5d416
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/92/11f7a4342b756d b/tmp/cache/bootsnap/compile-cache-iseq/92/11f7a4342b756d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/93/18ec79efd09a52 b/tmp/cache/bootsnap/compile-cache-iseq/93/18ec79efd09a52
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/93/45c493b88a8a6c b/tmp/cache/bootsnap/compile-cache-iseq/93/45c493b88a8a6c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/93/a1dc605ce51a59 b/tmp/cache/bootsnap/compile-cache-iseq/93/a1dc605ce51a59
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/93/dfb3f8e733e976 b/tmp/cache/bootsnap/compile-cache-iseq/93/dfb3f8e733e976
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/016bd2c5286040 b/tmp/cache/bootsnap/compile-cache-iseq/94/016bd2c5286040
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/0185cff415e918 b/tmp/cache/bootsnap/compile-cache-iseq/94/0185cff415e918
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/2d1c5f22d79688 b/tmp/cache/bootsnap/compile-cache-iseq/94/2d1c5f22d79688
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/6ff6ab54b03594 b/tmp/cache/bootsnap/compile-cache-iseq/94/6ff6ab54b03594
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/7bc75d969052bc b/tmp/cache/bootsnap/compile-cache-iseq/94/7bc75d969052bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/93034efa641574 b/tmp/cache/bootsnap/compile-cache-iseq/94/93034efa641574
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/b95d42f1ff06e8 b/tmp/cache/bootsnap/compile-cache-iseq/94/b95d42f1ff06e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/cc93a13dd3f945 b/tmp/cache/bootsnap/compile-cache-iseq/94/cc93a13dd3f945
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/d036b5baa939d6 b/tmp/cache/bootsnap/compile-cache-iseq/94/d036b5baa939d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/94/f757889ea477da b/tmp/cache/bootsnap/compile-cache-iseq/94/f757889ea477da
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/0af81996560799 b/tmp/cache/bootsnap/compile-cache-iseq/95/0af81996560799
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/142907ce4881a6 b/tmp/cache/bootsnap/compile-cache-iseq/95/142907ce4881a6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/30212119b9661d b/tmp/cache/bootsnap/compile-cache-iseq/95/30212119b9661d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/8acfea05562a1b b/tmp/cache/bootsnap/compile-cache-iseq/95/8acfea05562a1b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/97eba75d177112 b/tmp/cache/bootsnap/compile-cache-iseq/95/97eba75d177112
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/c2040c88c3c098 b/tmp/cache/bootsnap/compile-cache-iseq/95/c2040c88c3c098
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/95/cc913cad4990e9 b/tmp/cache/bootsnap/compile-cache-iseq/95/cc913cad4990e9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/96/1423b21c8b041e b/tmp/cache/bootsnap/compile-cache-iseq/96/1423b21c8b041e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/96/30b13ea6c4c7e2 b/tmp/cache/bootsnap/compile-cache-iseq/96/30b13ea6c4c7e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/96/5a23a22704ebed b/tmp/cache/bootsnap/compile-cache-iseq/96/5a23a22704ebed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/079841522c7ad5 b/tmp/cache/bootsnap/compile-cache-iseq/97/079841522c7ad5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/5fab297270a6c9 b/tmp/cache/bootsnap/compile-cache-iseq/97/5fab297270a6c9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/927275123f6ee4 b/tmp/cache/bootsnap/compile-cache-iseq/97/927275123f6ee4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/9473d5cae347f1 b/tmp/cache/bootsnap/compile-cache-iseq/97/9473d5cae347f1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/d76a5486159184 b/tmp/cache/bootsnap/compile-cache-iseq/97/d76a5486159184
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/97/e694c8339bf69f b/tmp/cache/bootsnap/compile-cache-iseq/97/e694c8339bf69f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/01374eeb368756 b/tmp/cache/bootsnap/compile-cache-iseq/98/01374eeb368756
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/12a0e94ee17a72 b/tmp/cache/bootsnap/compile-cache-iseq/98/12a0e94ee17a72
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/26cdb4712694e0 b/tmp/cache/bootsnap/compile-cache-iseq/98/26cdb4712694e0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/37b01a7939e3b2 b/tmp/cache/bootsnap/compile-cache-iseq/98/37b01a7939e3b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/3d28e98aa1a0bc b/tmp/cache/bootsnap/compile-cache-iseq/98/3d28e98aa1a0bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/5109fe81ca0af2 b/tmp/cache/bootsnap/compile-cache-iseq/98/5109fe81ca0af2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/77f2bc9f4a1fdf b/tmp/cache/bootsnap/compile-cache-iseq/98/77f2bc9f4a1fdf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/832619bf143e23 b/tmp/cache/bootsnap/compile-cache-iseq/98/832619bf143e23
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/85bffd2c063461 b/tmp/cache/bootsnap/compile-cache-iseq/98/85bffd2c063461
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/98/93bcaca5fb3eec b/tmp/cache/bootsnap/compile-cache-iseq/98/93bcaca5fb3eec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/99/3a704292d4156e b/tmp/cache/bootsnap/compile-cache-iseq/99/3a704292d4156e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/99/3e868db87609bb b/tmp/cache/bootsnap/compile-cache-iseq/99/3e868db87609bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/99/409c0d9bfac549 b/tmp/cache/bootsnap/compile-cache-iseq/99/409c0d9bfac549
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/99/848b152cb93cd8 b/tmp/cache/bootsnap/compile-cache-iseq/99/848b152cb93cd8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/2e695d83e4aa1e b/tmp/cache/bootsnap/compile-cache-iseq/9a/2e695d83e4aa1e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/4aafc6da4f8a9c b/tmp/cache/bootsnap/compile-cache-iseq/9a/4aafc6da4f8a9c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/4ca3e34541349b b/tmp/cache/bootsnap/compile-cache-iseq/9a/4ca3e34541349b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/6e2c3ea19adab6 b/tmp/cache/bootsnap/compile-cache-iseq/9a/6e2c3ea19adab6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/87d4da4f74d2fb b/tmp/cache/bootsnap/compile-cache-iseq/9a/87d4da4f74d2fb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9a/8bd5123a3d4a7c b/tmp/cache/bootsnap/compile-cache-iseq/9a/8bd5123a3d4a7c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9b/f5aef632544c49 b/tmp/cache/bootsnap/compile-cache-iseq/9b/f5aef632544c49
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9b/ff8c28a6f9f17a b/tmp/cache/bootsnap/compile-cache-iseq/9b/ff8c28a6f9f17a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/067df650e5aeb2 b/tmp/cache/bootsnap/compile-cache-iseq/9c/067df650e5aeb2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/1cb0850fe7e7e0 b/tmp/cache/bootsnap/compile-cache-iseq/9c/1cb0850fe7e7e0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/90f649a8c16794 b/tmp/cache/bootsnap/compile-cache-iseq/9c/90f649a8c16794
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/97727e28adb67f b/tmp/cache/bootsnap/compile-cache-iseq/9c/97727e28adb67f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/97b200bc066131 b/tmp/cache/bootsnap/compile-cache-iseq/9c/97b200bc066131
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/9a636ca5dc1e57 b/tmp/cache/bootsnap/compile-cache-iseq/9c/9a636ca5dc1e57
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/b2abe73fe80a5d b/tmp/cache/bootsnap/compile-cache-iseq/9c/b2abe73fe80a5d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/c51dee8bb02d0f b/tmp/cache/bootsnap/compile-cache-iseq/9c/c51dee8bb02d0f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/d34a4358b63724 b/tmp/cache/bootsnap/compile-cache-iseq/9c/d34a4358b63724
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9c/d3da47986900e6 b/tmp/cache/bootsnap/compile-cache-iseq/9c/d3da47986900e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/1b43c7fcdd3f61 b/tmp/cache/bootsnap/compile-cache-iseq/9d/1b43c7fcdd3f61
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/1c0054c968a520 b/tmp/cache/bootsnap/compile-cache-iseq/9d/1c0054c968a520
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/3007ad6b99a442 b/tmp/cache/bootsnap/compile-cache-iseq/9d/3007ad6b99a442
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/3dfa31b034cf83 b/tmp/cache/bootsnap/compile-cache-iseq/9d/3dfa31b034cf83
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/643c1a675a8eb3 b/tmp/cache/bootsnap/compile-cache-iseq/9d/643c1a675a8eb3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/791ee757ccdeef b/tmp/cache/bootsnap/compile-cache-iseq/9d/791ee757ccdeef
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/97eb1297d3b52f b/tmp/cache/bootsnap/compile-cache-iseq/9d/97eb1297d3b52f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9d/e493d08634cfd5 b/tmp/cache/bootsnap/compile-cache-iseq/9d/e493d08634cfd5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/025046cac6f19a b/tmp/cache/bootsnap/compile-cache-iseq/9e/025046cac6f19a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/490c4e5046426b b/tmp/cache/bootsnap/compile-cache-iseq/9e/490c4e5046426b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/6f21fe45444a58 b/tmp/cache/bootsnap/compile-cache-iseq/9e/6f21fe45444a58
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/c19650c7bad9a6 b/tmp/cache/bootsnap/compile-cache-iseq/9e/c19650c7bad9a6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/e30755b5b81bc2 b/tmp/cache/bootsnap/compile-cache-iseq/9e/e30755b5b81bc2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/f998caf604550d b/tmp/cache/bootsnap/compile-cache-iseq/9e/f998caf604550d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9e/fca74908e5d128 b/tmp/cache/bootsnap/compile-cache-iseq/9e/fca74908e5d128
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/157edf5a488ccc b/tmp/cache/bootsnap/compile-cache-iseq/9f/157edf5a488ccc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/5ef8e7b0bd809a b/tmp/cache/bootsnap/compile-cache-iseq/9f/5ef8e7b0bd809a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/85f715661e48de b/tmp/cache/bootsnap/compile-cache-iseq/9f/85f715661e48de
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/8a675d941adc97 b/tmp/cache/bootsnap/compile-cache-iseq/9f/8a675d941adc97
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/979b54e59ad7f9 b/tmp/cache/bootsnap/compile-cache-iseq/9f/979b54e59ad7f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/9f2e3a3c5b09ca b/tmp/cache/bootsnap/compile-cache-iseq/9f/9f2e3a3c5b09ca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/be7b9c0459f349 b/tmp/cache/bootsnap/compile-cache-iseq/9f/be7b9c0459f349
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/d266b475247a1e b/tmp/cache/bootsnap/compile-cache-iseq/9f/d266b475247a1e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/9f/d425006380c3d6 b/tmp/cache/bootsnap/compile-cache-iseq/9f/d425006380c3d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/12e374eb2e3278 b/tmp/cache/bootsnap/compile-cache-iseq/a0/12e374eb2e3278
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/7eef53e3478f6b b/tmp/cache/bootsnap/compile-cache-iseq/a0/7eef53e3478f6b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/95e6b5668aa7c0 b/tmp/cache/bootsnap/compile-cache-iseq/a0/95e6b5668aa7c0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/999e77ca9490c6 b/tmp/cache/bootsnap/compile-cache-iseq/a0/999e77ca9490c6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/9eb848dd0f5bce b/tmp/cache/bootsnap/compile-cache-iseq/a0/9eb848dd0f5bce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/b2d9a48cfa87f9 b/tmp/cache/bootsnap/compile-cache-iseq/a0/b2d9a48cfa87f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/b847129d924bdf b/tmp/cache/bootsnap/compile-cache-iseq/a0/b847129d924bdf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a0/d4120456694589 b/tmp/cache/bootsnap/compile-cache-iseq/a0/d4120456694589
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/097951d40ae450 b/tmp/cache/bootsnap/compile-cache-iseq/a1/097951d40ae450
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/5fbcd78debd6f5 b/tmp/cache/bootsnap/compile-cache-iseq/a1/5fbcd78debd6f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/61af54b684cc12 b/tmp/cache/bootsnap/compile-cache-iseq/a1/61af54b684cc12
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/685d980083ee7b b/tmp/cache/bootsnap/compile-cache-iseq/a1/685d980083ee7b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/756c856c4bfa83 b/tmp/cache/bootsnap/compile-cache-iseq/a1/756c856c4bfa83
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/8b368f446e5fe1 b/tmp/cache/bootsnap/compile-cache-iseq/a1/8b368f446e5fe1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/9a83e9bb6d015e b/tmp/cache/bootsnap/compile-cache-iseq/a1/9a83e9bb6d015e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a1/ceb1ea3f8274b6 b/tmp/cache/bootsnap/compile-cache-iseq/a1/ceb1ea3f8274b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/04964bd1d4162c b/tmp/cache/bootsnap/compile-cache-iseq/a2/04964bd1d4162c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/1c27c04c2caf92 b/tmp/cache/bootsnap/compile-cache-iseq/a2/1c27c04c2caf92
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/7c06a0379056f9 b/tmp/cache/bootsnap/compile-cache-iseq/a2/7c06a0379056f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/9692837abeb79b b/tmp/cache/bootsnap/compile-cache-iseq/a2/9692837abeb79b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/a01db2678cf915 b/tmp/cache/bootsnap/compile-cache-iseq/a2/a01db2678cf915
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a2/bf7dc86c3975bb b/tmp/cache/bootsnap/compile-cache-iseq/a2/bf7dc86c3975bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a3/1fad6d97710ff3 b/tmp/cache/bootsnap/compile-cache-iseq/a3/1fad6d97710ff3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a3/69f5268f3a636a b/tmp/cache/bootsnap/compile-cache-iseq/a3/69f5268f3a636a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a3/a3e5da93bc61d0 b/tmp/cache/bootsnap/compile-cache-iseq/a3/a3e5da93bc61d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a3/a41d711b289388 b/tmp/cache/bootsnap/compile-cache-iseq/a3/a41d711b289388
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a3/aa7b5d68c51f49 b/tmp/cache/bootsnap/compile-cache-iseq/a3/aa7b5d68c51f49
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/528679eaf9645b b/tmp/cache/bootsnap/compile-cache-iseq/a4/528679eaf9645b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/96a117371abbd9 b/tmp/cache/bootsnap/compile-cache-iseq/a4/96a117371abbd9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/a194b3999d1d4e b/tmp/cache/bootsnap/compile-cache-iseq/a4/a194b3999d1d4e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/bbe75155288592 b/tmp/cache/bootsnap/compile-cache-iseq/a4/bbe75155288592
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/d493d9d1883994 b/tmp/cache/bootsnap/compile-cache-iseq/a4/d493d9d1883994
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a4/fcca49e0a89b2c b/tmp/cache/bootsnap/compile-cache-iseq/a4/fcca49e0a89b2c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a5/0f9b8ca24b0fdc b/tmp/cache/bootsnap/compile-cache-iseq/a5/0f9b8ca24b0fdc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a5/75162b5e0bd7b2 b/tmp/cache/bootsnap/compile-cache-iseq/a5/75162b5e0bd7b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a5/c64cd9fe529725 b/tmp/cache/bootsnap/compile-cache-iseq/a5/c64cd9fe529725
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a5/f23e323544f6bd b/tmp/cache/bootsnap/compile-cache-iseq/a5/f23e323544f6bd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a5/fb53263a9606df b/tmp/cache/bootsnap/compile-cache-iseq/a5/fb53263a9606df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a6/22fc857bfc8c00 b/tmp/cache/bootsnap/compile-cache-iseq/a6/22fc857bfc8c00
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a6/2a3c516d70f116 b/tmp/cache/bootsnap/compile-cache-iseq/a6/2a3c516d70f116
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a6/465583bade3aa9 b/tmp/cache/bootsnap/compile-cache-iseq/a6/465583bade3aa9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a6/72247b07ba28c2 b/tmp/cache/bootsnap/compile-cache-iseq/a6/72247b07ba28c2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a6/b276094ee742d3 b/tmp/cache/bootsnap/compile-cache-iseq/a6/b276094ee742d3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/3ca0c1bdd8295a b/tmp/cache/bootsnap/compile-cache-iseq/a7/3ca0c1bdd8295a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/5c83148091ccdf b/tmp/cache/bootsnap/compile-cache-iseq/a7/5c83148091ccdf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/7502cd45387585 b/tmp/cache/bootsnap/compile-cache-iseq/a7/7502cd45387585
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/e7c827245e2228 b/tmp/cache/bootsnap/compile-cache-iseq/a7/e7c827245e2228
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/f0ad95085eafa4 b/tmp/cache/bootsnap/compile-cache-iseq/a7/f0ad95085eafa4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a7/f44cc51d1204d4 b/tmp/cache/bootsnap/compile-cache-iseq/a7/f44cc51d1204d4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/37f16068abe6a5 b/tmp/cache/bootsnap/compile-cache-iseq/a8/37f16068abe6a5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/4e6664ef374fad b/tmp/cache/bootsnap/compile-cache-iseq/a8/4e6664ef374fad
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/5fa55e6f2276f2 b/tmp/cache/bootsnap/compile-cache-iseq/a8/5fa55e6f2276f2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/a7322840e21408 b/tmp/cache/bootsnap/compile-cache-iseq/a8/a7322840e21408
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/bd0c0a04cf8d10 b/tmp/cache/bootsnap/compile-cache-iseq/a8/bd0c0a04cf8d10
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/c9d5f677f0f680 b/tmp/cache/bootsnap/compile-cache-iseq/a8/c9d5f677f0f680
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a8/e09e6278ed0359 b/tmp/cache/bootsnap/compile-cache-iseq/a8/e09e6278ed0359
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a9/36dd27d0b16ee4 b/tmp/cache/bootsnap/compile-cache-iseq/a9/36dd27d0b16ee4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a9/41ae398e8f04f7 b/tmp/cache/bootsnap/compile-cache-iseq/a9/41ae398e8f04f7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a9/450fea8e06b5b2 b/tmp/cache/bootsnap/compile-cache-iseq/a9/450fea8e06b5b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a9/5eac6e35ffa423 b/tmp/cache/bootsnap/compile-cache-iseq/a9/5eac6e35ffa423
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/a9/ee339ca1da42b9 b/tmp/cache/bootsnap/compile-cache-iseq/a9/ee339ca1da42b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/15c3ca335f4fb2 b/tmp/cache/bootsnap/compile-cache-iseq/aa/15c3ca335f4fb2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/40b9d0cd9c4e86 b/tmp/cache/bootsnap/compile-cache-iseq/aa/40b9d0cd9c4e86
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/528e9c0d259a0c b/tmp/cache/bootsnap/compile-cache-iseq/aa/528e9c0d259a0c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/5325f3f4e1f3ec b/tmp/cache/bootsnap/compile-cache-iseq/aa/5325f3f4e1f3ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/8f019ff14e797a b/tmp/cache/bootsnap/compile-cache-iseq/aa/8f019ff14e797a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/ac8dc79c435fd9 b/tmp/cache/bootsnap/compile-cache-iseq/aa/ac8dc79c435fd9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/bf672d44519206 b/tmp/cache/bootsnap/compile-cache-iseq/aa/bf672d44519206
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/aa/c7ab4a6f590f75 b/tmp/cache/bootsnap/compile-cache-iseq/aa/c7ab4a6f590f75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/00fd08556d9cdd b/tmp/cache/bootsnap/compile-cache-iseq/ab/00fd08556d9cdd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/1b887b67471c59 b/tmp/cache/bootsnap/compile-cache-iseq/ab/1b887b67471c59
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/34b388d412bfcb b/tmp/cache/bootsnap/compile-cache-iseq/ab/34b388d412bfcb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/839c64b9271c90 b/tmp/cache/bootsnap/compile-cache-iseq/ab/839c64b9271c90
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/8a6c375689fe40 b/tmp/cache/bootsnap/compile-cache-iseq/ab/8a6c375689fe40
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ab/be6eba8e57793a b/tmp/cache/bootsnap/compile-cache-iseq/ab/be6eba8e57793a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ac/352310809e64e8 b/tmp/cache/bootsnap/compile-cache-iseq/ac/352310809e64e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ac/46c76d2d855ee1 b/tmp/cache/bootsnap/compile-cache-iseq/ac/46c76d2d855ee1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ad/193ef143ebfd89 b/tmp/cache/bootsnap/compile-cache-iseq/ad/193ef143ebfd89
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ad/7725c1b6030056 b/tmp/cache/bootsnap/compile-cache-iseq/ad/7725c1b6030056
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/009d604a3d38d5 b/tmp/cache/bootsnap/compile-cache-iseq/ae/009d604a3d38d5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/026605af98b15f b/tmp/cache/bootsnap/compile-cache-iseq/ae/026605af98b15f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/0bc723b00353cf b/tmp/cache/bootsnap/compile-cache-iseq/ae/0bc723b00353cf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/48c91fac6db6d5 b/tmp/cache/bootsnap/compile-cache-iseq/ae/48c91fac6db6d5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/9e2cd4352af3ba b/tmp/cache/bootsnap/compile-cache-iseq/ae/9e2cd4352af3ba
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/a6f5812fc36a7c b/tmp/cache/bootsnap/compile-cache-iseq/ae/a6f5812fc36a7c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/b5676ff58c167e b/tmp/cache/bootsnap/compile-cache-iseq/ae/b5676ff58c167e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ae/e36adb591a0c69 b/tmp/cache/bootsnap/compile-cache-iseq/ae/e36adb591a0c69
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/af/2631f0ce691935 b/tmp/cache/bootsnap/compile-cache-iseq/af/2631f0ce691935
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/af/bff3a04514da20 b/tmp/cache/bootsnap/compile-cache-iseq/af/bff3a04514da20
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/af/f5216b5b354a21 b/tmp/cache/bootsnap/compile-cache-iseq/af/f5216b5b354a21
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/af/fea8e79b59d60f b/tmp/cache/bootsnap/compile-cache-iseq/af/fea8e79b59d60f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/1681a6b9cefb7e b/tmp/cache/bootsnap/compile-cache-iseq/b0/1681a6b9cefb7e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/16ceb56e4fd1e9 b/tmp/cache/bootsnap/compile-cache-iseq/b0/16ceb56e4fd1e9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/1d2310d16a6bc0 b/tmp/cache/bootsnap/compile-cache-iseq/b0/1d2310d16a6bc0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/326fede34b99d1 b/tmp/cache/bootsnap/compile-cache-iseq/b0/326fede34b99d1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/5ff937a7e267b5 b/tmp/cache/bootsnap/compile-cache-iseq/b0/5ff937a7e267b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/695404b0fc9668 b/tmp/cache/bootsnap/compile-cache-iseq/b0/695404b0fc9668
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/98f1eb70f15488 b/tmp/cache/bootsnap/compile-cache-iseq/b0/98f1eb70f15488
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b0/a205f1ca55d9f3 b/tmp/cache/bootsnap/compile-cache-iseq/b0/a205f1ca55d9f3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/02efe998696a2a b/tmp/cache/bootsnap/compile-cache-iseq/b1/02efe998696a2a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/2044ac2df41646 b/tmp/cache/bootsnap/compile-cache-iseq/b1/2044ac2df41646
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/2dba9f36882915 b/tmp/cache/bootsnap/compile-cache-iseq/b1/2dba9f36882915
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/422c441043bb03 b/tmp/cache/bootsnap/compile-cache-iseq/b1/422c441043bb03
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/498861df91ca4f b/tmp/cache/bootsnap/compile-cache-iseq/b1/498861df91ca4f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/6b85a16c7b48b5 b/tmp/cache/bootsnap/compile-cache-iseq/b1/6b85a16c7b48b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b1/ef77f9416687b1 b/tmp/cache/bootsnap/compile-cache-iseq/b1/ef77f9416687b1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/29759d1b00cdd4 b/tmp/cache/bootsnap/compile-cache-iseq/b2/29759d1b00cdd4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/35a168df766dda b/tmp/cache/bootsnap/compile-cache-iseq/b2/35a168df766dda
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/3fafec55585b2e b/tmp/cache/bootsnap/compile-cache-iseq/b2/3fafec55585b2e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/42f1f7922ea6e8 b/tmp/cache/bootsnap/compile-cache-iseq/b2/42f1f7922ea6e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/9b854e2f8e1fac b/tmp/cache/bootsnap/compile-cache-iseq/b2/9b854e2f8e1fac
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b2/ddf8b82be544c6 b/tmp/cache/bootsnap/compile-cache-iseq/b2/ddf8b82be544c6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/0aeb1fc9adb694 b/tmp/cache/bootsnap/compile-cache-iseq/b3/0aeb1fc9adb694
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/6977fc46d94df0 b/tmp/cache/bootsnap/compile-cache-iseq/b3/6977fc46d94df0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/6d01a4f1c10d79 b/tmp/cache/bootsnap/compile-cache-iseq/b3/6d01a4f1c10d79
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/a115a729996ab6 b/tmp/cache/bootsnap/compile-cache-iseq/b3/a115a729996ab6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/eec158f03212ed b/tmp/cache/bootsnap/compile-cache-iseq/b3/eec158f03212ed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b3/ef8a4c0abbe69e b/tmp/cache/bootsnap/compile-cache-iseq/b3/ef8a4c0abbe69e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b4/01de0ea1c13cb9 b/tmp/cache/bootsnap/compile-cache-iseq/b4/01de0ea1c13cb9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b4/18bc880e67e7aa b/tmp/cache/bootsnap/compile-cache-iseq/b4/18bc880e67e7aa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b4/ccbc739f523c9e b/tmp/cache/bootsnap/compile-cache-iseq/b4/ccbc739f523c9e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b4/e1009ee3e41607 b/tmp/cache/bootsnap/compile-cache-iseq/b4/e1009ee3e41607
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b5/0ce3997ea6ed7b b/tmp/cache/bootsnap/compile-cache-iseq/b5/0ce3997ea6ed7b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b5/28330bb05dce9a b/tmp/cache/bootsnap/compile-cache-iseq/b5/28330bb05dce9a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b5/8643a80f976945 b/tmp/cache/bootsnap/compile-cache-iseq/b5/8643a80f976945
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b5/c5f14a188e86ec b/tmp/cache/bootsnap/compile-cache-iseq/b5/c5f14a188e86ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b5/e49220ab08bddd b/tmp/cache/bootsnap/compile-cache-iseq/b5/e49220ab08bddd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/2ca5177b4e6704 b/tmp/cache/bootsnap/compile-cache-iseq/b6/2ca5177b4e6704
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/6ab10526e878b0 b/tmp/cache/bootsnap/compile-cache-iseq/b6/6ab10526e878b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/7636930d4b4c24 b/tmp/cache/bootsnap/compile-cache-iseq/b6/7636930d4b4c24
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/bc518dfa2701a5 b/tmp/cache/bootsnap/compile-cache-iseq/b6/bc518dfa2701a5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/bf8c290d173293 b/tmp/cache/bootsnap/compile-cache-iseq/b6/bf8c290d173293
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/ce21d777f1ac14 b/tmp/cache/bootsnap/compile-cache-iseq/b6/ce21d777f1ac14
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/cedb65f4e98b0f b/tmp/cache/bootsnap/compile-cache-iseq/b6/cedb65f4e98b0f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/d5c0ed4191f49a b/tmp/cache/bootsnap/compile-cache-iseq/b6/d5c0ed4191f49a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/dbad05953cd9f6 b/tmp/cache/bootsnap/compile-cache-iseq/b6/dbad05953cd9f6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b6/fe0c878aae2aa8 b/tmp/cache/bootsnap/compile-cache-iseq/b6/fe0c878aae2aa8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b7/4c218a0b448eb8 b/tmp/cache/bootsnap/compile-cache-iseq/b7/4c218a0b448eb8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b7/4ea56d36031698 b/tmp/cache/bootsnap/compile-cache-iseq/b7/4ea56d36031698
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b7/662700d18cebad b/tmp/cache/bootsnap/compile-cache-iseq/b7/662700d18cebad
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b7/9491848f394813 b/tmp/cache/bootsnap/compile-cache-iseq/b7/9491848f394813
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b7/daf81d472694d0 b/tmp/cache/bootsnap/compile-cache-iseq/b7/daf81d472694d0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b8/01d65b0f4cfa04 b/tmp/cache/bootsnap/compile-cache-iseq/b8/01d65b0f4cfa04
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b8/6d6547578562d6 b/tmp/cache/bootsnap/compile-cache-iseq/b8/6d6547578562d6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b8/a27b747114df62 b/tmp/cache/bootsnap/compile-cache-iseq/b8/a27b747114df62
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b8/bd3d7f2a13ee63 b/tmp/cache/bootsnap/compile-cache-iseq/b8/bd3d7f2a13ee63
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b9/1da96969de1958 b/tmp/cache/bootsnap/compile-cache-iseq/b9/1da96969de1958
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b9/3ec923203e68bc b/tmp/cache/bootsnap/compile-cache-iseq/b9/3ec923203e68bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b9/3ecd8e09e40bd9 b/tmp/cache/bootsnap/compile-cache-iseq/b9/3ecd8e09e40bd9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/b9/5526ac95b63b5f b/tmp/cache/bootsnap/compile-cache-iseq/b9/5526ac95b63b5f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ba/3b69602600f424 b/tmp/cache/bootsnap/compile-cache-iseq/ba/3b69602600f424
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ba/642edc81b26053 b/tmp/cache/bootsnap/compile-cache-iseq/ba/642edc81b26053
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ba/9ca61750df2709 b/tmp/cache/bootsnap/compile-cache-iseq/ba/9ca61750df2709
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ba/a7310b10f99150 b/tmp/cache/bootsnap/compile-cache-iseq/ba/a7310b10f99150
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ba/ae8e695638fe6c b/tmp/cache/bootsnap/compile-cache-iseq/ba/ae8e695638fe6c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/21ddb3750774bb b/tmp/cache/bootsnap/compile-cache-iseq/bb/21ddb3750774bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/2a45b262e08fc7 b/tmp/cache/bootsnap/compile-cache-iseq/bb/2a45b262e08fc7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/2dbe5832f422f5 b/tmp/cache/bootsnap/compile-cache-iseq/bb/2dbe5832f422f5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/34da68a7f0dea3 b/tmp/cache/bootsnap/compile-cache-iseq/bb/34da68a7f0dea3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/50ab8f068599f7 b/tmp/cache/bootsnap/compile-cache-iseq/bb/50ab8f068599f7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/5c066b14c715c9 b/tmp/cache/bootsnap/compile-cache-iseq/bb/5c066b14c715c9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/5c19e8ac47a781 b/tmp/cache/bootsnap/compile-cache-iseq/bb/5c19e8ac47a781
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bb/6e5b1bfd70a153 b/tmp/cache/bootsnap/compile-cache-iseq/bb/6e5b1bfd70a153
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/1c083d01dd9687 b/tmp/cache/bootsnap/compile-cache-iseq/bc/1c083d01dd9687
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/3a40e45814de20 b/tmp/cache/bootsnap/compile-cache-iseq/bc/3a40e45814de20
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/3c5074628ccfee b/tmp/cache/bootsnap/compile-cache-iseq/bc/3c5074628ccfee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/3d05458f50833b b/tmp/cache/bootsnap/compile-cache-iseq/bc/3d05458f50833b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/3db3e0cb6bc4ce b/tmp/cache/bootsnap/compile-cache-iseq/bc/3db3e0cb6bc4ce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/484eb2870bbfa6 b/tmp/cache/bootsnap/compile-cache-iseq/bc/484eb2870bbfa6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/71f3132d5d64d3 b/tmp/cache/bootsnap/compile-cache-iseq/bc/71f3132d5d64d3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/b0ba73ea8230f9 b/tmp/cache/bootsnap/compile-cache-iseq/bc/b0ba73ea8230f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/b5010695a77570 b/tmp/cache/bootsnap/compile-cache-iseq/bc/b5010695a77570
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bc/b514eaeba1a6a5 b/tmp/cache/bootsnap/compile-cache-iseq/bc/b514eaeba1a6a5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/0e88c16dbcd933 b/tmp/cache/bootsnap/compile-cache-iseq/bd/0e88c16dbcd933
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/30b16e07f58865 b/tmp/cache/bootsnap/compile-cache-iseq/bd/30b16e07f58865
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/58ccd64e36d917 b/tmp/cache/bootsnap/compile-cache-iseq/bd/58ccd64e36d917
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/67a4ce1d27b234 b/tmp/cache/bootsnap/compile-cache-iseq/bd/67a4ce1d27b234
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/afb9852f89d5d9 b/tmp/cache/bootsnap/compile-cache-iseq/bd/afb9852f89d5d9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bd/eca5ce30e98d6a b/tmp/cache/bootsnap/compile-cache-iseq/bd/eca5ce30e98d6a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/be/1119b28a3e5217 b/tmp/cache/bootsnap/compile-cache-iseq/be/1119b28a3e5217
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/be/7eb27a4c62044c b/tmp/cache/bootsnap/compile-cache-iseq/be/7eb27a4c62044c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/be/84aa482d0b8608 b/tmp/cache/bootsnap/compile-cache-iseq/be/84aa482d0b8608
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/be/a74ef1eabdea11 b/tmp/cache/bootsnap/compile-cache-iseq/be/a74ef1eabdea11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/0e1b93972a63da b/tmp/cache/bootsnap/compile-cache-iseq/bf/0e1b93972a63da
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/15276274c39149 b/tmp/cache/bootsnap/compile-cache-iseq/bf/15276274c39149
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/2ab1f15b74216b b/tmp/cache/bootsnap/compile-cache-iseq/bf/2ab1f15b74216b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/68c312ee313e89 b/tmp/cache/bootsnap/compile-cache-iseq/bf/68c312ee313e89
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/79a78443d4d6fa b/tmp/cache/bootsnap/compile-cache-iseq/bf/79a78443d4d6fa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/c90fa4d8dbb6b5 b/tmp/cache/bootsnap/compile-cache-iseq/bf/c90fa4d8dbb6b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/bf/ed878ae42c7902 b/tmp/cache/bootsnap/compile-cache-iseq/bf/ed878ae42c7902
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/0ff78202888884 b/tmp/cache/bootsnap/compile-cache-iseq/c0/0ff78202888884
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/19809b388a9a86 b/tmp/cache/bootsnap/compile-cache-iseq/c0/19809b388a9a86
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/28b442fdb2ba9d b/tmp/cache/bootsnap/compile-cache-iseq/c0/28b442fdb2ba9d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/2cc43cc701a643 b/tmp/cache/bootsnap/compile-cache-iseq/c0/2cc43cc701a643
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/3e03710e52f18d b/tmp/cache/bootsnap/compile-cache-iseq/c0/3e03710e52f18d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/542255519a92ec b/tmp/cache/bootsnap/compile-cache-iseq/c0/542255519a92ec
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/659a11ee0c54a7 b/tmp/cache/bootsnap/compile-cache-iseq/c0/659a11ee0c54a7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/805ecd7f36fbd9 b/tmp/cache/bootsnap/compile-cache-iseq/c0/805ecd7f36fbd9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c0/e8fff7fb1773b6 b/tmp/cache/bootsnap/compile-cache-iseq/c0/e8fff7fb1773b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/0dd72b31a00077 b/tmp/cache/bootsnap/compile-cache-iseq/c1/0dd72b31a00077
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/1da2bc8434d6dc b/tmp/cache/bootsnap/compile-cache-iseq/c1/1da2bc8434d6dc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/1ec4174581a353 b/tmp/cache/bootsnap/compile-cache-iseq/c1/1ec4174581a353
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/590ce1bcc0b003 b/tmp/cache/bootsnap/compile-cache-iseq/c1/590ce1bcc0b003
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/8dcd2a79dd1aa0 b/tmp/cache/bootsnap/compile-cache-iseq/c1/8dcd2a79dd1aa0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/9e4ce46610dcad b/tmp/cache/bootsnap/compile-cache-iseq/c1/9e4ce46610dcad
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c1/afda715a637595 b/tmp/cache/bootsnap/compile-cache-iseq/c1/afda715a637595
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/5d8c2c662576e4 b/tmp/cache/bootsnap/compile-cache-iseq/c2/5d8c2c662576e4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/65a2be84a7b456 b/tmp/cache/bootsnap/compile-cache-iseq/c2/65a2be84a7b456
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/7822cf37f7cc90 b/tmp/cache/bootsnap/compile-cache-iseq/c2/7822cf37f7cc90
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/7f20c03a692345 b/tmp/cache/bootsnap/compile-cache-iseq/c2/7f20c03a692345
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/a1a8a584a74335 b/tmp/cache/bootsnap/compile-cache-iseq/c2/a1a8a584a74335
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/c3c2da6df9dd69 b/tmp/cache/bootsnap/compile-cache-iseq/c2/c3c2da6df9dd69
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/cf17774869ceb4 b/tmp/cache/bootsnap/compile-cache-iseq/c2/cf17774869ceb4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c2/e1505c1ce8a42b b/tmp/cache/bootsnap/compile-cache-iseq/c2/e1505c1ce8a42b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/20ca194ce5030a b/tmp/cache/bootsnap/compile-cache-iseq/c3/20ca194ce5030a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/395c7b28b692e7 b/tmp/cache/bootsnap/compile-cache-iseq/c3/395c7b28b692e7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/3a5bb44b3842a8 b/tmp/cache/bootsnap/compile-cache-iseq/c3/3a5bb44b3842a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/3f3c1bb09d4ad3 b/tmp/cache/bootsnap/compile-cache-iseq/c3/3f3c1bb09d4ad3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/939941ba0ce9db b/tmp/cache/bootsnap/compile-cache-iseq/c3/939941ba0ce9db
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/96d0a2515f7859 b/tmp/cache/bootsnap/compile-cache-iseq/c3/96d0a2515f7859
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c3/f6d9ee78ab01e6 b/tmp/cache/bootsnap/compile-cache-iseq/c3/f6d9ee78ab01e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/16883b8fd1504f b/tmp/cache/bootsnap/compile-cache-iseq/c4/16883b8fd1504f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/3eebb3de3eed29 b/tmp/cache/bootsnap/compile-cache-iseq/c4/3eebb3de3eed29
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/518bc3f7b14a74 b/tmp/cache/bootsnap/compile-cache-iseq/c4/518bc3f7b14a74
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/b16460adaa1ee8 b/tmp/cache/bootsnap/compile-cache-iseq/c4/b16460adaa1ee8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/c0a45efe483f7b b/tmp/cache/bootsnap/compile-cache-iseq/c4/c0a45efe483f7b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/c2bc6423547f42 b/tmp/cache/bootsnap/compile-cache-iseq/c4/c2bc6423547f42
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c4/cb97a56864e2e2 b/tmp/cache/bootsnap/compile-cache-iseq/c4/cb97a56864e2e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/0b8c11218c472c b/tmp/cache/bootsnap/compile-cache-iseq/c5/0b8c11218c472c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/124b3f7f61018e b/tmp/cache/bootsnap/compile-cache-iseq/c5/124b3f7f61018e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/25cb63139606cb b/tmp/cache/bootsnap/compile-cache-iseq/c5/25cb63139606cb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/39402cee340d49 b/tmp/cache/bootsnap/compile-cache-iseq/c5/39402cee340d49
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/99c164f58273a5 b/tmp/cache/bootsnap/compile-cache-iseq/c5/99c164f58273a5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/cbbb398d8db2d2 b/tmp/cache/bootsnap/compile-cache-iseq/c5/cbbb398d8db2d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/e1cfc14e588633 b/tmp/cache/bootsnap/compile-cache-iseq/c5/e1cfc14e588633
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c5/e616429fce6d8c b/tmp/cache/bootsnap/compile-cache-iseq/c5/e616429fce6d8c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/025c5654d36ae7 b/tmp/cache/bootsnap/compile-cache-iseq/c6/025c5654d36ae7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/1bb5308e6a596f b/tmp/cache/bootsnap/compile-cache-iseq/c6/1bb5308e6a596f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/64e919c65bd85c b/tmp/cache/bootsnap/compile-cache-iseq/c6/64e919c65bd85c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/94c1fd4ed4db0b b/tmp/cache/bootsnap/compile-cache-iseq/c6/94c1fd4ed4db0b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/a7a798f1898be7 b/tmp/cache/bootsnap/compile-cache-iseq/c6/a7a798f1898be7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/b4bf6a1953d34e b/tmp/cache/bootsnap/compile-cache-iseq/c6/b4bf6a1953d34e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c6/b6b3d253596936 b/tmp/cache/bootsnap/compile-cache-iseq/c6/b6b3d253596936
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/a0e8a9d47294fe b/tmp/cache/bootsnap/compile-cache-iseq/c7/a0e8a9d47294fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/bf27eb9cc7e8d2 b/tmp/cache/bootsnap/compile-cache-iseq/c7/bf27eb9cc7e8d2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/cc8951712b46d5 b/tmp/cache/bootsnap/compile-cache-iseq/c7/cc8951712b46d5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/cf405858801361 b/tmp/cache/bootsnap/compile-cache-iseq/c7/cf405858801361
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/f4ce43f5906381 b/tmp/cache/bootsnap/compile-cache-iseq/c7/f4ce43f5906381
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c7/f9f8e99e824143 b/tmp/cache/bootsnap/compile-cache-iseq/c7/f9f8e99e824143
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/2ffd2a0883ef2b b/tmp/cache/bootsnap/compile-cache-iseq/c8/2ffd2a0883ef2b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/59a482503c6d64 b/tmp/cache/bootsnap/compile-cache-iseq/c8/59a482503c6d64
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/69b2a4f42d1a62 b/tmp/cache/bootsnap/compile-cache-iseq/c8/69b2a4f42d1a62
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/6ea5461f4db4d8 b/tmp/cache/bootsnap/compile-cache-iseq/c8/6ea5461f4db4d8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/dd59eea5667e4d b/tmp/cache/bootsnap/compile-cache-iseq/c8/dd59eea5667e4d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/f1f7d87cbd551d b/tmp/cache/bootsnap/compile-cache-iseq/c8/f1f7d87cbd551d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c8/ff59f3115acdf4 b/tmp/cache/bootsnap/compile-cache-iseq/c8/ff59f3115acdf4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/22e50578368edd b/tmp/cache/bootsnap/compile-cache-iseq/c9/22e50578368edd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/27c68548ceb481 b/tmp/cache/bootsnap/compile-cache-iseq/c9/27c68548ceb481
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/34232bbfeb215e b/tmp/cache/bootsnap/compile-cache-iseq/c9/34232bbfeb215e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/4b7b24fce66d92 b/tmp/cache/bootsnap/compile-cache-iseq/c9/4b7b24fce66d92
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/4bb30926724b6d b/tmp/cache/bootsnap/compile-cache-iseq/c9/4bb30926724b6d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/e2e8951a5e2cc8 b/tmp/cache/bootsnap/compile-cache-iseq/c9/e2e8951a5e2cc8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/c9/f0600de8f8e410 b/tmp/cache/bootsnap/compile-cache-iseq/c9/f0600de8f8e410
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/67942e85bc47a8 b/tmp/cache/bootsnap/compile-cache-iseq/ca/67942e85bc47a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/98f7c5347195b5 b/tmp/cache/bootsnap/compile-cache-iseq/ca/98f7c5347195b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/9a8897a9c1e597 b/tmp/cache/bootsnap/compile-cache-iseq/ca/9a8897a9c1e597
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/a3e8bda891fdae b/tmp/cache/bootsnap/compile-cache-iseq/ca/a3e8bda891fdae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/a5bc2f4d15dbe4 b/tmp/cache/bootsnap/compile-cache-iseq/ca/a5bc2f4d15dbe4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/c1a0376dbd3703 b/tmp/cache/bootsnap/compile-cache-iseq/ca/c1a0376dbd3703
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/c455122b053fcb b/tmp/cache/bootsnap/compile-cache-iseq/ca/c455122b053fcb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ca/df4a7f6648ce34 b/tmp/cache/bootsnap/compile-cache-iseq/ca/df4a7f6648ce34
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/061d2d44bd538c b/tmp/cache/bootsnap/compile-cache-iseq/cb/061d2d44bd538c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/13d858717808ed b/tmp/cache/bootsnap/compile-cache-iseq/cb/13d858717808ed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/5db1a853adf0b6 b/tmp/cache/bootsnap/compile-cache-iseq/cb/5db1a853adf0b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/a5430a86b5afe8 b/tmp/cache/bootsnap/compile-cache-iseq/cb/a5430a86b5afe8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/acb206dff71635 b/tmp/cache/bootsnap/compile-cache-iseq/cb/acb206dff71635
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/b8fb8081ed4436 b/tmp/cache/bootsnap/compile-cache-iseq/cb/b8fb8081ed4436
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cb/e66f2a6f74ceb3 b/tmp/cache/bootsnap/compile-cache-iseq/cb/e66f2a6f74ceb3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cc/bea4899e791bd0 b/tmp/cache/bootsnap/compile-cache-iseq/cc/bea4899e791bd0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cc/d8d5f5001b567d b/tmp/cache/bootsnap/compile-cache-iseq/cc/d8d5f5001b567d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cc/dc0579190b315e b/tmp/cache/bootsnap/compile-cache-iseq/cc/dc0579190b315e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cc/f5e1ca5670fd2b b/tmp/cache/bootsnap/compile-cache-iseq/cc/f5e1ca5670fd2b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/2234ecaaaaa4bb b/tmp/cache/bootsnap/compile-cache-iseq/cd/2234ecaaaaa4bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/376ee5fac50e1e b/tmp/cache/bootsnap/compile-cache-iseq/cd/376ee5fac50e1e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/5c9107d719a80a b/tmp/cache/bootsnap/compile-cache-iseq/cd/5c9107d719a80a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/c7d8e09280a725 b/tmp/cache/bootsnap/compile-cache-iseq/cd/c7d8e09280a725
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/c8c0de8e885836 b/tmp/cache/bootsnap/compile-cache-iseq/cd/c8c0de8e885836
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/e298d9aefa315a b/tmp/cache/bootsnap/compile-cache-iseq/cd/e298d9aefa315a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cd/fa8b320ac2ad4e b/tmp/cache/bootsnap/compile-cache-iseq/cd/fa8b320ac2ad4e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/04ff5e0d604c39 b/tmp/cache/bootsnap/compile-cache-iseq/ce/04ff5e0d604c39
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/465220b6a753eb b/tmp/cache/bootsnap/compile-cache-iseq/ce/465220b6a753eb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/5504e70406d4c6 b/tmp/cache/bootsnap/compile-cache-iseq/ce/5504e70406d4c6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/7fdf657b3144a1 b/tmp/cache/bootsnap/compile-cache-iseq/ce/7fdf657b3144a1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/7fe12eaac92a6c b/tmp/cache/bootsnap/compile-cache-iseq/ce/7fe12eaac92a6c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/c964702a2e4584 b/tmp/cache/bootsnap/compile-cache-iseq/ce/c964702a2e4584
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/d01f6f16b8e7a0 b/tmp/cache/bootsnap/compile-cache-iseq/ce/d01f6f16b8e7a0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/df05dfd0ad9ea4 b/tmp/cache/bootsnap/compile-cache-iseq/ce/df05dfd0ad9ea4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ce/f10cf8b21b6878 b/tmp/cache/bootsnap/compile-cache-iseq/ce/f10cf8b21b6878
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/208b787bb55bb4 b/tmp/cache/bootsnap/compile-cache-iseq/cf/208b787bb55bb4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/30f9774e490eba b/tmp/cache/bootsnap/compile-cache-iseq/cf/30f9774e490eba
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/6b57e535e3e8e6 b/tmp/cache/bootsnap/compile-cache-iseq/cf/6b57e535e3e8e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/bc8eb4f3575f27 b/tmp/cache/bootsnap/compile-cache-iseq/cf/bc8eb4f3575f27
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/db66ac02bc89da b/tmp/cache/bootsnap/compile-cache-iseq/cf/db66ac02bc89da
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/cf/ef3881712efede b/tmp/cache/bootsnap/compile-cache-iseq/cf/ef3881712efede
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d0/4c02e20f87d638 b/tmp/cache/bootsnap/compile-cache-iseq/d0/4c02e20f87d638
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d0/77f24f3a7d7702 b/tmp/cache/bootsnap/compile-cache-iseq/d0/77f24f3a7d7702
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d0/8dc313dbbf5bb2 b/tmp/cache/bootsnap/compile-cache-iseq/d0/8dc313dbbf5bb2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/04ae9d23e88e2a b/tmp/cache/bootsnap/compile-cache-iseq/d1/04ae9d23e88e2a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/316df59dc0166d b/tmp/cache/bootsnap/compile-cache-iseq/d1/316df59dc0166d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/76266283e8e8bb b/tmp/cache/bootsnap/compile-cache-iseq/d1/76266283e8e8bb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/940e2ea0deffcd b/tmp/cache/bootsnap/compile-cache-iseq/d1/940e2ea0deffcd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/ad62af9a6da5bd b/tmp/cache/bootsnap/compile-cache-iseq/d1/ad62af9a6da5bd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d1/b85341a9b34da2 b/tmp/cache/bootsnap/compile-cache-iseq/d1/b85341a9b34da2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d2/144a6039e8224a b/tmp/cache/bootsnap/compile-cache-iseq/d2/144a6039e8224a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d2/25b5b15d5a85fd b/tmp/cache/bootsnap/compile-cache-iseq/d2/25b5b15d5a85fd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d3/00d5ee85759aa2 b/tmp/cache/bootsnap/compile-cache-iseq/d3/00d5ee85759aa2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d3/1ebfab2c4b703d b/tmp/cache/bootsnap/compile-cache-iseq/d3/1ebfab2c4b703d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d3/4c82819a7b6127 b/tmp/cache/bootsnap/compile-cache-iseq/d3/4c82819a7b6127
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d3/834177be8419b0 b/tmp/cache/bootsnap/compile-cache-iseq/d3/834177be8419b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d3/de9f870bd8f340 b/tmp/cache/bootsnap/compile-cache-iseq/d3/de9f870bd8f340
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d4/055564b45f6f3c b/tmp/cache/bootsnap/compile-cache-iseq/d4/055564b45f6f3c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d4/d3668fbdb9435a b/tmp/cache/bootsnap/compile-cache-iseq/d4/d3668fbdb9435a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d4/f1d389960af18c b/tmp/cache/bootsnap/compile-cache-iseq/d4/f1d389960af18c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/0e998ae95aafd2 b/tmp/cache/bootsnap/compile-cache-iseq/d5/0e998ae95aafd2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/170bb2b0d6f48b b/tmp/cache/bootsnap/compile-cache-iseq/d5/170bb2b0d6f48b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/4c69c2f88085ce b/tmp/cache/bootsnap/compile-cache-iseq/d5/4c69c2f88085ce
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/a890166c589773 b/tmp/cache/bootsnap/compile-cache-iseq/d5/a890166c589773
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/b73a5036e0f7b0 b/tmp/cache/bootsnap/compile-cache-iseq/d5/b73a5036e0f7b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d5/c5f59189627c6f b/tmp/cache/bootsnap/compile-cache-iseq/d5/c5f59189627c6f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d6/17ec286fd0b5e2 b/tmp/cache/bootsnap/compile-cache-iseq/d6/17ec286fd0b5e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d6/39e4d02355a30f b/tmp/cache/bootsnap/compile-cache-iseq/d6/39e4d02355a30f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d6/c4bc04e812a5fa b/tmp/cache/bootsnap/compile-cache-iseq/d6/c4bc04e812a5fa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d6/de5a06ec6f0d3c b/tmp/cache/bootsnap/compile-cache-iseq/d6/de5a06ec6f0d3c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d6/f18f5722b139c0 b/tmp/cache/bootsnap/compile-cache-iseq/d6/f18f5722b139c0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/2719f118e47108 b/tmp/cache/bootsnap/compile-cache-iseq/d7/2719f118e47108
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/40c49980dc8dbf b/tmp/cache/bootsnap/compile-cache-iseq/d7/40c49980dc8dbf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/454d41e480cda8 b/tmp/cache/bootsnap/compile-cache-iseq/d7/454d41e480cda8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/67245a0df43984 b/tmp/cache/bootsnap/compile-cache-iseq/d7/67245a0df43984
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/8608d5fda979be b/tmp/cache/bootsnap/compile-cache-iseq/d7/8608d5fda979be
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/c481ef7ad6f79b b/tmp/cache/bootsnap/compile-cache-iseq/d7/c481ef7ad6f79b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d7/e93e557411ec24 b/tmp/cache/bootsnap/compile-cache-iseq/d7/e93e557411ec24
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d8/5c52a47ff5605c b/tmp/cache/bootsnap/compile-cache-iseq/d8/5c52a47ff5605c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d8/5dbe913737c2d3 b/tmp/cache/bootsnap/compile-cache-iseq/d8/5dbe913737c2d3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d8/bcaa309e300b47 b/tmp/cache/bootsnap/compile-cache-iseq/d8/bcaa309e300b47
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d9/11d787d876b370 b/tmp/cache/bootsnap/compile-cache-iseq/d9/11d787d876b370
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d9/2dd2b580738eb1 b/tmp/cache/bootsnap/compile-cache-iseq/d9/2dd2b580738eb1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d9/6784594bd15d33 b/tmp/cache/bootsnap/compile-cache-iseq/d9/6784594bd15d33
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d9/a19d462b565913 b/tmp/cache/bootsnap/compile-cache-iseq/d9/a19d462b565913
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/d9/ae28e57a513396 b/tmp/cache/bootsnap/compile-cache-iseq/d9/ae28e57a513396
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/da/4bc1329feed0cb b/tmp/cache/bootsnap/compile-cache-iseq/da/4bc1329feed0cb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/da/8059f154c15082 b/tmp/cache/bootsnap/compile-cache-iseq/da/8059f154c15082
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/da/d25c31f2931ca8 b/tmp/cache/bootsnap/compile-cache-iseq/da/d25c31f2931ca8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/da/e9d20d009241be b/tmp/cache/bootsnap/compile-cache-iseq/da/e9d20d009241be
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/db/28be5ede9f4e4c b/tmp/cache/bootsnap/compile-cache-iseq/db/28be5ede9f4e4c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/db/322b3966bc9ab2 b/tmp/cache/bootsnap/compile-cache-iseq/db/322b3966bc9ab2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/db/6e0f076fd76b43 b/tmp/cache/bootsnap/compile-cache-iseq/db/6e0f076fd76b43
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/db/7fa1ce99d10bdb b/tmp/cache/bootsnap/compile-cache-iseq/db/7fa1ce99d10bdb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/db/e4af0e00578020 b/tmp/cache/bootsnap/compile-cache-iseq/db/e4af0e00578020
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/1070edcbf61d6a b/tmp/cache/bootsnap/compile-cache-iseq/dc/1070edcbf61d6a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/124d666aa8b5df b/tmp/cache/bootsnap/compile-cache-iseq/dc/124d666aa8b5df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/6ba5717ae742c5 b/tmp/cache/bootsnap/compile-cache-iseq/dc/6ba5717ae742c5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/c54e95f675a947 b/tmp/cache/bootsnap/compile-cache-iseq/dc/c54e95f675a947
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/d0d8e98f8234e8 b/tmp/cache/bootsnap/compile-cache-iseq/dc/d0d8e98f8234e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dc/fa1188b9990c11 b/tmp/cache/bootsnap/compile-cache-iseq/dc/fa1188b9990c11
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/01b73330e1fbbd b/tmp/cache/bootsnap/compile-cache-iseq/dd/01b73330e1fbbd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/039878e0ddfcf3 b/tmp/cache/bootsnap/compile-cache-iseq/dd/039878e0ddfcf3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/25250f079cb67a b/tmp/cache/bootsnap/compile-cache-iseq/dd/25250f079cb67a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/39a13db4f0b6dc b/tmp/cache/bootsnap/compile-cache-iseq/dd/39a13db4f0b6dc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/4461390d506454 b/tmp/cache/bootsnap/compile-cache-iseq/dd/4461390d506454
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/5f2731bf64cf3b b/tmp/cache/bootsnap/compile-cache-iseq/dd/5f2731bf64cf3b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/dd/82fc4a8d10c168 b/tmp/cache/bootsnap/compile-cache-iseq/dd/82fc4a8d10c168
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/298c1c7f9c57e8 b/tmp/cache/bootsnap/compile-cache-iseq/de/298c1c7f9c57e8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/5e35abc55f2d52 b/tmp/cache/bootsnap/compile-cache-iseq/de/5e35abc55f2d52
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/666165d673254c b/tmp/cache/bootsnap/compile-cache-iseq/de/666165d673254c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/b2ad64abb906f1 b/tmp/cache/bootsnap/compile-cache-iseq/de/b2ad64abb906f1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/c4c07d6b86ce47 b/tmp/cache/bootsnap/compile-cache-iseq/de/c4c07d6b86ce47
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/de/f688e385701e1f b/tmp/cache/bootsnap/compile-cache-iseq/de/f688e385701e1f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/2736797998fbe6 b/tmp/cache/bootsnap/compile-cache-iseq/df/2736797998fbe6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/4fd81c8473fbd1 b/tmp/cache/bootsnap/compile-cache-iseq/df/4fd81c8473fbd1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/684212b469aad2 b/tmp/cache/bootsnap/compile-cache-iseq/df/684212b469aad2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/7f90339aa11828 b/tmp/cache/bootsnap/compile-cache-iseq/df/7f90339aa11828
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/9a819c483992f4 b/tmp/cache/bootsnap/compile-cache-iseq/df/9a819c483992f4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/bb4baeca789d67 b/tmp/cache/bootsnap/compile-cache-iseq/df/bb4baeca789d67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/df/d345d1445a0454 b/tmp/cache/bootsnap/compile-cache-iseq/df/d345d1445a0454
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e0/238a33da8b908b b/tmp/cache/bootsnap/compile-cache-iseq/e0/238a33da8b908b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e0/26c42fba264a14 b/tmp/cache/bootsnap/compile-cache-iseq/e0/26c42fba264a14
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e0/3b7c169b96634a b/tmp/cache/bootsnap/compile-cache-iseq/e0/3b7c169b96634a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e0/3e2b73ec5a1a65 b/tmp/cache/bootsnap/compile-cache-iseq/e0/3e2b73ec5a1a65
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e0/a350e870a53438 b/tmp/cache/bootsnap/compile-cache-iseq/e0/a350e870a53438
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e1/4f84804fe98110 b/tmp/cache/bootsnap/compile-cache-iseq/e1/4f84804fe98110
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e1/5665ed531c4b5c b/tmp/cache/bootsnap/compile-cache-iseq/e1/5665ed531c4b5c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e1/d1147ea8e556df b/tmp/cache/bootsnap/compile-cache-iseq/e1/d1147ea8e556df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e1/eef525a09f1eb3 b/tmp/cache/bootsnap/compile-cache-iseq/e1/eef525a09f1eb3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e1/f0048235f9bb01 b/tmp/cache/bootsnap/compile-cache-iseq/e1/f0048235f9bb01
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/1ba82d708a6ed6 b/tmp/cache/bootsnap/compile-cache-iseq/e2/1ba82d708a6ed6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/283835cc07622c b/tmp/cache/bootsnap/compile-cache-iseq/e2/283835cc07622c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/2d2c2820c36656 b/tmp/cache/bootsnap/compile-cache-iseq/e2/2d2c2820c36656
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/4ebaa3dc46b2eb b/tmp/cache/bootsnap/compile-cache-iseq/e2/4ebaa3dc46b2eb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/655e95a8f47bab b/tmp/cache/bootsnap/compile-cache-iseq/e2/655e95a8f47bab
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/67f5fea958bb7f b/tmp/cache/bootsnap/compile-cache-iseq/e2/67f5fea958bb7f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/8ddb945515e6ae b/tmp/cache/bootsnap/compile-cache-iseq/e2/8ddb945515e6ae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/8fe88560bb5564 b/tmp/cache/bootsnap/compile-cache-iseq/e2/8fe88560bb5564
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/bc5bb1dd817e0c b/tmp/cache/bootsnap/compile-cache-iseq/e2/bc5bb1dd817e0c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/db6d36067c2dc9 b/tmp/cache/bootsnap/compile-cache-iseq/e2/db6d36067c2dc9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/f7415599acdcc1 b/tmp/cache/bootsnap/compile-cache-iseq/e2/f7415599acdcc1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e2/fc1c715917bfdc b/tmp/cache/bootsnap/compile-cache-iseq/e2/fc1c715917bfdc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e3/16a6448045882a b/tmp/cache/bootsnap/compile-cache-iseq/e3/16a6448045882a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e3/4547a81627eb68 b/tmp/cache/bootsnap/compile-cache-iseq/e3/4547a81627eb68
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e3/48b06074770453 b/tmp/cache/bootsnap/compile-cache-iseq/e3/48b06074770453
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e3/b1fed79d97e695 b/tmp/cache/bootsnap/compile-cache-iseq/e3/b1fed79d97e695
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e4/411950223224e5 b/tmp/cache/bootsnap/compile-cache-iseq/e4/411950223224e5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e4/c3a8d89b62f55e b/tmp/cache/bootsnap/compile-cache-iseq/e4/c3a8d89b62f55e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e4/ec36064a220db7 b/tmp/cache/bootsnap/compile-cache-iseq/e4/ec36064a220db7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/43e1b81e0dd9a1 b/tmp/cache/bootsnap/compile-cache-iseq/e5/43e1b81e0dd9a1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/4daa7b4fae6741 b/tmp/cache/bootsnap/compile-cache-iseq/e5/4daa7b4fae6741
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/7411c2cfc9582f b/tmp/cache/bootsnap/compile-cache-iseq/e5/7411c2cfc9582f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/752ea5417c6261 b/tmp/cache/bootsnap/compile-cache-iseq/e5/752ea5417c6261
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/abc385a5e77ac2 b/tmp/cache/bootsnap/compile-cache-iseq/e5/abc385a5e77ac2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/b2261fb0f1f9fa b/tmp/cache/bootsnap/compile-cache-iseq/e5/b2261fb0f1f9fa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/b5c8edfbf056f9 b/tmp/cache/bootsnap/compile-cache-iseq/e5/b5c8edfbf056f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e5/b6d3fe6f2fbcc8 b/tmp/cache/bootsnap/compile-cache-iseq/e5/b6d3fe6f2fbcc8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/2561eae915c57e b/tmp/cache/bootsnap/compile-cache-iseq/e6/2561eae915c57e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/2d02bae79e1879 b/tmp/cache/bootsnap/compile-cache-iseq/e6/2d02bae79e1879
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/72fd2b7f38d62b b/tmp/cache/bootsnap/compile-cache-iseq/e6/72fd2b7f38d62b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/a6b4b06109d6ac b/tmp/cache/bootsnap/compile-cache-iseq/e6/a6b4b06109d6ac
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/bafa3ade2ab967 b/tmp/cache/bootsnap/compile-cache-iseq/e6/bafa3ade2ab967
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/bd8120bc090856 b/tmp/cache/bootsnap/compile-cache-iseq/e6/bd8120bc090856
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/bd93f2e20614ae b/tmp/cache/bootsnap/compile-cache-iseq/e6/bd93f2e20614ae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e6/c3eef3fc606bfa b/tmp/cache/bootsnap/compile-cache-iseq/e6/c3eef3fc606bfa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e7/0c59163434dce6 b/tmp/cache/bootsnap/compile-cache-iseq/e7/0c59163434dce6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e7/1c7a96d0e576d9 b/tmp/cache/bootsnap/compile-cache-iseq/e7/1c7a96d0e576d9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e7/5254acd76f879f b/tmp/cache/bootsnap/compile-cache-iseq/e7/5254acd76f879f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e7/693282602d0bc3 b/tmp/cache/bootsnap/compile-cache-iseq/e7/693282602d0bc3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e7/6f8d1e3c875b1a b/tmp/cache/bootsnap/compile-cache-iseq/e7/6f8d1e3c875b1a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/024b4c47e92ba0 b/tmp/cache/bootsnap/compile-cache-iseq/e8/024b4c47e92ba0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/21840a2ca6ac5d b/tmp/cache/bootsnap/compile-cache-iseq/e8/21840a2ca6ac5d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/369201d4915f1f b/tmp/cache/bootsnap/compile-cache-iseq/e8/369201d4915f1f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/72f603c68b54c1 b/tmp/cache/bootsnap/compile-cache-iseq/e8/72f603c68b54c1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/abd1d115b12d43 b/tmp/cache/bootsnap/compile-cache-iseq/e8/abd1d115b12d43
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e8/eceeda90421909 b/tmp/cache/bootsnap/compile-cache-iseq/e8/eceeda90421909
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/33e3d23fa7b8ad b/tmp/cache/bootsnap/compile-cache-iseq/e9/33e3d23fa7b8ad
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/490a99ec314508 b/tmp/cache/bootsnap/compile-cache-iseq/e9/490a99ec314508
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/492546c01c5495 b/tmp/cache/bootsnap/compile-cache-iseq/e9/492546c01c5495
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/56e4b0d19dbbcc b/tmp/cache/bootsnap/compile-cache-iseq/e9/56e4b0d19dbbcc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/833a4e283088d1 b/tmp/cache/bootsnap/compile-cache-iseq/e9/833a4e283088d1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/91d4ee19fa9645 b/tmp/cache/bootsnap/compile-cache-iseq/e9/91d4ee19fa9645
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/c1994fa0a3f7a3 b/tmp/cache/bootsnap/compile-cache-iseq/e9/c1994fa0a3f7a3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/caa41e8c7c44b9 b/tmp/cache/bootsnap/compile-cache-iseq/e9/caa41e8c7c44b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/e9/f5780cf8546d17 b/tmp/cache/bootsnap/compile-cache-iseq/e9/f5780cf8546d17
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/18584087b279b2 b/tmp/cache/bootsnap/compile-cache-iseq/ea/18584087b279b2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/2e5bfa088af191 b/tmp/cache/bootsnap/compile-cache-iseq/ea/2e5bfa088af191
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/897247b4a03763 b/tmp/cache/bootsnap/compile-cache-iseq/ea/897247b4a03763
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/bd81e36a1b5907 b/tmp/cache/bootsnap/compile-cache-iseq/ea/bd81e36a1b5907
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/d9ca72358ec86d b/tmp/cache/bootsnap/compile-cache-iseq/ea/d9ca72358ec86d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ea/df9d94b2255ea1 b/tmp/cache/bootsnap/compile-cache-iseq/ea/df9d94b2255ea1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/11daf2e8997a6e b/tmp/cache/bootsnap/compile-cache-iseq/eb/11daf2e8997a6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/70f32b4934c08a b/tmp/cache/bootsnap/compile-cache-iseq/eb/70f32b4934c08a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/7947b11683f01f b/tmp/cache/bootsnap/compile-cache-iseq/eb/7947b11683f01f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/847ba374bcb8f9 b/tmp/cache/bootsnap/compile-cache-iseq/eb/847ba374bcb8f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/9e5bdd2f62ff67 b/tmp/cache/bootsnap/compile-cache-iseq/eb/9e5bdd2f62ff67
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/aab8df66a49487 b/tmp/cache/bootsnap/compile-cache-iseq/eb/aab8df66a49487
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/c24760bdf45930 b/tmp/cache/bootsnap/compile-cache-iseq/eb/c24760bdf45930
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/eb/c513c3926c0ffd b/tmp/cache/bootsnap/compile-cache-iseq/eb/c513c3926c0ffd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ec/70482fe0df7349 b/tmp/cache/bootsnap/compile-cache-iseq/ec/70482fe0df7349
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ec/757bfa40093488 b/tmp/cache/bootsnap/compile-cache-iseq/ec/757bfa40093488
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ec/86ccfbdad10008 b/tmp/cache/bootsnap/compile-cache-iseq/ec/86ccfbdad10008
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ec/898c38e8b1cb75 b/tmp/cache/bootsnap/compile-cache-iseq/ec/898c38e8b1cb75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ec/bbb8c97b9fb574 b/tmp/cache/bootsnap/compile-cache-iseq/ec/bbb8c97b9fb574
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/00f4139e3b3306 b/tmp/cache/bootsnap/compile-cache-iseq/ed/00f4139e3b3306
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/1bb0060e9b5121 b/tmp/cache/bootsnap/compile-cache-iseq/ed/1bb0060e9b5121
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/27b8cf1bda663a b/tmp/cache/bootsnap/compile-cache-iseq/ed/27b8cf1bda663a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/2ece470598218c b/tmp/cache/bootsnap/compile-cache-iseq/ed/2ece470598218c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/54f182df97fc1e b/tmp/cache/bootsnap/compile-cache-iseq/ed/54f182df97fc1e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ed/9a7710328cdde2 b/tmp/cache/bootsnap/compile-cache-iseq/ed/9a7710328cdde2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ee/a17dd14beb63bc b/tmp/cache/bootsnap/compile-cache-iseq/ee/a17dd14beb63bc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ee/b86c13d86b197b b/tmp/cache/bootsnap/compile-cache-iseq/ee/b86c13d86b197b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ee/dbf966da60da42 b/tmp/cache/bootsnap/compile-cache-iseq/ee/dbf966da60da42
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ee/e72abbe2b253b6 b/tmp/cache/bootsnap/compile-cache-iseq/ee/e72abbe2b253b6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ee/f8a52058f2491f b/tmp/cache/bootsnap/compile-cache-iseq/ee/f8a52058f2491f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/5d564ea0a318df b/tmp/cache/bootsnap/compile-cache-iseq/ef/5d564ea0a318df
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/63fb5122b17cf5 b/tmp/cache/bootsnap/compile-cache-iseq/ef/63fb5122b17cf5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/6c9a54a0da5b15 b/tmp/cache/bootsnap/compile-cache-iseq/ef/6c9a54a0da5b15
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/8dd92c543c05e5 b/tmp/cache/bootsnap/compile-cache-iseq/ef/8dd92c543c05e5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/92312c8b19a9f3 b/tmp/cache/bootsnap/compile-cache-iseq/ef/92312c8b19a9f3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/98d07572efde37 b/tmp/cache/bootsnap/compile-cache-iseq/ef/98d07572efde37
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/c5ce358d4a65a9 b/tmp/cache/bootsnap/compile-cache-iseq/ef/c5ce358d4a65a9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ef/c5de1091010abb b/tmp/cache/bootsnap/compile-cache-iseq/ef/c5de1091010abb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f0/24f75c0d32328a b/tmp/cache/bootsnap/compile-cache-iseq/f0/24f75c0d32328a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f0/4da6769454fb57 b/tmp/cache/bootsnap/compile-cache-iseq/f0/4da6769454fb57
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f0/76928f1055ff33 b/tmp/cache/bootsnap/compile-cache-iseq/f0/76928f1055ff33
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f0/c6678a61360f73 b/tmp/cache/bootsnap/compile-cache-iseq/f0/c6678a61360f73
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f0/ff88d349d9fb38 b/tmp/cache/bootsnap/compile-cache-iseq/f0/ff88d349d9fb38
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/29ec60c03c8394 b/tmp/cache/bootsnap/compile-cache-iseq/f1/29ec60c03c8394
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/4ef395b2816fc5 b/tmp/cache/bootsnap/compile-cache-iseq/f1/4ef395b2816fc5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/629cf623bbaad9 b/tmp/cache/bootsnap/compile-cache-iseq/f1/629cf623bbaad9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/688a6497f85348 b/tmp/cache/bootsnap/compile-cache-iseq/f1/688a6497f85348
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/6d3e5cf5d9f6e6 b/tmp/cache/bootsnap/compile-cache-iseq/f1/6d3e5cf5d9f6e6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/8de7d4309c731e b/tmp/cache/bootsnap/compile-cache-iseq/f1/8de7d4309c731e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/9a83e0a70c221f b/tmp/cache/bootsnap/compile-cache-iseq/f1/9a83e0a70c221f
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/a391b717312bf0 b/tmp/cache/bootsnap/compile-cache-iseq/f1/a391b717312bf0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/beadf258e5b1a3 b/tmp/cache/bootsnap/compile-cache-iseq/f1/beadf258e5b1a3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f1/c5be11cbb8becc b/tmp/cache/bootsnap/compile-cache-iseq/f1/c5be11cbb8becc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f2/2d1b1bd5fcf515 b/tmp/cache/bootsnap/compile-cache-iseq/f2/2d1b1bd5fcf515
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f2/491d1d857a8bfc b/tmp/cache/bootsnap/compile-cache-iseq/f2/491d1d857a8bfc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f2/c48a609e4d5d30 b/tmp/cache/bootsnap/compile-cache-iseq/f2/c48a609e4d5d30
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f2/d08360f35cea1c b/tmp/cache/bootsnap/compile-cache-iseq/f2/d08360f35cea1c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f2/e800483b746406 b/tmp/cache/bootsnap/compile-cache-iseq/f2/e800483b746406
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/07f1991f1886a8 b/tmp/cache/bootsnap/compile-cache-iseq/f3/07f1991f1886a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/4c1e7bee29fae6 b/tmp/cache/bootsnap/compile-cache-iseq/f3/4c1e7bee29fae6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/5362e42cfe5680 b/tmp/cache/bootsnap/compile-cache-iseq/f3/5362e42cfe5680
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/5aec686fc20bd4 b/tmp/cache/bootsnap/compile-cache-iseq/f3/5aec686fc20bd4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/74cbc65cbbae34 b/tmp/cache/bootsnap/compile-cache-iseq/f3/74cbc65cbbae34
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f3/9f6ca922a2fa35 b/tmp/cache/bootsnap/compile-cache-iseq/f3/9f6ca922a2fa35
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/03de740a10a069 b/tmp/cache/bootsnap/compile-cache-iseq/f4/03de740a10a069
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/3b6d91cd2b94b9 b/tmp/cache/bootsnap/compile-cache-iseq/f4/3b6d91cd2b94b9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/447f2231e911ed b/tmp/cache/bootsnap/compile-cache-iseq/f4/447f2231e911ed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/5db5bf23335f33 b/tmp/cache/bootsnap/compile-cache-iseq/f4/5db5bf23335f33
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/80fae55b0aa94b b/tmp/cache/bootsnap/compile-cache-iseq/f4/80fae55b0aa94b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/aa1bf81e12a5a6 b/tmp/cache/bootsnap/compile-cache-iseq/f4/aa1bf81e12a5a6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f4/e2b895a503d04d b/tmp/cache/bootsnap/compile-cache-iseq/f4/e2b895a503d04d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f5/2915d7583924e2 b/tmp/cache/bootsnap/compile-cache-iseq/f5/2915d7583924e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f5/487df2654cb3fe b/tmp/cache/bootsnap/compile-cache-iseq/f5/487df2654cb3fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f5/b05b985b89daf4 b/tmp/cache/bootsnap/compile-cache-iseq/f5/b05b985b89daf4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/1cb934eb9a3feb b/tmp/cache/bootsnap/compile-cache-iseq/f6/1cb934eb9a3feb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/3434a7ce601cc3 b/tmp/cache/bootsnap/compile-cache-iseq/f6/3434a7ce601cc3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/5cb3084ca76ad3 b/tmp/cache/bootsnap/compile-cache-iseq/f6/5cb3084ca76ad3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/9686bb1ad418a8 b/tmp/cache/bootsnap/compile-cache-iseq/f6/9686bb1ad418a8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/a4a13599161c22 b/tmp/cache/bootsnap/compile-cache-iseq/f6/a4a13599161c22
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/b7ec730ed23cee b/tmp/cache/bootsnap/compile-cache-iseq/f6/b7ec730ed23cee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/d9b701d26f53cb b/tmp/cache/bootsnap/compile-cache-iseq/f6/d9b701d26f53cb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f6/dfbf56f4509944 b/tmp/cache/bootsnap/compile-cache-iseq/f6/dfbf56f4509944
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/624f78eb99f9ae b/tmp/cache/bootsnap/compile-cache-iseq/f7/624f78eb99f9ae
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/677b940f6dc555 b/tmp/cache/bootsnap/compile-cache-iseq/f7/677b940f6dc555
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/7be77b01c14d23 b/tmp/cache/bootsnap/compile-cache-iseq/f7/7be77b01c14d23
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/c66f97cacb99aa b/tmp/cache/bootsnap/compile-cache-iseq/f7/c66f97cacb99aa
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/d2ded0a412f753 b/tmp/cache/bootsnap/compile-cache-iseq/f7/d2ded0a412f753
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/e532d69488b7f6 b/tmp/cache/bootsnap/compile-cache-iseq/f7/e532d69488b7f6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f7/fcb3535af457b0 b/tmp/cache/bootsnap/compile-cache-iseq/f7/fcb3535af457b0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f8/0addfb7fb1be81 b/tmp/cache/bootsnap/compile-cache-iseq/f8/0addfb7fb1be81
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f8/0ec241ed875eb4 b/tmp/cache/bootsnap/compile-cache-iseq/f8/0ec241ed875eb4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f8/75e78f44d05218 b/tmp/cache/bootsnap/compile-cache-iseq/f8/75e78f44d05218
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f8/94a798dcbbe5b5 b/tmp/cache/bootsnap/compile-cache-iseq/f8/94a798dcbbe5b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/339f9b7bb620fb b/tmp/cache/bootsnap/compile-cache-iseq/f9/339f9b7bb620fb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/632875b6db9220 b/tmp/cache/bootsnap/compile-cache-iseq/f9/632875b6db9220
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/652bed17422fe7 b/tmp/cache/bootsnap/compile-cache-iseq/f9/652bed17422fe7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/8304b528007274 b/tmp/cache/bootsnap/compile-cache-iseq/f9/8304b528007274
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/bf153000bb0415 b/tmp/cache/bootsnap/compile-cache-iseq/f9/bf153000bb0415
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/c0426e7e7435e2 b/tmp/cache/bootsnap/compile-cache-iseq/f9/c0426e7e7435e2
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/c9c1dc3c580af4 b/tmp/cache/bootsnap/compile-cache-iseq/f9/c9c1dc3c580af4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/ced885c1e1d925 b/tmp/cache/bootsnap/compile-cache-iseq/f9/ced885c1e1d925
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/f9/f07d269dddd6cc b/tmp/cache/bootsnap/compile-cache-iseq/f9/f07d269dddd6cc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fa/108c5bf0d6fee8 b/tmp/cache/bootsnap/compile-cache-iseq/fa/108c5bf0d6fee8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fa/37fd545ea70e75 b/tmp/cache/bootsnap/compile-cache-iseq/fa/37fd545ea70e75
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fa/50dde0469f6d8b b/tmp/cache/bootsnap/compile-cache-iseq/fa/50dde0469f6d8b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fa/cee58ed6b184fe b/tmp/cache/bootsnap/compile-cache-iseq/fa/cee58ed6b184fe
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/14a8ae173b0bdb b/tmp/cache/bootsnap/compile-cache-iseq/fb/14a8ae173b0bdb
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/4769faa9a38ad4 b/tmp/cache/bootsnap/compile-cache-iseq/fb/4769faa9a38ad4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/6c83a0c7389c71 b/tmp/cache/bootsnap/compile-cache-iseq/fb/6c83a0c7389c71
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/83b47a7240e43b b/tmp/cache/bootsnap/compile-cache-iseq/fb/83b47a7240e43b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/b1fcefb6bd8ecd b/tmp/cache/bootsnap/compile-cache-iseq/fb/b1fcefb6bd8ecd
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/b332fc2d55ecc7 b/tmp/cache/bootsnap/compile-cache-iseq/fb/b332fc2d55ecc7
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/bc57c46472234b b/tmp/cache/bootsnap/compile-cache-iseq/fb/bc57c46472234b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fb/eb8f267b96f512 b/tmp/cache/bootsnap/compile-cache-iseq/fb/eb8f267b96f512
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/060c42721469d8 b/tmp/cache/bootsnap/compile-cache-iseq/fc/060c42721469d8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/150ce2dfe269de b/tmp/cache/bootsnap/compile-cache-iseq/fc/150ce2dfe269de
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/1a97f4df6c5fa9 b/tmp/cache/bootsnap/compile-cache-iseq/fc/1a97f4df6c5fa9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/2f89375a145932 b/tmp/cache/bootsnap/compile-cache-iseq/fc/2f89375a145932
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/49805d83a7cfc8 b/tmp/cache/bootsnap/compile-cache-iseq/fc/49805d83a7cfc8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/c415165ec5f9a3 b/tmp/cache/bootsnap/compile-cache-iseq/fc/c415165ec5f9a3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/cdc9e16acb7b9b b/tmp/cache/bootsnap/compile-cache-iseq/fc/cdc9e16acb7b9b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/cef35e51436df0 b/tmp/cache/bootsnap/compile-cache-iseq/fc/cef35e51436df0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/dfeb68bd4124b4 b/tmp/cache/bootsnap/compile-cache-iseq/fc/dfeb68bd4124b4
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/ef0760aa238226 b/tmp/cache/bootsnap/compile-cache-iseq/fc/ef0760aa238226
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/f47ff679affcfc b/tmp/cache/bootsnap/compile-cache-iseq/fc/f47ff679affcfc
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/f89c12fd4b25f9 b/tmp/cache/bootsnap/compile-cache-iseq/fc/f89c12fd4b25f9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fc/fb86027aa15c95 b/tmp/cache/bootsnap/compile-cache-iseq/fc/fb86027aa15c95
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/0b6c07cc64073a b/tmp/cache/bootsnap/compile-cache-iseq/fd/0b6c07cc64073a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/0e9c87dad91a23 b/tmp/cache/bootsnap/compile-cache-iseq/fd/0e9c87dad91a23
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/1252d7c9ccd64d b/tmp/cache/bootsnap/compile-cache-iseq/fd/1252d7c9ccd64d
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/5cc21956e777ed b/tmp/cache/bootsnap/compile-cache-iseq/fd/5cc21956e777ed
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/786ac03122495e b/tmp/cache/bootsnap/compile-cache-iseq/fd/786ac03122495e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fd/ac3c879e615837 b/tmp/cache/bootsnap/compile-cache-iseq/fd/ac3c879e615837
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/21e85512d7de6e b/tmp/cache/bootsnap/compile-cache-iseq/fe/21e85512d7de6e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/2555de70055c3a b/tmp/cache/bootsnap/compile-cache-iseq/fe/2555de70055c3a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/4298a8aa7330c3 b/tmp/cache/bootsnap/compile-cache-iseq/fe/4298a8aa7330c3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/6466b866785d83 b/tmp/cache/bootsnap/compile-cache-iseq/fe/6466b866785d83
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/833440293e8bca b/tmp/cache/bootsnap/compile-cache-iseq/fe/833440293e8bca
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/903b2a48432a18 b/tmp/cache/bootsnap/compile-cache-iseq/fe/903b2a48432a18
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/9adda804e73ed6 b/tmp/cache/bootsnap/compile-cache-iseq/fe/9adda804e73ed6
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/e79e108c5ad12a b/tmp/cache/bootsnap/compile-cache-iseq/fe/e79e108c5ad12a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/fe/f19ce736f60eb8 b/tmp/cache/bootsnap/compile-cache-iseq/fe/f19ce736f60eb8
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/05d1f061995ab9 b/tmp/cache/bootsnap/compile-cache-iseq/ff/05d1f061995ab9
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/2103a0ef703f2e b/tmp/cache/bootsnap/compile-cache-iseq/ff/2103a0ef703f2e
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/34fece0b1e6fe0 b/tmp/cache/bootsnap/compile-cache-iseq/ff/34fece0b1e6fe0
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/720cb30ae6be56 b/tmp/cache/bootsnap/compile-cache-iseq/ff/720cb30ae6be56
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/792c092c79857b b/tmp/cache/bootsnap/compile-cache-iseq/ff/792c092c79857b
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/8e4fa8e22d0bf1 b/tmp/cache/bootsnap/compile-cache-iseq/ff/8e4fa8e22d0bf1
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/956c85b75a3873 b/tmp/cache/bootsnap/compile-cache-iseq/ff/956c85b75a3873
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/tmp/cache/bootsnap/compile-cache-iseq/ff/f612726f157aee b/tmp/cache/bootsnap/compile-cache-iseq/ff/f612726f157aee
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/logo.png b/assets/logo.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/lets go.jpg b/assets/lets go.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Letsgo.JPEG b/assets/Letsgo.JPEG
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Picture3.png b/assets/Picture3.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Picture5.jpg b/assets/Picture5.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/cover .png.jpg b/assets/cover .png.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/let's go cover.jpg b/assets/let's go cover.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/let's go image.png b/assets/let's go image.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Letsgo_approved.ai b/assets/Letsgo_approved.ai
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Letsgo_blackbg.png b/assets/Letsgo_blackbg.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Letsgo_approved1.ai b/assets/Letsgo_approved1.ai
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/assets/Letsgo_approved1.pdf b/assets/Letsgo_approved1.pdf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/Roads.jpeg b/Roads.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/IMG_5203.png b/IMG_5203.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/IMG_5793.png b/IMG_5793.png
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/libffi-3.4.6/doc/libffi.pdf b/libffi-3.4.6/doc/libffi.pdf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/libffi-3.4.6/x86_64-pc-msys/config.status b/libffi-3.4.6/x86_64-pc-msys/config.status
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/IMG_5790.jpeg b/IMG_5790.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/IMG_5794.jpeg b/IMG_5794.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/letsgo_B.jpeg b/letsgo_B.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/Letsgo_W.jpeg b/Letsgo_W.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

diff --git a/b2ca4751-eda9-4bf9-97e2-f00814f79357.jpeg b/b2ca4751-eda9-4bf9-97e2-f00814f79357.jpeg
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
GIT binary patch
literal 0
Hc$@<O00001

